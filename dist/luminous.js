var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/hammerjs/hammer.js
var require_hammer = __commonJS({
  "node_modules/hammerjs/hammer.js"(exports, module2) {
    (function(window2, document2, exportName, undefined2) {
      "use strict";
      var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
      var TEST_ELEMENT = document2.createElement("div");
      var TYPE_FUNCTION = "function";
      var round2 = Math.round;
      var abs = Math.abs;
      var now2 = Date.now;
      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }
      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each2(arg, context[fn], context);
          return true;
        }
        return false;
      }
      function each2(obj, iterator, context) {
        var i2;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined2) {
          i2 = 0;
          while (i2 < obj.length) {
            iterator.call(context, obj[i2], i2, obj);
            i2++;
          }
        } else {
          for (i2 in obj) {
            obj.hasOwnProperty(i2) && iterator.call(context, obj[i2], i2, obj);
          }
        }
      }
      function deprecate(method, name, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
        return function() {
          var e = new Error("get-stack-trace");
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
          var log = window2.console && (window2.console.warn || window2.console.log);
          if (log) {
            log.call(window2.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
        };
      }
      var assign;
      if (typeof Object.assign !== "function") {
        assign = function assign2(target) {
          if (target === undefined2 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index2 = 1; index2 < arguments.length; index2++) {
            var source = arguments[index2];
            if (source !== undefined2 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }
          return output;
        };
      } else {
        assign = Object.assign;
      }
      var extend = deprecate(function extend2(dest, src, merge3) {
        var keys = Object.keys(src);
        var i2 = 0;
        while (i2 < keys.length) {
          if (!merge3 || merge3 && dest[keys[i2]] === undefined2) {
            dest[keys[i2]] = src[keys[i2]];
          }
          i2++;
        }
        return dest;
      }, "extend", "Use `assign`.");
      var merge2 = deprecate(function merge3(dest, src) {
        return extend(dest, src, true);
      }, "merge", "Use `assign`.");
      function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          assign(childP, properties);
        }
      }
      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }
      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined2 : undefined2, args);
        }
        return val;
      }
      function ifUndefined(val1, val2) {
        return val1 === undefined2 ? val2 : val1;
      }
      function addEventListeners(target, types, handler) {
        each2(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
        });
      }
      function removeEventListeners(target, types, handler) {
        each2(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
        });
      }
      function hasParent(node, parent) {
        while (node) {
          if (node == parent) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      }
      function inStr(str, find) {
        return str.indexOf(find) > -1;
      }
      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }
      function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find);
        } else {
          var i2 = 0;
          while (i2 < src.length) {
            if (findByKey && src[i2][findByKey] == find || !findByKey && src[i2] === find) {
              return i2;
            }
            i2++;
          }
          return -1;
        }
      }
      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      function uniqueArray(src, key, sort) {
        var results = [];
        var values2 = [];
        var i2 = 0;
        while (i2 < src.length) {
          var val = key ? src[i2][key] : src[i2];
          if (inArray(values2, val) < 0) {
            results.push(src[i2]);
          }
          values2[i2] = val;
          i2++;
        }
        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a, b) {
              return a[key] > b[key];
            });
          }
        }
        return results;
      }
      function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i2 = 0;
        while (i2 < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i2];
          prop = prefix ? prefix + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i2++;
        }
        return undefined2;
      }
      var _uniqueId = 1;
      function uniqueId() {
        return _uniqueId++;
      }
      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window2;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = "ontouchstart" in window2;
      var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = "touch";
      var INPUT_TYPE_PEN = "pen";
      var INPUT_TYPE_MOUSE = "mouse";
      var INPUT_TYPE_KINECT = "kinect";
      var COMPUTE_INTERVAL = 25;
      var INPUT_START = 1;
      var INPUT_MOVE = 2;
      var INPUT_END = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ["x", "y"];
      var PROPS_CLIENT_XY = ["clientX", "clientY"];
      function Input(manager, callback2) {
        var self2 = this;
        this.manager = manager;
        this.callback = callback2;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self2.handler(ev);
          }
        };
        this.init();
      }
      Input.prototype = {
        handler: function() {
        },
        init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
        } else {
          Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
      }
      function inputHandler(manager, eventType, input2) {
        var pointersLen = input2.pointers.length;
        var changedPointersLen = input2.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input2.isFirst = !!isFirst;
        input2.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }
        input2.eventType = eventType;
        computeInputData(manager, input2);
        manager.emit("hammer.input", input2);
        manager.recognize(input2);
        manager.session.prevInput = input2;
      }
      function computeInputData(manager, input2) {
        var session = manager.session;
        var pointers = input2.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input2);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input2);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input2.center = getCenter2(pointers);
        input2.timeStamp = now2();
        input2.deltaTime = input2.timeStamp - firstInput.timeStamp;
        input2.angle = getAngle(offsetCenter, center);
        input2.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input2);
        input2.offsetDirection = getDirection(input2.deltaX, input2.deltaY);
        var overallVelocity = getVelocity(input2.deltaTime, input2.deltaX, input2.deltaY);
        input2.overallVelocityX = overallVelocity.x;
        input2.overallVelocityY = overallVelocity.y;
        input2.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input2.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input2.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input2.maxPointers = !session.prevInput ? input2.pointers.length : input2.pointers.length > session.prevInput.maxPointers ? input2.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input2);
        var target = manager.element;
        if (hasParent(input2.srcEvent.target, target)) {
          target = input2.srcEvent.target;
        }
        input2.target = target;
      }
      function computeDeltaXY(session, input2) {
        var center = input2.center;
        var offset2 = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input2.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset2 = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }
        input2.deltaX = prevDelta.x + (center.x - offset2.x);
        input2.deltaY = prevDelta.y + (center.y - offset2.y);
      }
      function computeIntervalInputData(session, input2) {
        var last = session.lastInterval || input2, deltaTime = input2.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input2.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
          var deltaX = input2.deltaX - last.deltaX;
          var deltaY = input2.deltaY - last.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input2;
        } else {
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
        }
        input2.velocity = velocity;
        input2.velocityX = velocityX;
        input2.velocityY = velocityY;
        input2.direction = direction;
      }
      function simpleCloneInputData(input2) {
        var pointers = [];
        var i2 = 0;
        while (i2 < input2.pointers.length) {
          pointers[i2] = {
            clientX: round2(input2.pointers[i2].clientX),
            clientY: round2(input2.pointers[i2].clientY)
          };
          i2++;
        }
        return {
          timeStamp: now2(),
          pointers,
          center: getCenter2(pointers),
          deltaX: input2.deltaX,
          deltaY: input2.deltaY
        };
      }
      function getCenter2(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
          return {
            x: round2(pointers[0].clientX),
            y: round2(pointers[0].clientY)
          };
        }
        var x = 0, y = 0, i2 = 0;
        while (i2 < pointersLength) {
          x += pointers[i2].clientX;
          y += pointers[i2].clientY;
          i2++;
        }
        return {
          x: round2(x / pointersLength),
          y: round2(y / pointersLength)
        };
      }
      function getVelocity(deltaTime, x, y) {
        return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }
      function getDirection(x, y) {
        if (x === y) {
          return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
      }
      function getAngle(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
      }
      function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
      }
      function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
      };
      var MOUSE_ELEMENT_EVENTS = "mousedown";
      var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
      function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false;
        Input.apply(this, arguments);
      }
      inherit(MouseInput, Input, {
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];
          if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
          }
          if (!this.pressed) {
            return;
          }
          if (eventType & INPUT_END) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
      };
      var POINTER_ELEMENT_EVENTS = "pointerdown";
      var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
      if (window2.MSPointerEvent && !window2.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
      }
      function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput, Input, {
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH;
          var storeIndex = inArray(store, ev.pointerId, "pointerId");
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
          }
          if (storeIndex < 0) {
            return;
          }
          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
      var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
          if (type === INPUT_START) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), "identifier", true);
        }
        return [all, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
      }
      inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i2, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
        });
        if (type === INPUT_START) {
          i2 = 0;
          while (i2 < targetTouches.length) {
            targetIds[targetTouches[i2].identifier] = true;
            i2++;
          }
        }
        i2 = 0;
        while (i2 < changedTouches.length) {
          if (targetIds[changedTouches[i2].identifier]) {
            changedTargetTouches.push(changedTouches[i2]);
          }
          if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i2].identifier];
          }
          i2++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
          uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
          changedTargetTouches
        ];
      }
      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;
      function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }
      inherit(TouchMouseInput, Input, {
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          }
          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }
          this.callback(manager, inputEvent, inputData);
        },
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }
      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
          var lastTouch = { x: touch.clientX, y: touch.clientY };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
            var i2 = lts.indexOf(lastTouch);
            if (i2 > -1) {
              lts.splice(i2, 1);
            }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }
      function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i2 = 0; i2 < this.lastTouches.length; i2++) {
          var t = this.lastTouches[i2];
          var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }
        return false;
      }
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
      var TOUCH_ACTION_COMPUTE = "compute";
      var TOUCH_ACTION_AUTO = "auto";
      var TOUCH_ACTION_MANIPULATION = "manipulation";
      var TOUCH_ACTION_NONE = "none";
      var TOUCH_ACTION_PAN_X = "pan-x";
      var TOUCH_ACTION_PAN_Y = "pan-y";
      var TOUCH_ACTION_MAP = getTouchActionProps();
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype = {
        set: function(value) {
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }
          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
        },
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        compute: function() {
          var actions = [];
          each2(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(" "));
        },
        preventDefaults: function(input2) {
          var srcEvent = input2.srcEvent;
          var direction = input2.offsetDirection;
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
          if (hasNone) {
            var isTapPointer = input2.pointers.length === 1;
            var isTapMovement = input2.distance < 2;
            var isTapTouchTime = input2.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }
          if (hasPanX && hasPanY) {
            return;
          }
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        }
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }
        var touchMap = {};
        var cssSupports = window2.CSS && window2.CSS.supports;
        ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
          touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
      }
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        defaults: {},
        set: function(options) {
          assign(this.options, options);
          this.manager && this.manager.touchAction.update();
          return this;
        },
        recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index2 = inArray(this.requireFail, otherRecognizer);
          if (index2 > -1) {
            this.requireFail.splice(index2, 1);
          }
          return this;
        },
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        emit: function(input2) {
          var self2 = this;
          var state = this.state;
          function emit(event) {
            self2.manager.emit(event, input2);
          }
          if (state < STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
          emit(self2.options.event);
          if (input2.additionalEvent) {
            emit(input2.additionalEvent);
          }
          if (state >= STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
        },
        tryEmit: function(input2) {
          if (this.canEmit()) {
            return this.emit(input2);
          }
          this.state = STATE_FAILED;
        },
        canEmit: function() {
          var i2 = 0;
          while (i2 < this.requireFail.length) {
            if (!(this.requireFail[i2].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i2++;
          }
          return true;
        },
        recognize: function(inputData) {
          var inputDataClone = assign({}, inputData);
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        process: function(inputData) {
        },
        getTouchAction: function() {
        },
        reset: function() {
        }
      };
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return "cancel";
        } else if (state & STATE_ENDED) {
          return "end";
        } else if (state & STATE_CHANGED) {
          return "move";
        } else if (state & STATE_BEGAN) {
          return "start";
        }
        return "";
      }
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return "down";
        } else if (direction == DIRECTION_UP) {
          return "up";
        } else if (direction == DIRECTION_LEFT) {
          return "left";
        } else if (direction == DIRECTION_RIGHT) {
          return "right";
        }
        return "";
      }
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        defaults: {
          pointers: 1
        },
        attrTest: function(input2) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input2.pointers.length === optionPointers;
        },
        process: function(input2) {
          var state = this.state;
          var eventType = input2.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input2);
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function(input2) {
          var options = this.options;
          var hasMoved = true;
          var distance = input2.distance;
          var direction = input2.direction;
          var x = input2.deltaX;
          var y = input2.deltaY;
          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x != this.pX;
              distance = Math.abs(input2.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance = Math.abs(input2.deltaY);
            }
          }
          input2.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function(input2) {
          return AttrRecognizer.prototype.attrTest.call(this, input2) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input2));
        },
        emit: function(input2) {
          this.pX = input2.deltaX;
          this.pY = input2.deltaY;
          var direction = directionStr(input2.direction);
          if (direction) {
            input2.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input2);
        }
      });
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input2) {
          return this._super.attrTest.call(this, input2) && (Math.abs(input2.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input2) {
          if (input2.scale !== 1) {
            var inOut = input2.scale < 1 ? "in" : "out";
            input2.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input2);
        }
      });
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          threshold: 9
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function(input2) {
          var options = this.options;
          var validPointers = input2.pointers.length === options.pointers;
          var validMovement = input2.distance < options.threshold;
          var validTime = input2.deltaTime > options.time;
          this._input = input2;
          if (!validMovement || !validPointers || input2.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input2.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input2.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(input2) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input2 && input2.eventType & INPUT_END) {
            this.manager.emit(this.options.event + "up", input2);
          } else {
            this._input.timeStamp = now2();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input2) {
          return this._super.attrTest.call(this, input2) && (Math.abs(input2.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input2) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input2.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input2.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input2.overallVelocityY;
          }
          return this._super.attrTest.call(this, input2) && direction & input2.offsetDirection && input2.distance > this.options.threshold && input2.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input2.eventType & INPUT_END;
        },
        emit: function(input2) {
          var direction = directionStr(input2.offsetDirection);
          if (direction) {
            this.manager.emit(this.options.event + direction, input2);
          }
          this.manager.emit(this.options.event, input2);
        }
      });
      function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer, Recognizer, {
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          time: 250,
          threshold: 9,
          posThreshold: 10
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function(input2) {
          var options = this.options;
          var validPointers = input2.pointers.length === options.pointers;
          var validMovement = input2.distance < options.threshold;
          var validTouchTime = input2.deltaTime < options.time;
          this.reset();
          if (input2.eventType & INPUT_START && this.count === 0) {
            return this.failTimeout();
          }
          if (validMovement && validTouchTime && validPointers) {
            if (input2.eventType != INPUT_END) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input2.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input2.center) < options.posThreshold;
            this.pTime = input2.timeStamp;
            this.pCenter = input2.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input2;
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function() {
          this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function Hammer2(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer2.defaults.preset);
        return new Manager(element, options);
      }
      Hammer2.VERSION = "2.0.7";
      Hammer2.defaults = {
        domEvents: false,
        touchAction: TOUCH_ACTION_COMPUTE,
        enable: true,
        inputTarget: null,
        inputClass: null,
        preset: [
          [RotateRecognizer, { enable: false }],
          [PinchRecognizer, { enable: false }, ["rotate"]],
          [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
          [TapRecognizer],
          [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
          [PressRecognizer]
        ],
        cssProps: {
          userSelect: "none",
          touchSelect: "none",
          touchCallout: "none",
          contentZooming: "none",
          userDrag: "none",
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      function Manager(element, options) {
        this.options = assign({}, Hammer2.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each2(this.options.recognizers, function(item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager.prototype = {
        set: function(options) {
          assign(this.options, options);
          if (options.touchAction) {
            this.touchAction.update();
          }
          if (options.inputTarget) {
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }
          return this;
        },
        stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;
          var curRecognizer = session.curRecognizer;
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i2 = 0;
          while (i2 < recognizers.length) {
            recognizer = recognizers[i2];
            if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i2++;
          }
        },
        get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i2 = 0; i2 < recognizers.length; i2++) {
            if (recognizers[i2].options.event == recognizer) {
              return recognizers[i2];
            }
          }
          return null;
        },
        add: function(recognizer) {
          if (invokeArrayArg(recognizer, "add", this)) {
            return this;
          }
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        remove: function(recognizer) {
          if (invokeArrayArg(recognizer, "remove", this)) {
            return this;
          }
          recognizer = this.get(recognizer);
          if (recognizer) {
            var recognizers = this.recognizers;
            var index2 = inArray(recognizers, recognizer);
            if (index2 !== -1) {
              recognizers.splice(index2, 1);
              this.touchAction.update();
            }
          }
          return this;
        },
        on: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          if (handler === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each2(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },
        off: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each2(splitStr(events), function(event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
          });
          return this;
        },
        emit: function(event, data) {
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          }
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data.type = event;
          data.preventDefault = function() {
            data.srcEvent.preventDefault();
          };
          var i2 = 0;
          while (i2 < handlers.length) {
            handlers[i2](data);
            i2++;
          }
        },
        destroy: function() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) {
          return;
        }
        var prop;
        each2(manager.options.cssProps, function(value, name) {
          prop = prefixed(element.style, name);
          if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || "";
          }
        });
        if (!add) {
          manager.oldCssProps = {};
        }
      }
      function triggerDomEvent(event, data) {
        var gestureEvent = document2.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }
      assign(Hammer2, {
        INPUT_START,
        INPUT_MOVE,
        INPUT_END,
        INPUT_CANCEL,
        STATE_POSSIBLE,
        STATE_BEGAN,
        STATE_CHANGED,
        STATE_ENDED,
        STATE_RECOGNIZED,
        STATE_CANCELLED,
        STATE_FAILED,
        DIRECTION_NONE,
        DIRECTION_LEFT,
        DIRECTION_RIGHT,
        DIRECTION_UP,
        DIRECTION_DOWN,
        DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL,
        DIRECTION_ALL,
        Manager,
        Input,
        TouchAction,
        TouchInput,
        MouseInput,
        PointerEventInput,
        TouchMouseInput,
        SingleTouchInput,
        Recognizer,
        AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each2,
        merge: merge2,
        extend,
        assign,
        inherit,
        bindFn,
        prefixed
      });
      var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
      freeGlobal.Hammer = Hammer2;
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Hammer2;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = Hammer2;
      } else {
        window2[exportName] = Hammer2;
      }
    })(window, document, "Hammer");
  }
});

// node_modules/highcharts/highcharts.js
var require_highcharts = __commonJS({
  "node_modules/highcharts/highcharts.js"(exports, module2) {
    "use strict";
    (function(U, M) {
      typeof module2 === "object" && module2.exports ? (M["default"] = M, module2.exports = U.document ? M(U) : M) : typeof define === "function" && define.amd ? define("highcharts/highcharts", function() {
        return M(U);
      }) : (U.Highcharts && U.Highcharts.error(16, true), U.Highcharts = M(U));
    })(typeof window !== "undefined" ? window : exports, function(U) {
      function M(a2, y, I, L) {
        a2.hasOwnProperty(y) || (a2[y] = L.apply(null, I), typeof CustomEvent === "function" && U.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: y, module: a2[y] } })));
      }
      var a = {};
      M(a, "Core/Globals.js", [], function() {
        var a2;
        (function(a3) {
          a3.SVG_NS = "http://www.w3.org/2000/svg";
          a3.product = "Highcharts";
          a3.version = "11.1.0";
          a3.win = typeof U !== "undefined" ? U : {};
          a3.doc = a3.win.document;
          a3.svg = a3.doc && a3.doc.createElementNS && !!a3.doc.createElementNS(a3.SVG_NS, "svg").createSVGRect;
          a3.userAgent = a3.win.navigator && a3.win.navigator.userAgent || "";
          a3.isChrome = a3.userAgent.indexOf("Chrome") !== -1;
          a3.isFirefox = a3.userAgent.indexOf("Firefox") !== -1;
          a3.isMS = /(edge|msie|trident)/i.test(a3.userAgent) && !a3.win.opera;
          a3.isSafari = !a3.isChrome && a3.userAgent.indexOf("Safari") !== -1;
          a3.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a3.userAgent);
          a3.isWebKit = a3.userAgent.indexOf("AppleWebKit") !== -1;
          a3.deg2rad = 2 * Math.PI / 360;
          a3.hasBidiBug = a3.isFirefox && 4 > parseInt(a3.userAgent.split("Firefox/")[1], 10);
          a3.hasTouch = !!a3.win.TouchEvent;
          a3.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];
          a3.noop = function() {
          };
          a3.supportsPassiveEvents = function() {
            let x = false;
            if (!a3.isMS) {
              const y = Object.defineProperty({}, "passive", { get: function() {
                x = true;
              } });
              a3.win.addEventListener && a3.win.removeEventListener && (a3.win.addEventListener("testPassive", a3.noop, y), a3.win.removeEventListener("testPassive", a3.noop, y));
            }
            return x;
          }();
          a3.charts = [];
          a3.dateFormats = {};
          a3.seriesTypes = {};
          a3.symbolSizes = {};
          a3.chartCount = 0;
        })(a2 || (a2 = {}));
        "";
        return a2;
      });
      M(a, "Core/Utilities.js", [a["Core/Globals.js"]], function(a2) {
        function x(c, b2, f2, k2) {
          const n3 = b2 ? "Highcharts error" : "Highcharts warning";
          c === 32 && (c = `${n3}: Deprecated member`);
          const r2 = u(c);
          let e2 = r2 ? `${n3} #${c}: www.highcharts.com/errors/${c}/` : c.toString();
          if (typeof k2 !== "undefined") {
            let c2 = "";
            r2 && (e2 += "?");
            E(k2, function(b3, n4) {
              c2 += `
 - ${n4}: ${b3}`;
              r2 && (e2 += encodeURI(n4) + "=" + encodeURI(b3));
            });
            e2 += c2;
          }
          d(a2, "displayError", { chart: f2, code: c, message: e2, params: k2 }, function() {
            if (b2)
              throw Error(e2);
            q.console && x.messages.indexOf(e2) === -1 && console.warn(e2);
          });
          x.messages.push(e2);
        }
        function I(c, b2) {
          return parseInt(c, b2 || 10);
        }
        function L(c) {
          return typeof c === "string";
        }
        function C(c) {
          c = Object.prototype.toString.call(c);
          return c === "[object Array]" || c === "[object Array Iterator]";
        }
        function z(c, b2) {
          return !!c && typeof c === "object" && (!b2 || !C(c));
        }
        function H(c) {
          return z(c) && typeof c.nodeType === "number";
        }
        function B(c) {
          const b2 = c && c.constructor;
          return !(!z(c, true) || H(c) || !b2 || !b2.name || b2.name === "Object");
        }
        function u(c) {
          return typeof c === "number" && !isNaN(c) && Infinity > c && -Infinity < c;
        }
        function v(c) {
          return typeof c !== "undefined" && c !== null;
        }
        function l2(c, b2, f2) {
          const n3 = L(b2) && !v(f2);
          let d2;
          const k2 = (b3, f3) => {
            v(b3) ? c.setAttribute(f3, b3) : n3 ? (d2 = c.getAttribute(f3)) || f3 !== "class" || (d2 = c.getAttribute(f3 + "Name")) : c.removeAttribute(f3);
          };
          L(b2) ? k2(f2, b2) : E(b2, k2);
          return d2;
        }
        function p(c) {
          return C(c) ? c : [c];
        }
        function t(c, b2) {
          let n3;
          c || (c = {});
          for (n3 in b2)
            c[n3] = b2[n3];
          return c;
        }
        function m() {
          const c = arguments, b2 = c.length;
          for (let n3 = 0; n3 < b2; n3++) {
            const b3 = c[n3];
            if (typeof b3 !== "undefined" && b3 !== null)
              return b3;
          }
        }
        function h(c, b2) {
          a2.isMS && !a2.svg && b2 && v(b2.opacity) && (b2.filter = `alpha(opacity=${100 * b2.opacity})`);
          t(c.style, b2);
        }
        function g(c) {
          return Math.pow(10, Math.floor(Math.log(c) / Math.LN10));
        }
        function e(c, b2) {
          return 1e14 < c ? c : parseFloat(c.toPrecision(b2 || 14));
        }
        function w(c, b2, f2) {
          let n3;
          if (b2 === "width")
            return b2 = Math.min(c.offsetWidth, c.scrollWidth), f2 = c.getBoundingClientRect && c.getBoundingClientRect().width, f2 < b2 && f2 >= b2 - 1 && (b2 = Math.floor(f2)), Math.max(0, b2 - (w(c, "padding-left", true) || 0) - (w(c, "padding-right", true) || 0));
          if (b2 === "height")
            return Math.max(0, Math.min(c.offsetHeight, c.scrollHeight) - (w(c, "padding-top", true) || 0) - (w(c, "padding-bottom", true) || 0));
          if (c = q.getComputedStyle(c, void 0))
            n3 = c.getPropertyValue(b2), m(f2, b2 !== "opacity") && (n3 = I(n3));
          return n3;
        }
        function E(c, b2, f2) {
          for (const n3 in c)
            Object.hasOwnProperty.call(c, n3) && b2.call(f2 || c[n3], c[n3], n3, c);
        }
        function F(c, b2, f2) {
          function n3(b3, n4) {
            const f3 = c.removeEventListener;
            f3 && f3.call(c, b3, n4, false);
          }
          function d2(f3) {
            let d3, K;
            c.nodeName && (b2 ? (d3 = {}, d3[b2] = true) : d3 = f3, E(d3, function(c2, b3) {
              if (f3[b3])
                for (K = f3[b3].length; K--; )
                  n3(b3, f3[b3][K].fn);
            }));
          }
          var k2 = typeof c === "function" && c.prototype || c;
          if (Object.hasOwnProperty.call(k2, "hcEvents")) {
            const c2 = k2.hcEvents;
            b2 ? (k2 = c2[b2] || [], f2 ? (c2[b2] = k2.filter(function(c3) {
              return f2 !== c3.fn;
            }), n3(b2, f2)) : (d2(c2), c2[b2] = [])) : (d2(c2), delete k2.hcEvents);
          }
        }
        function d(c, b2, f2, d2) {
          f2 = f2 || {};
          if (r.createEvent && (c.dispatchEvent || c.fireEvent && c !== a2)) {
            var n3 = r.createEvent("Events");
            n3.initEvent(b2, true, true);
            f2 = t(n3, f2);
            c.dispatchEvent ? c.dispatchEvent(f2) : c.fireEvent(b2, f2);
          } else if (c.hcEvents) {
            f2.target || t(f2, { preventDefault: function() {
              f2.defaultPrevented = true;
            }, target: c, type: b2 });
            n3 = [];
            let d3 = c, K = false;
            for (; d3.hcEvents; )
              Object.hasOwnProperty.call(d3, "hcEvents") && d3.hcEvents[b2] && (n3.length && (K = true), n3.unshift.apply(n3, d3.hcEvents[b2])), d3 = Object.getPrototypeOf(d3);
            K && n3.sort((c2, b3) => c2.order - b3.order);
            n3.forEach((b3) => {
              b3.fn.call(c, f2) === false && f2.preventDefault();
            });
          }
          d2 && !f2.defaultPrevented && d2.call(c, f2);
        }
        const { charts: k, doc: r, win: q } = a2;
        (x || (x = {})).messages = [];
        Math.easeInOutSine = function(c) {
          return -0.5 * (Math.cos(Math.PI * c) - 1);
        };
        var G = Array.prototype.find ? function(c, b2) {
          return c.find(b2);
        } : function(c, b2) {
          let f2;
          const n3 = c.length;
          for (f2 = 0; f2 < n3; f2++)
            if (b2(c[f2], f2))
              return c[f2];
        };
        E({ map: "map", each: "forEach", grep: "filter", reduce: "reduce", some: "some" }, function(c, b2) {
          a2[b2] = function(f2) {
            x(32, false, void 0, { [`Highcharts.${b2}`]: `use Array.${c}` });
            return Array.prototype[c].apply(f2, [].slice.call(arguments, 1));
          };
        });
        let b;
        const f = function() {
          const c = Math.random().toString(36).substring(2, 9) + "-";
          let f2 = 0;
          return function() {
            return "highcharts-" + (b ? "" : c) + f2++;
          };
        }();
        q.jQuery && (q.jQuery.fn.highcharts = function() {
          const c = [].slice.call(arguments);
          if (this[0])
            return c[0] ? (new a2[L(c[0]) ? c.shift() : "Chart"](this[0], c[0], c[1]), this) : k[l2(this[0], "data-highcharts-chart")];
        });
        G = { addEvent: function(c, b2, f2, d2 = {}) {
          var n3 = typeof c === "function" && c.prototype || c;
          Object.hasOwnProperty.call(n3, "hcEvents") || (n3.hcEvents = {});
          n3 = n3.hcEvents;
          a2.Point && c instanceof a2.Point && c.series && c.series.chart && (c.series.chart.runTrackerClick = true);
          const k2 = c.addEventListener;
          k2 && k2.call(c, b2, f2, a2.supportsPassiveEvents ? { passive: d2.passive === void 0 ? b2.indexOf("touch") !== -1 : d2.passive, capture: false } : false);
          n3[b2] || (n3[b2] = []);
          n3[b2].push({ fn: f2, order: typeof d2.order === "number" ? d2.order : Infinity });
          n3[b2].sort((c2, b3) => c2.order - b3.order);
          return function() {
            F(c, b2, f2);
          };
        }, arrayMax: function(c) {
          let b2 = c.length, f2 = c[0];
          for (; b2--; )
            c[b2] > f2 && (f2 = c[b2]);
          return f2;
        }, arrayMin: function(c) {
          let b2 = c.length, f2 = c[0];
          for (; b2--; )
            c[b2] < f2 && (f2 = c[b2]);
          return f2;
        }, attr: l2, clamp: function(c, b2, f2) {
          return c > b2 ? c < f2 ? c : f2 : b2;
        }, clearTimeout: function(c) {
          v(c) && clearTimeout(c);
        }, correctFloat: e, createElement: function(c, b2, f2, d2, K) {
          c = r.createElement(c);
          b2 && t(c, b2);
          K && h(c, { padding: "0", border: "none", margin: "0" });
          f2 && h(c, f2);
          d2 && d2.appendChild(c);
          return c;
        }, css: h, defined: v, destroyObjectProperties: function(c, b2) {
          E(c, function(f2, n3) {
            f2 && f2 !== b2 && f2.destroy && f2.destroy();
            delete c[n3];
          });
        }, diffObjects: function(c, b2, f2, d2) {
          function n3(b3, c2, K, k3) {
            const A = f2 ? c2 : b3;
            E(b3, function(f3, q2) {
              if (!k3 && d2 && -1 < d2.indexOf(q2) && c2[q2]) {
                f3 = p(f3);
                K[q2] = [];
                for (let b4 = 0; b4 < Math.max(f3.length, c2[q2].length); b4++)
                  c2[q2][b4] && (f3[b4] === void 0 ? K[q2][b4] = c2[q2][b4] : (K[q2][b4] = {}, n3(f3[b4], c2[q2][b4], K[q2][b4], k3 + 1)));
              } else if (z(f3, true) && !f3.nodeType)
                K[q2] = C(f3) ? [] : {}, n3(f3, c2[q2] || {}, K[q2], k3 + 1), Object.keys(K[q2]).length !== 0 || q2 === "colorAxis" && k3 === 0 || delete K[q2];
              else if (b3[q2] !== c2[q2] || q2 in b3 && !(q2 in c2))
                K[q2] = A[q2];
            });
          }
          const k2 = {};
          n3(c, b2, k2, 0);
          return k2;
        }, discardElement: function(b2) {
          b2 && b2.parentElement && b2.parentElement.removeChild(b2);
        }, erase: function(b2, f2) {
          let c = b2.length;
          for (; c--; )
            if (b2[c] === f2) {
              b2.splice(c, 1);
              break;
            }
        }, error: x, extend: t, extendClass: function(b2, f2) {
          const c = function() {
          };
          c.prototype = new b2();
          t(c.prototype, f2);
          return c;
        }, find: G, fireEvent: d, getClosestDistance: function(b2, f2) {
          const c = !f2;
          let d2, n3, k2, q2;
          b2.forEach((b3) => {
            if (1 < b3.length)
              for (q2 = n3 = b3.length - 1; 0 < q2; q2--)
                k2 = b3[q2] - b3[q2 - 1], 0 > k2 && !c ? (f2 === null || f2 === void 0 ? void 0 : f2(), f2 = void 0) : k2 && (typeof d2 === "undefined" || k2 < d2) && (d2 = k2);
          });
          return d2;
        }, getMagnitude: g, getNestedProperty: function(b2, f2) {
          for (b2 = b2.split("."); b2.length && v(f2); ) {
            const c = b2.shift();
            if (typeof c === "undefined" || c === "__proto__")
              return;
            if (c === "this") {
              let b3;
              z(f2) && (b3 = f2["@this"]);
              return b3 !== null && b3 !== void 0 ? b3 : f2;
            }
            f2 = f2[c];
            if (!v(f2) || typeof f2 === "function" || typeof f2.nodeType === "number" || f2 === q)
              return;
          }
          return f2;
        }, getStyle: w, inArray: function(b2, f2, d2) {
          x(32, false, void 0, { "Highcharts.inArray": "use Array.indexOf" });
          return f2.indexOf(b2, d2);
        }, insertItem: function(b2, f2) {
          const c = b2.options.index, d2 = f2.length;
          let n3;
          for (n3 = b2.options.isInternal ? d2 : 0; n3 < d2 + 1; n3++)
            if (!f2[n3] || u(c) && c < m(f2[n3].options.index, f2[n3]._i) || f2[n3].options.isInternal) {
              f2.splice(n3, 0, b2);
              break;
            }
          return n3;
        }, isArray: C, isClass: B, isDOMElement: H, isFunction: function(b2) {
          return typeof b2 === "function";
        }, isNumber: u, isObject: z, isString: L, keys: function(b2) {
          x(32, false, void 0, { "Highcharts.keys": "use Object.keys" });
          return Object.keys(b2);
        }, merge: function() {
          let b2, f2 = arguments, d2 = {};
          const k2 = function(b3, c) {
            typeof b3 !== "object" && (b3 = {});
            E(c, function(f3, d3) {
              d3 !== "__proto__" && d3 !== "constructor" && (!z(f3, true) || B(f3) || H(f3) ? b3[d3] = c[d3] : b3[d3] = k2(b3[d3] || {}, f3));
            });
            return b3;
          };
          f2[0] === true && (d2 = f2[1], f2 = Array.prototype.slice.call(f2, 2));
          const K = f2.length;
          for (b2 = 0; b2 < K; b2++)
            d2 = k2(d2, f2[b2]);
          return d2;
        }, normalizeTickInterval: function(b2, f2, d2, k2, K) {
          let c = b2;
          d2 = m(d2, g(b2));
          const n3 = b2 / d2;
          f2 || (f2 = K ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], k2 === false && (d2 === 1 ? f2 = f2.filter(function(b3) {
            return b3 % 1 === 0;
          }) : 0.1 >= d2 && (f2 = [1 / d2])));
          for (k2 = 0; k2 < f2.length && !(c = f2[k2], K && c * d2 >= b2 || !K && n3 <= (f2[k2] + (f2[k2 + 1] || f2[k2])) / 2); k2++)
            ;
          return c = e(c * d2, -Math.round(Math.log(1e-3) / Math.LN10));
        }, objectEach: E, offset: function(b2) {
          const c = r.documentElement;
          b2 = b2.parentElement || b2.parentNode ? b2.getBoundingClientRect() : {
            top: 0,
            left: 0,
            width: 0,
            height: 0
          };
          return { top: b2.top + (q.pageYOffset || c.scrollTop) - (c.clientTop || 0), left: b2.left + (q.pageXOffset || c.scrollLeft) - (c.clientLeft || 0), width: b2.width, height: b2.height };
        }, pad: function(b2, f2, d2) {
          return Array((f2 || 2) + 1 - String(b2).replace("-", "").length).join(d2 || "0") + b2;
        }, pick: m, pInt: I, pushUnique: function(b2, f2) {
          return 0 > b2.indexOf(f2) && !!b2.push(f2);
        }, relativeLength: function(b2, f2, d2) {
          return /%$/.test(b2) ? f2 * parseFloat(b2) / 100 + (d2 || 0) : parseFloat(b2);
        }, removeEvent: F, splat: p, stableSort: function(b2, f2) {
          const c = b2.length;
          let d2, k2;
          for (k2 = 0; k2 < c; k2++)
            b2[k2].safeI = k2;
          b2.sort(function(b3, c2) {
            d2 = f2(b3, c2);
            return d2 === 0 ? b3.safeI - c2.safeI : d2;
          });
          for (k2 = 0; k2 < c; k2++)
            delete b2[k2].safeI;
        }, syncTimeout: function(b2, f2, d2) {
          if (0 < f2)
            return setTimeout(b2, f2, d2);
          b2.call(0, d2);
          return -1;
        }, timeUnits: { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 314496e5 }, uniqueKey: f, useSerialIds: function(c) {
          return b = m(c, b);
        }, wrap: function(b2, f2, d2) {
          const c = b2[f2];
          b2[f2] = function() {
            const b3 = arguments, f3 = this;
            return d2.apply(this, [function() {
              return c.apply(f3, arguments.length ? arguments : b3);
            }].concat([].slice.call(arguments)));
          };
        } };
        "";
        return G;
      });
      M(a, "Core/Chart/ChartDefaults.js", [], function() {
        return {
          alignThresholds: false,
          panning: { enabled: false, type: "x" },
          styledMode: false,
          borderRadius: 0,
          colorCount: 10,
          allowMutatingData: true,
          ignoreHiddenSeries: true,
          spacing: [10, 10, 15, 10],
          resetZoomButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } },
          reflow: true,
          type: "line",
          zooming: { singleTouch: false, resetButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } } },
          width: null,
          height: null,
          borderColor: "#334eff",
          backgroundColor: "#ffffff",
          plotBorderColor: "#cccccc"
        };
      });
      M(a, "Core/Color/Color.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y) {
        const { isNumber: x, merge: L, pInt: C } = y;
        class z {
          static parse(a3) {
            return a3 ? new z(a3) : z.None;
          }
          constructor(x2) {
            this.rgba = [NaN, NaN, NaN, NaN];
            this.input = x2;
            const B = a2.Color;
            if (B && B !== z)
              return new B(x2);
            this.init(x2);
          }
          init(a3) {
            let B;
            let u;
            if (typeof a3 === "object" && typeof a3.stops !== "undefined")
              this.stops = a3.stops.map((l3) => new z(l3[1]));
            else if (typeof a3 === "string") {
              this.input = a3 = z.names[a3.toLowerCase()] || a3;
              if (a3.charAt(0) === "#") {
                var v = a3.length;
                var l2 = parseInt(a3.substr(1), 16);
                v === 7 ? B = [(l2 & 16711680) >> 16, (l2 & 65280) >> 8, l2 & 255, 1] : v === 4 && (B = [(l2 & 3840) >> 4 | (l2 & 3840) >> 8, (l2 & 240) >> 4 | l2 & 240, (l2 & 15) << 4 | l2 & 15, 1]);
              }
              if (!B)
                for (l2 = z.parsers.length; l2-- && !B; )
                  u = z.parsers[l2], (v = u.regex.exec(a3)) && (B = u.parse(v));
            }
            B && (this.rgba = B);
          }
          get(a3) {
            const B = this.input, u = this.rgba;
            if (typeof B === "object" && typeof this.stops !== "undefined") {
              const v = L(B);
              v.stops = [].slice.call(v.stops);
              this.stops.forEach((l2, p) => {
                v.stops[p] = [
                  v.stops[p][0],
                  l2.get(a3)
                ];
              });
              return v;
            }
            return u && x(u[0]) ? a3 === "rgb" || !a3 && u[3] === 1 ? "rgb(" + u[0] + "," + u[1] + "," + u[2] + ")" : a3 === "a" ? `${u[3]}` : "rgba(" + u.join(",") + ")" : B;
          }
          brighten(a3) {
            const B = this.rgba;
            if (this.stops)
              this.stops.forEach(function(u) {
                u.brighten(a3);
              });
            else if (x(a3) && a3 !== 0)
              for (let u = 0; 3 > u; u++)
                B[u] += C(255 * a3), 0 > B[u] && (B[u] = 0), 255 < B[u] && (B[u] = 255);
            return this;
          }
          setOpacity(a3) {
            this.rgba[3] = a3;
            return this;
          }
          tweenTo(a3, B) {
            const u = this.rgba, v = a3.rgba;
            if (!x(u[0]) || !x(v[0]))
              return a3.input || "none";
            a3 = v[3] !== 1 || u[3] !== 1;
            return (a3 ? "rgba(" : "rgb(") + Math.round(v[0] + (u[0] - v[0]) * (1 - B)) + "," + Math.round(v[1] + (u[1] - v[1]) * (1 - B)) + "," + Math.round(v[2] + (u[2] - v[2]) * (1 - B)) + (a3 ? "," + (v[3] + (u[3] - v[3]) * (1 - B)) : "") + ")";
          }
        }
        z.names = { white: "#ffffff", black: "#000000" };
        z.parsers = [{ regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, parse: function(a3) {
          return [C(a3[1]), C(a3[2]), C(a3[3]), parseFloat(a3[4], 10)];
        } }, { regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, parse: function(a3) {
          return [
            C(a3[1]),
            C(a3[2]),
            C(a3[3]),
            1
          ];
        } }];
        z.None = new z("");
        "";
        return z;
      });
      M(a, "Core/Color/Palettes.js", [], function() {
        return { colors: "#2caffe #544fc5 #00e272 #fe6a35 #6b8abc #d568fb #2ee0ca #fa4b42 #feb56a #91e8e1".split(" ") };
      });
      M(a, "Core/Time.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y) {
        const { win: x } = a2, { defined: L, error: C, extend: z, isObject: H, merge: B, objectEach: u, pad: v, pick: l2, splat: p, timeUnits: t } = y, m = a2.isSafari && x.Intl && x.Intl.DateTimeFormat.prototype.formatRange, h = a2.isSafari && x.Intl && !x.Intl.DateTimeFormat.prototype.formatRange;
        class g {
          constructor(e) {
            this.options = {};
            this.variableTimezone = this.useUTC = false;
            this.Date = x.Date;
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            this.update(e);
          }
          get(e, g2) {
            if (this.variableTimezone || this.timezoneOffset) {
              const h3 = g2.getTime(), m2 = h3 - this.getTimezoneOffset(g2);
              g2.setTime(m2);
              e = g2["getUTC" + e]();
              g2.setTime(h3);
              return e;
            }
            return this.useUTC ? g2["getUTC" + e]() : g2["get" + e]();
          }
          set(e, g2, h3) {
            if (this.variableTimezone || this.timezoneOffset) {
              if (e === "Milliseconds" || e === "Seconds" || e === "Minutes" && this.getTimezoneOffset(g2) % 36e5 === 0)
                return g2["setUTC" + e](h3);
              var w = this.getTimezoneOffset(g2);
              w = g2.getTime() - w;
              g2.setTime(w);
              g2["setUTC" + e](h3);
              e = this.getTimezoneOffset(g2);
              w = g2.getTime() + e;
              return g2.setTime(w);
            }
            return this.useUTC || m && e === "FullYear" ? g2["setUTC" + e](h3) : g2["set" + e](h3);
          }
          update(e = {}) {
            const g2 = l2(e.useUTC, true);
            this.options = e = B(true, this.options, e);
            this.Date = e.Date || x.Date || Date;
            this.timezoneOffset = (this.useUTC = g2) && e.timezoneOffset || void 0;
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            this.variableTimezone = g2 && !(!e.getTimezoneOffset && !e.timezone);
          }
          makeTime(e, g2, m2, p2, d, k) {
            let r, q, w;
            this.useUTC ? (r = this.Date.UTC.apply(0, arguments), q = this.getTimezoneOffset(r), r += q, w = this.getTimezoneOffset(r), q !== w ? r += w - q : q - 36e5 !== this.getTimezoneOffset(r - 36e5) || h || (r -= 36e5)) : r = new this.Date(e, g2, l2(m2, 1), l2(p2, 0), l2(d, 0), l2(k, 0)).getTime();
            return r;
          }
          timezoneOffsetFunction() {
            const e = this, g2 = this.options, h3 = g2.getTimezoneOffset, m2 = g2.moment || x.moment;
            if (!this.useUTC)
              return function(d) {
                return 6e4 * new Date(d.toString()).getTimezoneOffset();
              };
            if (g2.timezone) {
              if (m2)
                return function(d) {
                  return 6e4 * -m2.tz(d, g2.timezone).utcOffset();
                };
              C(25);
            }
            return this.useUTC && h3 ? function(d) {
              return 6e4 * h3(d.valueOf());
            } : function() {
              return 6e4 * (e.timezoneOffset || 0);
            };
          }
          dateFormat(e, g2, h3) {
            if (!L(g2) || isNaN(g2))
              return a2.defaultOptions.lang && a2.defaultOptions.lang.invalidDate || "";
            e = l2(e, "%Y-%m-%d %H:%M:%S");
            const m2 = this;
            var d = new this.Date(g2);
            const k = this.get("Hours", d), r = this.get("Day", d), q = this.get("Date", d), w = this.get("Month", d), b = this.get("FullYear", d), f = a2.defaultOptions.lang, c = f && f.weekdays, n3 = f && f.shortWeekdays;
            d = z({ a: n3 ? n3[r] : c[r].substr(0, 3), A: c[r], d: v(q), e: v(q, 2, " "), w: r, b: f.shortMonths[w], B: f.months[w], m: v(w + 1), o: w + 1, y: b.toString().substr(2, 2), Y: b, H: v(k), k, I: v(k % 12 || 12), l: k % 12 || 12, M: v(this.get("Minutes", d)), p: 12 > k ? "AM" : "PM", P: 12 > k ? "am" : "pm", S: v(d.getSeconds()), L: v(Math.floor(g2 % 1e3), 3) }, a2.dateFormats);
            u(d, function(b2, c2) {
              for (; e.indexOf("%" + c2) !== -1; )
                e = e.replace("%" + c2, typeof b2 === "function" ? b2.call(m2, g2) : b2);
            });
            return h3 ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;
          }
          resolveDTLFormat(e) {
            return H(e, true) ? e : (e = p(e), {
              main: e[0],
              from: e[1],
              to: e[2]
            });
          }
          getTimeTicks(e, g2, h3, m2) {
            const d = this, k = [], r = {};
            var q = new d.Date(g2);
            const w = e.unitRange, b = e.count || 1;
            let f;
            m2 = l2(m2, 1);
            if (L(g2)) {
              d.set("Milliseconds", q, w >= t.second ? 0 : b * Math.floor(d.get("Milliseconds", q) / b));
              w >= t.second && d.set("Seconds", q, w >= t.minute ? 0 : b * Math.floor(d.get("Seconds", q) / b));
              w >= t.minute && d.set("Minutes", q, w >= t.hour ? 0 : b * Math.floor(d.get("Minutes", q) / b));
              w >= t.hour && d.set("Hours", q, w >= t.day ? 0 : b * Math.floor(d.get("Hours", q) / b));
              w >= t.day && d.set("Date", q, w >= t.month ? 1 : Math.max(1, b * Math.floor(d.get("Date", q) / b)));
              if (w >= t.month) {
                d.set("Month", q, w >= t.year ? 0 : b * Math.floor(d.get("Month", q) / b));
                var c = d.get("FullYear", q);
              }
              w >= t.year && d.set("FullYear", q, c - c % b);
              w === t.week && (c = d.get("Day", q), d.set("Date", q, d.get("Date", q) - c + m2 + (c < m2 ? -7 : 0)));
              c = d.get("FullYear", q);
              m2 = d.get("Month", q);
              const n3 = d.get("Date", q), e2 = d.get("Hours", q);
              g2 = q.getTime();
              !d.variableTimezone && d.useUTC || !L(h3) || (f = h3 - g2 > 4 * t.month || d.getTimezoneOffset(g2) !== d.getTimezoneOffset(h3));
              g2 = q.getTime();
              for (q = 1; g2 < h3; )
                k.push(g2), g2 = w === t.year ? d.makeTime(c + q * b, 0) : w === t.month ? d.makeTime(c, m2 + q * b) : !f || w !== t.day && w !== t.week ? f && w === t.hour && 1 < b ? d.makeTime(c, m2, n3, e2 + q * b) : g2 + w * b : d.makeTime(c, m2, n3 + q * b * (w === t.day ? 1 : 7)), q++;
              k.push(g2);
              w <= t.hour && 1e4 > k.length && k.forEach(function(b2) {
                b2 % 18e5 === 0 && d.dateFormat("%H%M%S%L", b2) === "000000000" && (r[b2] = "day");
              });
            }
            k.info = z(e, { higherRanks: r, totalRange: w * b });
            return k;
          }
          getDateFormat(e, g2, h3, m2) {
            const d = this.dateFormat("%m-%d %H:%M:%S.%L", g2), k = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 };
            let r, q = "millisecond";
            for (r in t) {
              if (e === t.week && +this.dateFormat("%w", g2) === h3 && d.substr(6) === "00:00:00.000") {
                r = "week";
                break;
              }
              if (t[r] > e) {
                r = q;
                break;
              }
              if (k[r] && d.substr(k[r]) !== "01-01 00:00:00.000".substr(k[r]))
                break;
              r !== "week" && (q = r);
            }
            return this.resolveDTLFormat(m2[r]).main;
          }
        }
        "";
        return g;
      });
      M(a, "Core/Defaults.js", [a["Core/Chart/ChartDefaults.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Color/Palettes.js"], a["Core/Time.js"], a["Core/Utilities.js"]], function(a2, y, I, L, C, z) {
        const { isTouchDevice: x, svg: B } = I, { merge: u } = z, v = {
          colors: L.colors,
          symbols: [
            "circle",
            "diamond",
            "square",
            "triangle",
            "triangle-down"
          ],
          lang: { loading: "Loading...", months: "January February March April May June July August September October November December".split(" "), shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), decimalPoint: ".", numericSymbols: "kMGTPE".split(""), resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " " },
          global: {},
          time: {
            Date: void 0,
            getTimezoneOffset: void 0,
            timezone: void 0,
            timezoneOffset: 0,
            useUTC: true
          },
          chart: a2,
          title: { style: { color: "#333333", fontWeight: "bold" }, text: "Chart title", align: "center", margin: 15, widthAdjust: -44 },
          subtitle: { style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "center", widthAdjust: -44 },
          caption: { margin: 15, style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "left", verticalAlign: "bottom" },
          plotOptions: {},
          legend: {
            enabled: true,
            align: "center",
            alignColumns: true,
            className: "highcharts-no-tooltip",
            layout: "horizontal",
            itemMarginBottom: 2,
            itemMarginTop: 2,
            labelFormatter: function() {
              return this.name;
            },
            borderColor: "#999999",
            borderRadius: 0,
            navigation: { style: { fontSize: "0.8em" }, activeColor: "#0022ff", inactiveColor: "#cccccc" },
            itemStyle: { color: "#333333", cursor: "pointer", fontSize: "0.8em", textDecoration: "none", textOverflow: "ellipsis" },
            itemHoverStyle: { color: "#000000" },
            itemHiddenStyle: { color: "#666666", textDecoration: "line-through" },
            shadow: false,
            itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" },
            squareSymbol: true,
            symbolPadding: 5,
            verticalAlign: "bottom",
            x: 0,
            y: 0,
            title: { style: { fontSize: "0.8em", fontWeight: "bold" } }
          },
          loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute", backgroundColor: "#ffffff", opacity: 0.5, textAlign: "center" } },
          tooltip: {
            enabled: true,
            animation: B,
            borderRadius: 3,
            dateTimeLabelFormats: { millisecond: "%A, %e %b, %H:%M:%S.%L", second: "%A, %e %b, %H:%M:%S", minute: "%A, %e %b, %H:%M", hour: "%A, %e %b, %H:%M", day: "%A, %e %b %Y", week: "Week from %A, %e %b %Y", month: "%B %Y", year: "%Y" },
            footerFormat: "",
            headerShape: "callout",
            hideDelay: 500,
            padding: 8,
            shape: "callout",
            shared: false,
            snap: x ? 25 : 10,
            headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>',
            pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
            backgroundColor: "#ffffff",
            borderWidth: void 0,
            shadow: true,
            stickOnContact: false,
            style: { color: "#333333", cursor: "default", fontSize: "0.8em" },
            useHTML: false
          },
          credits: {
            enabled: true,
            href: "https://www.highcharts.com?credits",
            position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 },
            style: { cursor: "pointer", color: "#999999", fontSize: "0.6em" },
            text: "Highcharts.com"
          }
        };
        v.chart.styledMode = false;
        "";
        const l2 = new C(v.time);
        a2 = { defaultOptions: v, defaultTime: l2, getOptions: function() {
          return v;
        }, setOptions: function(a3) {
          u(true, v, a3);
          if (a3.time || a3.global)
            I.time ? I.time.update(u(v.global, v.time, a3.global, a3.time)) : I.time = l2;
          return v;
        } };
        "";
        return a2;
      });
      M(a, "Core/Animation/Fx.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { parse: x } = a2, { win: C } = y, { isNumber: z, objectEach: H } = I;
        class B {
          constructor(a3, v, l2) {
            this.pos = NaN;
            this.options = v;
            this.elem = a3;
            this.prop = l2;
          }
          dSetter() {
            var a3 = this.paths;
            const v = a3 && a3[0];
            a3 = a3 && a3[1];
            const l2 = this.now || 0;
            let p = [];
            if (l2 !== 1 && v && a3)
              if (v.length === a3.length && 1 > l2)
                for (let t = 0; t < a3.length; t++) {
                  const m = v[t], h = a3[t], g = [];
                  for (let e = 0; e < h.length; e++) {
                    const w = m[e], a4 = h[e];
                    z(w) && z(a4) && (h[0] !== "A" || e !== 4 && e !== 5) ? g[e] = w + l2 * (a4 - w) : g[e] = a4;
                  }
                  p.push(g);
                }
              else
                p = a3;
            else
              p = this.toD || [];
            this.elem.attr("d", p, void 0, true);
          }
          update() {
            const a3 = this.elem, v = this.prop, l2 = this.now, p = this.options.step;
            if (this[v + "Setter"])
              this[v + "Setter"]();
            else
              a3.attr ? a3.element && a3.attr(v, l2, null, true) : a3.style[v] = l2 + this.unit;
            p && p.call(a3, l2, this);
          }
          run(a3, v, l2) {
            const p = this, t = p.options, m = function(e) {
              return m.stopped ? false : p.step(e);
            }, h = C.requestAnimationFrame || function(e) {
              setTimeout(e, 13);
            }, g = function() {
              for (let e = 0; e < B.timers.length; e++)
                B.timers[e]() || B.timers.splice(e--, 1);
              B.timers.length && h(g);
            };
            a3 !== v || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = a3, this.end = v, this.unit = l2, this.now = this.start, this.pos = 0, m.elem = this.elem, m.prop = this.prop, m() && B.timers.push(m) === 1 && h(g)) : (delete t.curAnim[this.prop], t.complete && Object.keys(t.curAnim).length === 0 && t.complete.call(this.elem));
          }
          step(a3) {
            const v = +new Date(), l2 = this.options, p = this.elem, t = l2.complete, m = l2.duration, h = l2.curAnim;
            let g;
            p.attr && !p.element ? a3 = false : a3 || v >= m + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), g = h[this.prop] = true, H(h, function(e) {
              e !== true && (g = false);
            }), g && t && t.call(p), a3 = false) : (this.pos = l2.easing((v - this.startTime) / m), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a3 = true);
            return a3;
          }
          initPath(a3, v, l2) {
            function p(d, k) {
              for (; d.length < E; ) {
                var r = d[0];
                const q = k[E - d.length];
                q && r[0] === "M" && (d[0] = q[0] === "C" ? ["C", r[1], r[2], r[1], r[2], r[1], r[2]] : ["L", r[1], r[2]]);
                d.unshift(r);
                g && (r = d.pop(), d.push(d[d.length - 1], r));
              }
            }
            function t(d, k) {
              for (; d.length < E; )
                if (k = d[Math.floor(d.length / e) - 1].slice(), k[0] === "C" && (k[1] = k[5], k[2] = k[6]), g) {
                  const r = d[Math.floor(d.length / e)].slice();
                  d.splice(d.length / 2, 0, k, r);
                } else
                  d.push(k);
            }
            const m = a3.startX, h = a3.endX;
            l2 = l2.slice();
            const g = a3.isArea, e = g ? 2 : 1;
            let w, E, F;
            v = v && v.slice();
            if (!v)
              return [
                l2,
                l2
              ];
            if (m && h && h.length) {
              for (a3 = 0; a3 < m.length; a3++)
                if (m[a3] === h[0]) {
                  w = a3;
                  break;
                } else if (m[0] === h[h.length - m.length + a3]) {
                  w = a3;
                  F = true;
                  break;
                } else if (m[m.length - 1] === h[h.length - m.length + a3]) {
                  w = m.length - a3;
                  break;
                }
              typeof w === "undefined" && (v = []);
            }
            v.length && z(w) && (E = l2.length + w * e, F ? (p(v, l2), t(l2, v)) : (p(l2, v), t(v, l2)));
            return [v, l2];
          }
          fillSetter() {
            B.prototype.strokeSetter.apply(this, arguments);
          }
          strokeSetter() {
            this.elem.attr(this.prop, x(this.start).tweenTo(x(this.end), this.pos), void 0, true);
          }
        }
        B.timers = [];
        return B;
      });
      M(a, "Core/Animation/AnimationUtilities.js", [a["Core/Animation/Fx.js"], a["Core/Utilities.js"]], function(a2, y) {
        function x(a3) {
          return u(a3) ? v({ duration: 500, defer: 0 }, a3) : { duration: a3 ? 500 : 0, defer: 0 };
        }
        function L(l3, m) {
          let h = a2.timers.length;
          for (; h--; )
            a2.timers[h].elem !== l3 || m && m !== a2.timers[h].prop || (a2.timers[h].stopped = true);
        }
        const { defined: C, getStyle: z, isArray: H, isNumber: B, isObject: u, merge: v, objectEach: l2, pick: p } = y;
        return { animate: function(p2, m, h) {
          let g, e = "", w, E, F;
          u(h) || (F = arguments, h = { duration: F[2], easing: F[3], complete: F[4] });
          B(h.duration) || (h.duration = 400);
          h.easing = typeof h.easing === "function" ? h.easing : Math[h.easing] || Math.easeInOutSine;
          h.curAnim = v(m);
          l2(m, function(d, k) {
            L(p2, k);
            E = new a2(p2, h, k);
            w = void 0;
            k === "d" && H(m.d) ? (E.paths = E.initPath(p2, p2.pathArray, m.d), E.toD = m.d, g = 0, w = 1) : p2.attr ? g = p2.attr(k) : (g = parseFloat(z(p2, k)) || 0, k !== "opacity" && (e = "px"));
            w || (w = d);
            typeof w === "string" && w.match("px") && (w = w.replace(/px/g, ""));
            E.run(g, w, e);
          });
        }, animObject: x, getDeferredAnimation: function(a3, m, h) {
          const g = x(m);
          let e = 0, w = 0;
          (h ? [h] : a3.series).forEach((h3) => {
            h3 = x(h3.options.animation);
            e = m && C(m.defer) ? g.defer : Math.max(e, h3.duration + h3.defer);
            w = Math.min(g.duration, h3.duration);
          });
          a3.renderer.forExport && (e = 0);
          return { defer: Math.max(0, e - w), duration: Math.min(e, w) };
        }, setAnimation: function(a3, m) {
          m.renderer.globalAnimation = p(a3, m.options.chart.animation, true);
        }, stop: L };
      });
      M(a, "Core/Renderer/HTML/AST.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y) {
        const { SVG_NS: x, win: L } = a2, { attr: C, createElement: z, css: H, error: B, isFunction: u, isString: v, objectEach: l2, splat: p } = y;
        ({ trustedTypes: y } = L);
        const t = y && u(y.createPolicy) && y.createPolicy("highcharts", { createHTML: (e) => e });
        y = t ? t.createHTML("") : "";
        try {
          var m = !!new DOMParser().parseFromString(y, "text/html");
        } catch (e) {
          m = false;
        }
        const h = m;
        class g {
          static filterUserAttributes(e) {
            l2(e, (h3, m2) => {
              let a3 = true;
              g.allowedAttributes.indexOf(m2) === -1 && (a3 = false);
              ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(m2) !== -1 && (a3 = v(h3) && g.allowedReferences.some((d) => h3.indexOf(d) === 0));
              a3 || (B(33, false, void 0, { "Invalid attribute in config": `${m2}` }), delete e[m2]);
              v(h3) && e[m2] && (e[m2] = h3.replace(/</g, "&lt;"));
            });
            return e;
          }
          static parseStyle(e) {
            return e.split(";").reduce((e2, g2) => {
              g2 = g2.split(":").map((d) => d.trim());
              const h3 = g2.shift();
              h3 && g2.length && (e2[h3.replace(/-([a-z])/g, (d) => d[1].toUpperCase())] = g2.join(":"));
              return e2;
            }, {});
          }
          static setElementHTML(e, h3) {
            e.innerHTML = g.emptyHTML;
            h3 && new g(h3).addToDOM(e);
          }
          constructor(e) {
            this.nodes = typeof e === "string" ? this.parseMarkup(e) : e;
          }
          addToDOM(e) {
            function h3(e2, m2) {
              let d;
              p(e2).forEach(function(k) {
                var e3 = k.tagName;
                const q = k.textContent ? a2.doc.createTextNode(k.textContent) : void 0, w = g.bypassHTMLFiltering;
                let b;
                if (e3)
                  if (e3 === "#text")
                    b = q;
                  else if (g.allowedTags.indexOf(e3) !== -1 || w) {
                    e3 = a2.doc.createElementNS(e3 === "svg" ? x : m2.namespaceURI || x, e3);
                    const f = k.attributes || {};
                    l2(k, function(b2, d2) {
                      d2 !== "tagName" && d2 !== "attributes" && d2 !== "children" && d2 !== "style" && d2 !== "textContent" && (f[d2] = b2);
                    });
                    C(e3, w ? f : g.filterUserAttributes(f));
                    k.style && H(e3, k.style);
                    q && e3.appendChild(q);
                    h3(k.children || [], e3);
                    b = e3;
                  } else
                    B(33, false, void 0, { "Invalid tagName in config": e3 });
                b && m2.appendChild(b);
                d = b;
              });
              return d;
            }
            return h3(this.nodes, e);
          }
          parseMarkup(e) {
            const m2 = [];
            e = e.trim().replace(/ style=(["'])/g, " data-style=$1");
            if (h)
              e = new DOMParser().parseFromString(t ? t.createHTML(e) : e, "text/html");
            else {
              const g2 = z("div");
              g2.innerHTML = e;
              e = { body: g2 };
            }
            const a3 = (e2, d) => {
              var k = e2.nodeName.toLowerCase();
              const r = { tagName: k };
              k === "#text" && (r.textContent = e2.textContent || "");
              if (k = e2.attributes) {
                const d2 = {};
                [].forEach.call(k, (k2) => {
                  k2.name === "data-style" ? r.style = g.parseStyle(k2.value) : d2[k2.name] = k2.value;
                });
                r.attributes = d2;
              }
              if (e2.childNodes.length) {
                const d2 = [];
                [].forEach.call(e2.childNodes, (k2) => {
                  a3(k2, d2);
                });
                d2.length && (r.children = d2);
              }
              d.push(r);
            };
            [].forEach.call(e.body.childNodes, (e2) => a3(e2, m2));
            return m2;
          }
        }
        g.allowedAttributes = "alt aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill flood-color flood-opacity height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex".split(" ");
        g.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
        g.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feDropShadow feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text".split(" ");
        g.emptyHTML = y;
        g.bypassHTMLFiltering = false;
        "";
        return g;
      });
      M(a, "Core/Templating.js", [a["Core/Defaults.js"], a["Core/Utilities.js"]], function(a2, y) {
        function x(h = "", g, e) {
          const a3 = /\{([a-zA-Z0-9:\.,;\-\/<>%_@"'= #\(\)]+)\}/g, l3 = /\(([a-zA-Z0-9:\.,;\-\/<>%_@"'= ]+)\)/g, v2 = [], d = /f$/, k = /\.([0-9])/, r = C.lang, q = e && e.time || z, G = e && e.numberFormatter || L, b = (b2 = "") => {
            let c2;
            return b2 === "true" ? true : b2 === "false" ? false : (c2 = Number(b2)).toString() === b2 ? c2 : B(b2, g);
          };
          let f, c, n3 = 0, P;
          for (; (f = a3.exec(h)) !== null; ) {
            const b2 = l3.exec(f[1]);
            b2 && (f = b2, P = true);
            c && c.isBlock || (c = {
              ctx: g,
              expression: f[1],
              find: f[0],
              isBlock: f[1].charAt(0) === "#",
              start: f.index,
              startInner: f.index + f[0].length,
              length: f[0].length
            });
            var D = f[1].split(" ")[0].replace("#", "");
            m[D] && (c.isBlock && D === c.fn && n3++, c.fn || (c.fn = D));
            D = f[1] === "else";
            if (c.isBlock && c.fn && (f[1] === `/${c.fn}` || D))
              if (n3)
                D || n3--;
              else {
                var K = c.startInner;
                K = h.substr(K, f.index - K);
                c.body === void 0 ? (c.body = K, c.startInner = f.index + f[0].length) : c.elseBody = K;
                c.find += K + f[0];
                D || (v2.push(c), c = void 0);
              }
            else
              c.isBlock || v2.push(c);
            if (b2 && (c === null || c === void 0 || !c.isBlock))
              break;
          }
          v2.forEach((c2) => {
            const { body: f2, elseBody: n4, expression: K2, fn: e2 } = c2;
            var A;
            if (e2) {
              var a4 = [c2], w = K2.split(" ");
              for (A = m[e2].length; A--; )
                a4.unshift(b(w[A + 1]));
              A = m[e2].apply(g, a4);
              c2.isBlock && typeof A === "boolean" && (A = x(A ? f2 : n4, g));
            } else
              a4 = K2.split(":"), A = b(a4.shift() || ""), a4.length && typeof A === "number" && (a4 = a4.join(":"), d.test(a4) ? (w = parseInt((a4.match(k) || ["", "-1"])[1], 10), A !== null && (A = G(A, w, r.decimalPoint, -1 < a4.indexOf(",") ? r.thousandsSep : ""))) : A = q.dateFormat(a4, A));
            h = h.replace(c2.find, p(A, ""));
          });
          return P ? x(h, g, e) : h;
        }
        function L(h, g, e, a3) {
          h = +h || 0;
          g = +g;
          const m2 = C.lang;
          var w = (h.toString().split(".")[1] || "").split("e")[0].length;
          const d = h.toString().split("e"), k = g;
          if (g === -1)
            g = Math.min(w, 20);
          else if (!v(g))
            g = 2;
          else if (g && d[1] && 0 > d[1]) {
            var r = g + +d[1];
            0 <= r ? (d[0] = (+d[0]).toExponential(r).split("e")[0], g = r) : (d[0] = d[0].split(".")[0] || 0, h = 20 > g ? (d[0] * Math.pow(10, d[1])).toFixed(g) : 0, d[1] = 0);
          }
          r = (Math.abs(d[1] ? d[0] : h) + Math.pow(10, -Math.max(g, w) - 1)).toFixed(g);
          w = String(t(r));
          const q = 3 < w.length ? w.length % 3 : 0;
          e = p(e, m2.decimalPoint);
          a3 = p(a3, m2.thousandsSep);
          h = (0 > h ? "-" : "") + (q ? w.substr(0, q) + a3 : "");
          h = 0 > +d[1] && !k ? "0" : h + w.substr(q).replace(/(\d{3})(?=\d)/g, "$1" + a3);
          g && (h += e + r.slice(-g));
          d[1] && +h !== 0 && (h += "e" + d[1]);
          return h;
        }
        const { defaultOptions: C, defaultTime: z } = a2, { extend: H, getNestedProperty: B, isArray: u, isNumber: v, isObject: l2, pick: p, pInt: t } = y, m = { add: (h, g) => h + g, divide: (h, g) => g !== 0 ? h / g : "", eq: (h, g) => h == g, each: function(h) {
          const g = arguments[arguments.length - 1];
          return u(h) ? h.map((e, a3) => x(g.body, H(l2(e) ? e : { "@this": e }, { "@index": a3, "@first": a3 === 0, "@last": a3 === h.length - 1 }))).join("") : false;
        }, ge: (h, g) => h >= g, gt: (h, g) => h > g, "if": (h) => !!h, le: (h, g) => h <= g, lt: (h, g) => h < g, multiply: (h, g) => h * g, ne: (h, g) => h != g, subtract: (h, g) => h - g, unless: (h) => !h };
        return { dateFormat: function(h, g, e) {
          return z.dateFormat(h, g, e);
        }, format: x, helpers: m, numberFormat: L };
      });
      M(a, "Core/Renderer/RendererUtilities.js", [a["Core/Utilities.js"]], function(a2) {
        const { clamp: x, pick: I, stableSort: L } = a2;
        var C;
        (function(a3) {
          function y(a4, u, v) {
            const l2 = a4;
            var p = l2.reducedLen || u, t = (e2, g2) => (g2.rank || 0) - (e2.rank || 0);
            const m = (e2, g2) => e2.target - g2.target;
            let h, g = true, e = [], w = 0;
            for (h = a4.length; h--; )
              w += a4[h].size;
            if (w > p) {
              L(a4, t);
              for (w = h = 0; w <= p; )
                w += a4[h].size, h++;
              e = a4.splice(h - 1, a4.length);
            }
            L(a4, m);
            for (a4 = a4.map((e2) => ({ size: e2.size, targets: [e2.target], align: I(e2.align, 0.5) })); g; ) {
              for (h = a4.length; h--; )
                p = a4[h], t = (Math.min.apply(0, p.targets) + Math.max.apply(0, p.targets)) / 2, p.pos = x(t - p.size * p.align, 0, u - p.size);
              h = a4.length;
              for (g = false; h--; )
                0 < h && a4[h - 1].pos + a4[h - 1].size > a4[h].pos && (a4[h - 1].size += a4[h].size, a4[h - 1].targets = a4[h - 1].targets.concat(a4[h].targets), a4[h - 1].align = 0.5, a4[h - 1].pos + a4[h - 1].size > u && (a4[h - 1].pos = u - a4[h - 1].size), a4.splice(h, 1), g = true);
            }
            l2.push.apply(l2, e);
            h = 0;
            a4.some((e2) => {
              let g2 = 0;
              return (e2.targets || []).some(() => {
                l2[h].pos = e2.pos + g2;
                if (typeof v !== "undefined" && Math.abs(l2[h].pos - l2[h].target) > v)
                  return l2.slice(0, h + 1).forEach((d) => delete d.pos), l2.reducedLen = (l2.reducedLen || u) - 0.1 * u, l2.reducedLen > 0.1 * u && y(l2, u, v), true;
                g2 += l2[h].size;
                h++;
                return false;
              });
            });
            L(l2, m);
            return l2;
          }
          a3.distribute = y;
        })(C || (C = {}));
        return C;
      });
      M(a, "Core/Renderer/SVG/SVGElement.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Color/Color.js"],
        a["Core/Globals.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, I, L) {
        const { animate: x, animObject: z, stop: H } = a2, { deg2rad: B, doc: u, svg: v, SVG_NS: l2, win: p } = I, { addEvent: t, attr: m, createElement: h, css: g, defined: e, erase: w, extend: E, fireEvent: F, isArray: d, isFunction: k, isObject: r, isString: q, merge: G, objectEach: b, pick: f, pInt: c, syncTimeout: n3, uniqueKey: P } = L;
        class D {
          constructor() {
            this.element = void 0;
            this.onEvents = {};
            this.opacity = 1;
            this.renderer = void 0;
            this.SVG_NS = l2;
          }
          _defaultGetter(b2) {
            b2 = f(this[b2 + "Value"], this[b2], this.element ? this.element.getAttribute(b2) : null, 0);
            /^[\-0-9\.]+$/.test(b2) && (b2 = parseFloat(b2));
            return b2;
          }
          _defaultSetter(b2, c2, f2) {
            f2.setAttribute(c2, b2);
          }
          add(b2) {
            const c2 = this.renderer, f2 = this.element;
            let d2;
            b2 && (this.parentGroup = b2);
            typeof this.textStr !== "undefined" && this.element.nodeName === "text" && c2.buildText(this);
            this.added = true;
            if (!b2 || b2.handleZ || this.zIndex)
              d2 = this.zIndexSetter();
            d2 || (b2 ? b2.element : c2.box).appendChild(f2);
            if (this.onAdd)
              this.onAdd();
            return this;
          }
          addClass(b2, c2) {
            const f2 = c2 ? "" : this.attr("class") || "";
            b2 = (b2 || "").split(/ /g).reduce(function(b3, c3) {
              f2.indexOf(c3) === -1 && b3.push(c3);
              return b3;
            }, f2 ? [f2] : []).join(" ");
            b2 !== f2 && this.attr("class", b2);
            return this;
          }
          afterSetters() {
            this.doTransform && (this.updateTransform(), this.doTransform = false);
          }
          align(b2, c2, d2) {
            const k2 = {};
            var n4 = this.renderer, e2 = n4.alignedObjects, A;
            let K, g2;
            if (b2) {
              if (this.alignOptions = b2, this.alignByTranslate = c2, !d2 || q(d2))
                this.alignTo = A = d2 || "renderer", w(e2, this), e2.push(this), d2 = void 0;
            } else
              b2 = this.alignOptions, c2 = this.alignByTranslate, A = this.alignTo;
            d2 = f(d2, n4[A], A === "scrollablePlotBox" ? n4.plotBox : void 0, n4);
            A = b2.align;
            const a3 = b2.verticalAlign;
            n4 = (d2.x || 0) + (b2.x || 0);
            e2 = (d2.y || 0) + (b2.y || 0);
            A === "right" ? K = 1 : A === "center" && (K = 2);
            K && (n4 += (d2.width - (b2.width || 0)) / K);
            k2[c2 ? "translateX" : "x"] = Math.round(n4);
            a3 === "bottom" ? g2 = 1 : a3 === "middle" && (g2 = 2);
            g2 && (e2 += (d2.height - (b2.height || 0)) / g2);
            k2[c2 ? "translateY" : "y"] = Math.round(e2);
            this[this.placed ? "animate" : "attr"](k2);
            this.placed = true;
            this.alignAttr = k2;
            return this;
          }
          alignSetter(b2) {
            const c2 = { left: "start", center: "middle", right: "end" };
            c2[b2] && (this.alignValue = b2, this.element.setAttribute("text-anchor", c2[b2]));
          }
          animate(c2, d2, k2) {
            const e2 = z(f(d2, this.renderer.globalAnimation, true));
            d2 = e2.defer;
            u.hidden && (e2.duration = 0);
            e2.duration !== 0 ? (k2 && (e2.complete = k2), n3(() => {
              this.element && x(this, c2, e2);
            }, d2)) : (this.attr(c2, void 0, k2 || e2.complete), b(c2, function(b2, c3) {
              e2.step && e2.step.call(this, b2, { prop: c3, pos: 1, elem: this });
            }, this));
            return this;
          }
          applyTextOutline(b2) {
            const c2 = this.element;
            b2.indexOf("contrast") !== -1 && (b2 = b2.replace(/contrast/g, this.renderer.getContrast(c2.style.fill)));
            var f2 = b2.split(" ");
            b2 = f2[f2.length - 1];
            if ((f2 = f2[0]) && f2 !== "none" && I.svg) {
              this.fakeTS = true;
              f2 = f2.replace(/(^[\d\.]+)(.*?)$/g, function(b3, c3, f3) {
                return 2 * Number(c3) + f3;
              });
              this.removeTextOutline();
              const d2 = u.createElementNS(l2, "tspan");
              m(d2, { "class": "highcharts-text-outline", fill: b2, stroke: b2, "stroke-width": f2, "stroke-linejoin": "round" });
              b2 = c2.querySelector("textPath") || c2;
              [].forEach.call(b2.childNodes, (b3) => {
                const c3 = b3.cloneNode(true);
                c3.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach((b4) => c3.removeAttribute(b4));
                d2.appendChild(c3);
              });
              let k2 = 0;
              [].forEach.call(b2.querySelectorAll("text tspan"), (b3) => {
                k2 += Number(b3.getAttribute("dy"));
              });
              f2 = u.createElementNS(l2, "tspan");
              f2.textContent = "\u200B";
              m(f2, { x: Number(c2.getAttribute("x")), dy: -k2 });
              d2.appendChild(f2);
              b2.insertBefore(d2, b2.firstChild);
            }
          }
          attr(c2, f2, d2, k2) {
            const n4 = this.element, e2 = D.symbolCustomAttribs;
            let A, q2, g2 = this, a3, K;
            typeof c2 === "string" && typeof f2 !== "undefined" && (A = c2, c2 = {}, c2[A] = f2);
            typeof c2 === "string" ? g2 = (this[c2 + "Getter"] || this._defaultGetter).call(this, c2, n4) : (b(c2, function(b2, f3) {
              a3 = false;
              k2 || H(this, f3);
              this.symbolName && e2.indexOf(f3) !== -1 && (q2 || (this.symbolAttr(c2), q2 = true), a3 = true);
              !this.rotation || f3 !== "x" && f3 !== "y" || (this.doTransform = true);
              a3 || (K = this[f3 + "Setter"] || this._defaultSetter, K.call(this, b2, f3, n4));
            }, this), this.afterSetters());
            d2 && d2.call(this);
            return g2;
          }
          clip(b2) {
            return this.attr("clip-path", b2 ? "url(" + this.renderer.url + "#" + b2.id + ")" : "none");
          }
          crisp(b2, c2) {
            c2 = c2 || b2.strokeWidth || 0;
            const f2 = Math.round(c2) % 2 / 2;
            b2.x = Math.floor(b2.x || this.x || 0) + f2;
            b2.y = Math.floor(b2.y || this.y || 0) + f2;
            b2.width = Math.floor((b2.width || this.width || 0) - 2 * f2);
            b2.height = Math.floor((b2.height || this.height || 0) - 2 * f2);
            e(b2.strokeWidth) && (b2.strokeWidth = c2);
            return b2;
          }
          complexColor(c2, f2, k2) {
            const n4 = this.renderer;
            let q2, g2, A, a3, r2, K, h3, J, m2, O, w2 = [], l3;
            F(this.renderer, "complexColor", { args: arguments }, function() {
              c2.radialGradient ? g2 = "radialGradient" : c2.linearGradient && (g2 = "linearGradient");
              if (g2) {
                A = c2[g2];
                r2 = n4.gradients;
                K = c2.stops;
                m2 = k2.radialReference;
                d(A) && (c2[g2] = A = { x1: A[0], y1: A[1], x2: A[2], y2: A[3], gradientUnits: "userSpaceOnUse" });
                g2 === "radialGradient" && m2 && !e(A.gradientUnits) && (a3 = A, A = G(A, n4.getRadialAttr(m2, a3), { gradientUnits: "userSpaceOnUse" }));
                b(A, function(b2, c3) {
                  c3 !== "id" && w2.push(c3, b2);
                });
                b(K, function(b2) {
                  w2.push(b2);
                });
                w2 = w2.join(",");
                if (r2[w2])
                  O = r2[w2].attr("id");
                else {
                  A.id = O = P();
                  const b2 = r2[w2] = n4.createElement(g2).attr(A).add(n4.defs);
                  b2.radAttr = a3;
                  b2.stops = [];
                  K.forEach(function(c3) {
                    c3[1].indexOf("rgba") === 0 ? (q2 = y.parse(c3[1]), h3 = q2.get("rgb"), J = q2.get("a")) : (h3 = c3[1], J = 1);
                    c3 = n4.createElement("stop").attr({ offset: c3[0], "stop-color": h3, "stop-opacity": J }).add(b2);
                    b2.stops.push(c3);
                  });
                }
                l3 = "url(" + n4.url + "#" + O + ")";
                k2.setAttribute(f2, l3);
                k2.gradient = w2;
                c2.toString = function() {
                  return l3;
                };
              }
            });
          }
          css(f2) {
            const d2 = this.styles, k2 = {}, n4 = this.element;
            let e2, q2 = !d2;
            d2 && b(f2, function(b2, c2) {
              d2 && d2[c2] !== b2 && (k2[c2] = b2, q2 = true);
            });
            if (q2) {
              d2 && (f2 = E(d2, k2));
              f2.width === null || f2.width === "auto" ? delete this.textWidth : n4.nodeName.toLowerCase() === "text" && f2.width && (e2 = this.textWidth = c(f2.width));
              this.styles = f2;
              e2 && !v && this.renderer.forExport && delete f2.width;
              const b2 = G(f2);
              n4.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "width"].forEach((c2) => b2 && delete b2[c2]), b2.color && (b2.fill = b2.color));
              g(n4, b2);
            }
            this.added && (this.element.nodeName === "text" && this.renderer.buildText(this), f2.textOutline && this.applyTextOutline(f2.textOutline));
            return this;
          }
          dashstyleSetter(b2) {
            let d2 = this["stroke-width"];
            d2 === "inherit" && (d2 = 1);
            if (b2 = b2 && b2.toLowerCase()) {
              const k2 = b2.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
              for (b2 = k2.length; b2--; )
                k2[b2] = "" + c(k2[b2]) * f(d2, NaN);
              b2 = k2.join(",").replace(/NaN/g, "none");
              this.element.setAttribute("stroke-dasharray", b2);
            }
          }
          destroy() {
            const c2 = this;
            var f2 = c2.element || {};
            const d2 = c2.renderer;
            var k2 = f2.ownerSVGElement;
            let n4 = f2.nodeName === "SPAN" && c2.parentGroup || void 0;
            f2.onclick = f2.onmouseout = f2.onmouseover = f2.onmousemove = f2.point = null;
            H(c2);
            if (c2.clipPath && k2) {
              const b2 = c2.clipPath;
              [].forEach.call(k2.querySelectorAll("[clip-path],[CLIP-PATH]"), function(c3) {
                -1 < c3.getAttribute("clip-path").indexOf(b2.element.id) && c3.removeAttribute("clip-path");
              });
              c2.clipPath = b2.destroy();
            }
            if (c2.stops) {
              for (k2 = 0; k2 < c2.stops.length; k2++)
                c2.stops[k2].destroy();
              c2.stops.length = 0;
              c2.stops = void 0;
            }
            for (c2.safeRemoveChild(f2); n4 && n4.div && n4.div.childNodes.length === 0; )
              f2 = n4.parentGroup, c2.safeRemoveChild(n4.div), delete n4.div, n4 = f2;
            c2.alignTo && w(d2.alignedObjects, c2);
            b(c2, function(b2, f3) {
              c2[f3] && c2[f3].parentGroup === c2 && c2[f3].destroy && c2[f3].destroy();
              delete c2[f3];
            });
          }
          dSetter(b2, c2, f2) {
            d(b2) && (typeof b2[0] === "string" && (b2 = this.renderer.pathToSegments(b2)), this.pathArray = b2, b2 = b2.reduce((b3, c3, f3) => c3 && c3.join ? (f3 ? b3 + " " : "") + c3.join(" ") : (c3 || "").toString(), ""));
            /(NaN| {2}|^$)/.test(b2) && (b2 = "M 0 0");
            this[c2] !== b2 && (f2.setAttribute(c2, b2), this[c2] = b2);
          }
          fadeOut(b2) {
            const c2 = this;
            c2.animate({ opacity: 0 }, { duration: f(b2, 150), complete: function() {
              c2.hide();
            } });
          }
          fillSetter(b2, c2, f2) {
            typeof b2 === "string" ? f2.setAttribute(c2, b2) : b2 && this.complexColor(b2, c2, f2);
          }
          getBBox(b2, c2) {
            const { alignValue: d2, element: n4, renderer: q2, styles: a3, textStr: A } = this, { cache: r2, cacheKeys: h3 } = q2;
            var m2 = n4.namespaceURI === this.SVG_NS;
            c2 = f(c2, this.rotation, 0);
            var K = q2.styledMode ? n4 && D.prototype.getStyle.call(n4, "font-size") : a3 && a3.fontSize;
            let J;
            let N;
            e(A) && (N = A.toString(), N.indexOf("<") === -1 && (N = N.replace(/[0-9]/g, "0")), N += ["", q2.rootFontSize, K, c2, this.textWidth, d2, a3 && a3.textOverflow, a3 && a3.fontWeight].join());
            N && !b2 && (J = r2[N]);
            if (!J) {
              if (m2 || q2.forExport) {
                try {
                  var O = this.fakeTS && function(b3) {
                    const c3 = n4.querySelector(".highcharts-text-outline");
                    c3 && g(c3, { display: b3 });
                  };
                  k(O) && O("none");
                  J = n4.getBBox ? E({}, n4.getBBox()) : { width: n4.offsetWidth, height: n4.offsetHeight, x: 0, y: 0 };
                  k(O) && O("");
                } catch (fa) {
                  "";
                }
                if (!J || 0 > J.width)
                  J = { x: 0, y: 0, width: 0, height: 0 };
              } else
                J = this.htmlGetBBox();
              O = J.width;
              b2 = J.height;
              m2 && (J.height = b2 = { "11px,17": 14, "13px,20": 16 }[`${K || ""},${Math.round(b2)}`] || b2);
              if (c2) {
                m2 = Number(n4.getAttribute("y") || 0) - J.y;
                K = { right: 1, center: 0.5 }[d2 || 0] || 0;
                var w2 = c2 * B, l3 = (c2 - 90) * B, p2 = O * Math.cos(w2);
                c2 = O * Math.sin(w2);
                var G2 = Math.cos(l3);
                w2 = Math.sin(l3);
                O = J.x + K * (O - p2) + m2 * G2;
                l3 = O + p2;
                G2 = l3 - b2 * G2;
                p2 = G2 - p2;
                m2 = J.y + m2 - K * c2 + m2 * w2;
                K = m2 + c2;
                b2 = K - b2 * w2;
                c2 = b2 - c2;
                J.x = Math.min(O, l3, G2, p2);
                J.y = Math.min(m2, K, b2, c2);
                J.width = Math.max(O, l3, G2, p2) - J.x;
                J.height = Math.max(m2, K, b2, c2) - J.y;
              }
            }
            if (N && (A === "" || 0 < J.height)) {
              for (; 250 < h3.length; )
                delete r2[h3.shift()];
              r2[N] || h3.push(N);
              r2[N] = J;
            }
            return J;
          }
          getStyle(b2) {
            return p.getComputedStyle(this.element || this, "").getPropertyValue(b2);
          }
          hasClass(b2) {
            return ("" + this.attr("class")).split(" ").indexOf(b2) !== -1;
          }
          hide() {
            return this.attr({ visibility: "hidden" });
          }
          htmlGetBBox() {
            return { height: 0, width: 0, x: 0, y: 0 };
          }
          init(b2, c2) {
            this.element = c2 === "span" ? h(c2) : u.createElementNS(this.SVG_NS, c2);
            this.renderer = b2;
            F(this, "afterInit");
          }
          on(b2, c2) {
            const { onEvents: f2 } = this;
            if (f2[b2])
              f2[b2]();
            f2[b2] = t(this.element, b2, c2);
            return this;
          }
          opacitySetter(b2, c2, f2) {
            this.opacity = b2 = Number(Number(b2).toFixed(3));
            f2.setAttribute(c2, b2);
          }
          removeClass(b2) {
            return this.attr("class", ("" + this.attr("class")).replace(q(b2) ? new RegExp(`(^| )${b2}( |$)`) : b2, " ").replace(/ +/g, " ").trim());
          }
          removeTextOutline() {
            const b2 = this.element.querySelector("tspan.highcharts-text-outline");
            b2 && this.safeRemoveChild(b2);
          }
          safeRemoveChild(b2) {
            const c2 = b2.parentNode;
            c2 && c2.removeChild(b2);
          }
          setRadialReference(b2) {
            const c2 = this.element.gradient && this.renderer.gradients[this.element.gradient];
            this.element.radialReference = b2;
            c2 && c2.radAttr && c2.animate(this.renderer.getRadialAttr(b2, c2.radAttr));
            return this;
          }
          setTextPath(b2, c2) {
            c2 = G(true, { enabled: true, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, c2);
            const f2 = this.renderer.url, d2 = this.text || this, k2 = d2.textPath, { attributes: n4, enabled: A } = c2;
            b2 = b2 || k2 && k2.path;
            k2 && k2.undo();
            b2 && A ? (c2 = t(d2, "afterModifyTree", (c3) => {
              if (b2 && A) {
                let A2 = b2.attr("id");
                A2 || b2.attr("id", A2 = P());
                var k3 = { x: 0, y: 0 };
                e(n4.dx) && (k3.dx = n4.dx, delete n4.dx);
                e(n4.dy) && (k3.dy = n4.dy, delete n4.dy);
                d2.attr(k3);
                this.attr({ transform: "" });
                this.box && (this.box = this.box.destroy());
                k3 = c3.nodes.slice(0);
                c3.nodes.length = 0;
                c3.nodes[0] = { tagName: "textPath", attributes: E(n4, { "text-anchor": n4.textAnchor, href: `${f2}#${A2}` }), children: k3 };
              }
            }), d2.textPath = { path: b2, undo: c2 }) : (d2.attr({ dx: 0, dy: 0 }), delete d2.textPath);
            this.added && (d2.textCache = "", this.renderer.buildText(d2));
            return this;
          }
          shadow(b2) {
            var c2;
            const { renderer: f2 } = this, d2 = G(((c2 = this.parentGroup) === null || c2 === void 0 ? void 0 : c2.rotation) === 90 ? { offsetX: -1, offsetY: -1 } : {}, r(b2) ? b2 : {});
            c2 = f2.shadowDefinition(d2);
            return this.attr({ filter: b2 ? `url(${f2.url}#${c2})` : "none" });
          }
          show(b2 = true) {
            return this.attr({ visibility: b2 ? "inherit" : "visible" });
          }
          ["stroke-widthSetter"](b2, c2, f2) {
            this[c2] = b2;
            f2.setAttribute(c2, b2);
          }
          strokeWidth() {
            if (!this.renderer.styledMode)
              return this["stroke-width"] || 0;
            const b2 = this.getStyle("stroke-width");
            let f2 = 0, d2;
            b2.indexOf("px") === b2.length - 2 ? f2 = c(b2) : b2 !== "" && (d2 = u.createElementNS(l2, "rect"), m(d2, { width: b2, "stroke-width": 0 }), this.element.parentNode.appendChild(d2), f2 = d2.getBBox().width, d2.parentNode.removeChild(d2));
            return f2;
          }
          symbolAttr(b2) {
            const c2 = this;
            D.symbolCustomAttribs.forEach(function(d2) {
              c2[d2] = f(b2[d2], c2[d2]);
            });
            c2.attr({ d: c2.renderer.symbols[c2.symbolName](c2.x, c2.y, c2.width, c2.height, c2) });
          }
          textSetter(b2) {
            b2 !== this.textStr && (delete this.textPxLength, this.textStr = b2, this.added && this.renderer.buildText(this));
          }
          titleSetter(b2) {
            const c2 = this.element, d2 = c2.getElementsByTagName("title")[0] || u.createElementNS(this.SVG_NS, "title");
            c2.insertBefore ? c2.insertBefore(d2, c2.firstChild) : c2.appendChild(d2);
            d2.textContent = String(f(b2, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
          }
          toFront() {
            const b2 = this.element;
            b2.parentNode.appendChild(b2);
            return this;
          }
          translate(b2, c2) {
            return this.attr({
              translateX: b2,
              translateY: c2
            });
          }
          updateTransform() {
            const { element: b2, matrix: c2, rotation: d2 = 0, scaleX: k2, scaleY: n4, translateX: q2 = 0, translateY: A = 0 } = this, g2 = ["translate(" + q2 + "," + A + ")"];
            e(c2) && g2.push("matrix(" + c2.join(",") + ")");
            d2 && g2.push("rotate(" + d2 + " " + f(this.rotationOriginX, b2.getAttribute("x"), 0) + " " + f(this.rotationOriginY, b2.getAttribute("y") || 0) + ")");
            (e(k2) || e(n4)) && g2.push("scale(" + f(k2, 1) + " " + f(n4, 1) + ")");
            g2.length && !(this.text || this).textPath && b2.setAttribute("transform", g2.join(" "));
          }
          visibilitySetter(b2, c2, f2) {
            b2 === "inherit" ? f2.removeAttribute(c2) : this[c2] !== b2 && f2.setAttribute(c2, b2);
            this[c2] = b2;
          }
          xGetter(b2) {
            this.element.nodeName === "circle" && (b2 === "x" ? b2 = "cx" : b2 === "y" && (b2 = "cy"));
            return this._defaultGetter(b2);
          }
          zIndexSetter(b2, f2) {
            var d2 = this.renderer, k2 = this.parentGroup;
            const n4 = (k2 || d2).element || d2.box, q2 = this.element;
            d2 = n4 === d2.box;
            let A = false, g2;
            var a3 = this.added;
            let r2;
            e(b2) ? (q2.setAttribute("data-z-index", b2), b2 = +b2, this[f2] === b2 && (a3 = false)) : e(this[f2]) && q2.removeAttribute("data-z-index");
            this[f2] = b2;
            if (a3) {
              (b2 = this.zIndex) && k2 && (k2.handleZ = true);
              f2 = n4.childNodes;
              for (r2 = f2.length - 1; 0 <= r2 && !A; r2--)
                if (k2 = f2[r2], a3 = k2.getAttribute("data-z-index"), g2 = !e(a3), k2 !== q2) {
                  if (0 > b2 && g2 && !d2 && !r2)
                    n4.insertBefore(q2, f2[r2]), A = true;
                  else if (c(a3) <= b2 || g2 && (!e(b2) || 0 <= b2))
                    n4.insertBefore(q2, f2[r2 + 1]), A = true;
                }
              A || (n4.insertBefore(q2, f2[d2 ? 3 : 0]), A = true);
            }
            return A;
          }
        }
        D.symbolCustomAttribs = "anchorX anchorY clockwise end height innerR r start width x y".split(" ");
        D.prototype.strokeSetter = D.prototype.fillSetter;
        D.prototype.yGetter = D.prototype.xGetter;
        D.prototype.matrixSetter = D.prototype.rotationOriginXSetter = D.prototype.rotationOriginYSetter = D.prototype.rotationSetter = D.prototype.scaleXSetter = D.prototype.scaleYSetter = D.prototype.translateXSetter = D.prototype.translateYSetter = D.prototype.verticalAlignSetter = function(b2, c2) {
          this[c2] = b2;
          this.doTransform = true;
        };
        "";
        return D;
      });
      M(a, "Core/Renderer/RendererRegistry.js", [a["Core/Globals.js"]], function(a2) {
        var x;
        (function(x2) {
          x2.rendererTypes = {};
          let y;
          x2.getRendererType = function(a3 = y) {
            return x2.rendererTypes[a3] || x2.rendererTypes[y];
          };
          x2.registerRendererType = function(C, z, H) {
            x2.rendererTypes[C] = z;
            if (!y || H)
              y = C, a2.Renderer = z;
          };
        })(x || (x = {}));
        return x;
      });
      M(a, "Core/Renderer/SVG/SVGLabel.js", [a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function(a2, y) {
        const { defined: x, extend: L, isNumber: C, merge: z, pick: H, removeEvent: B } = y;
        class u extends a2 {
          constructor(a3, l2, p, t, m, h, g, e, w, E) {
            super();
            this.paddingRightSetter = this.paddingLeftSetter = this.paddingSetter;
            this.init(a3, "g");
            this.textStr = l2;
            this.x = p;
            this.y = t;
            this.anchorX = h;
            this.anchorY = g;
            this.baseline = w;
            this.className = E;
            this.addClass(E === "button" ? "highcharts-no-tooltip" : "highcharts-label");
            E && this.addClass("highcharts-" + E);
            this.text = a3.text(void 0, 0, 0, e).attr({ zIndex: 1 });
            let v;
            typeof m === "string" && ((v = /^url\((.*?)\)$/.test(m)) || this.renderer.symbols[m]) && (this.symbolKey = m);
            this.bBox = u.emptyBBox;
            this.padding = 3;
            this.baselineOffset = 0;
            this.needsBox = a3.styledMode || v;
            this.deferredAttr = {};
            this.alignFactor = 0;
          }
          alignSetter(a3) {
            a3 = { left: 0, center: 0.5, right: 1 }[a3];
            a3 !== this.alignFactor && (this.alignFactor = a3, this.bBox && C(this.xSetting) && this.attr({ x: this.xSetting }));
          }
          anchorXSetter(a3, l2) {
            this.anchorX = a3;
            this.boxAttr(l2, Math.round(a3) - this.getCrispAdjust() - this.xSetting);
          }
          anchorYSetter(a3, l2) {
            this.anchorY = a3;
            this.boxAttr(l2, a3 - this.ySetting);
          }
          boxAttr(a3, l2) {
            this.box ? this.box.attr(a3, l2) : this.deferredAttr[a3] = l2;
          }
          css(v) {
            if (v) {
              const a3 = {};
              v = z(v);
              u.textProps.forEach((l2) => {
                typeof v[l2] !== "undefined" && (a3[l2] = v[l2], delete v[l2]);
              });
              this.text.css(a3);
              "fontSize" in a3 || "fontWeight" in a3 ? this.updateTextPadding() : ("width" in a3 || "textOverflow" in a3) && this.updateBoxSize();
            }
            return a2.prototype.css.call(this, v);
          }
          destroy() {
            B(this.element, "mouseenter");
            B(this.element, "mouseleave");
            this.text && this.text.destroy();
            this.box && (this.box = this.box.destroy());
            a2.prototype.destroy.call(this);
          }
          fillSetter(a3, l2) {
            a3 && (this.needsBox = true);
            this.fill = a3;
            this.boxAttr(l2, a3);
          }
          getBBox() {
            this.textStr && this.bBox.width === 0 && this.bBox.height === 0 && this.updateBoxSize();
            const a3 = this.padding, l2 = H(this.paddingLeft, a3);
            return { width: this.width, height: this.height, x: this.bBox.x - l2, y: this.bBox.y - a3 };
          }
          getCrispAdjust() {
            return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
          }
          heightSetter(a3) {
            this.heightSetting = a3;
          }
          onAdd() {
            this.text.add(this);
            this.attr({ text: H(this.textStr, ""), x: this.x || 0, y: this.y || 0 });
            this.box && x(this.anchorX) && this.attr({ anchorX: this.anchorX, anchorY: this.anchorY });
          }
          paddingSetter(a3, l2) {
            C(a3) ? a3 !== this[l2] && (this[l2] = a3, this.updateTextPadding()) : this[l2] = void 0;
          }
          rSetter(a3, l2) {
            this.boxAttr(l2, a3);
          }
          strokeSetter(a3, l2) {
            this.stroke = a3;
            this.boxAttr(l2, a3);
          }
          ["stroke-widthSetter"](a3, l2) {
            a3 && (this.needsBox = true);
            this["stroke-width"] = a3;
            this.boxAttr(l2, a3);
          }
          ["text-alignSetter"](a3) {
            this.textAlign = a3;
          }
          textSetter(a3) {
            typeof a3 !== "undefined" && this.text.attr({ text: a3 });
            this.updateTextPadding();
          }
          updateBoxSize() {
            var a3 = this.text;
            const l2 = {}, p = this.padding, t = this.bBox = C(this.widthSetting) && C(this.heightSetting) && !this.textAlign || !x(a3.textStr) ? u.emptyBBox : a3.getBBox();
            this.width = this.getPaddedWidth();
            this.height = (this.heightSetting || t.height || 0) + 2 * p;
            const m = this.renderer.fontMetrics(a3);
            this.baselineOffset = p + Math.min((this.text.firstLineMetrics || m).b, t.height || Infinity);
            this.heightSetting && (this.baselineOffset += (this.heightSetting - m.h) / 2);
            this.needsBox && !a3.textPath && (this.box || (a3 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a3.addClass((this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), a3.add(this)), a3 = this.getCrispAdjust(), l2.x = a3, l2.y = (this.baseline ? -this.baselineOffset : 0) + a3, l2.width = Math.round(this.width), l2.height = Math.round(this.height), this.box.attr(L(l2, this.deferredAttr)), this.deferredAttr = {});
          }
          updateTextPadding() {
            const a3 = this.text;
            if (!a3.textPath) {
              this.updateBoxSize();
              const l2 = this.baseline ? 0 : this.baselineOffset;
              let p = H(this.paddingLeft, this.padding);
              x(this.widthSetting) && this.bBox && (this.textAlign === "center" || this.textAlign === "right") && (p += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width));
              if (p !== a3.x || l2 !== a3.y)
                a3.attr("x", p), a3.hasBoxWidthChanged && (this.bBox = a3.getBBox(true)), typeof l2 !== "undefined" && a3.attr("y", l2);
              a3.x = p;
              a3.y = l2;
            }
          }
          widthSetter(a3) {
            this.widthSetting = C(a3) ? a3 : void 0;
          }
          getPaddedWidth() {
            var a3 = this.padding;
            const l2 = H(this.paddingLeft, a3);
            a3 = H(this.paddingRight, a3);
            return (this.widthSetting || this.bBox.width || 0) + l2 + a3;
          }
          xSetter(a3) {
            this.x = a3;
            this.alignFactor && (a3 -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = true);
            this.xSetting = Math.round(a3);
            this.attr("translateX", this.xSetting);
          }
          ySetter(a3) {
            this.ySetting = this.y = Math.round(a3);
            this.attr("translateY", this.ySetting);
          }
        }
        u.emptyBBox = { width: 0, height: 0, x: 0, y: 0 };
        u.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow whiteSpace width".split(" ");
        return u;
      });
      M(a, "Core/Renderer/SVG/Symbols.js", [a["Core/Utilities.js"]], function(a2) {
        function x(a3, u, v, l2, p) {
          const t = [];
          if (p) {
            const m = p.start || 0, h = H(p.r, v);
            v = H(p.r, l2 || v);
            l2 = (p.end || 0) - 1e-3;
            const g = p.innerR, e = H(p.open, 1e-3 > Math.abs((p.end || 0) - m - 2 * Math.PI)), w = Math.cos(m), E = Math.sin(m), F = Math.cos(l2), d = Math.sin(l2), k = H(p.longArc, 1e-3 > l2 - m - Math.PI ? 0 : 1);
            let r = ["A", h, v, 0, k, H(p.clockwise, 1), a3 + h * F, u + v * d];
            r.params = { start: m, end: l2, cx: a3, cy: u };
            t.push(["M", a3 + h * w, u + v * E], r);
            C(g) && (r = ["A", g, g, 0, k, C(p.clockwise) ? 1 - p.clockwise : 0, a3 + g * w, u + g * E], r.params = { start: l2, end: m, cx: a3, cy: u }, t.push(e ? ["M", a3 + g * F, u + g * d] : ["L", a3 + g * F, u + g * d], r));
            e || t.push(["Z"]);
          }
          return t;
        }
        function I(a3, u, v, l2, p) {
          return p && p.r ? L(a3, u, v, l2, p) : [["M", a3, u], ["L", a3 + v, u], ["L", a3 + v, u + l2], ["L", a3, u + l2], ["Z"]];
        }
        function L(a3, u, v, l2, p) {
          p = (p === null || p === void 0 ? void 0 : p.r) || 0;
          return [["M", a3 + p, u], ["L", a3 + v - p, u], ["A", p, p, 0, 0, 1, a3 + v, u + p], ["L", a3 + v, u + l2 - p], ["A", p, p, 0, 0, 1, a3 + v - p, u + l2], ["L", a3 + p, u + l2], ["A", p, p, 0, 0, 1, a3, u + l2 - p], ["L", a3, u + p], ["A", p, p, 0, 0, 1, a3 + p, u], ["Z"]];
        }
        const { defined: C, isNumber: z, pick: H } = a2;
        return { arc: x, callout: function(a3, u, v, l2, p) {
          const t = Math.min(p && p.r || 0, v, l2), m = t + 6, h = p && p.anchorX;
          p = p && p.anchorY || 0;
          const g = L(a3, u, v, l2, { r: t });
          if (!z(h))
            return g;
          a3 + h >= v ? p > u + m && p < u + l2 - m ? g.splice(3, 1, ["L", a3 + v, p - 6], ["L", a3 + v + 6, p], ["L", a3 + v, p + 6], ["L", a3 + v, u + l2 - t]) : g.splice(3, 1, ["L", a3 + v, l2 / 2], ["L", h, p], ["L", a3 + v, l2 / 2], ["L", a3 + v, u + l2 - t]) : 0 >= a3 + h ? p > u + m && p < u + l2 - m ? g.splice(7, 1, ["L", a3, p + 6], ["L", a3 - 6, p], ["L", a3, p - 6], ["L", a3, u + t]) : g.splice(7, 1, ["L", a3, l2 / 2], ["L", h, p], ["L", a3, l2 / 2], ["L", a3, u + t]) : p && p > l2 && h > a3 + m && h < a3 + v - m ? g.splice(5, 1, [
            "L",
            h + 6,
            u + l2
          ], ["L", h, u + l2 + 6], ["L", h - 6, u + l2], ["L", a3 + t, u + l2]) : p && 0 > p && h > a3 + m && h < a3 + v - m && g.splice(1, 1, ["L", h - 6, u], ["L", h, u - 6], ["L", h + 6, u], ["L", v - t, u]);
          return g;
        }, circle: function(a3, u, v, l2) {
          return x(a3 + v / 2, u + l2 / 2, v / 2, l2 / 2, { start: 0.5 * Math.PI, end: 2.5 * Math.PI, open: false });
        }, diamond: function(a3, u, v, l2) {
          return [["M", a3 + v / 2, u], ["L", a3 + v, u + l2 / 2], ["L", a3 + v / 2, u + l2], ["L", a3, u + l2 / 2], ["Z"]];
        }, rect: I, roundedRect: L, square: I, triangle: function(a3, u, v, l2) {
          return [["M", a3 + v / 2, u], ["L", a3 + v, u + l2], ["L", a3, u + l2], ["Z"]];
        }, "triangle-down": function(a3, u, v, l2) {
          return [[
            "M",
            a3,
            u
          ], ["L", a3 + v, u], ["L", a3 + v / 2, u + l2], ["Z"]];
        } };
      });
      M(a, "Core/Renderer/SVG/TextBuilder.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { doc: x, SVG_NS: C, win: z } = y, { attr: H, extend: B, fireEvent: u, isString: v, objectEach: l2, pick: p } = I;
        class t {
          constructor(a3) {
            const h = a3.styles;
            this.renderer = a3.renderer;
            this.svgElement = a3;
            this.width = a3.textWidth;
            this.textLineHeight = h && h.lineHeight;
            this.textOutline = h && h.textOutline;
            this.ellipsis = !(!h || h.textOverflow !== "ellipsis");
            this.noWrap = !(!h || h.whiteSpace !== "nowrap");
          }
          buildSVG() {
            const m = this.svgElement, h = m.element;
            var g = m.renderer, e = p(m.textStr, "").toString();
            const w = e.indexOf("<") !== -1, l3 = h.childNodes;
            g = !m.added && g.box;
            const t2 = /<br.*?>/g;
            var d = [e, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, m.getStyle("font-size"), this.width].join();
            if (d !== m.textCache) {
              m.textCache = d;
              delete m.actualWidth;
              for (d = l3.length; d--; )
                h.removeChild(l3[d]);
              w || this.ellipsis || this.width || m.textPath || e.indexOf(" ") !== -1 && (!this.noWrap || t2.test(e)) ? e !== "" && (g && g.appendChild(h), e = new a2(e), this.modifyTree(e.nodes), e.addToDOM(h), this.modifyDOM(), this.ellipsis && (h.textContent || "").indexOf("\u2026") !== -1 && m.attr("title", this.unescapeEntities(m.textStr || "", ["&lt;", "&gt;"])), g && g.removeChild(h)) : h.appendChild(x.createTextNode(this.unescapeEntities(e)));
              v(this.textOutline) && m.applyTextOutline && m.applyTextOutline(this.textOutline);
            }
          }
          modifyDOM() {
            const a3 = this.svgElement, h = H(a3.element, "x");
            a3.firstLineMetrics = void 0;
            let g;
            for (; g = a3.element.firstChild; )
              if (/^[\s\u200B]*$/.test(g.textContent || " "))
                a3.element.removeChild(g);
              else
                break;
            [].forEach.call(a3.element.querySelectorAll("tspan.highcharts-br"), (e2, d) => {
              e2.nextSibling && e2.previousSibling && (d === 0 && e2.previousSibling.nodeType === 1 && (a3.firstLineMetrics = a3.renderer.fontMetrics(e2.previousSibling)), H(e2, { dy: this.getLineHeight(e2.nextSibling), x: h }));
            });
            const e = this.width || 0;
            if (e) {
              var w = (g2, d) => {
                var k = g2.textContent || "";
                const r = k.replace(/([^\^])-/g, "$1- ").split(" ");
                var q = !this.noWrap && (1 < r.length || 1 < a3.element.childNodes.length);
                const m = this.getLineHeight(d);
                let b = 0, f = a3.actualWidth;
                if (this.ellipsis)
                  k && this.truncate(g2, k, void 0, 0, Math.max(0, e - 0.8 * m), (b2, f2) => b2.substring(0, f2) + "\u2026");
                else if (q) {
                  k = [];
                  for (q = []; d.firstChild && d.firstChild !== g2; )
                    q.push(d.firstChild), d.removeChild(d.firstChild);
                  for (; r.length; )
                    r.length && !this.noWrap && 0 < b && (k.push(g2.textContent || ""), g2.textContent = r.join(" ").replace(/- /g, "-")), this.truncate(g2, void 0, r, b === 0 ? f || 0 : 0, e, (b2, f2) => r.slice(0, f2).join(" ").replace(/- /g, "-")), f = a3.actualWidth, b++;
                  q.forEach((b2) => {
                    d.insertBefore(b2, g2);
                  });
                  k.forEach((b2) => {
                    d.insertBefore(x.createTextNode(b2), g2);
                    b2 = x.createElementNS(C, "tspan");
                    b2.textContent = "\u200B";
                    H(b2, { dy: m, x: h });
                    d.insertBefore(b2, g2);
                  });
                }
              }, l3 = (e2) => {
                [].slice.call(e2.childNodes).forEach((d) => {
                  d.nodeType === z.Node.TEXT_NODE ? w(d, e2) : (d.className.baseVal.indexOf("highcharts-br") !== -1 && (a3.actualWidth = 0), l3(d));
                });
              };
              l3(a3.element);
            }
          }
          getLineHeight(a3) {
            a3 = a3.nodeType === z.Node.TEXT_NODE ? a3.parentElement : a3;
            return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a3 || this.svgElement.element).h;
          }
          modifyTree(a3) {
            const h = (g, e) => {
              const { attributes: m = {}, children: l3, style: p2 = {}, tagName: d } = g, k = this.renderer.styledMode;
              if (d === "b" || d === "strong")
                k ? m["class"] = "highcharts-strong" : p2.fontWeight = "bold";
              else if (d === "i" || d === "em")
                k ? m["class"] = "highcharts-emphasized" : p2.fontStyle = "italic";
              p2 && p2.color && (p2.fill = p2.color);
              d === "br" ? (m["class"] = "highcharts-br", g.textContent = "\u200B", (e = a3[e + 1]) && e.textContent && (e.textContent = e.textContent.replace(/^ +/gm, ""))) : d === "a" && l3 && l3.some((d2) => d2.tagName === "#text") && (g.children = [{ children: l3, tagName: "tspan" }]);
              d !== "#text" && d !== "a" && (g.tagName = "tspan");
              B(g, { attributes: m, style: p2 });
              l3 && l3.filter((d2) => d2.tagName !== "#text").forEach(h);
            };
            a3.forEach(h);
            u(this.svgElement, "afterModifyTree", { nodes: a3 });
          }
          truncate(a3, h, g, e, l3, p2) {
            const m = this.svgElement, { rotation: d } = m, k = [];
            let r = g ? 1 : 0, q = (h || g || "").length, w = q, b, f;
            const c = function(b2, c2) {
              b2 = c2 || b2;
              if ((c2 = a3.parentNode) && typeof k[b2] === "undefined" && c2.getSubStringLength)
                try {
                  k[b2] = e + c2.getSubStringLength(0, g ? b2 + 1 : b2);
                } catch (D) {
                  "";
                }
              return k[b2];
            };
            m.rotation = 0;
            f = c(a3.textContent.length);
            if (e + f > l3) {
              for (; r <= q; )
                w = Math.ceil((r + q) / 2), g && (b = p2(g, w)), f = c(w, b && b.length - 1), r === q ? r = q + 1 : f > l3 ? q = w - 1 : r = w;
              q === 0 ? a3.textContent = "" : h && q === h.length - 1 || (a3.textContent = b || p2(h || g, w));
            }
            g && g.splice(0, w);
            m.actualWidth = f;
            m.rotation = d;
          }
          unescapeEntities(a3, h) {
            l2(this.renderer.escapes, function(g, e) {
              h && h.indexOf(g) !== -1 || (a3 = a3.toString().replace(new RegExp(g, "g"), e));
            });
            return a3;
          }
        }
        return t;
      });
      M(a, "Core/Renderer/SVG/SVGRenderer.js", [
        a["Core/Renderer/HTML/AST.js"],
        a["Core/Color/Color.js"],
        a["Core/Globals.js"],
        a["Core/Renderer/RendererRegistry.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Renderer/SVG/SVGLabel.js"],
        a["Core/Renderer/SVG/Symbols.js"],
        a["Core/Renderer/SVG/TextBuilder.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, I, L, C, z, H, B, u) {
        const { charts: v, deg2rad: l2, doc: p, isFirefox: t, isMS: m, isWebKit: h, noop: g, SVG_NS: e, symbolSizes: w, win: E } = I, { addEvent: F, attr: d, createElement: k, css: r, defined: q, destroyObjectProperties: G, extend: b, isArray: f, isNumber: c, isObject: n3, isString: P, merge: D, pick: K, pInt: x, uniqueKey: T } = u;
        let Z;
        class V {
          constructor(b2, c2, f2, d2, a3, k2, n4) {
            this.width = this.url = this.style = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
            this.init(b2, c2, f2, d2, a3, k2, n4);
          }
          init(b2, c2, f2, a3, k2, n4, J) {
            const A = this.createElement("svg").attr({ version: "1.1", "class": "highcharts-root" }), e2 = A.element;
            J || A.css(this.getStyle(a3));
            b2.appendChild(e2);
            d(b2, "dir", "ltr");
            b2.innerHTML.indexOf("xmlns") === -1 && d(e2, "xmlns", this.SVG_NS);
            this.box = e2;
            this.boxWrapper = A;
            this.alignedObjects = [];
            this.url = this.getReferenceURL();
            this.createElement("desc").add().element.appendChild(p.createTextNode("Created with Highcharts 11.1.0"));
            this.defs = this.createElement("defs").add();
            this.allowHTML = n4;
            this.forExport = k2;
            this.styledMode = J;
            this.gradients = {};
            this.cache = {};
            this.cacheKeys = [];
            this.imgCount = 0;
            this.rootFontSize = A.getStyle("font-size");
            this.setSize(c2, f2, false);
            let q2;
            t && b2.getBoundingClientRect && (c2 = function() {
              r(b2, { left: 0, top: 0 });
              q2 = b2.getBoundingClientRect();
              r(b2, { left: Math.ceil(q2.left) - q2.left + "px", top: Math.ceil(q2.top) - q2.top + "px" });
            }, c2(), this.unSubPixelFix = F(E, "resize", c2));
          }
          definition(b2) {
            return new a2([b2]).addToDOM(this.defs.element);
          }
          getReferenceURL() {
            if ((t || h) && p.getElementsByTagName("base").length) {
              if (!q(Z)) {
                var b2 = T();
                b2 = new a2([{ tagName: "svg", attributes: { width: 8, height: 8 }, children: [{ tagName: "defs", children: [{ tagName: "clipPath", attributes: { id: b2 }, children: [{ tagName: "rect", attributes: { width: 4, height: 4 } }] }] }, { tagName: "rect", attributes: { id: "hitme", width: 8, height: 8, "clip-path": `url(#${b2})`, fill: "rgba(0,0,0,0.001)" } }] }]).addToDOM(p.body);
                r(b2, { position: "fixed", top: 0, left: 0, zIndex: 9e5 });
                const c2 = p.elementFromPoint(6, 6);
                Z = (c2 && c2.id) === "hitme";
                p.body.removeChild(b2);
              }
              if (Z)
                return E.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
            }
            return "";
          }
          getStyle(c2) {
            return this.style = b({ fontFamily: "Helvetica, Arial, sans-serif", fontSize: "1rem" }, c2);
          }
          setStyle(b2) {
            this.boxWrapper.css(this.getStyle(b2));
          }
          isHidden() {
            return !this.boxWrapper.getBBox().width;
          }
          destroy() {
            const b2 = this.defs;
            this.box = null;
            this.boxWrapper = this.boxWrapper.destroy();
            G(this.gradients || {});
            this.gradients = null;
            this.defs = b2.destroy();
            this.unSubPixelFix && this.unSubPixelFix();
            return this.alignedObjects = null;
          }
          createElement(b2) {
            const c2 = new this.Element();
            c2.init(this, b2);
            return c2;
          }
          getRadialAttr(b2, c2) {
            return { cx: b2[0] - b2[2] / 2 + (c2.cx || 0) * b2[2], cy: b2[1] - b2[2] / 2 + (c2.cy || 0) * b2[2], r: (c2.r || 0) * b2[2] };
          }
          shadowDefinition(b2) {
            const c2 = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(b2).map((c3) => b2[c3])].join("-").replace(/[^a-z0-9\-]/g, ""), f2 = D({
              color: "#000000",
              offsetX: 1,
              offsetY: 1,
              opacity: 0.15,
              width: 5
            }, b2);
            this.defs.element.querySelector(`#${c2}`) || this.definition({ tagName: "filter", attributes: { id: c2 }, children: [{ tagName: "feDropShadow", attributes: { dx: f2.offsetX, dy: f2.offsetY, "flood-color": f2.color, "flood-opacity": Math.min(5 * f2.opacity, 1), stdDeviation: f2.width / 2 } }] });
            return c2;
          }
          buildText(b2) {
            new B(b2).buildSVG();
          }
          getContrast(b2) {
            b2 = y.parse(b2).rgba.map((b3) => {
              b3 /= 255;
              return 0.03928 >= b3 ? b3 / 12.92 : Math.pow((b3 + 0.055) / 1.055, 2.4);
            });
            b2 = 0.2126 * b2[0] + 0.7152 * b2[1] + 0.0722 * b2[2];
            return 1.05 / (b2 + 0.05) > (b2 + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
          }
          button(c2, f2, d2, k2, e2 = {}, q2, J, g2, r2, h3) {
            const A = this.label(c2, f2, d2, r2, void 0, void 0, h3, void 0, "button"), O = this.styledMode;
            c2 = e2.states || {};
            let N = 0;
            e2 = D(e2);
            delete e2.states;
            const l3 = D({ color: "#333333", cursor: "pointer", fontSize: "0.8em", fontWeight: "normal" }, e2.style);
            delete e2.style;
            let w2 = a2.filterUserAttributes(e2);
            A.attr(D({ padding: 8, r: 2 }, w2));
            let p2, G2, R;
            O || (w2 = D({ fill: "#f7f7f7", stroke: "#cccccc", "stroke-width": 1 }, w2), q2 = D(w2, { fill: "#e6e6e6" }, a2.filterUserAttributes(q2 || c2.hover || {})), p2 = q2.style, delete q2.style, J = D(w2, { fill: "#e6e9ff", style: {
              color: "#000000",
              fontWeight: "bold"
            } }, a2.filterUserAttributes(J || c2.select || {})), G2 = J.style, delete J.style, g2 = D(w2, { style: { color: "#cccccc" } }, a2.filterUserAttributes(g2 || c2.disabled || {})), R = g2.style, delete g2.style);
            F(A.element, m ? "mouseover" : "mouseenter", function() {
              N !== 3 && A.setState(1);
            });
            F(A.element, m ? "mouseout" : "mouseleave", function() {
              N !== 3 && A.setState(N);
            });
            A.setState = function(b2) {
              b2 !== 1 && (A.state = N = b2);
              A.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + [
                "normal",
                "hover",
                "pressed",
                "disabled"
              ][b2 || 0]);
              O || (A.attr([w2, q2, J, g2][b2 || 0]), b2 = [l3, p2, G2, R][b2 || 0], n3(b2) && A.css(b2));
            };
            O || (A.attr(w2).css(b({ cursor: "default" }, l3)), h3 && A.text.css({ pointerEvents: "none" }));
            return A.on("touchstart", (b2) => b2.stopPropagation()).on("click", function(b2) {
              N !== 3 && k2.call(A, b2);
            });
          }
          crispLine(b2, c2, f2 = "round") {
            const d2 = b2[0], a3 = b2[1];
            q(d2[1]) && d2[1] === a3[1] && (d2[1] = a3[1] = Math[f2](d2[1]) - c2 % 2 / 2);
            q(d2[2]) && d2[2] === a3[2] && (d2[2] = a3[2] = Math[f2](d2[2]) + c2 % 2 / 2);
            return b2;
          }
          path(c2) {
            const d2 = this.styledMode ? {} : { fill: "none" };
            f(c2) ? d2.d = c2 : n3(c2) && b(d2, c2);
            return this.createElement("path").attr(d2);
          }
          circle(b2, c2, f2) {
            b2 = n3(b2) ? b2 : typeof b2 === "undefined" ? {} : { x: b2, y: c2, r: f2 };
            c2 = this.createElement("circle");
            c2.xSetter = c2.ySetter = function(b3, c3, f3) {
              f3.setAttribute("c" + c3, b3);
            };
            return c2.attr(b2);
          }
          arc(b2, c2, f2, d2, a3, k2) {
            n3(b2) ? (d2 = b2, c2 = d2.y, f2 = d2.r, b2 = d2.x) : d2 = { innerR: d2, start: a3, end: k2 };
            b2 = this.symbol("arc", b2, c2, f2, f2, d2);
            b2.r = f2;
            return b2;
          }
          rect(c2, f2, a3, k2, e2, q2) {
            c2 = n3(c2) ? c2 : typeof c2 === "undefined" ? {} : { x: c2, y: f2, r: e2, width: Math.max(a3 || 0, 0), height: Math.max(k2 || 0, 0) };
            const A = this.createElement("rect");
            this.styledMode || (typeof q2 !== "undefined" && (c2["stroke-width"] = q2, b(c2, A.crisp(c2))), c2.fill = "none");
            A.rSetter = function(b2, c3, f3) {
              A.r = b2;
              d(f3, { rx: b2, ry: b2 });
            };
            A.rGetter = function() {
              return A.r || 0;
            };
            return A.attr(c2);
          }
          roundedRect(b2) {
            return this.symbol("roundedRect").attr(b2);
          }
          setSize(b2, c2, f2) {
            this.width = b2;
            this.height = c2;
            this.boxWrapper.animate({ width: b2, height: c2 }, { step: function() {
              this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") });
            }, duration: K(f2, true) ? void 0 : 0 });
            this.alignElements();
          }
          g(b2) {
            const c2 = this.createElement("g");
            return b2 ? c2.attr({ "class": "highcharts-" + b2 }) : c2;
          }
          image(b2, f2, d2, a3, k2, n4) {
            const A = { preserveAspectRatio: "none" };
            c(f2) && (A.x = f2);
            c(d2) && (A.y = d2);
            c(a3) && (A.width = a3);
            c(k2) && (A.height = k2);
            const e2 = this.createElement("image").attr(A);
            f2 = function(c2) {
              e2.attr({ href: b2 });
              n4.call(e2, c2);
            };
            n4 ? (e2.attr({ href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" }), d2 = new E.Image(), F(d2, "load", f2), d2.src = b2, d2.complete && f2({})) : e2.attr({ href: b2 });
            return e2;
          }
          symbol(c2, f2, a3, n4, e2, g2) {
            const A = this, h3 = /^url\((.*?)\)$/, O = h3.test(c2), m2 = !O && (this.symbols[c2] ? c2 : "circle"), l3 = m2 && this.symbols[m2];
            let D2, G2, P2, t2;
            if (l3)
              typeof f2 === "number" && (G2 = l3.call(this.symbols, Math.round(f2 || 0), Math.round(a3 || 0), n4 || 0, e2 || 0, g2)), D2 = this.path(G2), A.styledMode || D2.attr("fill", "none"), b(D2, { symbolName: m2 || void 0, x: f2, y: a3, width: n4, height: e2 }), g2 && b(D2, g2);
            else if (O) {
              P2 = c2.match(h3)[1];
              const b2 = D2 = this.image(P2);
              b2.imgwidth = K(g2 && g2.width, w[P2] && w[P2].width);
              b2.imgheight = K(g2 && g2.height, w[P2] && w[P2].height);
              t2 = (b3) => b3.attr({ width: b3.width, height: b3.height });
              ["width", "height"].forEach(function(c3) {
                b2[c3 + "Setter"] = function(b3, c4) {
                  this[c4] = b3;
                  const {
                    alignByTranslate: f3,
                    element: a4,
                    width: k2,
                    height: A2,
                    imgwidth: n5,
                    imgheight: e3
                  } = this;
                  b3 = this["img" + c4];
                  if (q(b3)) {
                    let J = 1;
                    g2 && g2.backgroundSize === "within" && k2 && A2 ? (J = Math.min(k2 / n5, A2 / e3), d(a4, { width: Math.round(n5 * J), height: Math.round(e3 * J) })) : a4 && a4.setAttribute(c4, b3);
                    f3 || this.translate(((k2 || 0) - n5 * J) / 2, ((A2 || 0) - e3 * J) / 2);
                  }
                };
              });
              q(f2) && b2.attr({ x: f2, y: a3 });
              b2.isImg = true;
              q(b2.imgwidth) && q(b2.imgheight) ? t2(b2) : (b2.attr({ width: 0, height: 0 }), k("img", { onload: function() {
                const c3 = v[A.chartIndex];
                this.width === 0 && (r(this, { position: "absolute", top: "-999em" }), p.body.appendChild(this));
                w[P2] = {
                  width: this.width,
                  height: this.height
                };
                b2.imgwidth = this.width;
                b2.imgheight = this.height;
                b2.element && t2(b2);
                this.parentNode && this.parentNode.removeChild(this);
                A.imgCount--;
                if (!A.imgCount && c3 && !c3.hasLoaded)
                  c3.onload();
              }, src: P2 }), this.imgCount++);
            }
            return D2;
          }
          clipRect(b2, c2, f2, d2) {
            const a3 = T() + "-", k2 = this.createElement("clipPath").attr({ id: a3 }).add(this.defs);
            b2 = this.rect(b2, c2, f2, d2, 0).add(k2);
            b2.id = a3;
            b2.clipPath = k2;
            b2.count = 0;
            return b2;
          }
          text(b2, c2, f2, d2) {
            const a3 = {};
            if (d2 && (this.allowHTML || !this.forExport))
              return this.html(b2, c2, f2);
            a3.x = Math.round(c2 || 0);
            f2 && (a3.y = Math.round(f2));
            q(b2) && (a3.text = b2);
            b2 = this.createElement("text").attr(a3);
            if (!d2 || this.forExport && !this.allowHTML)
              b2.xSetter = function(b3, c3, f3) {
                const d3 = f3.getElementsByTagName("tspan"), a4 = f3.getAttribute(c3);
                for (let f4 = 0, k2; f4 < d3.length; f4++)
                  k2 = d3[f4], k2.getAttribute(c3) === a4 && k2.setAttribute(c3, b3);
                f3.setAttribute(c3, b3);
              };
            return b2;
          }
          fontMetrics(b2) {
            b2 = x(C.prototype.getStyle.call(b2, "font-size") || 0);
            const c2 = 24 > b2 ? b2 + 3 : Math.round(1.2 * b2);
            return { h: c2, b: Math.round(0.8 * c2), f: b2 };
          }
          rotCorr(b2, c2, f2) {
            let d2 = b2;
            c2 && f2 && (d2 = Math.max(d2 * Math.cos(c2 * l2), 4));
            return { x: -b2 / 3 * Math.sin(c2 * l2), y: d2 };
          }
          pathToSegments(b2) {
            const f2 = [], d2 = [], a3 = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 };
            for (let k2 = 0; k2 < b2.length; k2++)
              P(d2[0]) && c(b2[k2]) && d2.length === a3[d2[0].toUpperCase()] && b2.splice(k2, 0, d2[0].replace("M", "L").replace("m", "l")), typeof b2[k2] === "string" && (d2.length && f2.push(d2.slice(0)), d2.length = 0), d2.push(b2[k2]);
            f2.push(d2.slice(0));
            return f2;
          }
          label(b2, c2, f2, d2, a3, k2, n4, e2, q2) {
            return new z(this, b2, c2, f2, d2, a3, k2, n4, e2, q2);
          }
          alignElements() {
            this.alignedObjects.forEach((b2) => b2.align());
          }
        }
        b(V.prototype, {
          Element: C,
          SVG_NS: e,
          escapes: { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" },
          symbols: H,
          draw: g
        });
        L.registerRendererType("svg", V, true);
        "";
        return V;
      });
      M(a, "Core/Renderer/HTML/HTMLElement.js", [a["Core/Globals.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { isFirefox: x, isMS: C, isWebKit: z, win: H } = a2, { css: B, defined: u, extend: v, pick: l2, pInt: p } = I, t = [];
        class m extends y {
          static compose(a3) {
            if (I.pushUnique(t, a3)) {
              const g = m.prototype, e = a3.prototype;
              e.getSpanCorrection = g.getSpanCorrection;
              e.htmlCss = g.htmlCss;
              e.htmlGetBBox = g.htmlGetBBox;
              e.htmlUpdateTransform = g.htmlUpdateTransform;
              e.setSpanRotation = g.setSpanRotation;
            }
            return a3;
          }
          getSpanCorrection(a3, g, e) {
            this.xCorr = -a3 * e;
            this.yCorr = -g;
          }
          htmlCss(a3) {
            const g = this.element.tagName === "SPAN" && a3 && "width" in a3, e = l2(g && a3.width, void 0);
            let h;
            g && (delete a3.width, this.textWidth = e, h = true);
            a3 && a3.textOverflow === "ellipsis" && (a3.whiteSpace = "nowrap", a3.overflow = "hidden");
            this.styles = v(this.styles, a3);
            B(this.element, a3);
            h && this.htmlUpdateTransform();
            return this;
          }
          htmlGetBBox() {
            const a3 = this.element;
            return { x: a3.offsetLeft, y: a3.offsetTop, width: a3.offsetWidth, height: a3.offsetHeight };
          }
          htmlUpdateTransform() {
            if (this.added) {
              var a3 = this.renderer, g = this.element, e = this.x || 0, m2 = this.y || 0, l3 = this.textAlign || "left", t2 = { left: 0, center: 0.5, right: 1 }[l3], d = this.styles, k = d && d.whiteSpace;
              B(g, { marginLeft: this.translateX || 0, marginTop: this.translateY || 0 });
              if (g.tagName === "SPAN") {
                d = this.rotation;
                const q = this.textWidth && p(this.textWidth), h = [d, l3, g.innerHTML, this.textWidth, this.textAlign].join();
                let b = false;
                if (q !== this.oldTextWidth) {
                  if (this.textPxLength)
                    var r = this.textPxLength;
                  else
                    B(g, { width: "", whiteSpace: k || "nowrap" }), r = g.offsetWidth;
                  (q > this.oldTextWidth || r > q) && (/[ \-]/.test(g.textContent || g.innerText) || g.style.textOverflow === "ellipsis") && (B(g, { width: r > q || d ? q + "px" : "auto", display: "block", whiteSpace: k || "normal" }), this.oldTextWidth = q, b = true);
                }
                this.hasBoxWidthChanged = b;
                h !== this.cTT && (a3 = a3.fontMetrics(g).b, !u(d) || d === (this.oldRotation || 0) && l3 === this.oldAlign || this.setSpanRotation(d, t2, a3), this.getSpanCorrection(!u(d) && this.textPxLength || g.offsetWidth, a3, t2, d, l3));
                B(g, { left: e + (this.xCorr || 0) + "px", top: m2 + (this.yCorr || 0) + "px" });
                this.cTT = h;
                this.oldRotation = d;
                this.oldAlign = l3;
              }
            } else
              this.alignOnAdd = true;
          }
          setSpanRotation(a3, g, e) {
            const h = {}, m2 = C && !/Edge/.test(H.navigator.userAgent) ? "-ms-transform" : z ? "-webkit-transform" : x ? "MozTransform" : H.opera ? "-o-transform" : void 0;
            m2 && (h[m2] = h.transform = "rotate(" + a3 + "deg)", h[m2 + (x ? "Origin" : "-origin")] = h.transformOrigin = 100 * g + "% " + e + "px", B(this.element, h));
          }
        }
        return m;
      });
      M(a, "Core/Renderer/HTML/HTMLRenderer.js", [
        a["Core/Renderer/HTML/AST.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, I, L) {
        const { attr: x, createElement: z, extend: H, pick: B } = L, u = [];
        class v extends I {
          static compose(a3) {
            L.pushUnique(u, a3) && (a3.prototype.html = v.prototype.html);
            return a3;
          }
          html(l2, p, t) {
            const m = this.createElement("span"), h = m.element, g = m.renderer, e = function(a3, e2) {
              ["opacity", "visibility"].forEach(function(g2) {
                a3[g2 + "Setter"] = function(d, k, r) {
                  const q = a3.div ? a3.div.style : e2;
                  y.prototype[g2 + "Setter"].call(this, d, k, r);
                  q && (q[k] = d);
                };
              });
              a3.addedSetters = true;
            };
            m.textSetter = function(e2) {
              e2 !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a2.setElementHTML(this.element, B(e2, "")), this.textStr = e2, m.doTransform = true);
            };
            e(m, m.element.style);
            m.xSetter = m.ySetter = m.alignSetter = m.rotationSetter = function(a3, e2) {
              e2 === "align" ? m.alignValue = m.textAlign = a3 : m[e2] = a3;
              m.doTransform = true;
            };
            m.afterSetters = function() {
              this.doTransform && (this.htmlUpdateTransform(), this.doTransform = false);
            };
            m.attr({ text: l2, x: Math.round(p), y: Math.round(t) }).css({ position: "absolute" });
            g.styledMode || m.css({ fontFamily: this.style.fontFamily, fontSize: this.style.fontSize });
            h.style.whiteSpace = "nowrap";
            m.css = m.htmlCss;
            m.add = function(a3) {
              const l3 = g.box.parentNode, w = [];
              let d;
              if (this.parentGroup = a3) {
                if (d = a3.div, !d) {
                  for (; a3; )
                    w.push(a3), a3 = a3.parentGroup;
                  w.reverse().forEach(function(a4) {
                    function k(f, c) {
                      a4[c] = f;
                      c === "translateX" ? b.left = f + "px" : b.top = f + "px";
                      a4.doTransform = true;
                    }
                    const q = x(a4.element, "class"), g2 = a4.styles || {};
                    d = a4.div = a4.div || z("div", q ? { className: q } : void 0, { position: "absolute", left: (a4.translateX || 0) + "px", top: (a4.translateY || 0) + "px", display: a4.display, opacity: a4.opacity, visibility: a4.visibility }, d || l3);
                    const b = d.style;
                    H(a4, { classSetter: function(b2) {
                      return function(c) {
                        this.element.setAttribute("class", c);
                        b2.className = c;
                      };
                    }(d), css: function(f) {
                      m.css.call(a4, f);
                      ["cursor", "pointerEvents"].forEach((c) => {
                        f[c] && (b[c] = f[c]);
                      });
                      return a4;
                    }, on: function() {
                      w[0].div && m.on.apply({ element: w[0].div, onEvents: a4.onEvents }, arguments);
                      return a4;
                    }, translateXSetter: k, translateYSetter: k });
                    a4.addedSetters || e(a4);
                    a4.css(g2);
                  });
                }
              } else
                d = l3;
              d.appendChild(h);
              m.added = true;
              m.alignOnAdd && m.htmlUpdateTransform();
              return m;
            };
            return m;
          }
        }
        return v;
      });
      M(a, "Core/Axis/AxisDefaults.js", [], function() {
        var a2;
        (function(a3) {
          a3.defaultXAxisOptions = {
            alignTicks: true,
            allowDecimals: void 0,
            panningEnabled: true,
            zIndex: 2,
            zoomEnabled: true,
            dateTimeLabelFormats: { millisecond: { main: "%H:%M:%S.%L", range: false }, second: { main: "%H:%M:%S", range: false }, minute: { main: "%H:%M", range: false }, hour: { main: "%H:%M", range: false }, day: { main: "%e %b" }, week: { main: "%e %b" }, month: { main: "%b '%y" }, year: { main: "%Y" } },
            endOnTick: false,
            gridLineDashStyle: "Solid",
            gridZIndex: 1,
            labels: { autoRotation: void 0, autoRotationLimit: 80, distance: 15, enabled: true, indentation: 10, overflow: "justify", padding: 5, reserveSpace: void 0, rotation: void 0, staggerLines: 0, step: 0, useHTML: false, zIndex: 7, style: { color: "#333333", cursor: "default", fontSize: "0.8em" } },
            maxPadding: 0.01,
            minorGridLineDashStyle: "Solid",
            minorTickLength: 2,
            minorTickPosition: "outside",
            minorTicksPerMajor: 5,
            minPadding: 0.01,
            offset: void 0,
            opposite: false,
            reversed: void 0,
            reversedStacks: false,
            showEmpty: true,
            showFirstLabel: true,
            showLastLabel: true,
            startOfWeek: 1,
            startOnTick: false,
            tickLength: 10,
            tickPixelInterval: 100,
            tickmarkPlacement: "between",
            tickPosition: "outside",
            title: { align: "middle", rotation: 0, useHTML: false, x: 0, y: 0, style: { color: "#666666", fontSize: "0.8em" } },
            type: "linear",
            uniqueNames: true,
            visible: true,
            minorGridLineColor: "#f2f2f2",
            minorGridLineWidth: 1,
            minorTickColor: "#999999",
            lineColor: "#333333",
            lineWidth: 1,
            gridLineColor: "#e6e6e6",
            gridLineWidth: void 0,
            tickColor: "#333333"
          };
          a3.defaultYAxisOptions = {
            reversedStacks: true,
            endOnTick: true,
            maxPadding: 0.05,
            minPadding: 0.05,
            tickPixelInterval: 72,
            showLastLabel: true,
            labels: { x: void 0 },
            startOnTick: true,
            title: { rotation: 270, text: "Values" },
            stackLabels: { animation: {}, allowOverlap: false, enabled: false, crop: true, overflow: "justify", formatter: function() {
              const { numberFormatter: a4 } = this.axis.chart;
              return a4(this.total || 0, -1);
            }, style: { color: "#000000", fontSize: "0.7em", fontWeight: "bold", textOutline: "1px contrast" } },
            gridLineWidth: 1,
            lineWidth: 0
          };
          a3.defaultLeftAxisOptions = { title: { rotation: 270 } };
          a3.defaultRightAxisOptions = { title: { rotation: 90 } };
          a3.defaultBottomAxisOptions = { labels: { autoRotation: [-45] }, margin: 15, title: { rotation: 0 } };
          a3.defaultTopAxisOptions = { labels: { autoRotation: [-45] }, margin: 15, title: { rotation: 0 } };
        })(a2 || (a2 = {}));
        return a2;
      });
      M(a, "Core/Foundation.js", [a["Core/Utilities.js"]], function(a2) {
        const { addEvent: x, isFunction: I, objectEach: L, removeEvent: C } = a2;
        var z;
        (function(a3) {
          a3.registerEventOptions = function(a4, u) {
            a4.eventOptions = a4.eventOptions || {};
            L(u.events, function(v, l2) {
              a4.eventOptions[l2] !== v && (a4.eventOptions[l2] && (C(a4, l2, a4.eventOptions[l2]), delete a4.eventOptions[l2]), I(v) && (a4.eventOptions[l2] = v, x(a4, l2, v, { order: 0 })));
            });
          };
        })(z || (z = {}));
        return z;
      });
      M(a, "Core/Axis/Tick.js", [a["Core/Templating.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { deg2rad: x } = y, { clamp: C, correctFloat: z, defined: H, destroyObjectProperties: B, extend: u, fireEvent: v, isNumber: l2, merge: p, objectEach: t, pick: m } = I;
        class h {
          constructor(a3, e, h3, m2, l3) {
            this.isNewLabel = this.isNew = true;
            this.axis = a3;
            this.pos = e;
            this.type = h3 || "";
            this.parameters = l3 || {};
            this.tickmarkOffset = this.parameters.tickmarkOffset;
            this.options = this.parameters.options;
            v(this, "init");
            h3 || m2 || this.addLabel();
          }
          addLabel() {
            const g = this, e = g.axis;
            var h3 = e.options;
            const p2 = e.chart;
            var t2 = e.categories;
            const d = e.logarithmic, k = e.names, r = g.pos, q = m(g.options && g.options.labels, h3.labels);
            var G = e.tickPositions;
            const b = r === G[0], f = r === G[G.length - 1], c = (!q.step || q.step === 1) && e.tickInterval === 1;
            G = G.info;
            let n3 = g.label, P, D, K;
            t2 = this.parameters.category || (t2 ? m(t2[r], k[r], r) : r);
            d && l2(t2) && (t2 = z(d.lin2log(t2)));
            e.dateTime && (G ? (D = p2.time.resolveDTLFormat(h3.dateTimeLabelFormats[!h3.grid && G.higherRanks[r] || G.unitName]), P = D.main) : l2(t2) && (P = e.dateTime.getXDateFormat(t2, h3.dateTimeLabelFormats || {})));
            g.isFirst = b;
            g.isLast = f;
            const x2 = { axis: e, chart: p2, dateTimeLabelFormat: P, isFirst: b, isLast: f, pos: r, tick: g, tickPositionInfo: G, value: t2 };
            v(this, "labelFormat", x2);
            const B2 = (b2) => q.formatter ? q.formatter.call(b2, b2) : q.format ? (b2.text = e.defaultLabelFormatter.call(b2, b2), a2.format(q.format, b2, p2)) : e.defaultLabelFormatter.call(b2, b2);
            h3 = B2.call(x2, x2);
            const y2 = D && D.list;
            g.shortenLabel = y2 ? function() {
              for (K = 0; K < y2.length; K++)
                if (u(x2, { dateTimeLabelFormat: y2[K] }), n3.attr({ text: B2.call(x2, x2) }), n3.getBBox().width < e.getSlotWidth(g) - 2 * q.padding)
                  return;
              n3.attr({ text: "" });
            } : void 0;
            c && e._addedPlotLB && g.moveLabel(h3, q);
            H(n3) || g.movedLabel ? n3 && n3.textStr !== h3 && !c && (!n3.textWidth || q.style.width || n3.styles.width || n3.css({ width: null }), n3.attr({ text: h3 }), n3.textPxLength = n3.getBBox().width) : (g.label = n3 = g.createLabel({ x: 0, y: 0 }, h3, q), g.rotation = 0);
          }
          createLabel(a3, e, h3) {
            const g = this.axis, m2 = g.chart;
            if (a3 = H(e) && h3.enabled ? m2.renderer.text(e, a3.x, a3.y, h3.useHTML).add(g.labelGroup) : null)
              m2.styledMode || a3.css(p(h3.style)), a3.textPxLength = a3.getBBox().width;
            return a3;
          }
          destroy() {
            B(this, this.axis);
          }
          getPosition(a3, e, h3, m2) {
            const g = this.axis, d = g.chart, k = m2 && d.oldChartHeight || d.chartHeight;
            a3 = { x: a3 ? z(g.translate(e + h3, void 0, void 0, m2) + g.transB) : g.left + g.offset + (g.opposite ? (m2 && d.oldChartWidth || d.chartWidth) - g.right - g.left : 0), y: a3 ? k - g.bottom + g.offset - (g.opposite ? g.height : 0) : z(k - g.translate(e + h3, void 0, void 0, m2) - g.transB) };
            a3.y = C(a3.y, -1e5, 1e5);
            v(this, "afterGetPosition", { pos: a3 });
            return a3;
          }
          getLabelPosition(a3, e, h3, l3, p2, d, k, r) {
            const q = this.axis, g = q.transA, b = q.isLinked && q.linkedParent ? q.linkedParent.reversed : q.reversed, f = q.staggerLines, c = q.tickRotCorr || { x: 0, y: 0 }, n3 = l3 || q.reserveSpaceDefault ? 0 : -q.labelOffset * (q.labelAlign === "center" ? 0.5 : 1), w = p2.distance, D = {};
            h3 = q.side === 0 ? h3.rotation ? -w : -h3.getBBox().height : q.side === 2 ? c.y + w : Math.cos(h3.rotation * x) * (c.y - h3.getBBox(false, 0).height / 2);
            H(p2.y) && (h3 = q.side === 0 && q.horiz ? p2.y + h3 : p2.y);
            a3 = a3 + m(p2.x, [0, 1, 0, -1][q.side] * w) + n3 + c.x - (d && l3 ? d * g * (b ? -1 : 1) : 0);
            e = e + h3 - (d && !l3 ? d * g * (b ? 1 : -1) : 0);
            f && (l3 = k / (r || 1) % f, q.opposite && (l3 = f - l3 - 1), e += q.labelOffset / f * l3);
            D.x = a3;
            D.y = Math.round(e);
            v(this, "afterGetLabelPosition", { pos: D, tickmarkOffset: d, index: k });
            return D;
          }
          getLabelSize() {
            return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
          }
          getMarkPath(a3, e, h3, m2, l3, d) {
            return d.crispLine([["M", a3, e], ["L", a3 + (l3 ? 0 : -h3), e + (l3 ? h3 : 0)]], m2);
          }
          handleOverflow(a3) {
            const e = this.axis, g = e.options.labels, h3 = a3.x;
            var l3 = e.chart.chartWidth, d = e.chart.spacing;
            const k = m(e.labelLeft, Math.min(e.pos, d[3]));
            d = m(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, l3 - d[1]));
            const r = this.label, q = this.rotation, p2 = { left: 0, center: 0.5, right: 1 }[e.labelAlign || r.attr("align")], b = r.getBBox().width, f = e.getSlotWidth(this), c = {};
            let n3 = f, t2 = 1, D;
            if (q || g.overflow !== "justify")
              0 > q && h3 - p2 * b < k ? D = Math.round(h3 / Math.cos(q * x) - k) : 0 < q && h3 + p2 * b > d && (D = Math.round((l3 - h3) / Math.cos(q * x)));
            else if (l3 = h3 + (1 - p2) * b, h3 - p2 * b < k ? n3 = a3.x + n3 * (1 - p2) - k : l3 > d && (n3 = d - a3.x + n3 * p2, t2 = -1), n3 = Math.min(f, n3), n3 < f && e.labelAlign === "center" && (a3.x += t2 * (f - n3 - p2 * (f - Math.min(b, n3)))), b > n3 || e.autoRotation && (r.styles || {}).width)
              D = n3;
            D && (this.shortenLabel ? this.shortenLabel() : (c.width = Math.floor(D) + "px", (g.style || {}).textOverflow || (c.textOverflow = "ellipsis"), r.css(c)));
          }
          moveLabel(a3, e) {
            const g = this;
            var h3 = g.label;
            const m2 = g.axis;
            let d = false;
            h3 && h3.textStr === a3 ? (g.movedLabel = h3, d = true, delete g.label) : t(m2.ticks, function(k) {
              d || k.isNew || k === g || !k.label || k.label.textStr !== a3 || (g.movedLabel = k.label, d = true, k.labelPos = g.movedLabel.xy, delete k.label);
            });
            d || !g.labelPos && !h3 || (h3 = g.labelPos || h3.xy, g.movedLabel = g.createLabel(h3, a3, e), g.movedLabel && g.movedLabel.attr({ opacity: 0 }));
          }
          render(a3, e, h3) {
            var g = this.axis, l3 = g.horiz, d = this.pos, k = m(this.tickmarkOffset, g.tickmarkOffset);
            d = this.getPosition(l3, d, k, e);
            k = d.x;
            const r = d.y;
            g = l3 && k === g.pos + g.len || !l3 && r === g.pos ? -1 : 1;
            l3 = m(h3, this.label && this.label.newOpacity, 1);
            h3 = m(h3, 1);
            this.isActive = true;
            this.renderGridLine(e, h3, g);
            this.renderMark(d, h3, g);
            this.renderLabel(d, e, l3, a3);
            this.isNew = false;
            v(this, "afterRender");
          }
          renderGridLine(a3, e, h3) {
            const g = this.axis, l3 = g.options, d = {}, k = this.pos, r = this.type, q = m(this.tickmarkOffset, g.tickmarkOffset), p2 = g.chart.renderer;
            let b = this.gridLine, f = l3.gridLineWidth, c = l3.gridLineColor, n3 = l3.gridLineDashStyle;
            this.type === "minor" && (f = l3.minorGridLineWidth, c = l3.minorGridLineColor, n3 = l3.minorGridLineDashStyle);
            b || (g.chart.styledMode || (d.stroke = c, d["stroke-width"] = f || 0, d.dashstyle = n3), r || (d.zIndex = 1), a3 && (e = 0), this.gridLine = b = p2.path().attr(d).addClass("highcharts-" + (r ? r + "-" : "") + "grid-line").add(g.gridGroup));
            if (b && (h3 = g.getPlotLinePath({ value: k + q, lineWidth: b.strokeWidth() * h3, force: "pass", old: a3, acrossPanes: false })))
              b[a3 || this.isNew ? "attr" : "animate"]({ d: h3, opacity: e });
          }
          renderMark(a3, e, h3) {
            const g = this.axis;
            var l3 = g.options;
            const d = g.chart.renderer, k = this.type, r = g.tickSize(k ? k + "Tick" : "tick"), q = a3.x;
            a3 = a3.y;
            const p2 = m(l3[k !== "minor" ? "tickWidth" : "minorTickWidth"], !k && g.isXAxis ? 1 : 0);
            l3 = l3[k !== "minor" ? "tickColor" : "minorTickColor"];
            let b = this.mark;
            const f = !b;
            r && (g.opposite && (r[0] = -r[0]), b || (this.mark = b = d.path().addClass("highcharts-" + (k ? k + "-" : "") + "tick").add(g.axisGroup), g.chart.styledMode || b.attr({ stroke: l3, "stroke-width": p2 })), b[f ? "attr" : "animate"]({ d: this.getMarkPath(q, a3, r[0], b.strokeWidth() * h3, g.horiz, d), opacity: e }));
          }
          renderLabel(a3, e, h3, p2) {
            var g = this.axis;
            const d = g.horiz, k = g.options, r = this.label, q = k.labels, t2 = q.step;
            g = m(this.tickmarkOffset, g.tickmarkOffset);
            const b = a3.x;
            a3 = a3.y;
            let f = true;
            r && l2(b) && (r.xy = a3 = this.getLabelPosition(b, a3, r, d, q, g, p2, t2), this.isFirst && !this.isLast && !k.showFirstLabel || this.isLast && !this.isFirst && !k.showLastLabel ? f = false : !d || q.step || q.rotation || e || h3 === 0 || this.handleOverflow(a3), t2 && p2 % t2 && (f = false), f && l2(a3.y) ? (a3.opacity = h3, r[this.isNewLabel ? "attr" : "animate"](a3).show(true), this.isNewLabel = false) : (r.hide(), this.isNewLabel = true));
          }
          replaceMovedLabel() {
            const a3 = this.label, e = this.axis;
            a3 && !this.isNew && (a3.animate({ opacity: 0 }, void 0, a3.destroy), delete this.label);
            e.isDirty = true;
            this.label = this.movedLabel;
            delete this.movedLabel;
          }
        }
        "";
        return h;
      });
      M(a, "Core/Axis/Axis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/AxisDefaults.js"], a["Core/Color/Color.js"], a["Core/Defaults.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Axis/Tick.js"], a["Core/Utilities.js"]], function(a2, y, I, L, C, z, H, B) {
        const { animObject: u } = a2, { defaultOptions: v } = L, { registerEventOptions: l2 } = C, { deg2rad: p } = z, { arrayMax: t, arrayMin: m, clamp: h, correctFloat: g, defined: e, destroyObjectProperties: w, erase: x, error: F, extend: d, fireEvent: k, getClosestDistance: r, insertItem: q, isArray: G, isNumber: b, isString: f, merge: c, normalizeTickInterval: n3, objectEach: P, pick: D, relativeLength: K, removeEvent: X, splat: T, syncTimeout: Z } = B, V = (b2, c2) => n3(c2, void 0, void 0, D(b2.options.allowDecimals, 0.5 > c2 || b2.tickAmount !== void 0), !!b2.tickAmount);
        class Y {
          constructor(b2, c2, f2) {
            this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.index = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;
            this.init(b2, c2, f2);
          }
          init(c2, f2, a3 = this.coll) {
            const d2 = a3 === "xAxis";
            this.chart = c2;
            this.horiz = this.isZAxis || (c2.inverted ? !d2 : d2);
            this.isXAxis = d2;
            this.coll = a3;
            k(this, "init", { userOptions: f2 });
            this.opposite = D(f2.opposite, this.opposite);
            this.side = D(f2.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
            this.setOptions(f2);
            a3 = this.options;
            const A = a3.labels, n4 = a3.type;
            this.userOptions = f2;
            this.minPixelPadding = 0;
            this.reversed = D(a3.reversed, this.reversed);
            this.visible = a3.visible;
            this.zoomEnabled = a3.zoomEnabled;
            this.hasNames = n4 === "category" || a3.categories === true;
            this.categories = a3.categories || (this.hasNames ? [] : void 0);
            this.names || (this.names = [], this.names.keys = {});
            this.plotLinesAndBandsGroups = {};
            this.positiveValuesOnly = !!this.logarithmic;
            this.isLinked = e(a3.linkedTo);
            this.ticks = {};
            this.labelEdge = [];
            this.minorTicks = {};
            this.plotLinesAndBands = [];
            this.alternateBands = {};
            this.len = 0;
            this.minRange = this.userMinRange = a3.minRange || a3.maxZoom;
            this.range = a3.range;
            this.offset = a3.offset || 0;
            this.min = this.max = null;
            f2 = D(a3.crosshair, T(c2.options.tooltip.crosshairs)[d2 ? 0 : 1]);
            this.crosshair = f2 === true ? {} : f2;
            c2.axes.indexOf(this) === -1 && (d2 ? c2.axes.splice(c2.xAxis.length, 0, this) : c2.axes.push(this), q(this, c2[this.coll]));
            c2.orderItems(this.coll);
            this.series = this.series || [];
            c2.inverted && !this.isZAxis && d2 && typeof this.reversed === "undefined" && (this.reversed = true);
            this.labelRotation = b(A.rotation) ? A.rotation : void 0;
            l2(this, a3);
            k(this, "afterInit");
          }
          setOptions(b2) {
            this.options = c(y.defaultXAxisOptions, this.coll === "yAxis" && y.defaultYAxisOptions, [y.defaultTopAxisOptions, y.defaultRightAxisOptions, y.defaultBottomAxisOptions, y.defaultLeftAxisOptions][this.side], c(v[this.coll], b2));
            k(this, "afterSetOptions", { userOptions: b2 });
          }
          defaultLabelFormatter(c2) {
            var f2 = this.axis;
            ({ numberFormatter: c2 } = this.chart);
            const a3 = b(this.value) ? this.value : NaN, d2 = f2.chart.time, k2 = this.dateTimeLabelFormat;
            var n4 = v.lang;
            const A = n4.numericSymbols;
            n4 = n4.numericSymbolMagnitude || 1e3;
            const e2 = f2.logarithmic ? Math.abs(a3) : f2.tickInterval;
            let q2 = A && A.length, g2;
            if (f2.categories)
              g2 = `${this.value}`;
            else if (k2)
              g2 = d2.dateFormat(k2, a3);
            else if (q2 && 1e3 <= e2)
              for (; q2-- && typeof g2 === "undefined"; )
                f2 = Math.pow(n4, q2 + 1), e2 >= f2 && 10 * a3 % f2 === 0 && A[q2] !== null && a3 !== 0 && (g2 = c2(a3 / f2, -1) + A[q2]);
            typeof g2 === "undefined" && (g2 = 1e4 <= Math.abs(a3) ? c2(a3, -1) : c2(a3, -1, void 0, ""));
            return g2;
          }
          getSeriesExtremes() {
            const c2 = this, f2 = c2.chart;
            let a3;
            k(this, "getSeriesExtremes", null, function() {
              c2.hasVisibleSeries = false;
              c2.dataMin = c2.dataMax = c2.threshold = null;
              c2.softThreshold = !c2.isXAxis;
              c2.series.forEach(function(d2) {
                if (d2.visible || !f2.options.chart.ignoreHiddenSeries) {
                  var k2 = d2.options;
                  let f3 = k2.threshold, n4, A;
                  c2.hasVisibleSeries = true;
                  c2.positiveValuesOnly && 0 >= f3 && (f3 = null);
                  if (c2.isXAxis)
                    (k2 = d2.xData) && k2.length && (k2 = c2.logarithmic ? k2.filter((b2) => 0 < b2) : k2, a3 = d2.getXExtremes(k2), n4 = a3.min, A = a3.max, b(n4) || n4 instanceof Date || (k2 = k2.filter(b), a3 = d2.getXExtremes(k2), n4 = a3.min, A = a3.max), k2.length && (c2.dataMin = Math.min(D(c2.dataMin, n4), n4), c2.dataMax = Math.max(D(c2.dataMax, A), A)));
                  else if (d2 = d2.applyExtremes(), b(d2.dataMin) && (n4 = d2.dataMin, c2.dataMin = Math.min(D(c2.dataMin, n4), n4)), b(d2.dataMax) && (A = d2.dataMax, c2.dataMax = Math.max(D(c2.dataMax, A), A)), e(f3) && (c2.threshold = f3), !k2.softThreshold || c2.positiveValuesOnly)
                    c2.softThreshold = false;
                }
              });
            });
            k(this, "afterGetSeriesExtremes");
          }
          translate(c2, f2, a3, d2, k2, n4) {
            const e2 = this.linkedParent || this, A = d2 && e2.old ? e2.old.min : e2.min;
            if (!b(A))
              return NaN;
            const q2 = e2.minPixelPadding;
            k2 = (e2.isOrdinal || e2.brokenAxis && e2.brokenAxis.hasBreaks || e2.logarithmic && k2) && e2.lin2val;
            let J = 1, h3 = 0;
            d2 = d2 && e2.old ? e2.old.transA : e2.transA;
            d2 || (d2 = e2.transA);
            a3 && (J *= -1, h3 = e2.len);
            e2.reversed && (J *= -1, h3 -= J * (e2.sector || e2.len));
            f2 ? (n4 = (c2 * J + h3 - q2) / d2 + A, k2 && (n4 = e2.lin2val(n4))) : (k2 && (c2 = e2.val2lin(c2)), c2 = J * (c2 - A) * d2, n4 = (e2.isRadial ? c2 : g(c2)) + h3 + J * q2 + (b(n4) ? d2 * n4 : 0));
            return n4;
          }
          toPixels(b2, c2) {
            return this.translate(b2, false, !this.horiz, void 0, true) + (c2 ? 0 : this.pos);
          }
          toValue(b2, c2) {
            return this.translate(b2 - (c2 ? 0 : this.pos), true, !this.horiz, void 0, true);
          }
          getPlotLinePath(c2) {
            function f2(b2, c3, f3) {
              t2 !== "pass" && (b2 < c3 || b2 > f3) && (t2 ? b2 = h(b2, c3, f3) : K2 = true);
              return b2;
            }
            const a3 = this, d2 = a3.chart, n4 = a3.left, e2 = a3.top, A = c2.old, q2 = c2.value, g2 = c2.lineWidth, r2 = A && d2.oldChartHeight || d2.chartHeight, m2 = A && d2.oldChartWidth || d2.chartWidth, l3 = a3.transB;
            let p2 = c2.translatedValue, t2 = c2.force, P2, w2, R, Q, K2;
            c2 = { value: q2, lineWidth: g2, old: A, force: t2, acrossPanes: c2.acrossPanes, translatedValue: p2 };
            k(this, "getPlotLinePath", c2, function(c3) {
              p2 = D(p2, a3.translate(q2, void 0, void 0, A));
              p2 = h(p2, -1e5, 1e5);
              P2 = R = Math.round(p2 + l3);
              w2 = Q = Math.round(r2 - p2 - l3);
              b(p2) ? a3.horiz ? (w2 = e2, Q = r2 - a3.bottom, P2 = R = f2(P2, n4, n4 + a3.width)) : (P2 = n4, R = m2 - a3.right, w2 = Q = f2(w2, e2, e2 + a3.height)) : (K2 = true, t2 = false);
              c3.path = K2 && !t2 ? null : d2.renderer.crispLine([["M", P2, w2], ["L", R, Q]], g2 || 1);
            });
            return c2.path;
          }
          getLinearTickPositions(b2, c2, f2) {
            const a3 = g(Math.floor(c2 / b2) * b2);
            f2 = g(Math.ceil(f2 / b2) * b2);
            const d2 = [];
            let k2, n4;
            g(a3 + b2) === a3 && (n4 = 20);
            if (this.single)
              return [c2];
            for (c2 = a3; c2 <= f2; ) {
              d2.push(c2);
              c2 = g(c2 + b2, n4);
              if (c2 === k2)
                break;
              k2 = c2;
            }
            return d2;
          }
          getMinorTickInterval() {
            const b2 = this.options;
            return b2.minorTicks === true ? D(b2.minorTickInterval, "auto") : b2.minorTicks === false ? null : b2.minorTickInterval;
          }
          getMinorTickPositions() {
            var b2 = this.options;
            const c2 = this.tickPositions, f2 = this.minorTickInterval;
            var a3 = this.pointRangePadding || 0;
            const d2 = this.min - a3;
            a3 = this.max + a3;
            const k2 = a3 - d2;
            let n4 = [];
            if (k2 && k2 / f2 < this.len / 3) {
              const k3 = this.logarithmic;
              if (k3)
                this.paddedTicks.forEach(function(b3, c3, a4) {
                  c3 && n4.push.apply(n4, k3.getLogTickPositions(f2, a4[c3 - 1], a4[c3], true));
                });
              else if (this.dateTime && this.getMinorTickInterval() === "auto")
                n4 = n4.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(f2), d2, a3, b2.startOfWeek));
              else
                for (b2 = d2 + (c2[0] - d2) % f2; b2 <= a3 && b2 !== n4[0]; b2 += f2)
                  n4.push(b2);
            }
            n4.length !== 0 && this.trimTicks(n4);
            return n4;
          }
          adjustForMinRange() {
            const b2 = this.options, c2 = this.logarithmic;
            let f2 = this.min;
            var a3 = this.max;
            let d2, k2;
            if (this.isXAxis && typeof this.minRange === "undefined" && !c2)
              if (e(b2.min) || e(b2.max) || e(b2.floor) || e(b2.ceiling))
                this.minRange = null;
              else {
                var n4 = r(this.series.map((b3) => {
                  var c3;
                  return (b3.xIncrement ? (c3 = b3.xData) === null || c3 === void 0 ? void 0 : c3.slice(0, 2) : b3.xData) || [];
                })) || 0;
                this.minRange = Math.min(5 * n4, this.dataMax - this.dataMin);
              }
            a3 - f2 < this.minRange && (n4 = this.dataMax - this.dataMin >= this.minRange, k2 = this.minRange, a3 = (k2 - a3 + f2) / 2, d2 = [f2 - a3, D(b2.min, f2 - a3)], n4 && (d2[2] = c2 ? c2.log2lin(this.dataMin) : this.dataMin), f2 = t(d2), a3 = [f2 + k2, D(b2.max, f2 + k2)], n4 && (a3[2] = c2 ? c2.log2lin(this.dataMax) : this.dataMax), a3 = m(a3), a3 - f2 < k2 && (d2[0] = a3 - k2, d2[1] = D(b2.min, a3 - k2), f2 = t(d2)));
            this.min = f2;
            this.max = a3;
          }
          getClosest() {
            let b2, c2;
            if (this.categories)
              c2 = 1;
            else {
              const f2 = [];
              this.series.forEach(function(b3) {
                var a3;
                const d2 = b3.closestPointRange, k2 = b3.visible || !b3.chart.options.chart.ignoreHiddenSeries;
                ((a3 = b3.xData) === null || a3 === void 0 ? void 0 : a3.length) === 1 ? f2.push(b3.xData[0]) : !b3.noSharedTooltip && e(d2) && k2 && (c2 = e(c2) ? Math.min(c2, d2) : d2);
              });
              f2.length && (f2.sort((b3, c3) => b3 - c3), b2 = r([f2]));
            }
            return b2 && c2 ? Math.min(b2, c2) : b2 || c2;
          }
          nameToX(b2) {
            const c2 = G(this.options.categories), f2 = c2 ? this.categories : this.names;
            let a3 = b2.options.x, d2;
            b2.series.requireSorting = false;
            e(a3) || (a3 = this.options.uniqueNames && f2 ? c2 ? f2.indexOf(b2.name) : D(f2.keys[b2.name], -1) : b2.series.autoIncrement());
            a3 === -1 ? !c2 && f2 && (d2 = f2.length) : d2 = a3;
            typeof d2 !== "undefined" ? (this.names[d2] = b2.name, this.names.keys[b2.name] = d2) : b2.x && (d2 = b2.x);
            return d2;
          }
          updateNames() {
            const b2 = this, c2 = this.names;
            0 < c2.length && (Object.keys(c2.keys).forEach(function(b3) {
              delete c2.keys[b3];
            }), c2.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function(c3) {
              c3.xIncrement = null;
              if (!c3.points || c3.isDirtyData)
                b2.max = Math.max(b2.max, c3.xData.length - 1), c3.processData(), c3.generatePoints();
              c3.data.forEach(function(f2, a3) {
                let d2;
                f2 && f2.options && typeof f2.name !== "undefined" && (d2 = b2.nameToX(f2), typeof d2 !== "undefined" && d2 !== f2.x && (f2.x = d2, c3.xData[a3] = d2));
              });
            }));
          }
          setAxisTranslation() {
            const b2 = this, c2 = b2.max - b2.min;
            var a3 = b2.linkedParent;
            const d2 = !!b2.categories, n4 = b2.isXAxis;
            let e2 = b2.axisPointRange || 0, q2, g2 = 0, h3 = 0, r2 = b2.transA;
            if (n4 || d2 || e2)
              q2 = b2.getClosest(), a3 ? (g2 = a3.minPointOffset, h3 = a3.pointRangePadding) : b2.series.forEach(function(c3) {
                const a4 = d2 ? 1 : n4 ? D(c3.options.pointRange, q2, 0) : b2.axisPointRange || 0, k2 = c3.options.pointPlacement;
                e2 = Math.max(e2, a4);
                if (!b2.single || d2)
                  c3 = c3.is("xrange") ? !n4 : n4, g2 = Math.max(g2, c3 && f(k2) ? 0 : a4 / 2), h3 = Math.max(h3, c3 && k2 === "on" ? 0 : a4);
              }), a3 = b2.ordinal && b2.ordinal.slope && q2 ? b2.ordinal.slope / q2 : 1, b2.minPointOffset = g2 *= a3, b2.pointRangePadding = h3 *= a3, b2.pointRange = Math.min(e2, b2.single && d2 ? 1 : c2), n4 && q2 && (b2.closestPointRange = q2);
            b2.translationSlope = b2.transA = r2 = b2.staticScale || b2.len / (c2 + h3 || 1);
            b2.transB = b2.horiz ? b2.left : b2.bottom;
            b2.minPixelPadding = r2 * g2;
            k(this, "afterSetAxisTranslation");
          }
          minFromRange() {
            return this.max - this.range;
          }
          setTickInterval(c2) {
            var f2 = this.chart;
            const a3 = this.logarithmic, d2 = this.options, n4 = this.isXAxis, q2 = this.isLinked, h3 = d2.tickPixelInterval, A = this.categories, r2 = this.softThreshold;
            let m2 = d2.maxPadding, l3 = d2.minPadding;
            let p2 = b(d2.tickInterval) && 0 <= d2.tickInterval ? d2.tickInterval : void 0, t2 = b(this.threshold) ? this.threshold : null, P2, w2, K2;
            this.dateTime || A || q2 || this.getTickAmount();
            w2 = D(this.userMin, d2.min);
            K2 = D(this.userMax, d2.max);
            if (q2) {
              this.linkedParent = f2[this.coll][d2.linkedTo];
              var R = this.linkedParent.getExtremes();
              this.min = D(R.min, R.dataMin);
              this.max = D(R.max, R.dataMax);
              d2.type !== this.linkedParent.options.type && F(11, 1, f2);
            } else
              r2 && e(t2) && (this.dataMin >= t2 ? (R = t2, l3 = 0) : this.dataMax <= t2 && (P2 = t2, m2 = 0)), this.min = D(w2, R, this.dataMin), this.max = D(K2, P2, this.dataMax);
            a3 && (this.positiveValuesOnly && !c2 && 0 >= Math.min(this.min, D(this.dataMin, this.min)) && F(10, 1, f2), this.min = g(a3.log2lin(this.min), 16), this.max = g(a3.log2lin(this.max), 16));
            this.range && e(this.max) && (this.userMin = this.min = w2 = Math.max(this.dataMin, this.minFromRange()), this.userMax = K2 = this.max, this.range = null);
            k(this, "foundExtremes");
            this.beforePadding && this.beforePadding();
            this.adjustForMinRange();
            !b(this.userMin) && b(d2.softMin) && d2.softMin < this.min && (this.min = w2 = d2.softMin);
            !b(this.userMax) && b(d2.softMax) && d2.softMax > this.max && (this.max = K2 = d2.softMax);
            !(A || this.axisPointRange || this.stacking && this.stacking.usePercentage || q2) && e(this.min) && e(this.max) && (f2 = this.max - this.min) && (!e(w2) && l3 && (this.min -= f2 * l3), !e(K2) && m2 && (this.max += f2 * m2));
            !b(this.userMin) && b(d2.floor) && (this.min = Math.max(this.min, d2.floor));
            !b(this.userMax) && b(d2.ceiling) && (this.max = Math.min(this.max, d2.ceiling));
            r2 && e(this.dataMin) && (t2 = t2 || 0, !e(w2) && this.min < t2 && this.dataMin >= t2 ? this.min = this.options.minRange ? Math.min(t2, this.max - this.minRange) : t2 : !e(K2) && this.max > t2 && this.dataMax <= t2 && (this.max = this.options.minRange ? Math.max(t2, this.min + this.minRange) : t2));
            b(this.min) && b(this.max) && !this.chart.polar && this.min > this.max && (e(this.options.min) ? this.max = this.min : e(this.options.max) && (this.min = this.max));
            this.tickInterval = this.min === this.max || typeof this.min === "undefined" || typeof this.max === "undefined" ? 1 : q2 && this.linkedParent && !p2 && h3 === this.linkedParent.options.tickPixelInterval ? p2 = this.linkedParent.tickInterval : D(p2, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, A ? 1 : (this.max - this.min) * h3 / Math.max(this.len, h3));
            if (n4 && !c2) {
              const b2 = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
              this.series.forEach(function(c3) {
                c3.forceCrop = c3.forceCropping && c3.forceCropping();
                c3.processData(b2);
              });
              k(this, "postProcessData", { hasExtremesChanged: b2 });
            }
            this.setAxisTranslation();
            k(this, "initialAxisTranslation");
            this.pointRange && !p2 && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
            c2 = D(d2.minTickInterval, this.dateTime && !this.series.some((b2) => b2.noSharedTooltip) ? this.closestPointRange : 0);
            !p2 && this.tickInterval < c2 && (this.tickInterval = c2);
            this.dateTime || this.logarithmic || p2 || (this.tickInterval = V(this, this.tickInterval));
            this.tickAmount || (this.tickInterval = this.unsquish());
            this.setTickPositions();
          }
          setTickPositions() {
            var c2 = this.options;
            const f2 = c2.tickPositions, a3 = c2.tickPositioner;
            var d2 = this.getMinorTickInterval(), n4 = this.hasVerticalPanning(), q2 = this.coll === "colorAxis";
            const g2 = (q2 || !n4) && c2.startOnTick;
            n4 = (q2 || !n4) && c2.endOnTick;
            q2 = [];
            let h3;
            this.tickmarkOffset = this.categories && c2.tickmarkPlacement === "between" && this.tickInterval === 1 ? 0.5 : 0;
            this.minorTickInterval = d2 === "auto" && this.tickInterval ? this.tickInterval / c2.minorTicksPerMajor : d2;
            this.single = this.min === this.max && e(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || c2.allowDecimals !== false);
            if (f2)
              q2 = f2.slice();
            else if (b(this.min) && b(this.max)) {
              if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)))
                if (this.dateTime)
                  q2 = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, c2.units), this.min, this.max, c2.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, true);
                else if (this.logarithmic)
                  q2 = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
                else
                  for (d2 = c2 = this.tickInterval; d2 <= 2 * c2; )
                    if (q2 = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && q2.length > this.tickAmount)
                      this.tickInterval = V(this, d2 *= 1.1);
                    else
                      break;
              else
                q2 = [this.min, this.max], F(19, false, this.chart);
              q2.length > this.len && (q2 = [q2[0], q2[q2.length - 1]], q2[0] === q2[1] && (q2.length = 1));
              a3 && (this.tickPositions = q2, (h3 = a3.apply(this, [this.min, this.max])) && (q2 = h3));
            }
            this.tickPositions = q2;
            this.paddedTicks = q2.slice(0);
            this.trimTicks(q2, g2, n4);
            !this.isLinked && b(this.min) && b(this.max) && (this.single && 2 > q2.length && !this.categories && !this.series.some((b2) => b2.is("heatmap") && b2.options.pointPlacement === "between") && (this.min -= 0.5, this.max += 0.5), f2 || h3 || this.adjustTickAmount());
            k(this, "afterSetTickPositions");
          }
          trimTicks(b2, c2, f2) {
            const a3 = b2[0], d2 = b2[b2.length - 1], n4 = !this.isOrdinal && this.minPointOffset || 0;
            k(this, "trimTicks");
            if (!this.isLinked) {
              if (c2 && a3 !== -Infinity)
                this.min = a3;
              else
                for (; this.min - n4 > b2[0]; )
                  b2.shift();
              if (f2)
                this.max = d2;
              else
                for (; this.max + n4 < b2[b2.length - 1]; )
                  b2.pop();
              b2.length === 0 && e(a3) && !this.options.tickPositions && b2.push((d2 + a3) / 2);
            }
          }
          alignToOthers() {
            const c2 = this, f2 = [this], a3 = c2.options, d2 = this.coll === "yAxis" && this.chart.options.chart.alignThresholds, k2 = [];
            let n4;
            c2.thresholdAlignment = void 0;
            if ((this.chart.options.chart.alignTicks !== false && a3.alignTicks || d2) && a3.startOnTick !== false && a3.endOnTick !== false && !c2.logarithmic) {
              const b2 = (b3) => {
                const { horiz: c3, options: f3 } = b3;
                return [c3 ? f3.left : f3.top, f3.width, f3.height, f3.pane].join();
              }, a4 = b2(this);
              this.chart[this.coll].forEach(function(d3) {
                const { series: k3 } = d3;
                k3.length && k3.some((b3) => b3.visible) && d3 !== c2 && b2(d3) === a4 && (n4 = true, f2.push(d3));
              });
            }
            if (n4 && d2) {
              f2.forEach((f3) => {
                f3 = f3.getThresholdAlignment(c2);
                b(f3) && k2.push(f3);
              });
              const a4 = 1 < k2.length ? k2.reduce((b2, c3) => b2 + c3, 0) / k2.length : void 0;
              f2.forEach((b2) => {
                b2.thresholdAlignment = a4;
              });
            }
            return n4;
          }
          getThresholdAlignment(c2) {
            (!b(this.dataMin) || this !== c2 && this.series.some((b2) => b2.isDirty || b2.isDirtyData)) && this.getSeriesExtremes();
            if (b(this.threshold))
              return c2 = h((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (c2 = 1 - c2), c2;
          }
          getTickAmount() {
            const b2 = this.options, c2 = b2.tickPixelInterval;
            let f2 = b2.tickAmount;
            !e(b2.tickInterval) && !f2 && this.len < c2 && !this.isRadial && !this.logarithmic && b2.startOnTick && b2.endOnTick && (f2 = 2);
            !f2 && this.alignToOthers() && (f2 = Math.ceil(this.len / c2) + 1);
            4 > f2 && (this.finalTickAmt = f2, f2 = 5);
            this.tickAmount = f2;
          }
          adjustTickAmount() {
            const c2 = this, { finalTickAmt: f2, max: a3, min: d2, options: k2, tickPositions: n4, tickAmount: q2, thresholdAlignment: h3 } = c2, r2 = n4 && n4.length;
            var m2 = D(c2.threshold, c2.softThreshold ? 0 : null);
            var l3 = c2.tickInterval;
            let p2;
            b(h3) && (p2 = 0.5 > h3 ? Math.ceil(h3 * (q2 - 1)) : Math.floor(h3 * (q2 - 1)), k2.reversed && (p2 = q2 - 1 - p2));
            if (c2.hasData() && b(d2) && b(a3)) {
              const h4 = () => {
                c2.transA *= (r2 - 1) / (q2 - 1);
                c2.min = k2.startOnTick ? n4[0] : Math.min(d2, n4[0]);
                c2.max = k2.endOnTick ? n4[n4.length - 1] : Math.max(a3, n4[n4.length - 1]);
              };
              if (b(p2) && b(c2.threshold)) {
                for (; n4[p2] !== m2 || n4.length !== q2 || n4[0] > d2 || n4[n4.length - 1] < a3; ) {
                  n4.length = 0;
                  for (n4.push(c2.threshold); n4.length < q2; )
                    n4[p2] === void 0 || n4[p2] > c2.threshold ? n4.unshift(g(n4[0] - l3)) : n4.push(g(n4[n4.length - 1] + l3));
                  if (l3 > 8 * c2.tickInterval)
                    break;
                  l3 *= 2;
                }
                h4();
              } else if (r2 < q2) {
                for (; n4.length < q2; )
                  n4.length % 2 || d2 === m2 ? n4.push(g(n4[n4.length - 1] + l3)) : n4.unshift(g(n4[0] - l3));
                h4();
              }
              if (e(f2)) {
                for (l3 = m2 = n4.length; l3--; )
                  (f2 === 3 && l3 % 2 === 1 || 2 >= f2 && 0 < l3 && l3 < m2 - 1) && n4.splice(l3, 1);
                c2.finalTickAmt = void 0;
              }
            }
          }
          setScale() {
            let b2 = false, c2 = false;
            this.series.forEach(function(f3) {
              b2 = b2 || f3.isDirtyData || f3.isDirty;
              c2 = c2 || f3.xAxis && f3.xAxis.isDirty || false;
            });
            this.setAxisSize();
            const f2 = this.len !== (this.old && this.old.len);
            f2 || b2 || c2 || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && (this.stacking.resetStacks(), this.stacking.buildStacks()), this.forceRedraw = false, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = f2 || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
            b2 && this.panningState && (this.panningState.isDirty = true);
            k(this, "afterSetScale");
          }
          setExtremes(b2, c2, f2, a3, n4) {
            const e2 = this, q2 = e2.chart;
            f2 = D(f2, true);
            e2.series.forEach(function(b3) {
              delete b3.kdTree;
            });
            n4 = d(n4, { min: b2, max: c2 });
            k(e2, "setExtremes", n4, function() {
              e2.userMin = b2;
              e2.userMax = c2;
              e2.eventArgs = n4;
              f2 && q2.redraw(a3);
            });
          }
          zoom(b2, c2) {
            const f2 = this, a3 = this.dataMin, d2 = this.dataMax, n4 = this.options, q2 = Math.min(a3, D(n4.min, a3)), g2 = Math.max(d2, D(n4.max, d2));
            b2 = { newMin: b2, newMax: c2 };
            k(this, "zoom", b2, function(b3) {
              let c3 = b3.newMin, n5 = b3.newMax;
              if (c3 !== f2.min || n5 !== f2.max)
                f2.allowZoomOutside || (e(a3) && (c3 < q2 && (c3 = q2), c3 > g2 && (c3 = g2)), e(d2) && (n5 < q2 && (n5 = q2), n5 > g2 && (n5 = g2))), f2.displayBtn = typeof c3 !== "undefined" || typeof n5 !== "undefined", f2.setExtremes(c3, n5, false, void 0, { trigger: "zoom" });
              b3.zoomed = true;
            });
            return b2.zoomed;
          }
          setAxisSize() {
            const b2 = this.chart;
            var c2 = this.options;
            const f2 = c2.offsets || [0, 0, 0, 0], a3 = this.horiz, d2 = this.width = Math.round(K(D(c2.width, b2.plotWidth - f2[3] + f2[1]), b2.plotWidth)), n4 = this.height = Math.round(K(D(c2.height, b2.plotHeight - f2[0] + f2[2]), b2.plotHeight)), k2 = this.top = Math.round(K(D(c2.top, b2.plotTop + f2[0]), b2.plotHeight, b2.plotTop));
            c2 = this.left = Math.round(K(D(c2.left, b2.plotLeft + f2[3]), b2.plotWidth, b2.plotLeft));
            this.bottom = b2.chartHeight - n4 - k2;
            this.right = b2.chartWidth - d2 - c2;
            this.len = Math.max(a3 ? d2 : n4, 0);
            this.pos = a3 ? c2 : k2;
          }
          getExtremes() {
            const b2 = this.logarithmic;
            return { min: b2 ? g(b2.lin2log(this.min)) : this.min, max: b2 ? g(b2.lin2log(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax };
          }
          getThreshold(b2) {
            var c2 = this.logarithmic;
            const f2 = c2 ? c2.lin2log(this.min) : this.min;
            c2 = c2 ? c2.lin2log(this.max) : this.max;
            b2 === null || b2 === -Infinity ? b2 = f2 : b2 === Infinity ? b2 = c2 : f2 > b2 ? b2 = f2 : c2 < b2 && (b2 = c2);
            return this.translate(b2, 0, 1, 0, 1);
          }
          autoLabelAlign(b2) {
            const c2 = (D(b2, 0) - 90 * this.side + 720) % 360;
            b2 = { align: "center" };
            k(this, "autoLabelAlign", b2, function(b3) {
              15 < c2 && 165 > c2 ? b3.align = "right" : 195 < c2 && 345 > c2 && (b3.align = "left");
            });
            return b2.align;
          }
          tickSize(b2) {
            const c2 = this.options, f2 = D(c2[b2 === "tick" ? "tickWidth" : "minorTickWidth"], b2 === "tick" && this.isXAxis && !this.categories ? 1 : 0);
            let a3 = c2[b2 === "tick" ? "tickLength" : "minorTickLength"], d2;
            f2 && a3 && (c2[b2 + "Position"] === "inside" && (a3 = -a3), d2 = [a3, f2]);
            b2 = { tickSize: d2 };
            k(this, "afterTickSize", b2);
            return b2.tickSize;
          }
          labelMetrics() {
            const b2 = this.chart.renderer;
            var c2 = this.ticks;
            c2 = c2[Object.keys(c2)[0]] || {};
            return this.chart.renderer.fontMetrics(c2.label || c2.movedLabel || b2.box);
          }
          unsquish() {
            const c2 = this.options.labels;
            var f2 = this.horiz;
            const a3 = this.tickInterval, d2 = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / a3), n4 = c2.rotation, k2 = 0.75 * this.labelMetrics().h, e2 = Math.max(this.max - this.min, 0), q2 = function(b2) {
              let c3 = b2 / (d2 || 1);
              c3 = 1 < c3 ? Math.ceil(c3) : 1;
              c3 * a3 > e2 && b2 !== Infinity && d2 !== Infinity && e2 && (c3 = Math.ceil(e2 / a3));
              return g(c3 * a3);
            };
            let h3 = a3, r2, l3 = Number.MAX_VALUE, m2;
            if (f2) {
              if (c2.staggerLines || (b(n4) ? m2 = [n4] : d2 < c2.autoRotationLimit && (m2 = c2.autoRotation)), m2) {
                let b2;
                for (const c3 of m2)
                  if (c3 === n4 || c3 && -90 <= c3 && 90 >= c3)
                    f2 = q2(Math.abs(k2 / Math.sin(p * c3))), b2 = f2 + Math.abs(c3 / 360), b2 < l3 && (l3 = b2, r2 = c3, h3 = f2);
              }
            } else
              h3 = q2(k2);
            this.autoRotation = m2;
            this.labelRotation = D(r2, b(n4) ? n4 : 0);
            return c2.step ? a3 : h3;
          }
          getSlotWidth(c2) {
            const f2 = this.chart, a3 = this.horiz, d2 = this.options.labels, n4 = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), k2 = f2.margin[3];
            if (c2 && b(c2.slotWidth))
              return c2.slotWidth;
            if (a3 && 2 > d2.step)
              return d2.rotation ? 0 : (this.staggerLines || 1) * this.len / n4;
            if (!a3) {
              c2 = d2.style.width;
              if (c2 !== void 0)
                return parseInt(String(c2), 10);
              if (k2)
                return k2 - f2.spacing[3];
            }
            return 0.33 * f2.chartWidth;
          }
          renderUnsquish() {
            const b2 = this.chart, c2 = b2.renderer, a3 = this.tickPositions, d2 = this.ticks, n4 = this.options.labels, k2 = n4.style, e2 = this.horiz, q2 = this.getSlotWidth();
            var g2 = Math.max(1, Math.round(q2 - 2 * n4.padding));
            const h3 = {}, r2 = this.labelMetrics(), m2 = k2.textOverflow;
            let l3, p2, D2 = 0;
            f(n4.rotation) || (h3.rotation = n4.rotation || 0);
            a3.forEach(function(b3) {
              b3 = d2[b3];
              b3.movedLabel && b3.replaceMovedLabel();
              b3 && b3.label && b3.label.textPxLength > D2 && (D2 = b3.label.textPxLength);
            });
            this.maxLabelLength = D2;
            if (this.autoRotation)
              D2 > g2 && D2 > r2.h ? h3.rotation = this.labelRotation : this.labelRotation = 0;
            else if (q2 && (l3 = g2, !m2))
              for (p2 = "clip", g2 = a3.length; !e2 && g2--; ) {
                var t2 = a3[g2];
                if (t2 = d2[t2].label)
                  t2.styles && t2.styles.textOverflow === "ellipsis" ? t2.css({ textOverflow: "clip" }) : t2.textPxLength > q2 && t2.css({ width: q2 + "px" }), t2.getBBox().height > this.len / a3.length - (r2.h - r2.f) && (t2.specificTextOverflow = "ellipsis");
              }
            h3.rotation && (l3 = D2 > 0.5 * b2.chartHeight ? 0.33 * b2.chartHeight : D2, m2 || (p2 = "ellipsis"));
            if (this.labelAlign = n4.align || this.autoLabelAlign(this.labelRotation))
              h3.align = this.labelAlign;
            a3.forEach(function(b3) {
              const c3 = (b3 = d2[b3]) && b3.label, f2 = k2.width, a4 = {};
              c3 && (c3.attr(h3), b3.shortenLabel ? b3.shortenLabel() : l3 && !f2 && k2.whiteSpace !== "nowrap" && (l3 < c3.textPxLength || c3.element.tagName === "SPAN") ? (a4.width = l3 + "px", m2 || (a4.textOverflow = c3.specificTextOverflow || p2), c3.css(a4)) : c3.styles && c3.styles.width && !a4.width && !f2 && c3.css({ width: null }), delete c3.specificTextOverflow, b3.rotation = h3.rotation);
            }, this);
            this.tickRotCorr = c2.rotCorr(r2.b, this.labelRotation || 0, this.side !== 0);
          }
          hasData() {
            return this.series.some(function(b2) {
              return b2.hasData();
            }) || this.options.showEmpty && e(this.min) && e(this.max);
          }
          addTitle(b2) {
            const f2 = this.chart.renderer, a3 = this.horiz, d2 = this.opposite, n4 = this.options.title, k2 = this.chart.styledMode;
            let e2;
            this.axisTitle || ((e2 = n4.textAlign) || (e2 = (a3 ? { low: "left", middle: "center", high: "right" } : { low: d2 ? "right" : "left", middle: "center", high: d2 ? "left" : "right" })[n4.align]), this.axisTitle = f2.text(n4.text || "", 0, 0, n4.useHTML).attr({
              zIndex: 7,
              rotation: n4.rotation,
              align: e2
            }).addClass("highcharts-axis-title"), k2 || this.axisTitle.css(c(n4.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = true);
            k2 || n4.style.width || this.isRadial || this.axisTitle.css({ width: this.len + "px" });
            this.axisTitle[b2 ? "show" : "hide"](b2);
          }
          generateTick(b2) {
            const c2 = this.ticks;
            c2[b2] ? c2[b2].addLabel() : c2[b2] = new H(this, b2);
          }
          getOffset() {
            const c2 = this, { chart: f2, horiz: a3, options: d2, side: n4, ticks: q2, tickPositions: g2, coll: h3, axisParent: r2 } = c2, m2 = f2.renderer, l3 = f2.inverted && !c2.isZAxis ? [1, 0, 3, 2][n4] : n4;
            var p2 = c2.hasData();
            const t2 = d2.title;
            var w2 = d2.labels;
            const K2 = b(d2.crossing);
            var G2 = f2.axisOffset;
            const R = f2.clipOffset, Q = [-1, 1, 1, -1][n4], v2 = d2.className;
            let ja, u2 = 0, x2;
            var E = 0;
            let F2 = 0;
            c2.showAxis = ja = p2 || d2.showEmpty;
            c2.staggerLines = c2.horiz && w2.staggerLines || void 0;
            if (!c2.axisGroup) {
              const b2 = (b3, c3, f3) => m2.g(b3).attr({ zIndex: f3 }).addClass(`highcharts-${h3.toLowerCase()}${c3} ` + (this.isRadial ? `highcharts-radial-axis${c3} ` : "") + (v2 || "")).add(r2);
              c2.gridGroup = b2("grid", "-grid", d2.gridZIndex);
              c2.axisGroup = b2("axis", "", d2.zIndex);
              c2.labelGroup = b2("axis-labels", "-labels", w2.zIndex);
            }
            p2 || c2.isLinked ? (g2.forEach(function(b2) {
              c2.generateTick(b2);
            }), c2.renderUnsquish(), c2.reserveSpaceDefault = n4 === 0 || n4 === 2 || { 1: "left", 3: "right" }[n4] === c2.labelAlign, D(w2.reserveSpace, K2 ? false : null, c2.labelAlign === "center" ? true : null, c2.reserveSpaceDefault) && g2.forEach(function(b2) {
              F2 = Math.max(q2[b2].getLabelSize(), F2);
            }), c2.staggerLines && (F2 *= c2.staggerLines), c2.labelOffset = F2 * (c2.opposite ? -1 : 1)) : P(q2, function(b2, c3) {
              b2.destroy();
              delete q2[c3];
            });
            t2 && t2.text && t2.enabled !== false && (c2.addTitle(ja), ja && !K2 && t2.reserveSpace !== false && (c2.titleOffset = u2 = c2.axisTitle.getBBox()[a3 ? "height" : "width"], x2 = t2.offset, E = e(x2) ? 0 : D(t2.margin, a3 ? 5 : 10)));
            c2.renderLine();
            c2.offset = Q * D(d2.offset, G2[n4] ? G2[n4] + (d2.margin || 0) : 0);
            c2.tickRotCorr = c2.tickRotCorr || { x: 0, y: 0 };
            p2 = n4 === 0 ? -c2.labelMetrics().h : n4 === 2 ? c2.tickRotCorr.y : 0;
            E = Math.abs(F2) + E;
            F2 && (E = E - p2 + Q * (a3 ? D(w2.y, c2.tickRotCorr.y + Q * w2.distance) : D(w2.x, Q * w2.distance)));
            c2.axisTitleMargin = D(x2, E);
            c2.getMaxLabelDimensions && (c2.maxLabelDimensions = c2.getMaxLabelDimensions(q2, g2));
            h3 !== "colorAxis" && (w2 = this.tickSize("tick"), G2[n4] = Math.max(G2[n4], (c2.axisTitleMargin || 0) + u2 + Q * c2.offset, E, g2 && g2.length && w2 ? w2[0] + Q * c2.offset : 0), G2 = !c2.axisLine || d2.offset ? 0 : 2 * Math.floor(c2.axisLine.strokeWidth() / 2), R[l3] = Math.max(R[l3], G2));
            k(this, "afterGetOffset");
          }
          getLinePath(b2) {
            const c2 = this.chart, f2 = this.opposite;
            var a3 = this.offset;
            const d2 = this.horiz, n4 = this.left + (f2 ? this.width : 0) + a3;
            a3 = c2.chartHeight - this.bottom - (f2 ? this.height : 0) + a3;
            f2 && (b2 *= -1);
            return c2.renderer.crispLine([["M", d2 ? this.left : n4, d2 ? a3 : this.top], ["L", d2 ? c2.chartWidth - this.right : n4, d2 ? a3 : c2.chartHeight - this.bottom]], b2);
          }
          renderLine() {
            this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({ stroke: this.options.lineColor, "stroke-width": this.options.lineWidth, zIndex: 7 }));
          }
          getTitlePosition(b2) {
            var c2 = this.horiz, f2 = this.left;
            const a3 = this.top;
            var d2 = this.len;
            const n4 = this.options.title, e2 = c2 ? f2 : a3, q2 = this.opposite, g2 = this.offset, h3 = n4.x, r2 = n4.y, l3 = this.chart.renderer.fontMetrics(b2);
            b2 = b2 ? Math.max(b2.getBBox(false, 0).height - l3.h - 1, 0) : 0;
            d2 = { low: e2 + (c2 ? 0 : d2), middle: e2 + d2 / 2, high: e2 + (c2 ? d2 : 0) }[n4.align];
            f2 = (c2 ? a3 + this.height : f2) + (c2 ? 1 : -1) * (q2 ? -1 : 1) * (this.axisTitleMargin || 0) + [-b2, b2, l3.f, -b2][this.side];
            c2 = { x: c2 ? d2 + h3 : f2 + (q2 ? this.width : 0) + g2 + h3, y: c2 ? f2 + r2 - (q2 ? this.height : 0) + g2 : d2 + r2 };
            k(this, "afterGetTitlePosition", { titlePosition: c2 });
            return c2;
          }
          renderMinorTick(b2, c2) {
            const f2 = this.minorTicks;
            f2[b2] || (f2[b2] = new H(this, b2, "minor"));
            c2 && f2[b2].isNew && f2[b2].render(null, true);
            f2[b2].render(null, false, 1);
          }
          renderTick(b2, c2, f2) {
            const a3 = this.ticks;
            if (!this.isLinked || b2 >= this.min && b2 <= this.max || this.grid && this.grid.isColumn)
              a3[b2] || (a3[b2] = new H(this, b2)), f2 && a3[b2].isNew && a3[b2].render(c2, true, -1), a3[b2].render(c2);
          }
          render() {
            const c2 = this, f2 = c2.chart, a3 = c2.logarithmic, d2 = c2.options, n4 = c2.isLinked, e2 = c2.tickPositions, q2 = c2.axisTitle, g2 = c2.ticks, h3 = c2.minorTicks, r2 = c2.alternateBands, l3 = d2.stackLabels, m2 = d2.alternateGridColor;
            var p2 = d2.crossing;
            const D2 = c2.tickmarkOffset, t2 = c2.axisLine, w2 = c2.showAxis, K2 = u(f2.renderer.globalAnimation);
            let Q, G2;
            c2.labelEdge.length = 0;
            c2.overlap = false;
            [g2, h3, r2].forEach(function(b2) {
              P(b2, function(b3) {
                b3.isActive = false;
              });
            });
            if (b(p2)) {
              const b2 = this.isXAxis ? f2.yAxis[0] : f2.xAxis[0], a4 = [1, -1, -1, 1][this.side];
              b2 && (p2 = b2.toPixels(p2, true), c2.horiz && (p2 = b2.len - p2), c2.offset = a4 * p2);
            }
            if (c2.hasData() || n4) {
              const n5 = c2.chart.hasRendered && c2.old && b(c2.old.min);
              c2.minorTickInterval && !c2.categories && c2.getMinorTickPositions().forEach(function(b2) {
                c2.renderMinorTick(b2, n5);
              });
              e2.length && (e2.forEach(function(b2, f3) {
                c2.renderTick(b2, f3, n5);
              }), D2 && (c2.min === 0 || c2.single) && (g2[-1] || (g2[-1] = new H(c2, -1, null, true)), g2[-1].render(-1)));
              m2 && e2.forEach(function(b2, d3) {
                G2 = typeof e2[d3 + 1] !== "undefined" ? e2[d3 + 1] + D2 : c2.max - D2;
                d3 % 2 === 0 && b2 < c2.max && G2 <= c2.max + (f2.polar ? -D2 : D2) && (r2[b2] || (r2[b2] = new z.PlotLineOrBand(c2)), Q = b2 + D2, r2[b2].options = { from: a3 ? a3.lin2log(Q) : Q, to: a3 ? a3.lin2log(G2) : G2, color: m2, className: "highcharts-alternate-grid" }, r2[b2].render(), r2[b2].isActive = true);
              });
              c2._addedPlotLB || (c2._addedPlotLB = true, (d2.plotLines || []).concat(d2.plotBands || []).forEach(function(b2) {
                c2.addPlotBandOrLine(b2);
              }));
            }
            [g2, h3, r2].forEach(function(b2) {
              const c3 = [], a4 = K2.duration;
              P(b2, function(b3, f3) {
                b3.isActive || (b3.render(f3, false, 0), b3.isActive = false, c3.push(f3));
              });
              Z(function() {
                let f3 = c3.length;
                for (; f3--; )
                  b2[c3[f3]] && !b2[c3[f3]].isActive && (b2[c3[f3]].destroy(), delete b2[c3[f3]]);
              }, b2 !== r2 && f2.hasRendered && a4 ? a4 : 0);
            });
            t2 && (t2[t2.isPlaced ? "animate" : "attr"]({ d: this.getLinePath(t2.strokeWidth()) }), t2.isPlaced = true, t2[w2 ? "show" : "hide"](w2));
            q2 && w2 && (q2[q2.isNew ? "attr" : "animate"](c2.getTitlePosition(q2)), q2.isNew = false);
            l3 && l3.enabled && c2.stacking && c2.stacking.renderStackTotals();
            c2.old = { len: c2.len, max: c2.max, min: c2.min, transA: c2.transA, userMax: c2.userMax, userMin: c2.userMin };
            c2.isDirty = false;
            k(this, "afterRender");
          }
          redraw() {
            this.visible && (this.render(), this.plotLinesAndBands.forEach(function(b2) {
              b2.render();
            }));
            this.series.forEach(function(b2) {
              b2.isDirty = true;
            });
          }
          getKeepProps() {
            return this.keepProps || Y.keepProps;
          }
          destroy(b2) {
            const c2 = this, f2 = c2.plotLinesAndBands, a3 = this.eventOptions;
            k(this, "destroy", { keepEvents: b2 });
            b2 || X(c2);
            [c2.ticks, c2.minorTicks, c2.alternateBands].forEach(function(b3) {
              w(b3);
            });
            if (f2)
              for (b2 = f2.length; b2--; )
                f2[b2].destroy();
            "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function(b3) {
              c2[b3] && (c2[b3] = c2[b3].destroy());
            });
            for (const b3 in c2.plotLinesAndBandsGroups)
              c2.plotLinesAndBandsGroups[b3] = c2.plotLinesAndBandsGroups[b3].destroy();
            P(c2, function(b3, f3) {
              c2.getKeepProps().indexOf(f3) === -1 && delete c2[f3];
            });
            this.eventOptions = a3;
          }
          drawCrosshair(b2, c2) {
            const f2 = this.crosshair;
            var a3 = D(f2 && f2.snap, true);
            const n4 = this.chart;
            let q2, g2 = this.cross;
            k(this, "drawCrosshair", { e: b2, point: c2 });
            b2 || (b2 = this.cross && this.cross.e);
            if (f2 && (e(c2) || !a3) !== false) {
              a3 ? e(c2) && (q2 = D(this.coll !== "colorAxis" ? c2.crosshairPos : null, this.isXAxis ? c2.plotX : this.len - c2.plotY)) : q2 = b2 && (this.horiz ? b2.chartX - this.pos : this.len - b2.chartY + this.pos);
              if (e(q2)) {
                var h3 = { value: c2 && (this.isXAxis ? c2.x : D(c2.stackY, c2.y)), translatedValue: q2 };
                n4.polar && d(h3, { isCrosshair: true, chartX: b2 && b2.chartX, chartY: b2 && b2.chartY, point: c2 });
                h3 = this.getPlotLinePath(h3) || null;
              }
              if (!e(h3)) {
                this.hideCrosshair();
                return;
              }
              a3 = this.categories && !this.isRadial;
              g2 || (this.cross = g2 = n4.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (a3 ? "category " : "thin ") + (f2.className || "")).attr({ zIndex: D(f2.zIndex, 2) }).add(), n4.styledMode || (g2.attr({ stroke: f2.color || (a3 ? I.parse("#ccd3ff").setOpacity(0.25).get() : "#cccccc"), "stroke-width": D(f2.width, 1) }).css({ "pointer-events": "none" }), f2.dashStyle && g2.attr({ dashstyle: f2.dashStyle })));
              g2.show().attr({ d: h3 });
              a3 && !f2.width && g2.attr({ "stroke-width": this.transA });
              this.cross.e = b2;
            } else
              this.hideCrosshair();
            k(this, "afterDrawCrosshair", { e: b2, point: c2 });
          }
          hideCrosshair() {
            this.cross && this.cross.hide();
            k(this, "afterHideCrosshair");
          }
          hasVerticalPanning() {
            const b2 = this.chart.options.chart.panning;
            return !!(b2 && b2.enabled && /y/.test(b2.type));
          }
          update(b2, f2) {
            const a3 = this.chart;
            b2 = c(this.userOptions, b2);
            this.destroy(true);
            this.init(a3, b2);
            a3.isDirtyBox = true;
            D(f2, true) && a3.redraw();
          }
          remove(b2) {
            const c2 = this.chart, f2 = this.coll, a3 = this.series;
            let d2 = a3.length;
            for (; d2--; )
              a3[d2] && a3[d2].remove(false);
            x(c2.axes, this);
            x(c2[f2] || [], this);
            c2.orderItems(f2);
            this.destroy();
            c2.isDirtyBox = true;
            D(b2, true) && c2.redraw();
          }
          setTitle(b2, c2) {
            this.update({ title: b2 }, c2);
          }
          setCategories(b2, c2) {
            this.update({ categories: b2 }, c2);
          }
        }
        Y.defaultOptions = y.defaultXAxisOptions;
        Y.keepProps = "coll extKey hcEvents names series userMax userMin".split(" ");
        "";
        return Y;
      });
      M(a, "Core/Axis/DateTimeAxis.js", [a["Core/Utilities.js"]], function(a2) {
        const { addEvent: x, getMagnitude: I, normalizeTickInterval: L, timeUnits: C } = a2;
        var z;
        (function(y) {
          function B() {
            return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
          }
          function u(a3) {
            a3.userOptions.type !== "datetime" ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new l2(this));
          }
          const v = [];
          y.compose = function(l3) {
            a2.pushUnique(v, l3) && (l3.keepProps.push("dateTime"), l3.prototype.getTimeTicks = B, x(l3, "init", u));
            return l3;
          };
          class l2 {
            constructor(a3) {
              this.axis = a3;
            }
            normalizeTimeTickInterval(a3, l3) {
              const m = l3 || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
              l3 = m[m.length - 1];
              let h = C[l3[0]], g = l3[1], e;
              for (e = 0; e < m.length && !(l3 = m[e], h = C[l3[0]], g = l3[1], m[e + 1] && a3 <= (h * g[g.length - 1] + C[m[e + 1][0]]) / 2); e++)
                ;
              h === C.year && a3 < 5 * h && (g = [1, 2, 5]);
              a3 = L(a3 / h, g, l3[0] === "year" ? Math.max(I(a3 / h), 1) : 1);
              return { unitRange: h, count: a3, unitName: l3[0] };
            }
            getXDateFormat(a3, l3) {
              const { axis: m } = this, h = m.chart.time;
              return m.closestPointRange ? h.getDateFormat(m.closestPointRange, a3, m.options.startOfWeek, l3) || h.resolveDTLFormat(l3.year).main : h.resolveDTLFormat(l3.day).main;
            }
          }
          y.Additions = l2;
        })(z || (z = {}));
        return z;
      });
      M(a, "Core/Axis/LogarithmicAxis.js", [a["Core/Utilities.js"]], function(a2) {
        const { addEvent: x, normalizeTickInterval: I, pick: L } = a2;
        var C;
        (function(y) {
          function H(a3) {
            let l2 = this.logarithmic;
            a3.userOptions.type !== "logarithmic" ? this.logarithmic = void 0 : l2 || (this.logarithmic = new v(this));
          }
          function B() {
            const a3 = this.logarithmic;
            a3 && (this.lin2val = function(l2) {
              return a3.lin2log(l2);
            }, this.val2lin = function(l2) {
              return a3.log2lin(l2);
            });
          }
          const u = [];
          y.compose = function(l2) {
            a2.pushUnique(u, l2) && (l2.keepProps.push("logarithmic"), x(l2, "init", H), x(l2, "afterInit", B));
            return l2;
          };
          class v {
            constructor(a3) {
              this.axis = a3;
            }
            getLogTickPositions(a3, p, t, m) {
              const h = this.axis;
              var g = h.len, e = h.options;
              let l2 = [];
              m || (this.minorAutoInterval = void 0);
              if (0.5 <= a3)
                a3 = Math.round(a3), l2 = h.getLinearTickPositions(a3, p, t);
              else if (0.08 <= a3) {
                e = Math.floor(p);
                let h3, w, d, k, r;
                for (g = 0.3 < a3 ? [1, 2, 4] : 0.15 < a3 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; e < t + 1 && !r; e++)
                  for (w = g.length, h3 = 0; h3 < w && !r; h3++)
                    d = this.log2lin(this.lin2log(e) * g[h3]), d > p && (!m || k <= t) && typeof k !== "undefined" && l2.push(k), k > t && (r = true), k = d;
              } else
                p = this.lin2log(p), t = this.lin2log(t), a3 = m ? h.getMinorTickInterval() : e.tickInterval, a3 = L(a3 === "auto" ? null : a3, this.minorAutoInterval, e.tickPixelInterval / (m ? 5 : 1) * (t - p) / ((m ? g / h.tickPositions.length : g) || 1)), a3 = I(a3), l2 = h.getLinearTickPositions(a3, p, t).map(this.log2lin), m || (this.minorAutoInterval = a3 / 5);
              m || (h.tickInterval = a3);
              return l2;
            }
            lin2log(a3) {
              return Math.pow(10, a3);
            }
            log2lin(a3) {
              return Math.log(a3) / Math.LN10;
            }
          }
          y.Additions = v;
        })(C || (C = {}));
        return C;
      });
      M(a, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [a["Core/Utilities.js"]], function(a2) {
        const { erase: x, extend: I, isNumber: L } = a2;
        var C;
        (function(y) {
          function H(a3) {
            return this.addPlotBandOrLine(a3, "plotBands");
          }
          function B(a3, e) {
            const g = this.userOptions;
            let l3 = new h(this, a3);
            this.visible && (l3 = l3.render());
            if (l3) {
              this._addedPlotLB || (this._addedPlotLB = true, (g.plotLines || []).concat(g.plotBands || []).forEach((a4) => {
                this.addPlotBandOrLine(a4);
              }));
              if (e) {
                const h3 = g[e] || [];
                h3.push(a3);
                g[e] = h3;
              }
              this.plotLinesAndBands.push(l3);
            }
            return l3;
          }
          function u(a3) {
            return this.addPlotBandOrLine(a3, "plotLines");
          }
          function v(a3, e, h3 = this.options) {
            const g = this.getPlotLinePath({ value: e, force: true, acrossPanes: h3.acrossPanes }), l3 = [], d = this.horiz;
            e = !L(this.min) || !L(this.max) || a3 < this.min && e < this.min || a3 > this.max && e > this.max;
            a3 = this.getPlotLinePath({ value: a3, force: true, acrossPanes: h3.acrossPanes });
            h3 = 1;
            let k;
            if (a3 && g)
              for (e && (k = a3.toString() === g.toString(), h3 = 0), e = 0; e < a3.length; e += 2) {
                const r = a3[e], q = a3[e + 1], m2 = g[e], b = g[e + 1];
                r[0] !== "M" && r[0] !== "L" || q[0] !== "M" && q[0] !== "L" || m2[0] !== "M" && m2[0] !== "L" || b[0] !== "M" && b[0] !== "L" || (d && m2[1] === r[1] ? (m2[1] += h3, b[1] += h3) : d || m2[2] !== r[2] || (m2[2] += h3, b[2] += h3), l3.push(["M", r[1], r[2]], ["L", q[1], q[2]], ["L", b[1], b[2]], ["L", m2[1], m2[2]], ["Z"]));
                l3.isFlat = k;
              }
            return l3;
          }
          function l2(a3) {
            this.removePlotBandOrLine(a3);
          }
          function p(a3) {
            const e = this.plotLinesAndBands, g = this.options, h3 = this.userOptions;
            if (e) {
              let l3 = e.length;
              for (; l3--; )
                e[l3].id === a3 && e[l3].destroy();
              [
                g.plotLines || [],
                h3.plotLines || [],
                g.plotBands || [],
                h3.plotBands || []
              ].forEach(function(d) {
                for (l3 = d.length; l3--; )
                  (d[l3] || {}).id === a3 && x(d, d[l3]);
              });
            }
          }
          function t(a3) {
            this.removePlotBandOrLine(a3);
          }
          const m = [];
          let h;
          y.compose = function(g, e) {
            h || (h = g);
            a2.pushUnique(m, e) && I(e.prototype, { addPlotBand: H, addPlotLine: u, addPlotBandOrLine: B, getPlotBandPath: v, removePlotBand: l2, removePlotLine: t, removePlotBandOrLine: p });
            return e;
          };
        })(C || (C = {}));
        return C;
      });
      M(a, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [a["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], a["Core/Utilities.js"]], function(a2, y) {
        const { arrayMax: x, arrayMin: L, defined: C, destroyObjectProperties: z, erase: H, fireEvent: B, merge: u, objectEach: v, pick: l2 } = y;
        class p {
          static compose(l3) {
            return a2.compose(p, l3);
          }
          constructor(a3, l3) {
            this.axis = a3;
            l3 && (this.options = l3, this.id = l3.id);
          }
          render() {
            B(this, "render");
            const a3 = this, m = a3.axis, h = m.horiz;
            var g = m.logarithmic;
            const e = a3.options, p2 = e.color, x2 = l2(e.zIndex, 0), F = e.events, d = {}, k = m.chart.renderer;
            let r = e.label, q = a3.label, G = e.to, b = e.from, f = e.value, c = a3.svgElem;
            var n3 = [];
            const P = C(b) && C(G);
            n3 = C(f);
            const D = !c, K = { "class": "highcharts-plot-" + (P ? "band " : "line ") + (e.className || "") };
            let X = P ? "bands" : "lines";
            g && (b = g.log2lin(b), G = g.log2lin(G), f = g.log2lin(f));
            m.chart.styledMode || (n3 ? (K.stroke = p2 || "#999999", K["stroke-width"] = l2(e.width, 1), e.dashStyle && (K.dashstyle = e.dashStyle)) : P && (K.fill = p2 || "#e6e9ff", e.borderWidth && (K.stroke = e.borderColor, K["stroke-width"] = e.borderWidth)));
            d.zIndex = x2;
            X += "-" + x2;
            (g = m.plotLinesAndBandsGroups[X]) || (m.plotLinesAndBandsGroups[X] = g = k.g("plot-" + X).attr(d).add());
            D && (a3.svgElem = c = k.path().attr(K).add(g));
            if (n3)
              n3 = m.getPlotLinePath({ value: f, lineWidth: c.strokeWidth(), acrossPanes: e.acrossPanes });
            else if (P)
              n3 = m.getPlotBandPath(b, G, e);
            else
              return;
            !a3.eventsAdded && F && (v(F, function(b2, f2) {
              c.on(f2, function(b3) {
                F[f2].apply(a3, [b3]);
              });
            }), a3.eventsAdded = true);
            (D || !c.d) && n3 && n3.length ? c.attr({ d: n3 }) : c && (n3 ? (c.show(), c.animate({ d: n3 })) : c.d && (c.hide(), q && (a3.label = q = q.destroy())));
            r && (C(r.text) || C(r.formatter)) && n3 && n3.length && 0 < m.width && 0 < m.height && !n3.isFlat ? (r = u({ align: h && P && "center", x: h ? !P && 4 : 10, verticalAlign: !h && P && "middle", y: h ? P ? 16 : 10 : P ? 6 : -4, rotation: h && !P && 90 }, r), this.renderLabel(r, n3, P, x2)) : q && q.hide();
            return a3;
          }
          renderLabel(a3, l3, h, g) {
            const e = this.axis;
            var m = e.chart.renderer;
            let p2 = this.label;
            p2 || (this.label = p2 = m.text(this.getLabelText(a3), 0, 0, a3.useHTML).attr({ align: a3.textAlign || a3.align, rotation: a3.rotation, "class": "highcharts-plot-" + (h ? "band" : "line") + "-label " + (a3.className || ""), zIndex: g }).add(), e.chart.styledMode || p2.css(u({ fontSize: "0.8em", textOverflow: "ellipsis" }, a3.style)));
            g = l3.xBounds || [l3[0][1], l3[1][1], h ? l3[2][1] : l3[0][1]];
            l3 = l3.yBounds || [l3[0][2], l3[1][2], h ? l3[2][2] : l3[0][2]];
            h = L(g);
            m = L(l3);
            p2.align(a3, false, { x: h, y: m, width: x(g) - h, height: x(l3) - m });
            p2.alignValue && p2.alignValue !== "left" || (a3 = a3.clip ? e.width : e.chart.chartWidth, p2.css({ width: (p2.rotation === 90 ? e.height - (p2.alignAttr.y - e.top) : a3 - (p2.alignAttr.x - e.left)) + "px" }));
            p2.show(true);
          }
          getLabelText(a3) {
            return C(a3.formatter) ? a3.formatter.call(this) : a3.text;
          }
          destroy() {
            H(this.axis.plotLinesAndBands, this);
            delete this.axis;
            z(this);
          }
        }
        "";
        "";
        return p;
      });
      M(a, "Core/Tooltip.js", [
        a["Core/Templating.js"],
        a["Core/Globals.js"],
        a["Core/Renderer/RendererUtilities.js"],
        a["Core/Renderer/RendererRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, I, L, C) {
        const { format: x } = a2, { doc: H, isSafari: B } = y, { distribute: u } = I, { addEvent: v, clamp: l2, css: p, discardElement: t, extend: m, fireEvent: h, isArray: g, isNumber: e, isString: w, merge: E, pick: F, splat: d, syncTimeout: k } = C;
        class r {
          constructor(a3, d2) {
            this.allowShared = true;
            this.container = void 0;
            this.crosshairs = [];
            this.distance = 0;
            this.isHidden = true;
            this.isSticky = false;
            this.now = {};
            this.options = {};
            this.outside = false;
            this.chart = a3;
            this.init(a3, d2);
          }
          bodyFormatter(a3) {
            return a3.map(function(a4) {
              const b = a4.series.tooltipOptions;
              return (b[(a4.point.formatPrefix || "point") + "Formatter"] || a4.point.tooltipFormatter).call(a4.point, b[(a4.point.formatPrefix || "point") + "Format"] || "");
            });
          }
          cleanSplit(a3) {
            this.chart.series.forEach(function(d2) {
              const b = d2 && d2.tt;
              b && (!b.isActive || a3 ? d2.tt = b.destroy() : b.isActive = false);
            });
          }
          defaultFormatter(a3) {
            const k2 = this.points || d(this);
            let b;
            b = [a3.tooltipFooterHeaderFormatter(k2[0])];
            b = b.concat(a3.bodyFormatter(k2));
            b.push(a3.tooltipFooterHeaderFormatter(k2[0], true));
            return b;
          }
          destroy() {
            this.label && (this.label = this.label.destroy());
            this.split && (this.cleanSplit(true), this.tt && (this.tt = this.tt.destroy()));
            this.renderer && (this.renderer = this.renderer.destroy(), t(this.container));
            C.clearTimeout(this.hideTimer);
            C.clearTimeout(this.tooltipTimeout);
          }
          getAnchor(a3, k2) {
            var b = this.chart;
            const f = b.pointer, c = b.inverted, n3 = b.plotTop;
            b = b.plotLeft;
            a3 = d(a3);
            a3[0].series && a3[0].series.yAxis && !a3[0].series.yAxis.options.reversedStacks && (a3 = a3.slice().reverse());
            if (this.followPointer && k2)
              typeof k2.chartX === "undefined" && (k2 = f.normalize(k2)), a3 = [k2.chartX - b, k2.chartY - n3];
            else if (a3[0].tooltipPos)
              a3 = a3[0].tooltipPos;
            else {
              let f2 = 0, d2 = 0;
              a3.forEach(function(b2) {
                if (b2 = b2.pos(true))
                  f2 += b2[0], d2 += b2[1];
              });
              f2 /= a3.length;
              d2 /= a3.length;
              this.shared && 1 < a3.length && k2 && (c ? f2 = k2.chartX : d2 = k2.chartY);
              a3 = [f2 - b, d2 - n3];
            }
            return a3.map(Math.round);
          }
          getClassName(a3, d2, b) {
            const f = a3.series, c = f.options;
            return [this.options.className, "highcharts-label", b && "highcharts-tooltip-header", d2 ? "highcharts-tooltip-box" : "highcharts-tooltip", !b && "highcharts-color-" + F(a3.colorIndex, f.colorIndex), c && c.className].filter(w).join(" ");
          }
          getLabel() {
            const a3 = this, d2 = this.chart.styledMode, b = this.options, f = this.split && this.allowShared, c = b.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none");
            let n3, k2 = this.chart.renderer;
            if (this.label) {
              var e2 = !this.label.hasClass("highcharts-label");
              (!f && e2 || f && !e2) && this.destroy();
            }
            if (!this.label) {
              if (this.outside) {
                e2 = this.chart.options.chart.style;
                const b2 = L.getRendererType();
                this.container = n3 = y.doc.createElement("div");
                n3.className = "highcharts-tooltip-container";
                p(n3, { position: "absolute", top: "1px", pointerEvents: c, zIndex: Math.max(this.options.style.zIndex || 0, (e2 && e2.zIndex || 0) + 3) });
                y.doc.body.appendChild(n3);
                this.renderer = k2 = new b2(n3, 0, 0, e2, void 0, void 0, k2.styledMode);
              }
              f ? this.label = k2.g("tooltip") : (this.label = k2.label("", 0, 0, b.shape, void 0, void 0, b.useHTML, void 0, "tooltip").attr({ padding: b.padding, r: b.borderRadius }), d2 || this.label.attr({ fill: b.backgroundColor, "stroke-width": b.borderWidth || 0 }).css(b.style).css({ pointerEvents: c }));
              if (a3.outside) {
                const b2 = this.label, {
                  xSetter: c2,
                  ySetter: f2
                } = b2;
                b2.xSetter = function(f3) {
                  c2.call(b2, a3.distance);
                  n3.style.left = f3 + "px";
                };
                b2.ySetter = function(c3) {
                  f2.call(b2, a3.distance);
                  n3.style.top = c3 + "px";
                };
              }
              this.label.attr({ zIndex: 8 }).shadow(b.shadow).add();
            }
            return this.label;
          }
          getPlayingField() {
            const { body: a3, documentElement: d2 } = H, { chart: b, distance: f, outside: c } = this;
            return { width: c ? Math.max(a3.scrollWidth, d2.scrollWidth, a3.offsetWidth, d2.offsetWidth, d2.clientWidth) - 2 * f : b.chartWidth, height: c ? Math.max(a3.scrollHeight, d2.scrollHeight, a3.offsetHeight, d2.offsetHeight, d2.clientHeight) : b.chartHeight };
          }
          getPosition(a3, d2, b) {
            const f = this.chart, c = this.distance, n3 = {}, k2 = f.inverted && b.h || 0, e2 = this.outside;
            var q = this.getPlayingField();
            const g2 = q.width, h3 = q.height, r2 = f.pointer.getChartPosition();
            q = (n4) => {
              const k3 = n4 === "x";
              return [n4, k3 ? g2 : h3, k3 ? a3 : d2].concat(e2 ? [k3 ? a3 * r2.scaleX : d2 * r2.scaleY, k3 ? r2.left - c + (b.plotX + f.plotLeft) * r2.scaleX : r2.top - c + (b.plotY + f.plotTop) * r2.scaleY, 0, k3 ? g2 : h3] : [k3 ? a3 : d2, k3 ? b.plotX + f.plotLeft : b.plotY + f.plotTop, k3 ? f.plotLeft : f.plotTop, k3 ? f.plotLeft + f.plotWidth : f.plotTop + f.plotHeight]);
            };
            let l3 = q("y"), m2 = q("x"), p2;
            q = !!b.negative;
            !f.polar && f.hoverSeries && f.hoverSeries.yAxis && f.hoverSeries.yAxis.reversed && (q = !q);
            const t2 = !this.followPointer && F(b.ttBelow, !f.inverted === q), w2 = function(b2, a4, f2, d3, q2, g3, h4) {
              const l4 = e2 ? b2 === "y" ? c * r2.scaleY : c * r2.scaleX : c, m3 = (f2 - d3) / 2, p3 = d3 < q2 - c, J2 = q2 + c + d3 < a4, D = q2 - l4 - f2 + m3;
              q2 = q2 + l4 - m3;
              if (t2 && J2)
                n3[b2] = q2;
              else if (!t2 && p3)
                n3[b2] = D;
              else if (p3)
                n3[b2] = Math.min(h4 - d3, 0 > D - k2 ? D : D - k2);
              else if (J2)
                n3[b2] = Math.max(g3, q2 + k2 + f2 > a4 ? q2 : q2 + k2);
              else
                return false;
            }, G = function(b2, a4, f2, d3, k3) {
              let e3;
              k3 < c || k3 > a4 - c ? e3 = false : n3[b2] = k3 < f2 / 2 ? 1 : k3 > a4 - d3 / 2 ? a4 - d3 - 2 : k3 - f2 / 2;
              return e3;
            }, v2 = function(b2) {
              const c2 = l3;
              l3 = m2;
              m2 = c2;
              p2 = b2;
            }, J = function() {
              w2.apply(0, l3) !== false ? G.apply(0, m2) !== false || p2 || (v2(true), J()) : p2 ? n3.x = n3.y = 0 : (v2(true), J());
            };
            (f.inverted || 1 < this.len) && v2();
            J();
            return n3;
          }
          hide(a3) {
            const d2 = this;
            C.clearTimeout(this.hideTimer);
            a3 = F(a3, this.options.hideDelay);
            this.isHidden || (this.hideTimer = k(function() {
              d2.getLabel().fadeOut(a3 ? void 0 : a3);
              d2.isHidden = true;
            }, a3));
          }
          init(a3, d2) {
            this.chart = a3;
            this.options = d2;
            this.crosshairs = [];
            this.now = { x: 0, y: 0 };
            this.isHidden = true;
            this.split = d2.split && !a3.inverted && !a3.polar;
            this.shared = d2.shared || this.split;
            this.outside = F(d2.outside, !(!a3.scrollablePixelsX && !a3.scrollablePixelsY));
          }
          shouldStickOnContact(a3) {
            return !(this.followPointer || !this.options.stickOnContact || a3 && !this.chart.pointer.inClass(a3.target, "highcharts-tooltip"));
          }
          move(a3, d2, b, f) {
            const c = this, n3 = c.now, k2 = c.options.animation !== false && !c.isHidden && (1 < Math.abs(a3 - n3.x) || 1 < Math.abs(d2 - n3.y)), e2 = c.followPointer || 1 < c.len;
            m(n3, { x: k2 ? (2 * n3.x + a3) / 3 : a3, y: k2 ? (n3.y + d2) / 2 : d2, anchorX: e2 ? void 0 : k2 ? (2 * n3.anchorX + b) / 3 : b, anchorY: e2 ? void 0 : k2 ? (n3.anchorY + f) / 2 : f });
            c.getLabel().attr(n3);
            c.drawTracker();
            k2 && (C.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
              c && c.move(a3, d2, b, f);
            }, 32));
          }
          refresh(a3, k2) {
            const b = this.chart, f = this.options, c = b.pointer, n3 = d(a3), e2 = n3[0], q = [];
            var r2 = f.format, l3 = f.formatter || this.defaultFormatter;
            const m2 = this.shared, p2 = b.styledMode;
            let t2 = {};
            if (f.enabled && e2.series) {
              C.clearTimeout(this.hideTimer);
              this.allowShared = !(!g(a3) && a3.series && a3.series.noSharedTooltip);
              this.followPointer = !this.split && e2.series.tooltipOptions.followPointer;
              a3 = this.getAnchor(a3, k2);
              var v2 = a3[0], G = a3[1];
              m2 && this.allowShared ? (c.applyInactiveState(n3), n3.forEach(function(b2) {
                b2.setState("hover");
                q.push(b2.getLabelConfig());
              }), t2 = e2.getLabelConfig(), t2.points = q) : t2 = e2.getLabelConfig();
              this.len = q.length;
              r2 = w(r2) ? x(r2, t2, b) : l3.call(t2, this);
              l3 = e2.series;
              this.distance = F(l3.tooltipOptions.distance, 16);
              if (r2 === false)
                this.hide();
              else {
                if (this.split && this.allowShared)
                  this.renderSplit(r2, n3);
                else {
                  let d2 = v2, g2 = G;
                  k2 && c.isDirectTouch && (d2 = k2.chartX - b.plotLeft, g2 = k2.chartY - b.plotTop);
                  if (b.polar || l3.options.clip === false || n3.some((b2) => c.isDirectTouch || b2.series.shouldShowTooltip(d2, g2)))
                    k2 = this.getLabel(), f.style.width && !p2 || k2.css({ width: (this.outside ? this.getPlayingField() : b.spacingBox).width + "px" }), k2.attr({ text: r2 && r2.join ? r2.join("") : r2 }), k2.addClass(this.getClassName(e2), true), p2 || k2.attr({ stroke: f.borderColor || e2.color || l3.color || "#666666" }), this.updatePosition({ plotX: v2, plotY: G, negative: e2.negative, ttBelow: e2.ttBelow, h: a3[2] || 0 });
                  else {
                    this.hide();
                    return;
                  }
                }
                this.isHidden && this.label && this.label.attr({ opacity: 1 }).show();
                this.isHidden = false;
              }
              h(this, "refresh");
            }
          }
          renderSplit(a3, d2) {
            function b(b2, c2, a4, d3, n4 = true) {
              a4 ? (c2 = S ? 0 : z, b2 = l2(b2 - d3 / 2, J.left, J.right - d3 - (f.outside ? W : 0))) : (c2 -= da, b2 = n4 ? b2 - d3 - x2 : b2 + x2, b2 = l2(b2, n4 ? b2 : J.left, J.right));
              return { x: b2, y: c2 };
            }
            const f = this, { chart: c, chart: { chartWidth: n3, chartHeight: k2, plotHeight: e2, plotLeft: g2, plotTop: h3, pointer: q, scrollablePixelsY: r2 = 0, scrollablePixelsX: p2, scrollingContainer: { scrollLeft: t2, scrollTop: v2 } = { scrollLeft: 0, scrollTop: 0 }, styledMode: G }, distance: x2, options: E2, options: { positioner: y2 } } = f, J = f.outside && typeof p2 !== "number" ? H.documentElement.getBoundingClientRect() : {
              left: t2,
              right: t2 + n3,
              top: v2,
              bottom: v2 + k2
            }, N = f.getLabel(), O = this.renderer || c.renderer, S = !(!c.xAxis[0] || !c.xAxis[0].opposite), { left: W, top: ha } = q.getChartPosition();
            let da = h3 + v2, C2 = 0, z = e2 - r2;
            w(a3) && (a3 = [false, a3]);
            a3 = a3.slice(0, d2.length + 1).reduce(function(c2, a4, n4) {
              if (a4 !== false && a4 !== "") {
                n4 = d2[n4 - 1] || { isHeader: true, plotX: d2[0].plotX, plotY: e2, series: {} };
                const D = n4.isHeader;
                var k3 = D ? f : n4.series, q2;
                {
                  var r3 = n4;
                  a4 = a4.toString();
                  var m2 = k3.tt;
                  const { isHeader: b2, series: c3 } = r3;
                  m2 || (m2 = { padding: E2.padding, r: E2.borderRadius }, G || (m2.fill = E2.backgroundColor, m2["stroke-width"] = (q2 = E2.borderWidth) !== null && q2 !== void 0 ? q2 : 1), m2 = O.label("", 0, 0, E2[b2 ? "headerShape" : "shape"], void 0, void 0, E2.useHTML).addClass(f.getClassName(r3, true, b2)).attr(m2).add(N));
                  m2.isActive = true;
                  m2.attr({ text: a4 });
                  G || m2.css(E2.style).attr({ stroke: E2.borderColor || r3.color || c3.color || "#333333" });
                  q2 = m2;
                }
                q2 = k3.tt = q2;
                r3 = q2.getBBox();
                k3 = r3.width + q2.strokeWidth();
                D && (C2 = r3.height, z += C2, S && (da -= C2));
                {
                  const { isHeader: b2, plotX: c3 = 0, plotY: f2 = 0, series: d3 } = n4;
                  if (b2) {
                    a4 = g2 + c3;
                    var p3 = h3 + e2 / 2;
                  } else {
                    const { xAxis: b3, yAxis: n5 } = d3;
                    a4 = b3.pos + l2(c3, -x2, b3.len + x2);
                    d3.shouldShowTooltip(0, n5.pos - h3 + f2, { ignoreX: true }) && (p3 = n5.pos + f2);
                  }
                  a4 = l2(a4, J.left - x2, J.right + x2);
                  p3 = { anchorX: a4, anchorY: p3 };
                }
                const { anchorX: t3, anchorY: Q2 } = p3;
                typeof Q2 === "number" ? (p3 = r3.height + 1, r3 = y2 ? y2.call(f, k3, p3, n4) : b(t3, Q2, D, k3), c2.push({ align: y2 ? 0 : void 0, anchorX: t3, anchorY: Q2, boxWidth: k3, point: n4, rank: F(r3.rank, D ? 1 : 0), size: p3, target: r3.y, tt: q2, x: r3.x })) : q2.isActive = false;
              }
              return c2;
            }, []);
            !y2 && a3.some((b2) => {
              var { outside: c2 } = f;
              c2 = (c2 ? W : 0) + b2.anchorX;
              return c2 < J.left && c2 + b2.boxWidth < J.right ? true : c2 < W - J.left + b2.boxWidth && J.right - c2 > c2;
            }) && (a3 = a3.map((c2) => {
              const { x: a4, y: f2 } = b(c2.anchorX, c2.anchorY, c2.point.isHeader, c2.boxWidth, false);
              return m(c2, { target: f2, x: a4 });
            }));
            f.cleanSplit();
            u(a3, z);
            var ca = W, L2 = W;
            a3.forEach(function(b2) {
              const { x: c2, boxWidth: a4, isHeader: d3 } = b2;
              d3 || (f.outside && W + c2 < ca && (ca = W + c2), !d3 && f.outside && ca + a4 > L2 && (L2 = W + c2));
            });
            a3.forEach(function(b2) {
              const { x: c2, anchorX: a4, anchorY: d3, pos: n4, point: { isHeader: k3 } } = b2, e3 = { visibility: typeof n4 === "undefined" ? "hidden" : "inherit", x: c2, y: (n4 || 0) + da, anchorX: a4, anchorY: d3 };
              if (f.outside && c2 < a4) {
                const b3 = W - ca;
                0 < b3 && (k3 || (e3.x = c2 + b3, e3.anchorX = a4 + b3), k3 && (e3.x = (L2 - ca) / 2, e3.anchorX = a4 + b3));
              }
              b2.tt.attr(e3);
            });
            const {
              container: R,
              outside: Q,
              renderer: la
            } = f;
            if (Q && R && la) {
              const { width: b2, height: c2, x: a4, y: f2 } = N.getBBox();
              la.setSize(b2 + a4, c2 + f2, false);
              R.style.left = ca + "px";
              R.style.top = ha + "px";
            }
            B && N.attr({ opacity: N.opacity === 1 ? 0.999 : 1 });
          }
          drawTracker() {
            if (this.shouldStickOnContact()) {
              var a3 = this.chart, d2 = this.label, b = this.shared ? a3.hoverPoints : a3.hoverPoint;
              if (d2 && b) {
                var f = { x: 0, y: 0, width: 0, height: 0 };
                b = this.getAnchor(b);
                var c = d2.getBBox();
                b[0] += a3.plotLeft - d2.translateX;
                b[1] += a3.plotTop - d2.translateY;
                f.x = Math.min(0, b[0]);
                f.y = Math.min(0, b[1]);
                f.width = 0 > b[0] ? Math.max(Math.abs(b[0]), c.width - b[0]) : Math.max(Math.abs(b[0]), c.width);
                f.height = 0 > b[1] ? Math.max(Math.abs(b[1]), c.height - Math.abs(b[1])) : Math.max(Math.abs(b[1]), c.height);
                this.tracker ? this.tracker.attr(f) : (this.tracker = d2.renderer.rect(f).addClass("highcharts-tracker").add(d2), a3.styledMode || this.tracker.attr({ fill: "rgba(0,0,0,0)" }));
              }
            } else
              this.tracker && (this.tracker = this.tracker.destroy());
          }
          styledModeFormat(a3) {
            return a3.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
          }
          tooltipFooterHeaderFormatter(a3, d2) {
            const b = a3.series, f = b.tooltipOptions;
            var c = b.xAxis;
            const n3 = c && c.dateTime;
            c = { isFooter: d2, labelConfig: a3 };
            let k2 = f.xDateFormat, g2 = f[d2 ? "footerFormat" : "headerFormat"];
            h(this, "headerFormatter", c, function(c2) {
              n3 && !k2 && e(a3.key) && (k2 = n3.getXDateFormat(a3.key, f.dateTimeLabelFormats));
              n3 && k2 && (a3.point && a3.point.tooltipDateKeys || ["key"]).forEach(function(b2) {
                g2 = g2.replace("{point." + b2 + "}", "{point." + b2 + ":" + k2 + "}");
              });
              b.chart.styledMode && (g2 = this.styledModeFormat(g2));
              c2.text = x(g2, { point: a3, series: b }, this.chart);
            });
            return c.text;
          }
          update(a3) {
            this.destroy();
            this.init(this.chart, E(true, this.options, a3));
          }
          updatePosition(a3) {
            const { chart: d2, distance: b, options: f } = this;
            var c = d2.pointer;
            const n3 = this.getLabel(), { left: k2, top: e2, scaleX: g2, scaleY: h3 } = c.getChartPosition();
            c = (f.positioner || this.getPosition).call(this, n3.width, n3.height, a3);
            let q = (a3.plotX || 0) + d2.plotLeft;
            a3 = (a3.plotY || 0) + d2.plotTop;
            let r2;
            if (this.outside) {
              f.positioner && (c.x += k2 - b, c.y += e2 - b);
              r2 = (f.borderWidth || 0) + 2 * b;
              this.renderer.setSize(n3.width + r2, n3.height + r2, false);
              if (g2 !== 1 || h3 !== 1)
                p(this.container, { transform: `scale(${g2}, ${h3})` }), q *= g2, a3 *= h3;
              q += k2 - c.x;
              a3 += e2 - c.y;
            }
            this.move(Math.round(c.x), Math.round(c.y || 0), q, a3);
          }
        }
        (function(a3) {
          const d2 = [];
          a3.compose = function(b) {
            C.pushUnique(d2, b) && v(b, "afterInit", function() {
              const b2 = this.chart;
              b2.options.tooltip && (b2.tooltip = new a3(b2, b2.options.tooltip));
            });
          };
        })(r || (r = {}));
        "";
        return r;
      });
      M(a, "Core/Series/Point.js", [
        a["Core/Renderer/HTML/AST.js"],
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Defaults.js"],
        a["Core/Templating.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, I, L, C) {
        const { animObject: x } = y, { defaultOptions: H } = I, { format: B } = L, { addEvent: u, defined: v, erase: l2, extend: p, fireEvent: t, getNestedProperty: m, isArray: h, isFunction: g, isNumber: e, isObject: w, merge: E, objectEach: F, pick: d, syncTimeout: k, removeEvent: r, uniqueKey: q } = C;
        class G {
          constructor() {
            this.category = void 0;
            this.destroyed = false;
            this.formatPrefix = "point";
            this.id = void 0;
            this.isNull = false;
            this.percentage = this.options = this.name = void 0;
            this.selected = false;
            this.total = this.shapeArgs = this.series = void 0;
            this.visible = true;
            this.x = void 0;
          }
          animateBeforeDestroy() {
            const b = this, a3 = { x: b.startXPos, opacity: 0 }, c = b.getGraphicalProps();
            c.singular.forEach(function(c2) {
              b[c2] = b[c2].animate(c2 === "dataLabel" ? { x: b[c2].startXPos, y: b[c2].startYPos, opacity: 0 } : a3);
            });
            c.plural.forEach(function(c2) {
              b[c2].forEach(function(c3) {
                c3.element && c3.animate(p({ x: b.startXPos }, c3.startYPos ? { x: c3.startXPos, y: c3.startYPos } : {}));
              });
            });
          }
          applyOptions(b, a3) {
            const c = this.series, f = c.options.pointValKey || c.pointValKey;
            b = G.prototype.optionsToObject.call(this, b);
            p(this, b);
            this.options = this.options ? p(this.options, b) : b;
            b.group && delete this.group;
            b.dataLabels && delete this.dataLabels;
            f && (this.y = G.prototype.getNestedProperty.call(this, f));
            this.formatPrefix = (this.isNull = this.isValid && !this.isValid()) ? "null" : "point";
            this.selected && (this.state = "select");
            "name" in this && typeof a3 === "undefined" && c.xAxis && c.xAxis.hasNames && (this.x = c.xAxis.nameToX(this));
            typeof this.x === "undefined" && c ? this.x = typeof a3 === "undefined" ? c.autoIncrement() : a3 : e(b.x) && c.options.relativeXValue && (this.x = c.autoIncrement(b.x));
            return this;
          }
          destroy() {
            if (!this.destroyed) {
              const a3 = this;
              var b = a3.series;
              const c = b.chart;
              b = b.options.dataSorting;
              const d2 = c.hoverPoints, e2 = x(a3.series.chart.renderer.globalAnimation), g2 = () => {
                if (a3.graphic || a3.graphics || a3.dataLabel || a3.dataLabels)
                  r(a3), a3.destroyElements();
                for (const b2 in a3)
                  delete a3[b2];
              };
              a3.legendItem && c.legend.destroyItem(a3);
              d2 && (a3.setState(), l2(d2, a3), d2.length || (c.hoverPoints = null));
              if (a3 === c.hoverPoint)
                a3.onMouseOut();
              b && b.enabled ? (this.animateBeforeDestroy(), k(g2, e2.duration)) : g2();
              c.pointCount--;
            }
            this.destroyed = true;
          }
          destroyElements(b) {
            const a3 = this;
            b = a3.getGraphicalProps(b);
            b.singular.forEach(function(b2) {
              a3[b2] = a3[b2].destroy();
            });
            b.plural.forEach(function(b2) {
              a3[b2].forEach(function(b3) {
                b3 && b3.element && b3.destroy();
              });
              delete a3[b2];
            });
          }
          firePointEvent(b, a3, c) {
            const f = this, d2 = this.series.options;
            (d2.point.events[b] || f.options && f.options.events && f.options.events[b]) && f.importEvents();
            b === "click" && d2.allowPointSelect && (c = function(b2) {
              f.select && f.select(null, b2.ctrlKey || b2.metaKey || b2.shiftKey);
            });
            t(f, b, a3, c);
          }
          getClassName() {
            return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (typeof this.colorIndex !== "undefined" ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
          }
          getGraphicalProps(b) {
            const a3 = this, c = [], d2 = { singular: [], plural: [] };
            let k2, e2;
            b = b || { graphic: 1, dataLabel: 1 };
            b.graphic && c.push("graphic");
            b.dataLabel && c.push("dataLabel", "dataLabelPath", "dataLabelUpper", "connector");
            for (e2 = c.length; e2--; )
              k2 = c[e2], a3[k2] && d2.singular.push(k2);
            ["graphic", "dataLabel", "connector"].forEach(function(c2) {
              const f = c2 + "s";
              b[c2] && a3[f] && d2.plural.push(f);
            });
            return d2;
          }
          getLabelConfig() {
            return { x: this.category, y: this.y, color: this.color, colorIndex: this.colorIndex, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal };
          }
          getNestedProperty(b) {
            if (b)
              return b.indexOf("custom.") === 0 ? m(b, this.options) : this[b];
          }
          getZone() {
            var b = this.series;
            const a3 = b.zones;
            b = b.zoneAxis || "y";
            let c, d2 = 0;
            for (c = a3[d2]; this[b] >= c.value; )
              c = a3[++d2];
            this.nonZonedColor || (this.nonZonedColor = this.color);
            this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;
            return c;
          }
          hasNewShapeType() {
            return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
          }
          init(b, a3, c) {
            this.series = b;
            this.applyOptions(a3, c);
            this.id = v(this.id) ? this.id : q();
            this.resolveColor();
            b.chart.pointCount++;
            t(this, "afterInit");
            return this;
          }
          isValid() {
            return this.x !== null && e(this.y);
          }
          optionsToObject(b) {
            var a3 = this.series;
            const c = a3.options.keys, d2 = c || a3.pointArrayMap || ["y"], k2 = d2.length;
            let g2 = {}, q2 = 0, r2 = 0;
            if (e(b) || b === null)
              g2[d2[0]] = b;
            else if (h(b))
              for (!c && b.length > k2 && (a3 = typeof b[0], a3 === "string" ? g2.name = b[0] : a3 === "number" && (g2.x = b[0]), q2++); r2 < k2; )
                c && typeof b[q2] === "undefined" || (0 < d2[r2].indexOf(".") ? G.prototype.setNestedProperty(g2, b[q2], d2[r2]) : g2[d2[r2]] = b[q2]), q2++, r2++;
            else
              typeof b === "object" && (g2 = b, b.dataLabels && (a3._hasPointLabels = true), b.marker && (a3._hasPointMarkers = true));
            return g2;
          }
          pos(b, a3 = this.plotY) {
            if (!this.destroyed) {
              const { plotX: c, series: f } = this, { chart: d2, xAxis: k2, yAxis: g2 } = f;
              let h3 = 0, q2 = 0;
              if (e(c) && e(a3))
                return b && (h3 = k2 ? k2.pos : d2.plotLeft, q2 = g2 ? g2.pos : d2.plotTop), d2.inverted && k2 && g2 ? [g2.len - a3 + q2, k2.len - c + h3] : [c + h3, a3 + q2];
            }
          }
          resolveColor() {
            const b = this.series;
            var a3 = b.chart.styledMode;
            let c;
            var k2 = b.chart.options.chart.colorCount;
            delete this.nonZonedColor;
            b.options.colorByPoint ? (a3 || (k2 = b.options.colors || b.chart.options.colors, c = k2[b.colorCounter], k2 = k2.length), a3 = b.colorCounter, b.colorCounter++, b.colorCounter === k2 && (b.colorCounter = 0)) : (a3 || (c = b.color), a3 = b.colorIndex);
            this.colorIndex = d(this.options.colorIndex, a3);
            this.color = d(this.options.color, c);
          }
          setNestedProperty(b, a3, c) {
            c.split(".").reduce(function(b2, c2, f, d2) {
              b2[c2] = d2.length - 1 === f ? a3 : w(b2[c2], true) ? b2[c2] : {};
              return b2[c2];
            }, b);
            return b;
          }
          shouldDraw() {
            return !this.isNull;
          }
          tooltipFormatter(b) {
            const a3 = this.series, c = a3.tooltipOptions, k2 = d(c.valueDecimals, ""), e2 = c.valuePrefix || "", g2 = c.valueSuffix || "";
            a3.chart.styledMode && (b = a3.chart.tooltip.styledModeFormat(b));
            (a3.pointArrayMap || ["y"]).forEach(function(c2) {
              c2 = "{point." + c2;
              if (e2 || g2)
                b = b.replace(RegExp(c2 + "}", "g"), e2 + c2 + "}" + g2);
              b = b.replace(RegExp(c2 + "}", "g"), c2 + ":,." + k2 + "f}");
            });
            return B(b, { point: this, series: this.series }, a3.chart);
          }
          update(b, a3, c, k2) {
            function f() {
              n3.applyOptions(b);
              var f2 = g2 && n3.hasMockGraphic;
              f2 = n3.y === null ? !f2 : f2;
              g2 && f2 && (n3.graphic = g2.destroy(), delete n3.hasMockGraphic);
              w(b, true) && (g2 && g2.element && b && b.marker && typeof b.marker.symbol !== "undefined" && (n3.graphic = g2.destroy()), b && b.dataLabels && n3.dataLabel && (n3.dataLabel = n3.dataLabel.destroy()), n3.connector && (n3.connector = n3.connector.destroy()));
              r2 = n3.index;
              e2.updateParallelArrays(n3, r2);
              q2.data[r2] = w(q2.data[r2], true) || w(b, true) ? n3.options : d(b, q2.data[r2]);
              e2.isDirty = e2.isDirtyData = true;
              !e2.fixedBox && e2.hasCartesianSeries && (h3.isDirtyBox = true);
              q2.legendType === "point" && (h3.isDirtyLegend = true);
              a3 && h3.redraw(c);
            }
            const n3 = this, e2 = n3.series, g2 = n3.graphic, h3 = e2.chart, q2 = e2.options;
            let r2;
            a3 = d(a3, true);
            k2 === false ? f() : n3.firePointEvent("update", { options: b }, f);
          }
          remove(b, a3) {
            this.series.removePoint(this.series.data.indexOf(this), b, a3);
          }
          select(b, a3) {
            const c = this, f = c.series, k2 = f.chart;
            this.selectedStaging = b = d(b, !c.selected);
            c.firePointEvent(b ? "select" : "unselect", { accumulate: a3 }, function() {
              c.selected = c.options.selected = b;
              f.options.data[f.data.indexOf(c)] = c.options;
              c.setState(b && "select");
              a3 || k2.getSelectedPoints().forEach(function(b2) {
                const a4 = b2.series;
                b2.selected && b2 !== c && (b2.selected = b2.options.selected = false, a4.options.data[a4.data.indexOf(b2)] = b2.options, b2.setState(k2.hoverPoints && a4.options.inactiveOtherPoints ? "inactive" : ""), b2.firePointEvent("unselect"));
              });
            });
            delete this.selectedStaging;
          }
          onMouseOver(b) {
            const a3 = this.series.chart, c = a3.pointer;
            b = b ? c.normalize(b) : c.getChartCoordinatesFromPoint(this, a3.inverted);
            c.runPointActions(b, this);
          }
          onMouseOut() {
            const b = this.series.chart;
            this.firePointEvent("mouseOut");
            this.series.options.inactiveOtherPoints || (b.hoverPoints || []).forEach(function(b2) {
              b2.setState();
            });
            b.hoverPoints = b.hoverPoint = null;
          }
          importEvents() {
            if (!this.hasImportedEvents) {
              const b = this, a3 = E(b.series.options.point, b.options).events;
              b.events = a3;
              F(a3, function(c, a4) {
                g(c) && u(b, a4, c);
              });
              this.hasImportedEvents = true;
            }
          }
          setState(b, f) {
            const c = this.series;
            var k2 = this.state, g2 = c.options.states[b || "normal"] || {}, h3 = H.plotOptions[c.type].marker && c.options.marker;
            const q2 = h3 && h3.enabled === false, r2 = h3 && h3.states && h3.states[b || "normal"] || {}, l3 = r2.enabled === false, m2 = this.marker || {}, w2 = c.chart, v2 = h3 && c.markerAttribs;
            let G2 = c.halo;
            var u2;
            let x2;
            var E2 = c.stateMarkerGraphic;
            b = b || "";
            if (!(b === this.state && !f || this.selected && b !== "select" || g2.enabled === false || b && (l3 || q2 && r2.enabled === false) || b && m2.states && m2.states[b] && m2.states[b].enabled === false)) {
              this.state = b;
              v2 && (u2 = c.markerAttribs(this, b));
              if (this.graphic && !this.hasMockGraphic) {
                k2 && this.graphic.removeClass("highcharts-point-" + k2);
                b && this.graphic.addClass("highcharts-point-" + b);
                if (!w2.styledMode) {
                  k2 = c.pointAttribs(this, b);
                  x2 = d(w2.options.chart.animation, g2.animation);
                  const a3 = k2.opacity;
                  c.options.inactiveOtherPoints && e(a3) && ((this.dataLabels || []).forEach(function(b2) {
                    b2 && !b2.hasClass("highcharts-data-label-hidden") && b2.animate({ opacity: a3 }, x2);
                  }), this.connector && this.connector.animate({ opacity: a3 }, x2));
                  this.graphic.animate(k2, x2);
                }
                u2 && this.graphic.animate(u2, d(w2.options.chart.animation, r2.animation, h3.animation));
                E2 && E2.hide();
              } else {
                if (b && r2) {
                  h3 = m2.symbol || c.symbol;
                  E2 && E2.currentSymbol !== h3 && (E2 = E2.destroy());
                  if (u2)
                    if (E2)
                      E2[f ? "animate" : "attr"]({ x: u2.x, y: u2.y });
                    else
                      h3 && (c.stateMarkerGraphic = E2 = w2.renderer.symbol(h3, u2.x, u2.y, u2.width, u2.height).add(c.markerGroup), E2.currentSymbol = h3);
                  !w2.styledMode && E2 && this.state !== "inactive" && E2.attr(c.pointAttribs(this, b));
                }
                E2 && (E2[b && this.isInside ? "show" : "hide"](), E2.element.point = this, E2.addClass(this.getClassName(), true));
              }
              g2 = g2.halo;
              u2 = (E2 = this.graphic || E2) && E2.visibility || "inherit";
              g2 && g2.size && E2 && u2 !== "hidden" && !this.isCluster ? (G2 || (c.halo = G2 = w2.renderer.path().add(E2.parentGroup)), G2.show()[f ? "animate" : "attr"]({ d: this.haloPath(g2.size) }), G2.attr({ "class": "highcharts-halo highcharts-color-" + d(this.colorIndex, c.colorIndex) + (this.className ? " " + this.className : ""), visibility: u2, zIndex: -1 }), G2.point = this, w2.styledMode || G2.attr(p({ fill: this.color || c.color, "fill-opacity": g2.opacity }, a2.filterUserAttributes(g2.attributes || {})))) : G2 && G2.point && G2.point.haloPath && G2.animate({ d: G2.point.haloPath(0) }, null, G2.hide);
              t(this, "afterSetState", { state: b });
            }
          }
          haloPath(b) {
            const a3 = this.pos();
            return a3 ? this.series.chart.renderer.symbols.circle(Math.floor(a3[0]) - b, a3[1] - b, 2 * b, 2 * b) : [];
          }
        }
        "";
        return G;
      });
      M(a, "Core/Pointer.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { parse: x } = a2, { charts: C, noop: z } = y, { addEvent: H, attr: B, css: u, defined: v, extend: l2, find: p, fireEvent: t, isNumber: m, isObject: h, objectEach: g, offset: e, pick: w, splat: E } = I;
        class F {
          constructor(a3, k) {
            this.lastValidTouch = {};
            this.pinchDown = [];
            this.runChartClick = false;
            this.eventsToUnbind = [];
            this.chart = a3;
            this.hasDragged = false;
            this.options = k;
            this.init(a3, k);
          }
          applyInactiveState(a3) {
            let d = [], e2;
            (a3 || []).forEach(function(a4) {
              e2 = a4.series;
              d.push(e2);
              e2.linkedParent && d.push(e2.linkedParent);
              e2.linkedSeries && (d = d.concat(e2.linkedSeries));
              e2.navigatorSeries && d.push(e2.navigatorSeries);
            });
            this.chart.series.forEach(function(a4) {
              d.indexOf(a4) === -1 ? a4.setState("inactive", true) : a4.options.inactiveOtherPoints && a4.setAllPointsToState("inactive");
            });
          }
          destroy() {
            const a3 = this;
            this.eventsToUnbind.forEach((a4) => a4());
            this.eventsToUnbind = [];
            y.chartCount || (F.unbindDocumentMouseUp && (F.unbindDocumentMouseUp = F.unbindDocumentMouseUp()), F.unbindDocumentTouchEnd && (F.unbindDocumentTouchEnd = F.unbindDocumentTouchEnd()));
            clearInterval(a3.tooltipTimeout);
            g(a3, function(d, e2) {
              a3[e2] = void 0;
            });
          }
          getSelectionMarkerAttrs(a3, k) {
            const d = { args: { chartX: a3, chartY: k }, attrs: {}, shapeType: "rect" };
            t(this, "getSelectionMarkerAttrs", d, (d2) => {
              const { chart: e2, mouseDownX: b = 0, mouseDownY: f = 0, zoomHor: c, zoomVert: n3 } = this;
              d2 = d2.attrs;
              let g2;
              d2.x = e2.plotLeft;
              d2.y = e2.plotTop;
              d2.width = c ? 1 : e2.plotWidth;
              d2.height = n3 ? 1 : e2.plotHeight;
              c && (g2 = a3 - b, d2.width = Math.abs(g2), d2.x = (0 < g2 ? 0 : g2) + b);
              n3 && (g2 = k - f, d2.height = Math.abs(g2), d2.y = (0 < g2 ? 0 : g2) + f);
            });
            return d;
          }
          drag(a3) {
            const d = this.chart, e2 = d.options.chart;
            var g2 = d.plotLeft;
            const l3 = d.plotTop, b = d.plotWidth, f = d.plotHeight, c = this.mouseDownX || 0, n3 = this.mouseDownY || 0, m2 = h(e2.panning) ? e2.panning && e2.panning.enabled : e2.panning, p2 = e2.panKey && a3[e2.panKey + "Key"];
            let t2 = a3.chartX, w2 = a3.chartY, v2 = this.selectionMarker;
            if (!v2 || !v2.touch) {
              if (t2 < g2 ? t2 = g2 : t2 > g2 + b && (t2 = g2 + b), w2 < l3 ? w2 = l3 : w2 > l3 + f && (w2 = l3 + f), this.hasDragged = Math.sqrt(Math.pow(c - t2, 2) + Math.pow(n3 - w2, 2)), 10 < this.hasDragged) {
                g2 = d.isInsidePlot(c - g2, n3 - l3, { visiblePlotOnly: true });
                const { shapeType: b2, attrs: f2 } = this.getSelectionMarkerAttrs(t2, w2);
                !d.hasCartesianSeries && !d.mapView || !this.zoomX && !this.zoomY || !g2 || p2 || v2 || (this.selectionMarker = v2 = d.renderer[b2](), v2.attr({ "class": "highcharts-selection-marker", zIndex: 7 }).add(), d.styledMode || v2.attr({ fill: e2.selectionMarkerFill || x("#334eff").setOpacity(0.25).get() }));
                v2 && v2.attr(f2);
                g2 && !v2 && m2 && d.pan(a3, e2.panning);
              }
            }
          }
          dragStart(a3) {
            const d = this.chart;
            d.mouseIsDown = a3.type;
            d.cancelClick = false;
            d.mouseDownX = this.mouseDownX = a3.chartX;
            d.mouseDownY = this.mouseDownY = a3.chartY;
          }
          getSelectionBox(a3) {
            const d = { args: { marker: a3 }, result: {} };
            t(this, "getSelectionBox", d, (d2) => {
              d2.result = { x: a3.attr ? +a3.attr("x") : a3.x, y: a3.attr ? +a3.attr("y") : a3.y, width: a3.attr ? a3.attr("width") : a3.width, height: a3.attr ? a3.attr("height") : a3.height };
            });
            return d.result;
          }
          drop(a3) {
            const d = this, e2 = this.chart, g2 = this.hasPinched;
            if (this.selectionMarker) {
              const {
                x: k,
                y: b,
                width: f,
                height: c
              } = this.getSelectionBox(this.selectionMarker), n3 = { originalEvent: a3, xAxis: [], yAxis: [], x: k, y: b, width: f, height: c };
              let h3 = !!e2.mapView;
              if (this.hasDragged || g2)
                e2.axes.forEach(function(e3) {
                  if (e3.zoomEnabled && v(e3.min) && (g2 || d[{ xAxis: "zoomX", yAxis: "zoomY" }[e3.coll]]) && m(k) && m(b) && m(f) && m(c)) {
                    var q = e3.horiz;
                    const d2 = a3.type === "touchend" ? e3.minPixelPadding : 0, g3 = e3.toValue((q ? k : b) + d2);
                    q = e3.toValue((q ? k + f : b + c) - d2);
                    n3[e3.coll].push({ axis: e3, min: Math.min(g3, q), max: Math.max(g3, q) });
                    h3 = true;
                  }
                }), h3 && t(e2, "selection", n3, function(b2) {
                  e2.zoom(l2(b2, g2 ? { animation: false } : null));
                });
              m(e2.index) && (this.selectionMarker = this.selectionMarker.destroy());
              g2 && this.scaleGroups();
            }
            e2 && m(e2.index) && (u(e2.container, { cursor: e2._cursor }), e2.cancelClick = 10 < this.hasDragged, e2.mouseIsDown = this.hasDragged = this.hasPinched = false, this.pinchDown = []);
          }
          findNearestKDPoint(a3, k, e2) {
            let d;
            a3.forEach(function(a4) {
              var b = !(a4.noSharedTooltip && k) && 0 > a4.options.findNearestPointBy.indexOf("y");
              a4 = a4.searchPoint(e2, b);
              if ((b = h(a4, true) && a4.series) && !(b = !h(d, true))) {
                {
                  b = d.distX - a4.distX;
                  const f = d.dist - a4.dist, c = (a4.series.group && a4.series.group.zIndex) - (d.series.group && d.series.group.zIndex);
                  b = b !== 0 && k ? b : f !== 0 ? f : c !== 0 ? c : d.series.index > a4.series.index ? -1 : 1;
                }
                b = 0 < b;
              }
              b && (d = a4);
            });
            return d;
          }
          getChartCoordinatesFromPoint(a3, k) {
            var d = a3.series;
            const e2 = d.xAxis;
            d = d.yAxis;
            const g2 = a3.shapeArgs;
            if (e2 && d) {
              let b = w(a3.clientX, a3.plotX), f = a3.plotY || 0;
              a3.isNode && g2 && m(g2.x) && m(g2.y) && (b = g2.x, f = g2.y);
              return k ? { chartX: d.len + d.pos - f, chartY: e2.len + e2.pos - b } : { chartX: b + e2.pos, chartY: f + d.pos };
            }
            if (g2 && g2.x && g2.y)
              return { chartX: g2.x, chartY: g2.y };
          }
          getChartPosition() {
            if (this.chartPosition)
              return this.chartPosition;
            var { container: a3 } = this.chart;
            const k = e(a3);
            this.chartPosition = { left: k.left, top: k.top, scaleX: 1, scaleY: 1 };
            const g2 = a3.offsetWidth;
            a3 = a3.offsetHeight;
            2 < g2 && 2 < a3 && (this.chartPosition.scaleX = k.width / g2, this.chartPosition.scaleY = k.height / a3);
            return this.chartPosition;
          }
          getCoordinates(a3) {
            const d = { xAxis: [], yAxis: [] };
            this.chart.axes.forEach(function(k) {
              d[k.isXAxis ? "xAxis" : "yAxis"].push({ axis: k, value: k.toValue(a3[k.horiz ? "chartX" : "chartY"]) });
            });
            return d;
          }
          getHoverData(a3, k, e2, g2, l3, b) {
            const f = [];
            g2 = !(!g2 || !a3);
            const c = function(b2) {
              return b2.visible && !(!l3 && b2.directTouch) && w(b2.options.enableMouseTracking, true);
            };
            let d, q = { chartX: b ? b.chartX : void 0, chartY: b ? b.chartY : void 0, shared: l3 };
            t(this, "beforeGetHoverData", q);
            d = k && !k.stickyTracking ? [k] : e2.filter((b2) => b2.stickyTracking && (q.filter || c)(b2));
            const r = g2 || !b ? a3 : this.findNearestKDPoint(d, l3, b);
            k = r && r.series;
            r && (l3 && !k.noSharedTooltip ? (d = e2.filter(function(b2) {
              return q.filter ? q.filter(b2) : c(b2) && !b2.noSharedTooltip;
            }), d.forEach(function(b2) {
              let c2 = p(b2.points, function(b3) {
                return b3.x === r.x && !b3.isNull;
              });
              h(c2) && (b2.boosted && b2.boost && (c2 = b2.boost.getPoint(c2)), f.push(c2));
            })) : f.push(r));
            q = { hoverPoint: r };
            t(this, "afterGetHoverData", q);
            return { hoverPoint: q.hoverPoint, hoverSeries: k, hoverPoints: f };
          }
          getPointFromEvent(a3) {
            a3 = a3.target;
            let d;
            for (; a3 && !d; )
              d = a3.point, a3 = a3.parentNode;
            return d;
          }
          onTrackerMouseOut(a3) {
            a3 = a3.relatedTarget;
            const d = this.chart.hoverSeries;
            this.isDirectTouch = false;
            if (!(!d || !a3 || d.stickyTracking || this.inClass(a3, "highcharts-tooltip") || this.inClass(a3, "highcharts-series-" + d.index) && this.inClass(a3, "highcharts-tracker")))
              d.onMouseOut();
          }
          inClass(a3, k) {
            let d;
            for (; a3; ) {
              if (d = B(a3, "class")) {
                if (d.indexOf(k) !== -1)
                  return true;
                if (d.indexOf("highcharts-container") !== -1)
                  return false;
              }
              a3 = a3.parentElement;
            }
          }
          init(a3, k) {
            this.options = k;
            this.chart = a3;
            this.runChartClick = !(!k.chart.events || !k.chart.events.click);
            this.pinchDown = [];
            this.lastValidTouch = {};
            this.setDOMEvents();
            t(this, "afterInit");
          }
          normalize(a3, k) {
            var d = a3.touches, e2 = d ? d.length ? d.item(0) : w(d.changedTouches, a3.changedTouches)[0] : a3;
            k || (k = this.getChartPosition());
            d = e2.pageX - k.left;
            e2 = e2.pageY - k.top;
            d /= k.scaleX;
            e2 /= k.scaleY;
            return l2(a3, { chartX: Math.round(d), chartY: Math.round(e2) });
          }
          onContainerClick(a3) {
            const d = this.chart, e2 = d.hoverPoint;
            a3 = this.normalize(a3);
            const g2 = d.plotLeft, h3 = d.plotTop;
            d.cancelClick || (e2 && this.inClass(a3.target, "highcharts-tracker") ? (t(e2.series, "click", l2(a3, { point: e2 })), d.hoverPoint && e2.firePointEvent("click", a3)) : (l2(a3, this.getCoordinates(a3)), d.isInsidePlot(a3.chartX - g2, a3.chartY - h3, { visiblePlotOnly: true }) && t(d, "click", a3)));
          }
          onContainerMouseDown(a3) {
            const d = ((a3.buttons || a3.button) & 1) === 1;
            a3 = this.normalize(a3);
            if (y.isFirefox && a3.button !== 0)
              this.onContainerMouseMove(a3);
            if (typeof a3.button === "undefined" || d)
              this.zoomOption(a3), d && a3.preventDefault && a3.preventDefault(), this.dragStart(a3);
          }
          onContainerMouseLeave(a3) {
            const d = C[w(F.hoverChartIndex, -1)];
            a3 = this.normalize(a3);
            d && a3.relatedTarget && !this.inClass(a3.relatedTarget, "highcharts-tooltip") && (d.pointer.reset(), d.pointer.chartPosition = void 0);
          }
          onContainerMouseEnter(a3) {
            delete this.chartPosition;
          }
          onContainerMouseMove(a3) {
            const d = this.chart, e2 = d.tooltip;
            a3 = this.normalize(a3);
            this.setHoverChartIndex();
            (d.mouseIsDown === "mousedown" || this.touchSelect(a3)) && this.drag(a3);
            d.openMenu || !this.inClass(a3.target, "highcharts-tracker") && !d.isInsidePlot(a3.chartX - d.plotLeft, a3.chartY - d.plotTop, { visiblePlotOnly: true }) || e2 && e2.shouldStickOnContact(a3) || (this.inClass(a3.target, "highcharts-no-tooltip") ? this.reset(false, 0) : this.runPointActions(a3));
          }
          onDocumentTouchEnd(a3) {
            const d = C[w(F.hoverChartIndex, -1)];
            d && d.pointer.drop(a3);
          }
          onContainerTouchMove(a3) {
            if (this.touchSelect(a3))
              this.onContainerMouseMove(a3);
            else
              this.touch(a3);
          }
          onContainerTouchStart(a3) {
            if (this.touchSelect(a3))
              this.onContainerMouseDown(a3);
            else
              this.zoomOption(a3), this.touch(a3, true);
          }
          onDocumentMouseMove(a3) {
            const d = this.chart, e2 = d.tooltip, g2 = this.chartPosition;
            a3 = this.normalize(a3, g2);
            !g2 || d.isInsidePlot(a3.chartX - d.plotLeft, a3.chartY - d.plotTop, { visiblePlotOnly: true }) || e2 && e2.shouldStickOnContact(a3) || this.inClass(a3.target, "highcharts-tracker") || this.reset();
          }
          onDocumentMouseUp(a3) {
            const d = C[w(F.hoverChartIndex, -1)];
            d && d.pointer.drop(a3);
          }
          pinch(a3) {
            const d = this, e2 = d.chart, g2 = d.pinchDown, h3 = a3.touches || [], b = h3.length, f = d.lastValidTouch, c = d.hasZoom, n3 = {}, m2 = b === 1 && (d.inClass(a3.target, "highcharts-tracker") && e2.runTrackerClick || d.runChartClick), p2 = {};
            var v2 = d.chart.tooltip;
            v2 = b === 1 && w(v2 && v2.options.followTouchMove, true);
            let u2 = d.selectionMarker;
            1 < b ? d.initiated = true : v2 && (d.initiated = false);
            c && d.initiated && !m2 && a3.cancelable !== false && a3.preventDefault();
            [].map.call(h3, function(b2) {
              return d.normalize(b2);
            });
            a3.type === "touchstart" ? ([].forEach.call(h3, function(b2, a4) {
              g2[a4] = { chartX: b2.chartX, chartY: b2.chartY };
            }), f.x = [g2[0].chartX, g2[1] && g2[1].chartX], f.y = [g2[0].chartY, g2[1] && g2[1].chartY], e2.axes.forEach(function(b2) {
              if (b2.zoomEnabled) {
                const a4 = e2.bounds[b2.horiz ? "h" : "v"], c2 = b2.minPixelPadding, f2 = b2.toPixels(Math.min(w(b2.options.min, b2.dataMin), b2.dataMin)), d2 = b2.toPixels(Math.max(w(b2.options.max, b2.dataMax), b2.dataMax)), n4 = Math.max(f2, d2);
                a4.min = Math.min(b2.pos, Math.min(f2, d2) - c2);
                a4.max = Math.max(b2.pos + b2.len, n4 + c2);
              }
            }), d.res = true) : v2 ? this.runPointActions(d.normalize(a3)) : g2.length && (t(e2, "touchpan", { originalEvent: a3 }, () => {
              u2 || (d.selectionMarker = u2 = l2({ destroy: z, touch: true }, e2.plotBox));
              d.pinchTranslate(g2, h3, n3, u2, p2, f);
              d.hasPinched = c;
              d.scaleGroups(n3, p2);
            }), d.res && (d.res = false, this.reset(false, 0)));
          }
          pinchTranslate(a3, e2, g2, h3, l3, b) {
            this.zoomHor && this.pinchTranslateDirection(true, a3, e2, g2, h3, l3, b);
            this.zoomVert && this.pinchTranslateDirection(false, a3, e2, g2, h3, l3, b);
          }
          pinchTranslateDirection(a3, e2, g2, h3, l3, b, f, c) {
            const d = this.chart, k = a3 ? "x" : "y", q = a3 ? "X" : "Y", m2 = "chart" + q, r = a3 ? "width" : "height", p2 = d["plot" + (a3 ? "Left" : "Top")], t2 = d.inverted, w2 = d.bounds[a3 ? "h" : "v"], v2 = e2.length === 1, u2 = e2[0][m2], x2 = !v2 && e2[1][m2];
            e2 = function() {
              typeof N === "number" && 20 < Math.abs(u2 - x2) && (F2 = c || Math.abs(J - N) / Math.abs(u2 - x2));
              E2 = (p2 - J) / F2 + u2;
              G = d["plot" + (a3 ? "Width" : "Height")] / F2;
            };
            let G, E2, F2 = c || 1, J = g2[0][m2], N = !v2 && g2[1][m2], O;
            e2();
            g2 = E2;
            g2 < w2.min ? (g2 = w2.min, O = true) : g2 + G > w2.max && (g2 = w2.max - G, O = true);
            O ? (J -= 0.8 * (J - f[k][0]), typeof N === "number" && (N -= 0.8 * (N - f[k][1])), e2()) : f[k] = [J, N];
            t2 || (b[k] = E2 - p2, b[r] = G);
            b = t2 ? 1 / F2 : F2;
            l3[r] = G;
            l3[k] = g2;
            h3[t2 ? a3 ? "scaleY" : "scaleX" : "scale" + q] = F2;
            h3["translate" + q] = b * p2 + (J - b * u2);
          }
          reset(a3, e2) {
            const d = this.chart, k = d.hoverSeries, g2 = d.hoverPoint, b = d.hoverPoints, f = d.tooltip, c = f && f.shared ? b : g2;
            a3 && c && E(c).forEach(function(b2) {
              b2.series.isCartesian && typeof b2.plotX === "undefined" && (a3 = false);
            });
            if (a3)
              f && c && E(c).length && (f.refresh(c), f.shared && b ? b.forEach(function(b2) {
                b2.setState(b2.state, true);
                b2.series.isCartesian && (b2.series.xAxis.crosshair && b2.series.xAxis.drawCrosshair(null, b2), b2.series.yAxis.crosshair && b2.series.yAxis.drawCrosshair(null, b2));
              }) : g2 && (g2.setState(g2.state, true), d.axes.forEach(function(b2) {
                b2.crosshair && g2.series[b2.coll] === b2 && b2.drawCrosshair(null, g2);
              })));
            else {
              if (g2)
                g2.onMouseOut();
              b && b.forEach(function(b2) {
                b2.setState();
              });
              if (k)
                k.onMouseOut();
              f && f.hide(e2);
              this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
              d.axes.forEach(function(b2) {
                b2.hideCrosshair();
              });
              this.hoverX = d.hoverPoints = d.hoverPoint = null;
            }
          }
          runPointActions(a3, e2, g2) {
            const d = this.chart, k = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0, b = k ? k.shared : false;
            let f = e2 || d.hoverPoint, c = f && f.series || d.hoverSeries;
            e2 = this.getHoverData(f, c, d.series, (!a3 || a3.type !== "touchmove") && (!!e2 || c && c.directTouch && this.isDirectTouch), b, a3);
            f = e2.hoverPoint;
            c = e2.hoverSeries;
            const n3 = e2.hoverPoints;
            e2 = c && c.tooltipOptions.followPointer && !c.tooltipOptions.split;
            const h3 = b && c && !c.noSharedTooltip;
            if (f && (g2 || f !== d.hoverPoint || k && k.isHidden)) {
              (d.hoverPoints || []).forEach(function(b2) {
                n3.indexOf(b2) === -1 && b2.setState();
              });
              if (d.hoverSeries !== c)
                c.onMouseOver();
              this.applyInactiveState(n3);
              (n3 || []).forEach(function(b2) {
                b2.setState("hover");
              });
              d.hoverPoint && d.hoverPoint.firePointEvent("mouseOut");
              if (!f.series)
                return;
              d.hoverPoints = n3;
              d.hoverPoint = f;
              f.firePointEvent("mouseOver", void 0, () => {
                k && f && k.refresh(h3 ? n3 : f, a3);
              });
            } else
              e2 && k && !k.isHidden && (g2 = k.getAnchor([{}], a3), d.isInsidePlot(g2[0], g2[1], { visiblePlotOnly: true }) && k.updatePosition({
                plotX: g2[0],
                plotY: g2[1]
              }));
            this.unDocMouseMove || (this.unDocMouseMove = H(d.container.ownerDocument, "mousemove", function(b2) {
              const a4 = C[F.hoverChartIndex];
              if (a4)
                a4.pointer.onDocumentMouseMove(b2);
            }), this.eventsToUnbind.push(this.unDocMouseMove));
            d.axes.forEach(function(b2) {
              const c2 = w((b2.crosshair || {}).snap, true);
              let f2;
              c2 && ((f2 = d.hoverPoint) && f2.series[b2.coll] === b2 || (f2 = p(n3, (a4) => a4.series && a4.series[b2.coll] === b2)));
              f2 || !c2 ? b2.drawCrosshair(a3, f2) : b2.hideCrosshair();
            });
          }
          scaleGroups(a3, e2) {
            const d = this.chart;
            d.series.forEach(function(k) {
              const g2 = a3 || k.getPlotBox();
              k.group && (k.xAxis && k.xAxis.zoomEnabled || d.mapView) && (k.group.attr(g2), k.markerGroup && (k.markerGroup.attr(g2), k.markerGroup.clip(e2 ? d.clipRect : null)), k.dataLabelsGroup && k.dataLabelsGroup.attr(g2));
            });
            d.clipRect.attr(e2 || d.clipBox);
          }
          setDOMEvents() {
            const a3 = this.chart.container, e2 = a3.ownerDocument;
            a3.onmousedown = this.onContainerMouseDown.bind(this);
            a3.onmousemove = this.onContainerMouseMove.bind(this);
            a3.onclick = this.onContainerClick.bind(this);
            this.eventsToUnbind.push(H(a3, "mouseenter", this.onContainerMouseEnter.bind(this)));
            this.eventsToUnbind.push(H(a3, "mouseleave", this.onContainerMouseLeave.bind(this)));
            F.unbindDocumentMouseUp || (F.unbindDocumentMouseUp = H(e2, "mouseup", this.onDocumentMouseUp.bind(this)));
            let g2 = this.chart.renderTo.parentElement;
            for (; g2 && g2.tagName !== "BODY"; )
              this.eventsToUnbind.push(H(g2, "scroll", () => {
                delete this.chartPosition;
              })), g2 = g2.parentElement;
            y.hasTouch && (this.eventsToUnbind.push(H(a3, "touchstart", this.onContainerTouchStart.bind(this), { passive: false })), this.eventsToUnbind.push(H(a3, "touchmove", this.onContainerTouchMove.bind(this), { passive: false })), F.unbindDocumentTouchEnd || (F.unbindDocumentTouchEnd = H(e2, "touchend", this.onDocumentTouchEnd.bind(this), { passive: false })));
          }
          setHoverChartIndex() {
            const a3 = this.chart, e2 = y.charts[w(F.hoverChartIndex, -1)];
            if (e2 && e2 !== a3)
              e2.pointer.onContainerMouseLeave({ relatedTarget: a3.container });
            e2 && e2.mouseIsDown || (F.hoverChartIndex = a3.index);
          }
          touch(a3, e2) {
            const d = this.chart;
            let g2, k;
            this.setHoverChartIndex();
            a3.touches.length === 1 ? (a3 = this.normalize(a3), (k = d.isInsidePlot(a3.chartX - d.plotLeft, a3.chartY - d.plotTop, { visiblePlotOnly: true })) && !d.openMenu ? (e2 && this.runPointActions(a3), a3.type === "touchmove" && (e2 = this.pinchDown, g2 = e2[0] ? 4 <= Math.sqrt(Math.pow(e2[0].chartX - a3.chartX, 2) + Math.pow(e2[0].chartY - a3.chartY, 2)) : false), w(g2, true) && this.pinch(a3)) : e2 && this.reset()) : a3.touches.length === 2 && this.pinch(a3);
          }
          touchSelect(a3) {
            return !(!this.chart.zooming.singleTouch || !a3.touches || a3.touches.length !== 1);
          }
          zoomOption(a3) {
            const d = this.chart, e2 = d.inverted;
            var g2 = d.zooming.type || "";
            /touch/.test(a3.type) && (g2 = w(d.zooming.pinchType, g2));
            this.zoomX = a3 = /x/.test(g2);
            this.zoomY = g2 = /y/.test(g2);
            this.zoomHor = a3 && !e2 || g2 && e2;
            this.zoomVert = g2 && !e2 || a3 && e2;
            this.hasZoom = a3 || g2;
          }
        }
        (function(a3) {
          const d = [], e2 = [];
          a3.compose = function(d2) {
            I.pushUnique(e2, d2) && H(d2, "beforeRender", function() {
              this.pointer = new a3(this, this.options);
            });
          };
          a3.dissolve = function() {
            for (let a4 = 0, e3 = d.length; a4 < e3; ++a4)
              d[a4]();
            d.length = 0;
          };
        })(F || (F = {}));
        "";
        return F;
      });
      M(a, "Core/Legend/Legend.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Templating.js"], a["Core/Globals.js"], a["Core/Series/Point.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Utilities.js"]], function(a2, y, I, L, C, z) {
        const { animObject: x, setAnimation: B } = a2, { format: u } = y, { marginNames: v } = I, { distribute: l2 } = C, { addEvent: p, createElement: t, css: m, defined: h, discardElement: g, find: e, fireEvent: w, isNumber: E, merge: F, pick: d, relativeLength: k, stableSort: r, syncTimeout: q } = z;
        class G {
          constructor(b, a3) {
            this.allItems = [];
            this.contentGroup = this.box = void 0;
            this.display = false;
            this.group = void 0;
            this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
            this.options = void 0;
            this.padding = 0;
            this.pages = [];
            this.proximate = false;
            this.scrollGroup = void 0;
            this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
            this.chart = b;
            this.init(b, a3);
          }
          init(b, a3) {
            this.chart = b;
            this.setOptions(a3);
            a3.enabled && (this.render(), p(this.chart, "endResize", function() {
              this.legend.positionCheckboxes();
            }), p(this.chart, "render", () => {
              this.proximate && (this.proximatePositions(), this.positionItems());
            }));
          }
          setOptions(b) {
            const a3 = d(b.padding, 8);
            this.options = b;
            this.chart.styledMode || (this.itemStyle = b.itemStyle, this.itemHiddenStyle = F(this.itemStyle, b.itemHiddenStyle));
            this.itemMarginTop = b.itemMarginTop;
            this.itemMarginBottom = b.itemMarginBottom;
            this.padding = a3;
            this.initialItemY = a3 - 5;
            this.symbolWidth = d(b.symbolWidth, 16);
            this.pages = [];
            this.proximate = b.layout === "proximate" && !this.chart.inverted;
            this.baseline = void 0;
          }
          update(b, a3) {
            const c = this.chart;
            this.setOptions(F(true, this.options, b));
            this.destroy();
            c.isDirtyLegend = c.isDirtyBox = true;
            d(a3, true) && c.redraw();
            w(this, "afterUpdate");
          }
          colorizeItem(b, a3) {
            const { group: c, label: f, line: d2, symbol: e2 } = b.legendItem || {};
            if (c)
              c[a3 ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
            if (!this.chart.styledMode) {
              const { itemHiddenStyle: c2 } = this, g2 = c2.color, k2 = a3 ? b.color || g2 : g2, n3 = b.options && b.options.marker;
              let h3 = { fill: k2 };
              f === null || f === void 0 ? void 0 : f.css(F(a3 ? this.itemStyle : c2));
              d2 === null || d2 === void 0 ? void 0 : d2.attr({ stroke: k2 });
              e2 && (n3 && e2.isMarker && (h3 = b.pointAttribs(), a3 || (h3.stroke = h3.fill = g2)), e2.attr(h3));
            }
            w(this, "afterColorizeItem", { item: b, visible: a3 });
          }
          positionItems() {
            this.allItems.forEach(this.positionItem, this);
            this.chart.isResizing || this.positionCheckboxes();
          }
          positionItem(b) {
            const { group: a3, x: c = 0, y: d2 = 0 } = b.legendItem || {};
            var e2 = this.options, g2 = e2.symbolPadding;
            const k2 = !e2.rtl;
            e2 = b.checkbox;
            a3 && a3.element && (g2 = { translateX: k2 ? c : this.legendWidth - c - 2 * g2 - 4, translateY: d2 }, a3[h(a3.translateY) ? "animate" : "attr"](g2, void 0, () => {
              w(this, "afterPositionItem", { item: b });
            }));
            e2 && (e2.x = c, e2.y = d2);
          }
          destroyItem(b) {
            const a3 = b.checkbox, c = b.legendItem || {};
            for (const b2 of ["group", "label", "line", "symbol"])
              c[b2] && (c[b2] = c[b2].destroy());
            a3 && g(a3);
            b.legendItem = void 0;
          }
          destroy() {
            for (const b of this.getAllItems())
              this.destroyItem(b);
            for (const b of "clipRect up down pager nav box title group".split(" "))
              this[b] && (this[b] = this[b].destroy());
            this.display = null;
          }
          positionCheckboxes() {
            const b = this.group && this.group.alignAttr, a3 = this.clipHeight || this.legendHeight, c = this.titleHeight;
            let d2;
            b && (d2 = b.translateY, this.allItems.forEach(function(f) {
              const e2 = f.checkbox;
              let g2;
              e2 && (g2 = d2 + c + e2.y + (this.scrollOffset || 0) + 3, m(e2, { left: b.translateX + f.checkboxOffset + e2.x - 20 + "px", top: g2 + "px", display: this.proximate || g2 > d2 - 6 && g2 < d2 + a3 - 6 ? "" : "none" }));
            }, this));
          }
          renderTitle() {
            var b = this.options;
            const a3 = this.padding, c = b.title;
            let d2 = 0;
            c.text && (this.title || (this.title = this.chart.renderer.label(c.text, a3 - 3, a3 - 4, void 0, void 0, void 0, b.useHTML, void 0, "legend-title").attr({ zIndex: 1 }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({ width: this.maxLegendWidth + "px" }), b = this.title.getBBox(), d2 = b.height, this.offsetWidth = b.width, this.contentGroup.attr({ translateY: d2 }));
            this.titleHeight = d2;
          }
          setText(b) {
            const a3 = this.options;
            b.legendItem.label.attr({ text: a3.labelFormat ? u(a3.labelFormat, b, this.chart) : a3.labelFormatter.call(b) });
          }
          renderItem(b) {
            const a3 = b.legendItem = b.legendItem || {};
            var c = this.chart, e2 = c.renderer;
            const g2 = this.options, k2 = this.symbolWidth, h3 = g2.symbolPadding || 0, l3 = this.itemStyle, m2 = this.itemHiddenStyle, q2 = g2.layout === "horizontal" ? d(g2.itemDistance, 20) : 0, r2 = !g2.rtl, p2 = !b.series, t2 = !p2 && b.series.drawLegendSymbol ? b.series : b;
            var w2 = t2.options;
            const v2 = this.createCheckboxForItem && w2 && w2.showCheckbox, u2 = g2.useHTML, x2 = b.options.className;
            let J = a3.label;
            w2 = k2 + h3 + q2 + (v2 ? 20 : 0);
            J || (a3.group = e2.g("legend-item").addClass("highcharts-" + t2.type + "-series highcharts-color-" + b.colorIndex + (x2 ? " " + x2 : "") + (p2 ? " highcharts-series-" + b.index : "")).attr({ zIndex: 1 }).add(this.scrollGroup), a3.label = J = e2.text("", r2 ? k2 + h3 : -h3, this.baseline || 0, u2), c.styledMode || J.css(F(b.visible ? l3 : m2)), J.attr({ align: r2 ? "left" : "right", zIndex: 2 }).add(a3.group), this.baseline || (this.fontMetrics = e2.fontMetrics(J), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, J.attr("y", this.baseline), this.symbolHeight = d(g2.symbolHeight, this.fontMetrics.f), g2.squareSymbol && (this.symbolWidth = d(g2.symbolWidth, Math.max(this.symbolHeight, 16)), w2 = this.symbolWidth + h3 + q2 + (v2 ? 20 : 0), r2 && J.attr("x", this.symbolWidth + h3))), t2.drawLegendSymbol(this, b), this.setItemEvents && this.setItemEvents(b, J, u2));
            v2 && !b.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b);
            this.colorizeItem(b, b.visible);
            !c.styledMode && l3.width || J.css({ width: (g2.itemWidth || this.widthOption || c.spacingBox.width) - w2 + "px" });
            this.setText(b);
            c = J.getBBox();
            e2 = this.fontMetrics && this.fontMetrics.h || 0;
            b.itemWidth = b.checkboxOffset = g2.itemWidth || a3.labelWidth || c.width + w2;
            this.maxItemWidth = Math.max(this.maxItemWidth, b.itemWidth);
            this.totalItemWidth += b.itemWidth;
            this.itemHeight = b.itemHeight = Math.round(a3.labelHeight || (c.height > 1.5 * e2 ? c.height : e2));
          }
          layoutItem(b) {
            var a3 = this.options;
            const c = this.padding, e2 = a3.layout === "horizontal", g2 = b.itemHeight, k2 = this.itemMarginBottom, h3 = this.itemMarginTop, l3 = e2 ? d(a3.itemDistance, 20) : 0, m2 = this.maxLegendWidth;
            a3 = a3.alignColumns && this.totalItemWidth > m2 ? this.maxItemWidth : b.itemWidth;
            const q2 = b.legendItem || {};
            e2 && this.itemX - c + a3 > m2 && (this.itemX = c, this.lastLineHeight && (this.itemY += h3 + this.lastLineHeight + k2), this.lastLineHeight = 0);
            this.lastItemY = h3 + this.itemY + k2;
            this.lastLineHeight = Math.max(g2, this.lastLineHeight);
            q2.x = this.itemX;
            q2.y = this.itemY;
            e2 ? this.itemX += a3 : (this.itemY += h3 + g2 + k2, this.lastLineHeight = g2);
            this.offsetWidth = this.widthOption || Math.max((e2 ? this.itemX - c - (b.checkbox ? 0 : l3) : a3) + c, this.offsetWidth);
          }
          getAllItems() {
            let b = [];
            this.chart.series.forEach(function(a3) {
              const c = a3 && a3.options;
              a3 && d(c.showInLegend, h(c.linkedTo) ? false : void 0, true) && (b = b.concat((a3.legendItem || {}).labels || (c.legendType === "point" ? a3.data : a3)));
            });
            w(this, "afterGetAllItems", { allItems: b });
            return b;
          }
          getAlignment() {
            const b = this.options;
            return this.proximate ? b.align.charAt(0) + "tv" : b.floating ? "" : b.align.charAt(0) + b.verticalAlign.charAt(0) + b.layout.charAt(0);
          }
          adjustMargins(b, a3) {
            const c = this.chart, f = this.options, e2 = this.getAlignment();
            e2 && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function(g2, k2) {
              g2.test(e2) && !h(b[k2]) && (c[v[k2]] = Math.max(c[v[k2]], c.legend[(k2 + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][k2] * f[k2 % 2 ? "x" : "y"] + d(f.margin, 12) + a3[k2] + (c.titleOffset[k2] || 0)));
            });
          }
          proximatePositions() {
            const b = this.chart, a3 = [], c = this.options.align === "left";
            this.allItems.forEach(function(d3) {
              var f;
              var g2 = c;
              let k2;
              d3.yAxis && (d3.xAxis.options.reversed && (g2 = !g2), d3.points && (f = e(g2 ? d3.points : d3.points.slice(0).reverse(), function(b2) {
                return E(b2.plotY);
              })), g2 = this.itemMarginTop + d3.legendItem.label.getBBox().height + this.itemMarginBottom, k2 = d3.yAxis.top - b.plotTop, d3.visible ? (f = f ? f.plotY : d3.yAxis.height, f += k2 - 0.3 * g2) : f = k2 + d3.yAxis.height, a3.push({ target: f, size: g2, item: d3 }));
            }, this);
            let d2;
            for (const c2 of l2(a3, b.plotHeight))
              d2 = c2.item.legendItem || {}, E(c2.pos) && (d2.y = b.plotTop - b.spacing[0] + c2.pos);
          }
          render() {
            const b = this.chart, a3 = b.renderer, c = this.options, d2 = this.padding;
            var e2 = this.getAllItems();
            let g2, h3 = this.group, l3 = this.box;
            this.itemX = d2;
            this.itemY = this.initialItemY;
            this.lastItemY = this.offsetWidth = 0;
            this.widthOption = k(c.width, b.spacingBox.width - d2);
            var m2 = b.spacingBox.width - 2 * d2 - c.x;
            -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (m2 /= 2);
            this.maxLegendWidth = this.widthOption || m2;
            h3 || (this.group = h3 = a3.g("legend").addClass(c.className || "").attr({ zIndex: 7 }).add(), this.contentGroup = a3.g().attr({ zIndex: 1 }).add(h3), this.scrollGroup = a3.g().add(this.contentGroup));
            this.renderTitle();
            r(e2, (b2, a4) => (b2.options && b2.options.legendIndex || 0) - (a4.options && a4.options.legendIndex || 0));
            c.reversed && e2.reverse();
            this.allItems = e2;
            this.display = m2 = !!e2.length;
            this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
            e2.forEach(this.renderItem, this);
            e2.forEach(this.layoutItem, this);
            e2 = (this.widthOption || this.offsetWidth) + d2;
            g2 = this.lastItemY + this.lastLineHeight + this.titleHeight;
            g2 = this.handleOverflow(g2);
            g2 += d2;
            l3 || (this.box = l3 = a3.rect().addClass("highcharts-legend-box").attr({ r: c.borderRadius }).add(h3));
            b.styledMode || l3.attr({
              stroke: c.borderColor,
              "stroke-width": c.borderWidth || 0,
              fill: c.backgroundColor || "none"
            }).shadow(c.shadow);
            if (0 < e2 && 0 < g2)
              l3[l3.placed ? "animate" : "attr"](l3.crisp.call({}, { x: 0, y: 0, width: e2, height: g2 }, l3.strokeWidth()));
            h3[m2 ? "show" : "hide"]();
            b.styledMode && h3.getStyle("display") === "none" && (e2 = g2 = 0);
            this.legendWidth = e2;
            this.legendHeight = g2;
            m2 && this.align();
            this.proximate || this.positionItems();
            w(this, "afterRender");
          }
          align(b = this.chart.spacingBox) {
            const a3 = this.chart, c = this.options;
            let d2 = b.y;
            /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a3.titleOffset[0] ? d2 += a3.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a3.titleOffset[2] && (d2 -= a3.titleOffset[2]);
            d2 !== b.y && (b = F(b, { y: d2 }));
            a3.hasRendered || (this.group.placed = false);
            this.group.align(F(c, { width: this.legendWidth, height: this.legendHeight, verticalAlign: this.proximate ? "top" : c.verticalAlign }), true, b);
          }
          handleOverflow(b) {
            const a3 = this, c = this.chart, e2 = c.renderer, g2 = this.options;
            var k2 = g2.y;
            const h3 = g2.verticalAlign === "top", l3 = this.padding, m2 = g2.maxHeight, q2 = g2.navigation, r2 = d(q2.animation, true), p2 = q2.arrowSize || 12, t2 = this.pages, w2 = this.allItems, v2 = function(b2) {
              typeof b2 === "number" ? E2.attr({ height: b2 }) : E2 && (a3.clipRect = E2.destroy(), a3.contentGroup.clip());
              a3.contentGroup.div && (a3.contentGroup.div.style.clip = b2 ? "rect(" + l3 + "px,9999px," + (l3 + b2) + "px,0)" : "auto");
            }, u2 = function(b2) {
              a3[b2] = e2.circle(0, 0, 1.3 * p2).translate(p2 / 2, p2 / 2).add(O);
              c.styledMode || a3[b2].attr("fill", "rgba(0,0,0,0.0001)");
              return a3[b2];
            };
            let x2, J, N;
            k2 = c.spacingBox.height + (h3 ? -k2 : k2) - l3;
            let O = this.nav, E2 = this.clipRect;
            g2.layout !== "horizontal" || g2.verticalAlign === "middle" || g2.floating || (k2 /= 2);
            m2 && (k2 = Math.min(k2, m2));
            t2.length = 0;
            b && 0 < k2 && b > k2 && q2.enabled !== false ? (this.clipHeight = x2 = Math.max(k2 - 20 - this.titleHeight - l3, 0), this.currentPage = d(this.currentPage, 1), this.fullHeight = b, w2.forEach((b2, a4) => {
              N = b2.legendItem || {};
              b2 = N.y || 0;
              const c2 = Math.round(N.label.getBBox().height);
              let d2 = t2.length;
              if (!d2 || b2 - t2[d2 - 1] > x2 && (J || b2) !== t2[d2 - 1])
                t2.push(J || b2), d2++;
              N.pageIx = d2 - 1;
              J && ((w2[a4 - 1].legendItem || {}).pageIx = d2 - 1);
              a4 === w2.length - 1 && b2 + c2 - t2[d2 - 1] > x2 && b2 > t2[d2 - 1] && (t2.push(b2), N.pageIx = d2);
              b2 !== J && (J = b2);
            }), E2 || (E2 = a3.clipRect = e2.clipRect(0, l3 - 2, 9999, 0), a3.contentGroup.clip(E2)), v2(x2), O || (this.nav = O = e2.g().attr({ zIndex: 1 }).add(this.group), this.up = e2.symbol("triangle", 0, 0, p2, p2).add(O), u2("upTracker").on("click", function() {
              a3.scroll(-1, r2);
            }), this.pager = e2.text("", 15, 10).addClass("highcharts-legend-navigation"), !c.styledMode && q2.style && this.pager.css(q2.style), this.pager.add(O), this.down = e2.symbol("triangle-down", 0, 0, p2, p2).add(O), u2("downTracker").on("click", function() {
              a3.scroll(1, r2);
            })), a3.scroll(0), b = k2) : O && (v2(), this.nav = O.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0);
            return b;
          }
          scroll(b, a3) {
            const c = this.chart, f = this.pages, e2 = f.length, g2 = this.clipHeight, k2 = this.options.navigation, h3 = this.pager, l3 = this.padding;
            let m2 = this.currentPage + b;
            m2 > e2 && (m2 = e2);
            0 < m2 && (typeof a3 !== "undefined" && B(a3, c), this.nav.attr({ translateX: l3, translateY: g2 + this.padding + 7 + this.titleHeight, visibility: "inherit" }), [this.up, this.upTracker].forEach(function(b2) {
              b2.attr({ "class": m2 === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
            }), h3.attr({ text: m2 + "/" + e2 }), [this.down, this.downTracker].forEach(function(b2) {
              b2.attr({ x: 18 + this.pager.getBBox().width, "class": m2 === e2 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
            }, this), c.styledMode || (this.up.attr({ fill: m2 === 1 ? k2.inactiveColor : k2.activeColor }), this.upTracker.css({ cursor: m2 === 1 ? "default" : "pointer" }), this.down.attr({ fill: m2 === e2 ? k2.inactiveColor : k2.activeColor }), this.downTracker.css({ cursor: m2 === e2 ? "default" : "pointer" })), this.scrollOffset = -f[m2 - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: this.scrollOffset }), this.currentPage = m2, this.positionCheckboxes(), b = x(d(a3, c.renderer.globalAnimation, true)), q(() => {
              w(this, "afterScroll", { currentPage: m2 });
            }, b.duration));
          }
          setItemEvents(b, a3, c) {
            const d2 = this, f = b.legendItem || {}, e2 = d2.chart.renderer.boxWrapper, g2 = b instanceof L, k2 = "highcharts-legend-" + (g2 ? "point" : "series") + "-active", h3 = d2.chart.styledMode;
            c = c ? [a3, f.symbol] : [f.group];
            const l3 = (a4) => {
              d2.allItems.forEach((c2) => {
                b !== c2 && [c2].concat(c2.linkedSeries || []).forEach((b2) => {
                  b2.setState(a4, !g2);
                });
              });
            };
            for (const f2 of c)
              if (f2)
                f2.on("mouseover", function() {
                  b.visible && l3("inactive");
                  b.setState("hover");
                  b.visible && e2.addClass(k2);
                  h3 || a3.css(d2.options.itemHoverStyle);
                }).on("mouseout", function() {
                  d2.chart.styledMode || a3.css(F(b.visible ? d2.itemStyle : d2.itemHiddenStyle));
                  l3("");
                  e2.removeClass(k2);
                  b.setState();
                }).on("click", function(a4) {
                  const c2 = function() {
                    b.setVisible && b.setVisible();
                    l3(b.visible ? "inactive" : "");
                  };
                  e2.removeClass(k2);
                  a4 = { browserEvent: a4 };
                  b.firePointEvent ? b.firePointEvent("legendItemClick", a4, c2) : w(b, "legendItemClick", a4, c2);
                });
          }
          createCheckboxForItem(b) {
            b.checkbox = t("input", {
              type: "checkbox",
              className: "highcharts-legend-checkbox",
              checked: b.selected,
              defaultChecked: b.selected
            }, this.options.itemCheckboxStyle, this.chart.container);
            p(b.checkbox, "click", function(a3) {
              w(b.series || b, "checkboxClick", { checked: a3.target.checked, item: b }, function() {
                b.select();
              });
            });
          }
        }
        (function(b) {
          const a3 = [];
          b.compose = function(c) {
            z.pushUnique(a3, c) && p(c, "beforeMargins", function() {
              this.legend = new b(this, this.options.legend);
            });
          };
        })(G || (G = {}));
        "";
        return G;
      });
      M(a, "Core/Legend/LegendSymbol.js", [a["Core/Utilities.js"]], function(a2) {
        const { extend: x, merge: I, pick: L } = a2;
        var C;
        (function(a3) {
          a3.lineMarker = function(a4, B) {
            B = this.legendItem = this.legendItem || {};
            var u = this.options;
            const v = a4.symbolWidth, l2 = a4.symbolHeight, p = l2 / 2, t = this.chart.renderer, m = B.group;
            a4 = a4.baseline - Math.round(0.3 * a4.fontMetrics.b);
            let h = {}, g = u.marker, e = 0;
            this.chart.styledMode || (h = { "stroke-width": Math.min(u.lineWidth || 0, 24) }, u.dashStyle ? h.dashstyle = u.dashStyle : u.linecap !== "square" && (h["stroke-linecap"] = "round"));
            B.line = t.path().addClass("highcharts-graph").attr(h).add(m);
            h["stroke-linecap"] && (e = Math.min(B.line.strokeWidth(), v) / 2);
            v && B.line.attr({ d: [["M", e, a4], ["L", v - e, a4]] });
            g && g.enabled !== false && v && (u = Math.min(L(g.radius, p), p), this.symbol.indexOf("url") === 0 && (g = I(g, { width: l2, height: l2 }), u = 0), B.symbol = B = t.symbol(this.symbol, v / 2 - u, a4 - u, 2 * u, 2 * u, x({ context: "legend" }, g)).addClass("highcharts-point").add(m), B.isMarker = true);
          };
          a3.rectangle = function(a4, x2) {
            x2 = x2.legendItem || {};
            const u = a4.symbolHeight, v = a4.options.squareSymbol;
            x2.symbol = this.chart.renderer.rect(v ? (a4.symbolWidth - u) / 2 : 0, a4.baseline - u + 1, v ? u : a4.symbolWidth, u, L(a4.options.symbolRadius, u / 2)).addClass("highcharts-point").attr({ zIndex: 3 }).add(x2.group);
          };
        })(C || (C = {}));
        return C;
      });
      M(a, "Core/Series/SeriesDefaults.js", [], function() {
        return {
          lineWidth: 1,
          allowPointSelect: false,
          crisp: true,
          showCheckbox: false,
          animation: { duration: 1e3 },
          enableMouseTracking: true,
          events: {},
          marker: { enabledThreshold: 2, lineColor: "#ffffff", lineWidth: 0, radius: 4, states: { normal: { animation: true }, hover: { animation: { duration: 150 }, enabled: true, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2 } } },
          point: { events: {} },
          dataLabels: { animation: {}, align: "center", borderWidth: 0, defer: true, formatter: function() {
            const { numberFormatter: a2 } = this.series.chart;
            return typeof this.y !== "number" ? "" : a2(this.y, -1);
          }, padding: 5, style: { fontSize: "0.7em", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0 },
          cropThreshold: 300,
          opacity: 1,
          pointRange: 0,
          softThreshold: true,
          states: {
            normal: { animation: true },
            hover: { animation: { duration: 150 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: 0.25 } },
            select: { animation: { duration: 0 } },
            inactive: { animation: { duration: 150 }, opacity: 0.2 }
          },
          stickyTracking: true,
          turboThreshold: 1e3,
          findNearestPointBy: "x"
        };
      });
      M(a, "Core/Series/SeriesRegistry.js", [a["Core/Globals.js"], a["Core/Defaults.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function(a2, y, I, L) {
        const { defaultOptions: x } = y, { extendClass: z, merge: H } = L;
        var B;
        (function(u) {
          function v(a3, p) {
            const l2 = x.plotOptions || {}, m = p.defaultOptions, h = p.prototype;
            h.type = a3;
            h.pointClass || (h.pointClass = I);
            m && (l2[a3] = m);
            u.seriesTypes[a3] = p;
          }
          u.seriesTypes = a2.seriesTypes;
          u.registerSeriesType = v;
          u.seriesType = function(a3, p, t, m, h) {
            const g = x.plotOptions || {};
            p = p || "";
            g[a3] = H(g[p], t);
            v(a3, z(u.seriesTypes[p] || function() {
            }, m));
            u.seriesTypes[a3].prototype.type = a3;
            h && (u.seriesTypes[a3].prototype.pointClass = z(I, h));
            return u.seriesTypes[a3];
          };
        })(B || (B = {}));
        return B;
      });
      M(a, "Core/Series/Series.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Defaults.js"],
        a["Core/Foundation.js"],
        a["Core/Globals.js"],
        a["Core/Legend/LegendSymbol.js"],
        a["Core/Series/Point.js"],
        a["Core/Series/SeriesDefaults.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, I, L, C, z, H, B, u, v) {
        const { animObject: l2, setAnimation: p } = a2, { defaultOptions: t } = y, { registerEventOptions: m } = I, { hasTouch: h, svg: g, win: e } = L, { seriesTypes: w } = B, {
          arrayMax: x,
          arrayMin: F,
          clamp: d,
          correctFloat: k,
          defined: r,
          diffObjects: q,
          erase: G,
          error: b,
          extend: f,
          find: c,
          fireEvent: n3,
          getClosestDistance: P,
          getNestedProperty: D,
          insertItem: K,
          isArray: X,
          isNumber: T,
          isString: Z,
          merge: V,
          objectEach: Y,
          pick: A,
          removeEvent: M2,
          splat: ia,
          syncTimeout: ba
        } = v;
        class aa {
          constructor() {
            this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
          }
          init(b2, a3) {
            n3(this, "init", { options: a3 });
            const c2 = this, d2 = b2.series;
            this.eventsToUnbind = [];
            c2.chart = b2;
            c2.options = c2.setOptions(a3);
            a3 = c2.options;
            c2.linkedSeries = [];
            c2.bindAxes();
            f(c2, { name: a3.name, state: "", visible: a3.visible !== false, selected: a3.selected === true });
            m(this, a3);
            const e2 = a3.events;
            if (e2 && e2.click || a3.point && a3.point.events && a3.point.events.click || a3.allowPointSelect)
              b2.runTrackerClick = true;
            c2.getColor();
            c2.getSymbol();
            c2.parallelArrays.forEach(function(b3) {
              c2[b3 + "Data"] || (c2[b3 + "Data"] = []);
            });
            c2.isCartesian && (b2.hasCartesianSeries = true);
            let g2;
            d2.length && (g2 = d2[d2.length - 1]);
            c2._i = A(g2 && g2._i, -1) + 1;
            c2.opacity = c2.options.opacity;
            b2.orderItems("series", K(this, d2));
            a3.dataSorting && a3.dataSorting.enabled ? c2.setDataSortingOptions() : c2.points || c2.data || c2.setData(a3.data, false);
            n3(this, "afterInit");
          }
          is(b2) {
            return w[b2] && this instanceof w[b2];
          }
          bindAxes() {
            const a3 = this, c2 = a3.options, d2 = a3.chart;
            let f2;
            n3(this, "bindAxes", null, function() {
              (a3.axisTypes || []).forEach(function(e2) {
                d2[e2].forEach(function(b2) {
                  f2 = b2.options;
                  if (A(c2[e2], 0) === b2.index || typeof c2[e2] !== "undefined" && c2[e2] === f2.id)
                    K(a3, b2.series), a3[e2] = b2, b2.isDirty = true;
                });
                a3[e2] || a3.optionalAxis === e2 || b(18, true, d2);
              });
            });
            n3(this, "afterBindAxes");
          }
          updateParallelArrays(b2, a3, c2) {
            const d2 = b2.series, f2 = T(a3) ? function(c3) {
              const f3 = c3 === "y" && d2.toYData ? d2.toYData(b2) : b2[c3];
              d2[c3 + "Data"][a3] = f3;
            } : function(b3) {
              Array.prototype[a3].apply(d2[b3 + "Data"], c2);
            };
            d2.parallelArrays.forEach(f2);
          }
          hasData() {
            return this.visible && typeof this.dataMax !== "undefined" && typeof this.dataMin !== "undefined" || this.visible && this.yData && 0 < this.yData.length;
          }
          autoIncrement(b2) {
            var a3 = this.options;
            const c2 = a3.pointIntervalUnit, d2 = a3.relativeXValue, f2 = this.chart.time;
            let e2 = this.xIncrement, g2;
            e2 = A(e2, a3.pointStart, 0);
            this.pointInterval = g2 = A(this.pointInterval, a3.pointInterval, 1);
            d2 && T(b2) && (g2 *= b2);
            c2 && (a3 = new f2.Date(e2), c2 === "day" ? f2.set("Date", a3, f2.get("Date", a3) + g2) : c2 === "month" ? f2.set("Month", a3, f2.get("Month", a3) + g2) : c2 === "year" && f2.set("FullYear", a3, f2.get("FullYear", a3) + g2), g2 = a3.getTime() - e2);
            if (d2 && T(b2))
              return e2 + g2;
            this.xIncrement = e2 + g2;
            return e2;
          }
          setDataSortingOptions() {
            const b2 = this.options;
            f(this, { requireSorting: false, sorted: false, enabledDataSorting: true, allowDG: false });
            r(b2.pointRange) || (b2.pointRange = 1);
          }
          setOptions(b2) {
            var a3, c2;
            const d2 = this.chart;
            var f2 = d2.options.plotOptions, e2 = d2.userOptions || {};
            const g2 = V(b2);
            b2 = d2.styledMode;
            const k2 = { plotOptions: f2, userOptions: g2 };
            n3(this, "setOptions", k2);
            const h3 = k2.plotOptions[this.type];
            e2 = e2.plotOptions || {};
            const l3 = e2.series || {}, m2 = t.plotOptions[this.type] || {}, q2 = e2[this.type] || {};
            this.userOptions = k2.userOptions;
            f2 = V(h3, f2.series, q2, g2);
            this.tooltipOptions = V(t.tooltip, (a3 = t.plotOptions.series) === null || a3 === void 0 ? void 0 : a3.tooltip, m2 === null || m2 === void 0 ? void 0 : m2.tooltip, d2.userOptions.tooltip, (c2 = e2.series) === null || c2 === void 0 ? void 0 : c2.tooltip, q2.tooltip, g2.tooltip);
            this.stickyTracking = A(g2.stickyTracking, q2.stickyTracking, l3.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : f2.stickyTracking);
            h3.marker === null && delete f2.marker;
            this.zoneAxis = f2.zoneAxis;
            c2 = this.zones = (f2.zones || []).slice();
            !f2.negativeColor && !f2.negativeFillColor || f2.zones || (a3 = { value: f2[this.zoneAxis + "Threshold"] || f2.threshold || 0, className: "highcharts-negative" }, b2 || (a3.color = f2.negativeColor, a3.fillColor = f2.negativeFillColor), c2.push(a3));
            c2.length && r(c2[c2.length - 1].value) && c2.push(b2 ? {} : { color: this.color, fillColor: this.fillColor });
            n3(this, "afterSetOptions", { options: f2 });
            return f2;
          }
          getName() {
            return A(this.options.name, "Series " + (this.index + 1));
          }
          getCyclic(b2, a3, c2) {
            const d2 = this.chart, f2 = `${b2}Index`, e2 = `${b2}Counter`, g2 = (c2 === null || c2 === void 0 ? void 0 : c2.length) || d2.options.chart.colorCount;
            if (!a3) {
              var k2 = A(b2 === "color" ? this.options.colorIndex : void 0, this[f2]);
              r(k2) || (d2.series.length || (d2[e2] = 0), k2 = d2[e2] % g2, d2[e2] += 1);
              c2 && (a3 = c2[k2]);
            }
            typeof k2 !== "undefined" && (this[f2] = k2);
            this[b2] = a3;
          }
          getColor() {
            this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || t.plotOptions[this.type].color, this.chart.options.colors);
          }
          getPointsCollection() {
            return (this.hasGroupedData ? this.points : this.data) || [];
          }
          getSymbol() {
            this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
          }
          findPointIndex(b2, a3) {
            const d2 = b2.id, f2 = b2.x, e2 = this.points;
            var g2 = this.options.dataSorting, k2;
            let h3, n4;
            if (d2)
              g2 = this.chart.get(d2), g2 instanceof z && (k2 = g2);
            else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
              if (k2 = (a4) => !a4.touched && a4.index === b2.index, g2 && g2.matchByName ? k2 = (a4) => !a4.touched && a4.name === b2.name : this.options.relativeXValue && (k2 = (a4) => !a4.touched && a4.options.x === b2.x), k2 = c(e2, k2), !k2)
                return;
            }
            k2 && (n4 = k2 && k2.index, typeof n4 !== "undefined" && (h3 = true));
            typeof n4 === "undefined" && T(f2) && (n4 = this.xData.indexOf(f2, a3));
            n4 !== -1 && typeof n4 !== "undefined" && this.cropped && (n4 = n4 >= this.cropStart ? n4 - this.cropStart : n4);
            !h3 && T(n4) && e2[n4] && e2[n4].touched && (n4 = void 0);
            return n4;
          }
          updateData(b2, a3) {
            const c2 = this.options, d2 = c2.dataSorting, f2 = this.points, e2 = [], g2 = this.requireSorting, k2 = b2.length === f2.length;
            let n4, h3, l3, m2 = true;
            this.xIncrement = null;
            b2.forEach(function(b3, a4) {
              var h4 = r(b3) && this.pointClass.prototype.optionsToObject.call({ series: this }, b3) || {};
              const m3 = h4.x;
              if (h4.id || T(m3)) {
                if (h4 = this.findPointIndex(h4, l3), h4 === -1 || typeof h4 === "undefined" ? e2.push(b3) : f2[h4] && b3 !== c2.data[h4] ? (f2[h4].update(b3, false, null, false), f2[h4].touched = true, g2 && (l3 = h4 + 1)) : f2[h4] && (f2[h4].touched = true), !k2 || a4 !== h4 || d2 && d2.enabled || this.hasDerivedData)
                  n4 = true;
              } else
                e2.push(b3);
            }, this);
            if (n4)
              for (b2 = f2.length; b2--; )
                (h3 = f2[b2]) && !h3.touched && h3.remove && h3.remove(false, a3);
            else
              !k2 || d2 && d2.enabled ? m2 = false : (b2.forEach(function(b3, a4) {
                b3 === f2[a4].y || f2[a4].destroyed || f2[a4].update(b3, false, null, false);
              }), e2.length = 0);
            f2.forEach(function(b3) {
              b3 && (b3.touched = false);
            });
            if (!m2)
              return false;
            e2.forEach(function(b3) {
              this.addPoint(b3, false, null, null, false);
            }, this);
            this.xIncrement === null && this.xData && this.xData.length && (this.xIncrement = x(this.xData), this.autoIncrement());
            return true;
          }
          setData(a3, c2 = true, d2, f2) {
            var e2;
            const g2 = this, k2 = g2.points, h3 = k2 && k2.length || 0, n4 = g2.options, l3 = g2.chart, m2 = n4.dataSorting, q2 = g2.xAxis, p2 = n4.turboThreshold, r2 = this.xData, t2 = this.yData;
            var w2 = g2.pointArrayMap;
            w2 = w2 && w2.length;
            const J = n4.keys;
            let v2, u2 = 0, O = 1, x2 = null;
            if (!l3.options.chart.allowMutatingData) {
              n4.data && delete g2.options.data;
              g2.userOptions.data && delete g2.userOptions.data;
              var N = V(true, a3);
            }
            a3 = N || a3 || [];
            N = a3.length;
            m2 && m2.enabled && (a3 = this.sortData(a3));
            l3.options.chart.allowMutatingData && f2 !== false && N && h3 && !g2.cropped && !g2.hasGroupedData && g2.visible && !g2.boosted && (v2 = this.updateData(a3, d2));
            if (!v2) {
              g2.xIncrement = null;
              g2.colorCounter = 0;
              this.parallelArrays.forEach(function(b2) {
                g2[b2 + "Data"].length = 0;
              });
              if (p2 && N > p2)
                if (x2 = g2.getFirstValidPoint(a3), T(x2))
                  for (d2 = 0; d2 < N; d2++)
                    r2[d2] = this.autoIncrement(), t2[d2] = a3[d2];
                else if (X(x2))
                  if (w2)
                    if (x2.length === w2)
                      for (d2 = 0; d2 < N; d2++)
                        r2[d2] = this.autoIncrement(), t2[d2] = a3[d2];
                    else
                      for (d2 = 0; d2 < N; d2++)
                        f2 = a3[d2], r2[d2] = f2[0], t2[d2] = f2.slice(1, w2 + 1);
                  else if (J && (u2 = J.indexOf("x"), O = J.indexOf("y"), u2 = 0 <= u2 ? u2 : 0, O = 0 <= O ? O : 1), x2.length === 1 && (O = 0), u2 === O)
                    for (d2 = 0; d2 < N; d2++)
                      r2[d2] = this.autoIncrement(), t2[d2] = a3[d2][O];
                  else
                    for (d2 = 0; d2 < N; d2++)
                      f2 = a3[d2], r2[d2] = f2[u2], t2[d2] = f2[O];
                else
                  b(12, false, l3);
              else
                for (d2 = 0; d2 < N; d2++)
                  f2 = { series: g2 }, g2.pointClass.prototype.applyOptions.apply(f2, [a3[d2]]), g2.updateParallelArrays(f2, d2);
              t2 && Z(t2[0]) && b(14, true, l3);
              g2.data = [];
              g2.options.data = g2.userOptions.data = a3;
              for (d2 = h3; d2--; )
                (e2 = k2[d2]) === null || e2 === void 0 ? void 0 : e2.destroy();
              q2 && (q2.minRange = q2.userMinRange);
              g2.isDirty = l3.isDirtyBox = true;
              g2.isDirtyData = !!k2;
              d2 = false;
            }
            n4.legendType === "point" && (this.processData(), this.generatePoints());
            c2 && l3.redraw(d2);
          }
          sortData(b2) {
            const a3 = this, c2 = a3.options.dataSorting.sortKey || "y", d2 = function(b3, a4) {
              return r(a4) && b3.pointClass.prototype.optionsToObject.call({ series: b3 }, a4) || {};
            };
            b2.forEach(function(c3, f2) {
              b2[f2] = d2(a3, c3);
              b2[f2].index = f2;
            }, this);
            b2.concat().sort((b3, a4) => {
              b3 = D(c2, b3);
              a4 = D(c2, a4);
              return a4 < b3 ? -1 : a4 > b3 ? 1 : 0;
            }).forEach(function(b3, a4) {
              b3.x = a4;
            }, this);
            a3.linkedSeries && a3.linkedSeries.forEach(function(a4) {
              const c3 = a4.options, f2 = c3.data;
              c3.dataSorting && c3.dataSorting.enabled || !f2 || (f2.forEach(function(c4, e2) {
                f2[e2] = d2(a4, c4);
                b2[e2] && (f2[e2].x = b2[e2].x, f2[e2].index = e2);
              }), a4.setData(f2, false));
            });
            return b2;
          }
          getProcessedData(a3) {
            const c2 = this;
            var d2 = c2.xAxis, f2 = c2.options;
            const e2 = f2.cropThreshold, g2 = a3 || c2.getExtremesFromAll || f2.getExtremesFromAll, k2 = d2 === null || d2 === void 0 ? void 0 : d2.logarithmic, h3 = c2.isCartesian;
            let n4 = 0;
            let l3;
            a3 = c2.xData;
            f2 = c2.yData;
            let m2 = false;
            const q2 = a3.length;
            if (d2) {
              var r2 = d2.getExtremes();
              l3 = r2.min;
              r2 = r2.max;
              m2 = !(!d2.categories || d2.names.length);
            }
            if (h3 && c2.sorted && !g2 && (!e2 || q2 > e2 || c2.forceCrop)) {
              if (a3[q2 - 1] < l3 || a3[0] > r2)
                a3 = [], f2 = [];
              else if (c2.yData && (a3[0] < l3 || a3[q2 - 1] > r2)) {
                var p2 = this.cropData(c2.xData, c2.yData, l3, r2);
                a3 = p2.xData;
                f2 = p2.yData;
                n4 = p2.start;
                p2 = true;
              }
            }
            d2 = P([k2 ? a3.map(k2.log2lin) : a3], () => c2.requireSorting && !m2 && b(15, false, c2.chart));
            return { xData: a3, yData: f2, cropped: p2, cropStart: n4, closestPointRange: d2 };
          }
          processData(b2) {
            const a3 = this.xAxis;
            if (this.isCartesian && !this.isDirty && !a3.isDirty && !this.yAxis.isDirty && !b2)
              return false;
            b2 = this.getProcessedData();
            this.cropped = b2.cropped;
            this.cropStart = b2.cropStart;
            this.processedXData = b2.xData;
            this.processedYData = b2.yData;
            this.closestPointRange = this.basePointRange = b2.closestPointRange;
            n3(this, "afterProcessData");
          }
          cropData(b2, a3, c2, d2, f2) {
            const e2 = b2.length;
            let g2, k2 = 0, h3 = e2;
            f2 = A(f2, this.cropShoulder);
            for (g2 = 0; g2 < e2; g2++)
              if (b2[g2] >= c2) {
                k2 = Math.max(0, g2 - f2);
                break;
              }
            for (c2 = g2; c2 < e2; c2++)
              if (b2[c2] > d2) {
                h3 = c2 + f2;
                break;
              }
            return {
              xData: b2.slice(k2, h3),
              yData: a3.slice(k2, h3),
              start: k2,
              end: h3
            };
          }
          generatePoints() {
            var b2 = this.options;
            const a3 = this.processedData || b2.data, c2 = this.processedXData, d2 = this.processedYData, e2 = this.pointClass, g2 = c2.length, k2 = this.cropStart || 0, h3 = this.hasGroupedData, l3 = b2.keys, m2 = [];
            b2 = b2.dataGrouping && b2.dataGrouping.groupAll ? k2 : 0;
            let q2;
            let r2, p2, t2 = this.data;
            if (!t2 && !h3) {
              var w2 = [];
              w2.length = a3.length;
              t2 = this.data = w2;
            }
            l3 && h3 && (this.options.keys = false);
            for (p2 = 0; p2 < g2; p2++)
              w2 = k2 + p2, h3 ? (r2 = new e2().init(this, [c2[p2]].concat(ia(d2[p2]))), r2.dataGroup = this.groupMap[b2 + p2], r2.dataGroup.options && (r2.options = r2.dataGroup.options, f(r2, r2.dataGroup.options), delete r2.dataLabels)) : (r2 = t2[w2]) || typeof a3[w2] === "undefined" || (t2[w2] = r2 = new e2().init(this, a3[w2], c2[p2])), r2 && (r2.index = h3 ? b2 + p2 : w2, m2[p2] = r2);
            this.options.keys = l3;
            if (t2 && (g2 !== (q2 = t2.length) || h3))
              for (p2 = 0; p2 < q2; p2++)
                p2 !== k2 || h3 || (p2 += g2), t2[p2] && (t2[p2].destroyElements(), t2[p2].plotX = void 0);
            this.data = t2;
            this.points = m2;
            n3(this, "afterGeneratePoints");
          }
          getXExtremes(b2) {
            return { min: F(b2), max: x(b2) };
          }
          getExtremes(b2, a3) {
            const c2 = this.xAxis;
            var d2 = this.yAxis;
            const f2 = this.processedXData || this.xData, e2 = [], g2 = this.requireSorting ? this.cropShoulder : 0;
            d2 = d2 ? d2.positiveValuesOnly : false;
            let k2, h3 = 0, l3 = 0, m2 = 0;
            b2 = b2 || this.stackedYData || this.processedYData || [];
            const q2 = b2.length;
            if (c2) {
              var p2 = c2.getExtremes();
              h3 = p2.min;
              l3 = p2.max;
            }
            for (k2 = 0; k2 < q2; k2++) {
              var r2 = f2[k2];
              p2 = b2[k2];
              var t2 = (T(p2) || X(p2)) && (p2.length || 0 < p2 || !d2);
              r2 = a3 || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c2 || (f2[k2 + g2] || r2) >= h3 && (f2[k2 - g2] || r2) <= l3;
              if (t2 && r2)
                if (t2 = p2.length)
                  for (; t2--; )
                    T(p2[t2]) && (e2[m2++] = p2[t2]);
                else
                  e2[m2++] = p2;
            }
            b2 = { activeYData: e2, dataMin: F(e2), dataMax: x(e2) };
            n3(this, "afterGetExtremes", { dataExtremes: b2 });
            return b2;
          }
          applyExtremes() {
            const b2 = this.getExtremes();
            this.dataMin = b2.dataMin;
            this.dataMax = b2.dataMax;
            return b2;
          }
          getFirstValidPoint(b2) {
            const a3 = b2.length;
            let c2 = 0, d2 = null;
            for (; d2 === null && c2 < a3; )
              d2 = b2[c2], c2++;
            return d2;
          }
          translate() {
            var b2;
            this.processedXData || this.processData();
            this.generatePoints();
            var a3 = this.options;
            const c2 = a3.stacking, f2 = this.xAxis, e2 = f2.categories, g2 = this.enabledDataSorting, h3 = this.yAxis, l3 = this.points, m2 = l3.length, q2 = this.pointPlacementToXValue(), p2 = !!q2, t2 = a3.threshold;
            a3 = a3.startFromThreshold ? t2 : 0;
            let w2, v2, u2, x2, D2 = Number.MAX_VALUE;
            for (w2 = 0; w2 < m2; w2++) {
              const n4 = l3[w2], m3 = n4.x;
              let J, Q, R = n4.y, O = n4.low;
              const E = c2 && ((b2 = h3.stacking) === null || b2 === void 0 ? void 0 : b2.stacks[(this.negStacks && R < (a3 ? 0 : t2) ? "-" : "") + this.stackKey]);
              v2 = f2.translate(m3, false, false, false, true, q2);
              n4.plotX = T(v2) ? k(d(v2, -1e5, 1e5)) : void 0;
              c2 && this.visible && E && E[m3] && (x2 = this.getStackIndicator(x2, m3, this.index), !n4.isNull && x2.key && (J = E[m3], Q = J.points[x2.key]), J && X(Q) && (O = Q[0], R = Q[1], O === a3 && x2.key === E[m3].base && (O = A(T(t2) ? t2 : h3.min)), h3.positiveValuesOnly && r(O) && 0 >= O && (O = void 0), n4.total = n4.stackTotal = A(J.total), n4.percentage = r(n4.y) && J.total ? n4.y / J.total * 100 : void 0, n4.stackY = R, this.irregularWidths || J.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis)));
              n4.yBottom = r(O) ? d(h3.translate(O, false, true, false, true), -1e5, 1e5) : void 0;
              this.dataModify && (R = this.dataModify.modifyValue(R, w2));
              let N;
              T(R) && n4.plotX !== void 0 && (N = h3.translate(R, false, true, false, true), N = T(N) ? d(N, -1e5, 1e5) : void 0);
              n4.plotY = N;
              n4.isInside = this.isPointInside(n4);
              n4.clientX = p2 ? k(f2.translate(m3, false, false, false, true, q2)) : v2;
              n4.negative = (n4.y || 0) < (t2 || 0);
              n4.category = A(e2 && e2[n4.x], n4.x);
              n4.isNull || n4.visible === false || (typeof u2 !== "undefined" && (D2 = Math.min(D2, Math.abs(v2 - u2))), u2 = v2);
              n4.zone = this.zones.length ? n4.getZone() : void 0;
              !n4.graphic && this.group && g2 && (n4.isNew = true);
            }
            this.closestPointRangePx = D2;
            n3(this, "afterTranslate");
          }
          getValidPoints(b2, a3, c2) {
            const d2 = this.chart;
            return (b2 || this.points || []).filter(function(b3) {
              const { plotX: f2, plotY: e2 } = b3;
              return !c2 && (b3.isNull || !T(e2)) || a3 && !d2.isInsidePlot(f2, e2, { inverted: d2.inverted }) ? false : b3.visible !== false;
            });
          }
          getClipBox() {
            const { chart: b2, xAxis: a3, yAxis: c2 } = this, d2 = V(b2.clipBox);
            a3 && a3.len !== b2.plotSizeX && (d2.width = a3.len);
            c2 && c2.len !== b2.plotSizeY && (d2.height = c2.len);
            return d2;
          }
          getSharedClipKey() {
            return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
          }
          setClip() {
            const { chart: b2, group: a3, markerGroup: c2 } = this, d2 = b2.sharedClips, f2 = b2.renderer, e2 = this.getClipBox(), g2 = this.getSharedClipKey();
            let k2 = d2[g2];
            k2 ? k2.animate(e2) : d2[g2] = k2 = f2.clipRect(e2);
            a3 && a3.clip(this.options.clip === false ? void 0 : k2);
            c2 && c2.clip();
          }
          animate(b2) {
            const { chart: a3, group: c2, markerGroup: d2 } = this, f2 = a3.inverted;
            var e2 = l2(this.options.animation), g2 = [this.getSharedClipKey(), e2.duration, e2.easing, e2.defer].join();
            let k2 = a3.sharedClips[g2], n4 = a3.sharedClips[g2 + "m"];
            if (b2 && c2)
              e2 = this.getClipBox(), k2 ? k2.attr("height", e2.height) : (e2.width = 0, f2 && (e2.x = a3.plotHeight), k2 = a3.renderer.clipRect(e2), a3.sharedClips[g2] = k2, n4 = a3.renderer.clipRect({ x: -99, y: -99, width: f2 ? a3.plotWidth + 199 : 99, height: f2 ? 99 : a3.plotHeight + 199 }), a3.sharedClips[g2 + "m"] = n4), c2.clip(k2), d2 && d2.clip(n4);
            else if (k2 && !k2.hasClass("highcharts-animating")) {
              g2 = this.getClipBox();
              const b3 = e2.step;
              d2 && d2.element.childNodes.length && (e2.step = function(a4, c3) {
                b3 && b3.apply(c3, arguments);
                c3.prop === "width" && n4 && n4.element && n4.attr(f2 ? "height" : "width", a4 + 99);
              });
              k2.addClass("highcharts-animating").animate(g2, e2);
            }
          }
          afterAnimate() {
            this.setClip();
            Y(this.chart.sharedClips, (b2, a3, c2) => {
              b2 && !this.chart.container.querySelector(`[clip-path="url(#${b2.id})"]`) && (b2.destroy(), delete c2[a3]);
            });
            this.finishedAnimating = true;
            n3(this, "afterAnimate");
          }
          drawPoints(b2 = this.points) {
            const a3 = this.chart, c2 = a3.styledMode, { colorAxis: d2, options: f2 } = this, e2 = f2.marker, g2 = this[this.specialGroup || "markerGroup"], k2 = this.xAxis, n4 = A(e2.enabled, !k2 || k2.isRadial ? true : null, this.closestPointRangePx >= e2.enabledThreshold * e2.radius);
            let h3, l3, m2, q2;
            let p2, r2;
            if (e2.enabled !== false || this._hasPointMarkers)
              for (h3 = 0; h3 < b2.length; h3++) {
                l3 = b2[h3];
                q2 = (m2 = l3.graphic) ? "animate" : "attr";
                var t2 = l3.marker || {};
                p2 = !!l3.marker;
                if ((n4 && typeof t2.enabled === "undefined" || t2.enabled) && !l3.isNull && l3.visible !== false) {
                  const b3 = A(t2.symbol, this.symbol, "rect");
                  r2 = this.markerAttribs(l3, l3.selected && "select");
                  this.enabledDataSorting && (l3.startXPos = k2.reversed ? -(r2.width || 0) : k2.width);
                  const f3 = l3.isInside !== false;
                  !m2 && f3 && (0 < (r2.width || 0) || l3.hasImage) && (l3.graphic = m2 = a3.renderer.symbol(b3, r2.x, r2.y, r2.width, r2.height, p2 ? t2 : e2).add(g2), this.enabledDataSorting && a3.hasRendered && (m2.attr({ x: l3.startXPos }), q2 = "animate"));
                  m2 && q2 === "animate" && m2[f3 ? "show" : "hide"](f3).animate(r2);
                  if (m2)
                    if (t2 = this.pointAttribs(l3, c2 || !l3.selected ? void 0 : "select"), c2)
                      d2 && m2.css({ fill: t2.fill });
                    else
                      m2[q2](t2);
                  m2 && m2.addClass(l3.getClassName(), true);
                } else
                  m2 && (l3.graphic = m2.destroy());
              }
          }
          markerAttribs(b2, a3) {
            const c2 = this.options;
            var d2 = c2.marker;
            const f2 = b2.marker || {}, e2 = f2.symbol || d2.symbol, g2 = {};
            let k2 = A(f2.radius, d2 && d2.radius);
            a3 && (d2 = d2.states[a3], a3 = f2.states && f2.states[a3], k2 = A(a3 && a3.radius, d2 && d2.radius, k2 && k2 + (d2 && d2.radiusPlus || 0)));
            b2.hasImage = e2 && e2.indexOf("url") === 0;
            b2.hasImage && (k2 = 0);
            b2 = b2.pos();
            T(k2) && b2 && (g2.x = b2[0] - k2, g2.y = b2[1] - k2, c2.crisp && (g2.x = Math.floor(g2.x)));
            k2 && (g2.width = g2.height = 2 * k2);
            return g2;
          }
          pointAttribs(b2, a3) {
            var c2 = this.options.marker, d2 = b2 && b2.options;
            const f2 = d2 && d2.marker || {};
            var e2 = d2 && d2.color, g2 = b2 && b2.color;
            const k2 = b2 && b2.zone && b2.zone.color;
            let n4 = this.color;
            b2 = A(f2.lineWidth, c2.lineWidth);
            d2 = 1;
            n4 = e2 || k2 || g2 || n4;
            e2 = f2.fillColor || c2.fillColor || n4;
            g2 = f2.lineColor || c2.lineColor || n4;
            a3 = a3 || "normal";
            c2 = c2.states[a3] || {};
            a3 = f2.states && f2.states[a3] || {};
            b2 = A(a3.lineWidth, c2.lineWidth, b2 + A(a3.lineWidthPlus, c2.lineWidthPlus, 0));
            e2 = a3.fillColor || c2.fillColor || e2;
            g2 = a3.lineColor || c2.lineColor || g2;
            d2 = A(a3.opacity, c2.opacity, d2);
            return { stroke: g2, "stroke-width": b2, fill: e2, opacity: d2 };
          }
          destroy(b2) {
            const a3 = this, c2 = a3.chart, d2 = /AppleWebKit\/533/.test(e.navigator.userAgent), f2 = a3.data || [];
            let g2, k2, h3, l3;
            n3(a3, "destroy", { keepEventsForUpdate: b2 });
            this.removeEvents(b2);
            (a3.axisTypes || []).forEach(function(b3) {
              (l3 = a3[b3]) && l3.series && (G(l3.series, a3), l3.isDirty = l3.forceRedraw = true);
            });
            a3.legendItem && a3.chart.legend.destroyItem(a3);
            for (k2 = f2.length; k2--; )
              (h3 = f2[k2]) && h3.destroy && h3.destroy();
            a3.clips && a3.clips.forEach((b3) => b3.destroy());
            v.clearTimeout(a3.animationTimeout);
            Y(a3, function(b3, a4) {
              b3 instanceof u && !b3.survive && (g2 = d2 && a4 === "group" ? "hide" : "destroy", b3[g2]());
            });
            c2.hoverSeries === a3 && (c2.hoverSeries = void 0);
            G(c2.series, a3);
            c2.orderItems("series");
            Y(a3, function(c3, d3) {
              b2 && d3 === "hcEvents" || delete a3[d3];
            });
          }
          applyZones() {
            const b2 = this, a3 = this.chart, c2 = a3.renderer, f2 = this.zones, e2 = this.clips || [], g2 = this.graph, k2 = this.area, n4 = Math.max(a3.plotWidth, a3.plotHeight), h3 = this[(this.zoneAxis || "y") + "Axis"], l3 = a3.inverted;
            let m2, q2, p2, r2, t2, w2, v2, u2, x2, D2, E, G2 = false;
            f2.length && (g2 || k2) && h3 && typeof h3.min !== "undefined" ? (t2 = h3.reversed, w2 = h3.horiz, g2 && !this.showLine && g2.hide(), k2 && k2.hide(), r2 = h3.getExtremes(), f2.forEach(function(f3, Q) {
              m2 = t2 ? w2 ? a3.plotWidth : 0 : w2 ? 0 : h3.toPixels(r2.min) || 0;
              m2 = d(A(q2, m2), 0, n4);
              q2 = d(Math.round(h3.toPixels(A(f3.value, r2.max), true) || 0), 0, n4);
              G2 && (m2 = q2 = h3.toPixels(r2.max));
              v2 = Math.abs(m2 - q2);
              u2 = Math.min(m2, q2);
              x2 = Math.max(m2, q2);
              h3.isXAxis ? (p2 = { x: l3 ? x2 : u2, y: 0, width: v2, height: n4 }, w2 || (p2.x = a3.plotHeight - p2.x)) : (p2 = { x: 0, y: l3 ? x2 : u2, width: n4, height: v2 }, w2 && (p2.y = a3.plotWidth - p2.y));
              e2[Q] ? e2[Q].animate(p2) : e2[Q] = c2.clipRect(p2);
              D2 = b2["zone-area-" + Q];
              E = b2["zone-graph-" + Q];
              g2 && E && E.clip(e2[Q]);
              k2 && D2 && D2.clip(e2[Q]);
              G2 = f3.value > r2.max;
              b2.resetZones && q2 === 0 && (q2 = void 0);
            }), this.clips = e2) : b2.visible && (g2 && g2.show(), k2 && k2.show());
          }
          plotGroup(b2, a3, c2, d2, f2) {
            let e2 = this[b2];
            const g2 = !e2;
            c2 = { visibility: c2, zIndex: d2 || 0.1 };
            typeof this.opacity === "undefined" || this.chart.styledMode || this.state === "inactive" || (c2.opacity = this.opacity);
            g2 && (this[b2] = e2 = this.chart.renderer.g().add(f2));
            e2.addClass("highcharts-" + a3 + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (r(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (e2.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
            e2.attr(c2)[g2 ? "attr" : "animate"](this.getPlotBox(a3));
            return e2;
          }
          getPlotBox(b2) {
            let a3 = this.xAxis, c2 = this.yAxis;
            const d2 = this.chart;
            b2 = d2.inverted && !d2.polar && a3 && this.invertible !== false && b2 === "series";
            d2.inverted && (a3 = c2, c2 = this.xAxis);
            return { translateX: a3 ? a3.left : d2.plotLeft, translateY: c2 ? c2.top : d2.plotTop, rotation: b2 ? 90 : 0, rotationOriginX: b2 ? (a3.len - c2.len) / 2 : 0, rotationOriginY: b2 ? (a3.len + c2.len) / 2 : 0, scaleX: b2 ? -1 : 1, scaleY: 1 };
          }
          removeEvents(b2) {
            b2 || M2(this);
            this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function(b3) {
              b3();
            }), this.eventsToUnbind.length = 0);
          }
          render() {
            const b2 = this;
            var a3 = b2.chart;
            const c2 = b2.options, d2 = l2(c2.animation), f2 = b2.visible ? "inherit" : "hidden", e2 = c2.zIndex, g2 = b2.hasRendered;
            a3 = a3.seriesGroup;
            let k2 = b2.finishedAnimating ? 0 : d2.duration;
            n3(this, "render");
            b2.plotGroup("group", "series", f2, e2, a3);
            b2.markerGroup = b2.plotGroup("markerGroup", "markers", f2, e2, a3);
            c2.clip !== false && b2.setClip();
            b2.animate && k2 && b2.animate(true);
            b2.drawGraph && (b2.drawGraph(), b2.applyZones());
            b2.visible && b2.drawPoints();
            b2.drawDataLabels && b2.drawDataLabels();
            b2.redrawPoints && b2.redrawPoints();
            b2.drawTracker && c2.enableMouseTracking && b2.drawTracker();
            b2.animate && k2 && b2.animate();
            g2 || (k2 && d2.defer && (k2 += d2.defer), b2.animationTimeout = ba(function() {
              b2.afterAnimate();
            }, k2 || 0));
            b2.isDirty = false;
            b2.hasRendered = true;
            n3(b2, "afterRender");
          }
          redraw() {
            const b2 = this.isDirty || this.isDirtyData;
            this.translate();
            this.render();
            b2 && delete this.kdTree;
          }
          searchPoint(b2, a3) {
            const c2 = this.xAxis, d2 = this.yAxis, f2 = this.chart.inverted;
            return this.searchKDTree({ clientX: f2 ? c2.len - b2.chartY + c2.pos : b2.chartX - c2.pos, plotY: f2 ? d2.len - b2.chartX + d2.pos : b2.chartY - d2.pos }, a3, b2);
          }
          buildKDTree(b2) {
            function a3(b3, d3, f2) {
              var e2 = b3 && b3.length;
              let g2;
              if (e2)
                return g2 = c2.kdAxisArray[d3 % f2], b3.sort(function(b4, a4) {
                  return b4[g2] - a4[g2];
                }), e2 = Math.floor(e2 / 2), { point: b3[e2], left: a3(b3.slice(0, e2), d3 + 1, f2), right: a3(b3.slice(e2 + 1), d3 + 1, f2) };
            }
            this.buildingKdTree = true;
            const c2 = this, d2 = -1 < c2.options.findNearestPointBy.indexOf("y") ? 2 : 1;
            delete c2.kdTree;
            ba(function() {
              c2.kdTree = a3(c2.getValidPoints(null, !c2.directTouch), d2, d2);
              c2.buildingKdTree = false;
            }, c2.options.kdNow || b2 && b2.type === "touchstart" ? 0 : 1);
          }
          searchKDTree(b2, a3, c2) {
            function d2(b3, a4, c3, n4) {
              const h3 = a4.point;
              var l3 = f2.kdAxisArray[c3 % n4];
              let m2 = h3;
              var q2 = r(b3[e2]) && r(h3[e2]) ? Math.pow(b3[e2] - h3[e2], 2) : null;
              var p2 = r(b3[g2]) && r(h3[g2]) ? Math.pow(b3[g2] - h3[g2], 2) : null;
              p2 = (q2 || 0) + (p2 || 0);
              h3.dist = r(p2) ? Math.sqrt(p2) : Number.MAX_VALUE;
              h3.distX = r(q2) ? Math.sqrt(q2) : Number.MAX_VALUE;
              l3 = b3[l3] - h3[l3];
              p2 = 0 > l3 ? "left" : "right";
              q2 = 0 > l3 ? "right" : "left";
              a4[p2] && (p2 = d2(b3, a4[p2], c3 + 1, n4), m2 = p2[k2] < m2[k2] ? p2 : h3);
              a4[q2] && Math.sqrt(l3 * l3) < m2[k2] && (b3 = d2(b3, a4[q2], c3 + 1, n4), m2 = b3[k2] < m2[k2] ? b3 : m2);
              return m2;
            }
            const f2 = this, e2 = this.kdAxisArray[0], g2 = this.kdAxisArray[1], k2 = a3 ? "distX" : "dist";
            a3 = -1 < f2.options.findNearestPointBy.indexOf("y") ? 2 : 1;
            this.kdTree || this.buildingKdTree || this.buildKDTree(c2);
            if (this.kdTree)
              return d2(b2, this.kdTree, a3, a3);
          }
          pointPlacementToXValue() {
            const { options: { pointPlacement: b2, pointRange: a3 }, xAxis: c2 } = this;
            let d2 = b2;
            d2 === "between" && (d2 = c2.reversed ? -0.5 : 0.5);
            return T(d2) ? d2 * (a3 || c2.pointRange) : 0;
          }
          isPointInside(b2) {
            const { chart: a3, xAxis: c2, yAxis: d2 } = this;
            return typeof b2.plotY !== "undefined" && typeof b2.plotX !== "undefined" && 0 <= b2.plotY && b2.plotY <= (d2 ? d2.len : a3.plotHeight) && 0 <= b2.plotX && b2.plotX <= (c2 ? c2.len : a3.plotWidth);
          }
          drawTracker() {
            const b2 = this, a3 = b2.options, c2 = a3.trackByArea, d2 = [].concat(c2 ? b2.areaPath : b2.graphPath), f2 = b2.chart, e2 = f2.pointer, k2 = f2.renderer, l3 = f2.options.tooltip.snap, m2 = b2.tracker, q2 = function(c3) {
              if (a3.enableMouseTracking && f2.hoverSeries !== b2)
                b2.onMouseOver();
            }, p2 = "rgba(192,192,192," + (g ? 1e-4 : 2e-3) + ")";
            m2 ? m2.attr({ d: d2 }) : b2.graph && (b2.tracker = k2.path(d2).attr({ visibility: b2.visible ? "inherit" : "hidden", zIndex: 2 }).addClass(c2 ? "highcharts-tracker-area" : "highcharts-tracker-line").add(b2.group), f2.styledMode || b2.tracker.attr({ "stroke-linecap": "round", "stroke-linejoin": "round", stroke: p2, fill: c2 ? p2 : "none", "stroke-width": b2.graph.strokeWidth() + (c2 ? 0 : 2 * l3) }), [
              b2.tracker,
              b2.markerGroup,
              b2.dataLabelsGroup
            ].forEach(function(b3) {
              if (b3 && (b3.addClass("highcharts-tracker").on("mouseover", q2).on("mouseout", function(b4) {
                e2.onTrackerMouseOut(b4);
              }), a3.cursor && !f2.styledMode && b3.css({ cursor: a3.cursor }), h))
                b3.on("touchstart", q2);
            }));
            n3(this, "afterDrawTracker");
          }
          addPoint(b2, a3, c2, d2, f2) {
            const e2 = this.options, g2 = this.data, k2 = this.chart;
            var h3 = this.xAxis;
            h3 = h3 && h3.hasNames && h3.names;
            const l3 = e2.data, m2 = this.xData;
            let q2, p2;
            a3 = A(a3, true);
            const r2 = { series: this };
            this.pointClass.prototype.applyOptions.apply(r2, [b2]);
            const t2 = r2.x;
            p2 = m2.length;
            if (this.requireSorting && t2 < m2[p2 - 1])
              for (q2 = true; p2 && m2[p2 - 1] > t2; )
                p2--;
            this.updateParallelArrays(r2, "splice", [p2, 0, 0]);
            this.updateParallelArrays(r2, p2);
            h3 && r2.name && (h3[t2] = r2.name);
            l3.splice(p2, 0, b2);
            if (q2 || this.processedData)
              this.data.splice(p2, 0, null), this.processData();
            e2.legendType === "point" && this.generatePoints();
            c2 && (g2[0] && g2[0].remove ? g2[0].remove(false) : (g2.shift(), this.updateParallelArrays(r2, "shift"), l3.shift()));
            f2 !== false && n3(this, "addPoint", { point: r2 });
            this.isDirtyData = this.isDirty = true;
            a3 && k2.redraw(d2);
          }
          removePoint(b2, a3, c2) {
            const d2 = this, f2 = d2.data, e2 = f2[b2], g2 = d2.points, k2 = d2.chart, h3 = function() {
              g2 && g2.length === f2.length && g2.splice(b2, 1);
              f2.splice(b2, 1);
              d2.options.data.splice(b2, 1);
              d2.updateParallelArrays(e2 || { series: d2 }, "splice", [b2, 1]);
              e2 && e2.destroy();
              d2.isDirty = true;
              d2.isDirtyData = true;
              a3 && k2.redraw();
            };
            p(c2, k2);
            a3 = A(a3, true);
            e2 ? e2.firePointEvent("remove", null, h3) : h3();
          }
          remove(b2, a3, c2, d2) {
            function f2() {
              e2.destroy(d2);
              g2.isDirtyLegend = g2.isDirtyBox = true;
              g2.linkSeries(d2);
              A(b2, true) && g2.redraw(a3);
            }
            const e2 = this, g2 = e2.chart;
            c2 !== false ? n3(e2, "remove", null, f2) : f2();
          }
          update(a3, c2) {
            a3 = q(a3, this.userOptions);
            n3(this, "update", { options: a3 });
            const d2 = this, e2 = d2.chart;
            var g2 = d2.userOptions;
            const k2 = d2.initialType || d2.type;
            var h3 = e2.options.plotOptions;
            const l3 = w[k2].prototype;
            var m2 = d2.finishedAnimating && { animation: false };
            const p2 = {};
            let r2, t2 = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], v2 = a3.type || g2.type || e2.options.chart.type;
            const u2 = !(this.hasDerivedData || v2 && v2 !== this.type || typeof a3.pointStart !== "undefined" || typeof a3.pointInterval !== "undefined" || typeof a3.relativeXValue !== "undefined" || a3.joinBy || a3.mapData || d2.hasOptionChanged("dataGrouping") || d2.hasOptionChanged("pointStart") || d2.hasOptionChanged("pointInterval") || d2.hasOptionChanged("pointIntervalUnit") || d2.hasOptionChanged("keys"));
            v2 = v2 || k2;
            u2 && (t2.push("data", "isDirtyData", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), a3.visible !== false && t2.push("area", "graph"), d2.parallelArrays.forEach(function(b2) {
              t2.push(b2 + "Data");
            }), a3.data && (a3.dataSorting && f(d2.options.dataSorting, a3.dataSorting), this.setData(a3.data, false)));
            a3 = V(g2, m2, { index: typeof g2.index === "undefined" ? d2.index : g2.index, pointStart: A(h3 && h3.series && h3.series.pointStart, g2.pointStart, d2.xData[0]) }, !u2 && { data: d2.options.data }, a3);
            u2 && a3.data && (a3.data = d2.options.data);
            t2 = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(t2);
            t2.forEach(function(b2) {
              t2[b2] = d2[b2];
              delete d2[b2];
            });
            h3 = false;
            if (w[v2]) {
              if (h3 = v2 !== d2.type, d2.remove(false, false, false, true), h3)
                if (Object.setPrototypeOf)
                  Object.setPrototypeOf(d2, w[v2].prototype);
                else {
                  m2 = Object.hasOwnProperty.call(d2, "hcEvents") && d2.hcEvents;
                  for (r2 in l3)
                    d2[r2] = void 0;
                  f(d2, w[v2].prototype);
                  m2 ? d2.hcEvents = m2 : delete d2.hcEvents;
                }
            } else
              b(17, true, e2, { missingModuleFor: v2 });
            t2.forEach(function(b2) {
              d2[b2] = t2[b2];
            });
            d2.init(e2, a3);
            if (u2 && this.points) {
              a3 = d2.options;
              if (a3.visible === false)
                p2.graphic = 1, p2.dataLabel = 1;
              else if (!d2._hasPointLabels) {
                const { marker: b2, dataLabels: c3 } = a3;
                g2 = g2.marker || {};
                !b2 || b2.enabled !== false && g2.symbol === b2.symbol && g2.height === b2.height && g2.width === b2.width || (p2.graphic = 1);
                c3 && c3.enabled === false && (p2.dataLabel = 1);
              }
              for (const b2 of this.points)
                b2 && b2.series && (b2.resolveColor(), Object.keys(p2).length && b2.destroyElements(p2), a3.showInLegend === false && b2.legendItem && e2.legend.destroyItem(b2));
            }
            d2.initialType = k2;
            e2.linkSeries();
            h3 && d2.linkedSeries.length && (d2.isDirtyData = true);
            n3(this, "afterUpdate");
            A(c2, true) && e2.redraw(u2 ? void 0 : false);
          }
          setName(b2) {
            this.name = this.options.name = this.userOptions.name = b2;
            this.chart.isDirtyLegend = true;
          }
          hasOptionChanged(b2) {
            const a3 = this.options[b2], c2 = this.chart.options.plotOptions, d2 = this.userOptions[b2];
            return d2 ? a3 !== d2 : a3 !== A(c2 && c2[this.type] && c2[this.type][b2], c2 && c2.series && c2.series[b2], a3);
          }
          onMouseOver() {
            const b2 = this.chart, a3 = b2.hoverSeries;
            b2.pointer.setHoverChartIndex();
            if (a3 && a3 !== this)
              a3.onMouseOut();
            this.options.events.mouseOver && n3(this, "mouseOver");
            this.setState("hover");
            b2.hoverSeries = this;
          }
          onMouseOut() {
            const b2 = this.options, a3 = this.chart, c2 = a3.tooltip, d2 = a3.hoverPoint;
            a3.hoverSeries = null;
            if (d2)
              d2.onMouseOut();
            this && b2.events.mouseOut && n3(this, "mouseOut");
            !c2 || this.stickyTracking || c2.shared && !this.noSharedTooltip || c2.hide();
            a3.series.forEach(function(b3) {
              b3.setState("", true);
            });
          }
          setState(b2, a3) {
            const c2 = this;
            var d2 = c2.options;
            const f2 = c2.graph, e2 = d2.inactiveOtherPoints, g2 = d2.states, k2 = A(g2[b2 || "normal"] && g2[b2 || "normal"].animation, c2.chart.options.chart.animation);
            let h3 = d2.lineWidth, n4 = 0, l3 = d2.opacity;
            b2 = b2 || "";
            if (c2.state !== b2 && ([c2.group, c2.markerGroup, c2.dataLabelsGroup].forEach(function(a4) {
              a4 && (c2.state && a4.removeClass("highcharts-series-" + c2.state), b2 && a4.addClass("highcharts-series-" + b2));
            }), c2.state = b2, !c2.chart.styledMode)) {
              if (g2[b2] && g2[b2].enabled === false)
                return;
              b2 && (h3 = g2[b2].lineWidth || h3 + (g2[b2].lineWidthPlus || 0), l3 = A(g2[b2].opacity, l3));
              if (f2 && !f2.dashstyle && T(h3))
                for (d2 = { "stroke-width": h3 }, f2.animate(d2, k2); c2["zone-graph-" + n4]; )
                  c2["zone-graph-" + n4].animate(d2, k2), n4 += 1;
              e2 || [c2.group, c2.markerGroup, c2.dataLabelsGroup, c2.labelBySeries].forEach(function(b3) {
                b3 && b3.animate({ opacity: l3 }, k2);
              });
            }
            a3 && e2 && c2.points && c2.setAllPointsToState(b2 || void 0);
          }
          setAllPointsToState(b2) {
            this.points.forEach(function(a3) {
              a3.setState && a3.setState(b2);
            });
          }
          setVisible(b2, a3) {
            const c2 = this, d2 = c2.chart, f2 = d2.options.chart.ignoreHiddenSeries, e2 = c2.visible, g2 = (c2.visible = b2 = c2.options.visible = c2.userOptions.visible = typeof b2 === "undefined" ? !e2 : b2) ? "show" : "hide";
            ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function(b3) {
              if (c2[b3])
                c2[b3][g2]();
            });
            if (d2.hoverSeries === c2 || (d2.hoverPoint && d2.hoverPoint.series) === c2)
              c2.onMouseOut();
            c2.legendItem && d2.legend.colorizeItem(c2, b2);
            c2.isDirty = true;
            c2.options.stacking && d2.series.forEach(function(b3) {
              b3.options.stacking && b3.visible && (b3.isDirty = true);
            });
            c2.linkedSeries.forEach(function(a4) {
              a4.setVisible(b2, false);
            });
            f2 && (d2.isDirtyBox = true);
            n3(c2, g2);
            a3 !== false && d2.redraw();
          }
          show() {
            this.setVisible(true);
          }
          hide() {
            this.setVisible(false);
          }
          select(b2) {
            this.selected = b2 = this.options.selected = typeof b2 === "undefined" ? !this.selected : b2;
            this.checkbox && (this.checkbox.checked = b2);
            n3(this, b2 ? "select" : "unselect");
          }
          shouldShowTooltip(b2, a3, c2 = {}) {
            c2.series = this;
            c2.visiblePlotOnly = true;
            return this.chart.isInsidePlot(b2, a3, c2);
          }
          drawLegendSymbol(b2, a3) {
            var c2;
            (c2 = C[this.options.legendSymbol || "rectangle"]) === null || c2 === void 0 ? void 0 : c2.call(this, b2, a3);
          }
        }
        aa.defaultOptions = H;
        aa.types = B.seriesTypes;
        aa.registerType = B.registerSeriesType;
        f(aa.prototype, {
          axisTypes: ["xAxis", "yAxis"],
          coll: "series",
          colorCounter: 0,
          cropShoulder: 1,
          directTouch: false,
          isCartesian: true,
          kdAxisArray: ["clientX", "plotY"],
          parallelArrays: ["x", "y"],
          pointClass: z,
          requireSorting: true,
          sorted: true
        });
        B.series = aa;
        "";
        "";
        return aa;
      });
      M(a, "Core/Chart/Chart.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Axis/Axis.js"],
        a["Core/Defaults.js"],
        a["Core/Templating.js"],
        a["Core/Foundation.js"],
        a["Core/Globals.js"],
        a["Core/Renderer/RendererRegistry.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Time.js"],
        a["Core/Utilities.js"],
        a["Core/Renderer/HTML/AST.js"]
      ], function(a2, y, I, L, C, z, H, B, u, v, l2, p, t) {
        const { animate: m, animObject: h, setAnimation: g } = a2, { defaultOptions: e, defaultTime: w } = I, { numberFormat: x } = L, { registerEventOptions: F } = C, { charts: d, doc: k, marginNames: r, svg: q, win: G } = z, { seriesTypes: b } = u, {
          addEvent: f,
          attr: c,
          createElement: n3,
          css: P,
          defined: D,
          diffObjects: K,
          discardElement: X,
          erase: T,
          error: Z,
          extend: V,
          find: Y,
          fireEvent: A,
          getStyle: M2,
          isArray: ia,
          isNumber: ba,
          isObject: aa,
          isString: J,
          merge: N,
          objectEach: O,
          pick: S,
          pInt: W,
          relativeLength: ha,
          removeEvent: da,
          splat: fa,
          syncTimeout: ka,
          uniqueKey: ca
        } = p;
        class ea {
          static chart(b2, a3, c2) {
            return new ea(b2, a3, c2);
          }
          constructor(b2, a3, c2) {
            this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
            this.sharedClips = {};
            this.zooming = this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
            this.getArgs(b2, a3, c2);
          }
          getArgs(b2, a3, c2) {
            J(b2) || b2.nodeName ? (this.renderTo = b2, this.init(a3, c2)) : this.init(b2, a3);
          }
          setZoomOptions() {
            const b2 = this.options.chart, a3 = b2.zooming;
            this.zooming = Object.assign(Object.assign({}, a3), { type: S(b2.zoomType, a3.type), key: S(b2.zoomKey, a3.key), pinchType: S(b2.pinchType, a3.pinchType), singleTouch: S(b2.zoomBySingleTouch, a3.singleTouch, false), resetButton: N(a3.resetButton, b2.resetZoomButton) });
          }
          init(b2, a3) {
            A(this, "init", { args: arguments }, function() {
              const c2 = N(e, b2), f2 = c2.chart;
              this.userOptions = V({}, b2);
              this.margin = [];
              this.spacing = [];
              this.bounds = { h: {}, v: {} };
              this.labelCollectors = [];
              this.callback = a3;
              this.isResizing = 0;
              this.options = c2;
              this.axes = [];
              this.series = [];
              this.time = b2.time && Object.keys(b2.time).length ? new l2(b2.time) : z.time;
              this.numberFormatter = f2.numberFormatter || x;
              this.styledMode = f2.styledMode;
              this.hasCartesianSeries = f2.showAxes;
              this.index = d.length;
              d.push(this);
              z.chartCount++;
              F(this, f2);
              this.xAxis = [];
              this.yAxis = [];
              this.pointCount = this.colorCounter = this.symbolCounter = 0;
              this.setZoomOptions();
              A(this, "afterInit");
              this.firstRender();
            });
          }
          initSeries(a3) {
            var c2 = this.options.chart;
            c2 = a3.type || c2.type;
            const d2 = b[c2];
            d2 || Z(17, true, this, { missingModuleFor: c2 });
            c2 = new d2();
            typeof c2.init === "function" && c2.init(this, a3);
            return c2;
          }
          setSeriesData() {
            this.getSeriesOrderByLinks().forEach(function(b2) {
              b2.points || b2.data || !b2.enabledDataSorting || b2.setData(b2.options.data, false);
            });
          }
          getSeriesOrderByLinks() {
            return this.series.concat().sort(function(b2, a3) {
              return b2.linkedSeries.length || a3.linkedSeries.length ? a3.linkedSeries.length - b2.linkedSeries.length : 0;
            });
          }
          orderItems(b2, a3 = 0) {
            const c2 = this[b2], d2 = this.options[b2] = fa(this.options[b2]).slice();
            b2 = this.userOptions[b2] = this.userOptions[b2] ? fa(this.userOptions[b2]).slice() : [];
            this.hasRendered && (d2.splice(a3), b2.splice(a3));
            if (c2) {
              for (let f2 = a3, e2 = c2.length; f2 < e2; ++f2)
                if (a3 = c2[f2])
                  a3.index = f2, a3 instanceof B && (a3.name = a3.getName()), a3.options.isInternal || (d2[f2] = a3.options, b2[f2] = a3.userOptions);
            }
          }
          isInsidePlot(b2, a3, c2 = {}) {
            const {
              inverted: d2,
              plotBox: f2,
              plotLeft: e2,
              plotTop: g2,
              scrollablePlotBox: k2
            } = this;
            var h3 = 0;
            let n4 = 0;
            c2.visiblePlotOnly && this.scrollingContainer && ({ scrollLeft: h3, scrollTop: n4 } = this.scrollingContainer);
            const l3 = c2.series, m2 = c2.visiblePlotOnly && k2 || f2;
            var q2 = c2.inverted ? a3 : b2;
            a3 = c2.inverted ? b2 : a3;
            b2 = { x: q2, y: a3, isInsidePlot: true, options: c2 };
            if (!c2.ignoreX) {
              const a4 = l3 && (d2 && !this.polar ? l3.yAxis : l3.xAxis) || { pos: e2, len: Infinity };
              q2 = c2.paneCoordinates ? a4.pos + q2 : e2 + q2;
              q2 >= Math.max(h3 + e2, a4.pos) && q2 <= Math.min(h3 + e2 + m2.width, a4.pos + a4.len) || (b2.isInsidePlot = false);
            }
            !c2.ignoreY && b2.isInsidePlot && (h3 = !d2 && c2.axis && !c2.axis.isXAxis && c2.axis || l3 && (d2 ? l3.xAxis : l3.yAxis) || { pos: g2, len: Infinity }, c2 = c2.paneCoordinates ? h3.pos + a3 : g2 + a3, c2 >= Math.max(n4 + g2, h3.pos) && c2 <= Math.min(n4 + g2 + m2.height, h3.pos + h3.len) || (b2.isInsidePlot = false));
            A(this, "afterIsInsidePlot", b2);
            return b2.isInsidePlot;
          }
          redraw(b2) {
            A(this, "beforeRedraw");
            const a3 = this.hasCartesianSeries ? this.axes : this.colorAxis || [], c2 = this.series, d2 = this.pointer, f2 = this.legend, e2 = this.userOptions.legend, k2 = this.renderer, h3 = k2.isHidden(), n4 = [];
            let l3, m2, q2 = this.isDirtyBox, p2 = this.isDirtyLegend, r2;
            k2.rootFontSize = k2.boxWrapper.getStyle("font-size");
            this.setResponsive && this.setResponsive(false);
            g(this.hasRendered ? b2 : false, this);
            h3 && this.temporaryDisplay();
            this.layOutTitles(false);
            for (b2 = c2.length; b2--; )
              if (r2 = c2[b2], r2.options.stacking || r2.options.centerInCategory) {
                if (m2 = true, r2.isDirty) {
                  l3 = true;
                  break;
                }
              }
            if (l3)
              for (b2 = c2.length; b2--; )
                r2 = c2[b2], r2.options.stacking && (r2.isDirty = true);
            c2.forEach(function(b3) {
              b3.isDirty && (b3.options.legendType === "point" ? (typeof b3.updateTotals === "function" && b3.updateTotals(), p2 = true) : e2 && (e2.labelFormatter || e2.labelFormat) && (p2 = true));
              b3.isDirtyData && A(b3, "updatedData");
            });
            p2 && f2 && f2.options.enabled && (f2.render(), this.isDirtyLegend = false);
            m2 && this.getStacks();
            a3.forEach(function(b3) {
              b3.updateNames();
              b3.setScale();
            });
            this.getMargins();
            a3.forEach(function(b3) {
              b3.isDirty && (q2 = true);
            });
            a3.forEach(function(b3) {
              const a4 = b3.min + "," + b3.max;
              b3.extKey !== a4 && (b3.extKey = a4, n4.push(function() {
                A(b3, "afterSetExtremes", V(b3.eventArgs, b3.getExtremes()));
                delete b3.eventArgs;
              }));
              (q2 || m2) && b3.redraw();
            });
            q2 && this.drawChartBox();
            A(this, "predraw");
            c2.forEach(function(b3) {
              (q2 || b3.isDirty) && b3.visible && b3.redraw();
              b3.isDirtyData = false;
            });
            d2 && d2.reset(true);
            k2.draw();
            A(this, "redraw");
            A(this, "render");
            h3 && this.temporaryDisplay(true);
            n4.forEach(function(b3) {
              b3.call();
            });
          }
          get(b2) {
            function a3(a4) {
              return a4.id === b2 || a4.options && a4.options.id === b2;
            }
            const c2 = this.series;
            let d2 = Y(this.axes, a3) || Y(this.series, a3);
            for (let b3 = 0; !d2 && b3 < c2.length; b3++)
              d2 = Y(c2[b3].points || [], a3);
            return d2;
          }
          getAxes() {
            const b2 = this.options;
            A(this, "getAxes");
            for (const a3 of ["xAxis", "yAxis"]) {
              const c2 = b2[a3] = fa(b2[a3] || {});
              for (const b3 of c2)
                new y(this, b3, a3);
            }
            A(this, "afterGetAxes");
          }
          getSelectedPoints() {
            return this.series.reduce((b2, a3) => {
              a3.getPointsCollection().forEach((a4) => {
                S(a4.selectedStaging, a4.selected) && b2.push(a4);
              });
              return b2;
            }, []);
          }
          getSelectedSeries() {
            return this.series.filter(function(b2) {
              return b2.selected;
            });
          }
          setTitle(b2, a3, c2) {
            this.applyDescription("title", b2);
            this.applyDescription("subtitle", a3);
            this.applyDescription("caption", void 0);
            this.layOutTitles(c2);
          }
          applyDescription(b2, a3) {
            const c2 = this, d2 = this.options[b2] = N(this.options[b2], a3);
            let f2 = this[b2];
            f2 && a3 && (this[b2] = f2 = f2.destroy());
            d2 && !f2 && (f2 = this.renderer.text(d2.text, 0, 0, d2.useHTML).attr({
              align: d2.align,
              "class": "highcharts-" + b2,
              zIndex: d2.zIndex || 4
            }).add(), f2.update = function(a4, d3) {
              c2.applyDescription(b2, a4);
              c2.layOutTitles(d3);
            }, this.styledMode || f2.css(V(b2 === "title" ? { fontSize: this.options.isStock ? "1em" : "1.2em" } : {}, d2.style)), this[b2] = f2);
          }
          layOutTitles(b2 = true) {
            const a3 = [0, 0, 0], c2 = this.renderer, d2 = this.spacingBox;
            ["title", "subtitle", "caption"].forEach(function(b3) {
              const f3 = this[b3], e2 = this.options[b3], g2 = e2.verticalAlign || "top";
              b3 = b3 === "title" ? g2 === "top" ? -3 : 0 : g2 === "top" ? a3[0] + 2 : 0;
              if (f3) {
                f3.css({ width: (e2.width || d2.width + (e2.widthAdjust || 0)) + "px" });
                const k2 = c2.fontMetrics(f3).b, h3 = Math.round(f3.getBBox(e2.useHTML).height);
                f3.align(V({ y: g2 === "bottom" ? k2 : b3 + k2, height: h3 }, e2), false, "spacingBox");
                e2.floating || (g2 === "top" ? a3[0] = Math.ceil(a3[0] + h3) : g2 === "bottom" && (a3[2] = Math.ceil(a3[2] + h3)));
              }
            }, this);
            a3[0] && (this.options.title.verticalAlign || "top") === "top" && (a3[0] += this.options.title.margin);
            a3[2] && this.options.caption.verticalAlign === "bottom" && (a3[2] += this.options.caption.margin);
            const f2 = !this.titleOffset || this.titleOffset.join(",") !== a3.join(",");
            this.titleOffset = a3;
            A(this, "afterLayOutTitles");
            !this.isDirtyBox && f2 && (this.isDirtyBox = this.isDirtyLegend = f2, this.hasRendered && b2 && this.isDirtyBox && this.redraw());
          }
          getContainerBox() {
            return { width: M2(this.renderTo, "width", true) || 0, height: M2(this.renderTo, "height", true) || 0 };
          }
          getChartSize() {
            var b2 = this.options.chart;
            const a3 = b2.width;
            b2 = b2.height;
            const c2 = this.getContainerBox();
            this.chartWidth = Math.max(0, a3 || c2.width || 600);
            this.chartHeight = Math.max(0, ha(b2, this.chartWidth) || (1 < c2.height ? c2.height : 400));
            this.containerBox = c2;
          }
          temporaryDisplay(b2) {
            let a3 = this.renderTo;
            if (b2)
              for (; a3 && a3.style; )
                a3.hcOrigStyle && (P(a3, a3.hcOrigStyle), delete a3.hcOrigStyle), a3.hcOrigDetached && (k.body.removeChild(a3), a3.hcOrigDetached = false), a3 = a3.parentNode;
            else
              for (; a3 && a3.style; ) {
                k.body.contains(a3) || a3.parentNode || (a3.hcOrigDetached = true, k.body.appendChild(a3));
                if (M2(a3, "display", false) === "none" || a3.hcOricDetached)
                  a3.hcOrigStyle = { display: a3.style.display, height: a3.style.height, overflow: a3.style.overflow }, b2 = { display: "block", overflow: "hidden" }, a3 !== this.renderTo && (b2.height = 0), P(a3, b2), a3.offsetWidth || a3.style.setProperty("display", "block", "important");
                a3 = a3.parentNode;
                if (a3 === k.body)
                  break;
              }
          }
          setClassName(b2) {
            this.container.className = "highcharts-container " + (b2 || "");
          }
          getContainer() {
            const b2 = this.options, a3 = b2.chart;
            var f2 = ca();
            let e2, h3 = this.renderTo;
            h3 || (this.renderTo = h3 = a3.renderTo);
            J(h3) && (this.renderTo = h3 = k.getElementById(h3));
            h3 || Z(13, true, this);
            var l3 = W(c(h3, "data-highcharts-chart"));
            ba(l3) && d[l3] && d[l3].hasRendered && d[l3].destroy();
            c(h3, "data-highcharts-chart", this.index);
            h3.innerHTML = t.emptyHTML;
            a3.skipClone || h3.offsetWidth || this.temporaryDisplay();
            this.getChartSize();
            l3 = this.chartWidth;
            const m2 = this.chartHeight;
            P(h3, { overflow: "hidden" });
            this.styledMode || (e2 = V({ position: "relative", overflow: "hidden", width: l3 + "px", height: m2 + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)", userSelect: "none", "touch-action": "manipulation", outline: "none" }, a3.style || {}));
            this.container = f2 = n3("div", { id: f2 }, e2, h3);
            this._cursor = f2.style.cursor;
            this.renderer = new (a3.renderer || !q ? H.getRendererType(a3.renderer) : v)(f2, l3, m2, void 0, a3.forExport, b2.exporting && b2.exporting.allowHTML, this.styledMode);
            this.containerBox = this.getContainerBox();
            g(void 0, this);
            this.setClassName(a3.className);
            if (this.styledMode)
              for (const a4 in b2.defs)
                this.renderer.definition(b2.defs[a4]);
            else
              this.renderer.setStyle(a3.style);
            this.renderer.chartIndex = this.index;
            A(this, "afterGetContainer");
          }
          getMargins(b2) {
            const { spacing: a3, margin: c2, titleOffset: d2 } = this;
            this.resetMargins();
            d2[0] && !D(c2[0]) && (this.plotTop = Math.max(this.plotTop, d2[0] + a3[0]));
            d2[2] && !D(c2[2]) && (this.marginBottom = Math.max(this.marginBottom, d2[2] + a3[2]));
            this.legend && this.legend.display && this.legend.adjustMargins(c2, a3);
            A(this, "getMargins");
            b2 || this.getAxisMargins();
          }
          getAxisMargins() {
            const b2 = this, a3 = b2.axisOffset = [0, 0, 0, 0], c2 = b2.colorAxis, d2 = b2.margin, f2 = function(b3) {
              b3.forEach(function(b4) {
                b4.visible && b4.getOffset();
              });
            };
            b2.hasCartesianSeries ? f2(b2.axes) : c2 && c2.length && f2(c2);
            r.forEach(function(c3, f3) {
              D(d2[f3]) || (b2[c3] += a3[f3]);
            });
            b2.setChartSize();
          }
          getOptions() {
            return K(this.userOptions, e);
          }
          reflow(b2) {
            const a3 = this;
            var c2 = a3.options.chart;
            c2 = D(c2.width) && D(c2.height);
            const d2 = a3.containerBox, f2 = a3.getContainerBox();
            delete a3.pointer.chartPosition;
            if (!c2 && !a3.isPrinting && d2 && f2.width) {
              if (f2.width !== d2.width || f2.height !== d2.height)
                p.clearTimeout(a3.reflowTimeout), a3.reflowTimeout = ka(function() {
                  a3.container && a3.setSize(void 0, void 0, false);
                }, b2 ? 100 : 0);
              a3.containerBox = f2;
            }
          }
          setReflow() {
            const b2 = this;
            var a3 = (a4) => {
              var c2;
              ((c2 = b2.options) === null || c2 === void 0 ? 0 : c2.chart.reflow) && b2.hasLoaded && b2.reflow(a4);
            };
            typeof ResizeObserver === "function" ? new ResizeObserver(a3).observe(b2.renderTo) : (a3 = f(G, "resize", a3), f(this, "destroy", a3));
          }
          setSize(b2, a3, c2) {
            const d2 = this, f2 = d2.renderer;
            d2.isResizing += 1;
            g(c2, d2);
            c2 = f2.globalAnimation;
            d2.oldChartHeight = d2.chartHeight;
            d2.oldChartWidth = d2.chartWidth;
            typeof b2 !== "undefined" && (d2.options.chart.width = b2);
            typeof a3 !== "undefined" && (d2.options.chart.height = a3);
            d2.getChartSize();
            d2.styledMode || (c2 ? m : P)(d2.container, { width: d2.chartWidth + "px", height: d2.chartHeight + "px" }, c2);
            d2.setChartSize(true);
            f2.setSize(d2.chartWidth, d2.chartHeight, c2);
            d2.axes.forEach(function(b3) {
              b3.isDirty = true;
              b3.setScale();
            });
            d2.isDirtyLegend = true;
            d2.isDirtyBox = true;
            d2.layOutTitles();
            d2.getMargins();
            d2.redraw(c2);
            d2.oldChartHeight = null;
            A(d2, "resize");
            ka(function() {
              d2 && A(d2, "endResize", null, function() {
                --d2.isResizing;
              });
            }, h(c2).duration);
          }
          setChartSize(b2) {
            var a3 = this.inverted;
            const c2 = this.renderer;
            var d2 = this.chartWidth, f2 = this.chartHeight;
            const e2 = this.options.chart, g2 = this.spacing, k2 = this.clipOffset;
            let h3, n4, l3, m2;
            this.plotLeft = h3 = Math.round(this.plotLeft);
            this.plotTop = n4 = Math.round(this.plotTop);
            this.plotWidth = l3 = Math.max(0, Math.round(d2 - h3 - this.marginRight));
            this.plotHeight = m2 = Math.max(0, Math.round(f2 - n4 - this.marginBottom));
            this.plotSizeX = a3 ? m2 : l3;
            this.plotSizeY = a3 ? l3 : m2;
            this.plotBorderWidth = e2.plotBorderWidth || 0;
            this.spacingBox = c2.spacingBox = { x: g2[3], y: g2[0], width: d2 - g2[3] - g2[1], height: f2 - g2[0] - g2[2] };
            this.plotBox = c2.plotBox = { x: h3, y: n4, width: l3, height: m2 };
            a3 = 2 * Math.floor(this.plotBorderWidth / 2);
            d2 = Math.ceil(Math.max(a3, k2[3]) / 2);
            f2 = Math.ceil(Math.max(a3, k2[0]) / 2);
            this.clipBox = { x: d2, y: f2, width: Math.floor(this.plotSizeX - Math.max(a3, k2[1]) / 2 - d2), height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a3, k2[2]) / 2 - f2)) };
            b2 || (this.axes.forEach(function(b3) {
              b3.setAxisSize();
              b3.setAxisTranslation();
            }), c2.alignElements());
            A(this, "afterSetChartSize", { skipAxes: b2 });
          }
          resetMargins() {
            A(this, "resetMargins");
            const b2 = this, a3 = b2.options.chart;
            ["margin", "spacing"].forEach(function(c2) {
              const d2 = a3[c2], f2 = aa(d2) ? d2 : [d2, d2, d2, d2];
              ["Top", "Right", "Bottom", "Left"].forEach(function(d3, e2) {
                b2[c2][e2] = S(a3[c2 + d3], f2[e2]);
              });
            });
            r.forEach(function(a4, c2) {
              b2[a4] = S(b2.margin[c2], b2.spacing[c2]);
            });
            b2.axisOffset = [0, 0, 0, 0];
            b2.clipOffset = [0, 0, 0, 0];
          }
          drawChartBox() {
            const b2 = this.options.chart, a3 = this.renderer, c2 = this.chartWidth, d2 = this.chartHeight, f2 = this.styledMode, e2 = this.plotBGImage;
            var g2 = b2.backgroundColor;
            const k2 = b2.plotBackgroundColor, h3 = b2.plotBackgroundImage, n4 = this.plotLeft, l3 = this.plotTop, m2 = this.plotWidth, q2 = this.plotHeight, p2 = this.plotBox, r2 = this.clipRect, t2 = this.clipBox;
            let w2 = this.chartBackground, v2 = this.plotBackground, u2 = this.plotBorder, x2, D2, E = "animate";
            w2 || (this.chartBackground = w2 = a3.rect().addClass("highcharts-background").add(), E = "attr");
            if (f2)
              x2 = D2 = w2.strokeWidth();
            else {
              x2 = b2.borderWidth || 0;
              D2 = x2 + (b2.shadow ? 8 : 0);
              g2 = { fill: g2 || "none" };
              if (x2 || w2["stroke-width"])
                g2.stroke = b2.borderColor, g2["stroke-width"] = x2;
              w2.attr(g2).shadow(b2.shadow);
            }
            w2[E]({ x: D2 / 2, y: D2 / 2, width: c2 - D2 - x2 % 2, height: d2 - D2 - x2 % 2, r: b2.borderRadius });
            E = "animate";
            v2 || (E = "attr", this.plotBackground = v2 = a3.rect().addClass("highcharts-plot-background").add());
            v2[E](p2);
            f2 || (v2.attr({ fill: k2 || "none" }).shadow(b2.plotShadow), h3 && (e2 ? (h3 !== e2.attr("href") && e2.attr("href", h3), e2.animate(p2)) : this.plotBGImage = a3.image(h3, n4, l3, m2, q2).add()));
            r2 ? r2.animate({ width: t2.width, height: t2.height }) : this.clipRect = a3.clipRect(t2);
            E = "animate";
            u2 || (E = "attr", this.plotBorder = u2 = a3.rect().addClass("highcharts-plot-border").attr({ zIndex: 1 }).add());
            f2 || u2.attr({ stroke: b2.plotBorderColor, "stroke-width": b2.plotBorderWidth || 0, fill: "none" });
            u2[E](u2.crisp({ x: n4, y: l3, width: m2, height: q2 }, -u2.strokeWidth()));
            this.isDirtyBox = false;
            A(this, "afterDrawChartBox");
          }
          propFromSeries() {
            const a3 = this, c2 = a3.options.chart, d2 = a3.options.series;
            let f2, e2, g2;
            ["inverted", "angular", "polar"].forEach(function(k2) {
              e2 = b[c2.type];
              g2 = c2[k2] || e2 && e2.prototype[k2];
              for (f2 = d2 && d2.length; !g2 && f2--; )
                (e2 = b[d2[f2].type]) && e2.prototype[k2] && (g2 = true);
              a3[k2] = g2;
            });
          }
          linkSeries(b2) {
            const a3 = this, c2 = a3.series;
            c2.forEach(function(b3) {
              b3.linkedSeries.length = 0;
            });
            c2.forEach(function(b3) {
              let c3 = b3.options.linkedTo;
              J(c3) && (c3 = c3 === ":previous" ? a3.series[b3.index - 1] : a3.get(c3)) && c3.linkedParent !== b3 && (c3.linkedSeries.push(b3), b3.linkedParent = c3, c3.enabledDataSorting && b3.setDataSortingOptions(), b3.visible = S(b3.options.visible, c3.options.visible, b3.visible));
            });
            A(this, "afterLinkSeries", { isUpdating: b2 });
          }
          renderSeries() {
            this.series.forEach(function(b2) {
              b2.translate();
              b2.render();
            });
          }
          render() {
            const b2 = this.axes, a3 = this.colorAxis, c2 = this.renderer, d2 = function(b3) {
              b3.forEach(function(b4) {
                b4.visible && b4.render();
              });
            };
            let f2 = 0;
            this.setTitle();
            A(this, "beforeMargins");
            this.getStacks && this.getStacks();
            this.getMargins(true);
            this.setChartSize();
            const e2 = this.plotWidth;
            b2.some(function(b3) {
              if (b3.horiz && b3.visible && b3.options.labels.enabled && b3.series.length)
                return f2 = 21, true;
            });
            const g2 = this.plotHeight = Math.max(this.plotHeight - f2, 0);
            b2.forEach(function(b3) {
              b3.setScale();
            });
            this.getAxisMargins();
            const k2 = 1.1 < e2 / this.plotWidth, h3 = 1.05 < g2 / this.plotHeight;
            if (k2 || h3)
              b2.forEach(function(b3) {
                (b3.horiz && k2 || !b3.horiz && h3) && b3.setTickInterval(true);
              }), this.getMargins();
            this.drawChartBox();
            this.hasCartesianSeries ? d2(b2) : a3 && a3.length && d2(a3);
            this.seriesGroup || (this.seriesGroup = c2.g("series-group").attr({ zIndex: 3 }).shadow(this.options.chart.seriesGroupShadow).add());
            this.renderSeries();
            this.addCredits();
            this.setResponsive && this.setResponsive();
            this.hasRendered = true;
          }
          addCredits(b2) {
            const a3 = this, c2 = N(true, this.options.credits, b2);
            c2.enabled && !this.credits && (this.credits = this.renderer.text(c2.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
              c2.href && (G.location.href = c2.href);
            }).attr({ align: c2.position.align, zIndex: 8 }), a3.styledMode || this.credits.css(c2.style), this.credits.add().align(c2.position), this.credits.update = function(b3) {
              a3.credits = a3.credits.destroy();
              a3.addCredits(b3);
            });
          }
          destroy() {
            const b2 = this, a3 = b2.axes, c2 = b2.series, f2 = b2.container, e2 = f2 && f2.parentNode;
            let g2;
            A(b2, "destroy");
            b2.renderer.forExport ? T(d, b2) : d[b2.index] = void 0;
            z.chartCount--;
            b2.renderTo.removeAttribute("data-highcharts-chart");
            da(b2);
            for (g2 = a3.length; g2--; )
              a3[g2] = a3[g2].destroy();
            this.scroller && this.scroller.destroy && this.scroller.destroy();
            for (g2 = c2.length; g2--; )
              c2[g2] = c2[g2].destroy();
            "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function(a4) {
              const c3 = b2[a4];
              c3 && c3.destroy && (b2[a4] = c3.destroy());
            });
            f2 && (f2.innerHTML = t.emptyHTML, da(f2), e2 && X(f2));
            O(b2, function(a4, c3) {
              delete b2[c3];
            });
          }
          firstRender() {
            const b2 = this, a3 = b2.options;
            b2.getContainer();
            b2.resetMargins();
            b2.setChartSize();
            b2.propFromSeries();
            b2.getAxes();
            const c2 = ia(a3.series) ? a3.series : [];
            a3.series = [];
            c2.forEach(function(a4) {
              b2.initSeries(a4);
            });
            b2.linkSeries();
            b2.setSeriesData();
            A(b2, "beforeRender");
            b2.render();
            b2.pointer.getChartPosition();
            if (!b2.renderer.imgCount && !b2.hasLoaded)
              b2.onload();
            b2.temporaryDisplay(true);
          }
          onload() {
            this.callbacks.concat([this.callback]).forEach(function(b2) {
              b2 && typeof this.index !== "undefined" && b2.apply(this, [this]);
            }, this);
            A(this, "load");
            A(this, "render");
            D(this.index) && this.setReflow();
            this.warnIfA11yModuleNotLoaded();
            this.hasLoaded = true;
          }
          warnIfA11yModuleNotLoaded() {
            const { options: b2, title: a3 } = this;
            b2 && !this.accessibility && (this.renderer.boxWrapper.attr({ role: "img", "aria-label": (a3 && a3.element.textContent || "").replace(/</g, "&lt;") }), b2.accessibility && b2.accessibility.enabled === false || Z('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, this));
          }
          addSeries(b2, a3, c2) {
            const d2 = this;
            let f2;
            b2 && (a3 = S(a3, true), A(d2, "addSeries", { options: b2 }, function() {
              f2 = d2.initSeries(b2);
              d2.isDirtyLegend = true;
              d2.linkSeries();
              f2.enabledDataSorting && f2.setData(b2.data, false);
              A(d2, "afterAddSeries", { series: f2 });
              a3 && d2.redraw(c2);
            }));
            return f2;
          }
          addAxis(b2, a3, c2, d2) {
            return this.createAxis(a3 ? "xAxis" : "yAxis", { axis: b2, redraw: c2, animation: d2 });
          }
          addColorAxis(b2, a3, c2) {
            return this.createAxis("colorAxis", { axis: b2, redraw: a3, animation: c2 });
          }
          createAxis(b2, a3) {
            b2 = new y(this, a3.axis, b2);
            S(a3.redraw, true) && this.redraw(a3.animation);
            return b2;
          }
          showLoading(b2) {
            const a3 = this, c2 = a3.options, d2 = c2.loading, e2 = function() {
              g2 && P(g2, { left: a3.plotLeft + "px", top: a3.plotTop + "px", width: a3.plotWidth + "px", height: a3.plotHeight + "px" });
            };
            let g2 = a3.loadingDiv, k2 = a3.loadingSpan;
            g2 || (a3.loadingDiv = g2 = n3("div", { className: "highcharts-loading highcharts-loading-hidden" }, null, a3.container));
            k2 || (a3.loadingSpan = k2 = n3("span", { className: "highcharts-loading-inner" }, null, g2), f(a3, "redraw", e2));
            g2.className = "highcharts-loading";
            t.setElementHTML(k2, S(b2, c2.lang.loading, ""));
            a3.styledMode || (P(g2, V(d2.style, { zIndex: 10 })), P(k2, d2.labelStyle), a3.loadingShown || (P(g2, { opacity: 0, display: "" }), m(g2, { opacity: d2.style.opacity || 0.5 }, { duration: d2.showDuration || 0 })));
            a3.loadingShown = true;
            e2();
          }
          hideLoading() {
            const b2 = this.options, a3 = this.loadingDiv;
            a3 && (a3.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || m(a3, { opacity: 0 }, { duration: b2.loading.hideDuration || 100, complete: function() {
              P(a3, { display: "none" });
            } }));
            this.loadingShown = false;
          }
          update(b2, a3, c2, d2) {
            const f2 = this, e2 = {
              credits: "addCredits",
              title: "setTitle",
              subtitle: "setSubtitle",
              caption: "setCaption"
            }, g2 = b2.isResponsiveOptions, k2 = [];
            let h3, n4;
            A(f2, "update", { options: b2 });
            g2 || f2.setResponsive(false, true);
            b2 = K(b2, f2.options);
            f2.userOptions = N(f2.userOptions, b2);
            var m2 = b2.chart;
            if (m2) {
              N(true, f2.options.chart, m2);
              this.setZoomOptions();
              "className" in m2 && f2.setClassName(m2.className);
              if ("inverted" in m2 || "polar" in m2 || "type" in m2) {
                f2.propFromSeries();
                var q2 = true;
              }
              "alignTicks" in m2 && (q2 = true);
              "events" in m2 && F(this, m2);
              O(m2, function(b3, a4) {
                f2.propsRequireUpdateSeries.indexOf("chart." + a4) !== -1 && (h3 = true);
                f2.propsRequireDirtyBox.indexOf(a4) !== -1 && (f2.isDirtyBox = true);
                f2.propsRequireReflow.indexOf(a4) !== -1 && (g2 ? f2.isDirtyBox = true : n4 = true);
              });
              !f2.styledMode && m2.style && f2.renderer.setStyle(f2.options.chart.style || {});
            }
            !f2.styledMode && b2.colors && (this.options.colors = b2.colors);
            b2.time && (this.time === w && (this.time = new l2(b2.time)), N(true, f2.options.time, b2.time));
            O(b2, function(a4, c3) {
              if (f2[c3] && typeof f2[c3].update === "function")
                f2[c3].update(a4, false);
              else if (typeof f2[e2[c3]] === "function")
                f2[e2[c3]](a4);
              else
                c3 !== "colors" && f2.collectionsWithUpdate.indexOf(c3) === -1 && N(true, f2.options[c3], b2[c3]);
              c3 !== "chart" && f2.propsRequireUpdateSeries.indexOf(c3) !== -1 && (h3 = true);
            });
            this.collectionsWithUpdate.forEach(function(a4) {
              b2[a4] && (fa(b2[a4]).forEach(function(b3, d3) {
                const e3 = D(b3.id);
                let g3;
                e3 && (g3 = f2.get(b3.id));
                !g3 && f2[a4] && (g3 = f2[a4][S(b3.index, d3)]) && (e3 && D(g3.options.id) || g3.options.isInternal) && (g3 = void 0);
                g3 && g3.coll === a4 && (g3.update(b3, false), c2 && (g3.touched = true));
                !g3 && c2 && f2.collectionsWithInit[a4] && (f2.collectionsWithInit[a4][0].apply(f2, [b3].concat(f2.collectionsWithInit[a4][1] || []).concat([false])).touched = true);
              }), c2 && f2[a4].forEach(function(b3) {
                b3.touched || b3.options.isInternal ? delete b3.touched : k2.push(b3);
              }));
            });
            k2.forEach(function(b3) {
              b3.chart && b3.remove && b3.remove(false);
            });
            q2 && f2.axes.forEach(function(b3) {
              b3.update({}, false);
            });
            h3 && f2.getSeriesOrderByLinks().forEach(function(b3) {
              b3.chart && b3.update({}, false);
            }, this);
            q2 = m2 && m2.width;
            m2 = m2 && (J(m2.height) ? ha(m2.height, q2 || f2.chartWidth) : m2.height);
            n4 || ba(q2) && q2 !== f2.chartWidth || ba(m2) && m2 !== f2.chartHeight ? f2.setSize(q2, m2, d2) : S(a3, true) && f2.redraw(d2);
            A(f2, "afterUpdate", { options: b2, redraw: a3, animation: d2 });
          }
          setSubtitle(b2, a3) {
            this.applyDescription("subtitle", b2);
            this.layOutTitles(a3);
          }
          setCaption(b2, a3) {
            this.applyDescription("caption", b2);
            this.layOutTitles(a3);
          }
          showResetZoom() {
            function b2() {
              a3.zoomOut();
            }
            const a3 = this, c2 = e.lang, d2 = a3.zooming.resetButton, f2 = d2.theme, g2 = d2.relativeTo === "chart" || d2.relativeTo === "spacingBox" ? null : "scrollablePlotBox";
            A(this, "beforeShowResetZoom", null, function() {
              a3.resetZoomButton = a3.renderer.button(c2.resetZoom, null, null, b2, f2).attr({ align: d2.position.align, title: c2.resetZoomTitle }).addClass("highcharts-reset-zoom").add().align(d2.position, false, g2);
            });
            A(this, "afterShowResetZoom");
          }
          zoomOut() {
            A(this, "selection", { resetSelection: true }, this.zoom);
          }
          zoom(b2) {
            const a3 = this, c2 = a3.pointer;
            let d2 = false, f2;
            !b2 || b2.resetSelection ? (a3.axes.forEach(function(b3) {
              f2 = b3.zoom();
            }), c2.initiated = false) : b2.xAxis.concat(b2.yAxis).forEach(function(b3) {
              const e3 = b3.axis;
              if (c2[e3.isXAxis ? "zoomX" : "zoomY"] && D(c2.mouseDownX) && D(c2.mouseDownY) && a3.isInsidePlot(c2.mouseDownX - a3.plotLeft, c2.mouseDownY - a3.plotTop, { axis: e3 }) || !D(a3.inverted ? c2.mouseDownX : c2.mouseDownY))
                f2 = e3.zoom(b3.min, b3.max), e3.displayBtn && (d2 = true);
            });
            const e2 = a3.resetZoomButton;
            d2 && !e2 ? a3.showResetZoom() : !d2 && aa(e2) && (a3.resetZoomButton = e2.destroy());
            f2 && a3.redraw(S(a3.options.chart.animation, b2 && b2.animation, 100 > a3.pointCount));
          }
          pan(b2, a3) {
            const c2 = this, d2 = c2.hoverPoints;
            a3 = typeof a3 === "object" ? a3 : { enabled: a3, type: "x" };
            const f2 = c2.options.chart;
            f2 && f2.panning && (f2.panning = a3);
            const e2 = a3.type;
            let g2;
            A(this, "pan", { originalEvent: b2 }, function() {
              d2 && d2.forEach(function(b3) {
                b3.setState();
              });
              let a4 = c2.xAxis;
              e2 === "xy" ? a4 = a4.concat(c2.yAxis) : e2 === "y" && (a4 = c2.yAxis);
              const f3 = {};
              a4.forEach(function(a5) {
                if (a5.options.panningEnabled && !a5.options.isInternal) {
                  var d3 = a5.horiz, k2 = b2[d3 ? "chartX" : "chartY"];
                  d3 = d3 ? "mouseDownX" : "mouseDownY";
                  var h3 = c2[d3], n4 = a5.minPointOffset || 0, l3 = a5.reversed && !c2.inverted || !a5.reversed && c2.inverted ? -1 : 1, m2 = a5.getExtremes(), q2 = a5.toValue(h3 - k2, true) + n4 * l3, p2 = a5.toValue(h3 + a5.len - k2, true) - (n4 * l3 || a5.isXAxis && a5.pointRangePadding || 0), r2 = p2 < q2;
                  l3 = a5.hasVerticalPanning();
                  h3 = r2 ? p2 : q2;
                  q2 = r2 ? q2 : p2;
                  var t2 = a5.panningState;
                  !l3 || a5.isXAxis || t2 && !t2.isDirty || a5.series.forEach(function(b3) {
                    var a6 = b3.getProcessedData(true);
                    a6 = b3.getExtremes(a6.yData, true);
                    t2 || (t2 = {
                      startMin: Number.MAX_VALUE,
                      startMax: -Number.MAX_VALUE
                    });
                    ba(a6.dataMin) && ba(a6.dataMax) && (t2.startMin = Math.min(S(b3.options.threshold, Infinity), a6.dataMin, t2.startMin), t2.startMax = Math.max(S(b3.options.threshold, -Infinity), a6.dataMax, t2.startMax));
                  });
                  l3 = Math.min(S(t2 && t2.startMin, m2.dataMin), n4 ? m2.min : a5.toValue(a5.toPixels(m2.min) - a5.minPixelPadding));
                  p2 = Math.max(S(t2 && t2.startMax, m2.dataMax), n4 ? m2.max : a5.toValue(a5.toPixels(m2.max) + a5.minPixelPadding));
                  a5.panningState = t2;
                  a5.isOrdinal || (n4 = l3 - h3, 0 < n4 && (q2 += n4, h3 = l3), n4 = q2 - p2, 0 < n4 && (q2 = p2, h3 -= n4), a5.series.length && h3 !== m2.min && q2 !== m2.max && h3 >= l3 && q2 <= p2 && (a5.setExtremes(h3, q2, false, false, { trigger: "pan" }), !c2.resetZoomButton && h3 !== l3 && q2 !== p2 && e2.match("y") && (c2.showResetZoom(), a5.displayBtn = false), g2 = true), f3[d3] = k2);
                }
              });
              O(f3, (b3, a5) => {
                c2[a5] = b3;
              });
              g2 && c2.redraw(false);
              P(c2.container, { cursor: "move" });
            });
          }
        }
        V(ea.prototype, {
          callbacks: [],
          collectionsWithInit: { xAxis: [ea.prototype.addAxis, [true]], yAxis: [ea.prototype.addAxis, [false]], series: [ea.prototype.addSeries] },
          collectionsWithUpdate: ["xAxis", "yAxis", "series"],
          propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
          propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
          propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
        });
        "";
        return ea;
      });
      M(a, "Extensions/ScrollablePlotArea.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/Series/Series.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]], function(a2, y, I, L, C, z) {
        const { stop: x } = a2, { addEvent: B, createElement: u, defined: v, merge: l2, pick: p } = z;
        B(I, "afterSetChartSize", function(a3) {
          var m = this.options.chart.scrollablePlotArea, h = m && m.minWidth;
          m = m && m.minHeight;
          let g;
          if (!this.renderer.forExport) {
            if (h) {
              if (this.scrollablePixelsX = h = Math.max(0, h - this.chartWidth))
                this.scrollablePlotBox = this.renderer.scrollablePlotBox = l2(this.plotBox), this.plotBox.width = this.plotWidth += h, this.inverted ? this.clipBox.height += h : this.clipBox.width += h, g = { 1: { name: "right", value: h } };
            } else
              m && (this.scrollablePixelsY = h = Math.max(0, m - this.chartHeight), v(h) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = l2(this.plotBox), this.plotBox.height = this.plotHeight += h, this.inverted ? this.clipBox.width += h : this.clipBox.height += h, g = { 2: { name: "bottom", value: h } }));
            g && !a3.skipAxes && this.axes.forEach(function(a4) {
              g[a4.side] ? a4.getPlotLinePath = function() {
                let e = g[a4.side].name, h3 = this[e], l3;
                this[e] = h3 - g[a4.side].value;
                l3 = y.prototype.getPlotLinePath.apply(this, arguments);
                this[e] = h3;
                return l3;
              } : (a4.setAxisSize(), a4.setAxisTranslation());
            });
          }
        });
        B(I, "render", function() {
          this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
        });
        I.prototype.setUpScrolling = function() {
          const a3 = { WebkitOverflowScrolling: "touch", overflowX: "hidden", overflowY: "hidden" };
          this.scrollablePixelsX && (a3.overflowX = "auto");
          this.scrollablePixelsY && (a3.overflowY = "auto");
          this.scrollingParent = u("div", { className: "highcharts-scrolling-parent" }, { position: "relative" }, this.renderTo);
          this.scrollingContainer = u("div", { className: "highcharts-scrolling" }, a3, this.scrollingParent);
          let l3;
          B(this.scrollingContainer, "scroll", () => {
            this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (l3 = this.hoverPoint), this.pointer.runPointActions(void 0, l3, true));
          });
          this.innerContainer = u("div", { className: "highcharts-inner-container" }, null, this.scrollingContainer);
          this.innerContainer.appendChild(this.container);
          this.setUpScrolling = null;
        };
        I.prototype.moveFixedElements = function() {
          let a3 = this.container, l3 = this.fixedRenderer, h = ".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "), g;
          this.scrollablePixelsX && !this.inverted ? g = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (g = ".highcharts-yaxis");
          g && h.push(`${g}:not(.highcharts-radial-axis)`, `${g}-labels:not(.highcharts-radial-axis-labels)`);
          h.forEach(function(e) {
            [].forEach.call(a3.querySelectorAll(e), function(a4) {
              (a4.namespaceURI === l3.SVG_NS ? l3.box : l3.box.parentNode).appendChild(a4);
              a4.style.pointerEvents = "auto";
            });
          });
        };
        I.prototype.applyFixed = function() {
          var a3 = !this.fixedDiv, l3 = this.options.chart, h = l3.scrollablePlotArea, g = C.getRendererType();
          a3 ? (this.fixedDiv = u("div", { className: "highcharts-fixed" }, { position: "absolute", overflow: "hidden", pointerEvents: "none", zIndex: (l3.style && l3.style.zIndex || 0) + 2, top: 0 }, null, true), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = l3 = new g(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = l3.path().attr({ fill: this.options.chart.backgroundColor || "#fff", "fill-opacity": p(h.opacity, 0.85), zIndex: -1 }).addClass("highcharts-scrollable-mask").add(), B(this, "afterShowResetZoom", this.moveFixedElements), B(this, "afterApplyDrilldown", this.moveFixedElements), B(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
          if (this.scrollableDirty || a3)
            this.scrollableDirty = false, this.moveFixedElements();
          l3 = this.chartWidth + (this.scrollablePixelsX || 0);
          g = this.chartHeight + (this.scrollablePixelsY || 0);
          x(this.container);
          this.container.style.width = l3 + "px";
          this.container.style.height = g + "px";
          this.renderer.boxWrapper.attr({ width: l3, height: g, viewBox: [0, 0, l3, g].join(" ") });
          this.chartBackground.attr({ width: l3, height: g });
          this.scrollingContainer.style.height = this.chartHeight + "px";
          a3 && (h.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * h.scrollPositionX), h.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * h.scrollPositionY));
          g = this.axisOffset;
          a3 = this.plotTop - g[0] - 1;
          h = this.plotLeft - g[3] - 1;
          l3 = this.plotTop + this.plotHeight + g[2] + 1;
          g = this.plotLeft + this.plotWidth + g[1] + 1;
          let e = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), w = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
          a3 = this.scrollablePixelsX ? [["M", 0, a3], ["L", this.plotLeft - 1, a3], ["L", this.plotLeft - 1, l3], ["L", 0, l3], ["Z"], ["M", e, a3], ["L", this.chartWidth, a3], ["L", this.chartWidth, l3], ["L", e, l3], ["Z"]] : this.scrollablePixelsY ? [["M", h, 0], ["L", h, this.plotTop - 1], ["L", g, this.plotTop - 1], ["L", g, 0], ["Z"], ["M", h, w], ["L", h, this.chartHeight], ["L", g, this.chartHeight], [
            "L",
            g,
            w
          ], ["Z"]] : [["M", 0, 0]];
          this.redrawTrigger !== "adjustHeight" && this.scrollableMask.attr({ d: a3 });
        };
        B(y, "afterInit", function() {
          this.chart.scrollableDirty = true;
        });
        B(L, "show", function() {
          this.chart.scrollableDirty = true;
        });
        "";
      });
      M(a, "Core/Axis/Stacking/StackItem.js", [a["Core/Templating.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { format: x } = a2, { series: C } = y, { destroyObjectProperties: z, fireEvent: H, isNumber: B, pick: u } = I;
        class v {
          constructor(a3, p, t, m, h) {
            const g = a3.chart.inverted, e = a3.reversed;
            this.axis = a3;
            a3 = this.isNegative = !!t !== !!e;
            this.options = p = p || {};
            this.x = m;
            this.cumulative = this.total = null;
            this.points = {};
            this.hasValidPoints = false;
            this.stack = h;
            this.rightCliff = this.leftCliff = 0;
            this.alignOptions = { align: p.align || (g ? a3 ? "left" : "right" : "center"), verticalAlign: p.verticalAlign || (g ? "middle" : a3 ? "bottom" : "top"), y: p.y, x: p.x };
            this.textAlign = p.textAlign || (g ? a3 ? "right" : "left" : "center");
          }
          destroy() {
            z(this, this.axis);
          }
          render(a3) {
            const l2 = this.axis.chart, t = this.options;
            var m = t.format;
            m = m ? x(m, this, l2) : t.formatter.call(this);
            this.label ? this.label.attr({ text: m, visibility: "hidden" }) : (this.label = l2.renderer.label(m, null, void 0, t.shape, void 0, void 0, t.useHTML, false, "stack-labels"), m = { r: t.borderRadius || 0, text: m, padding: u(t.padding, 5), visibility: "hidden" }, l2.styledMode || (m.fill = t.backgroundColor, m.stroke = t.borderColor, m["stroke-width"] = t.borderWidth, this.label.css(t.style || {})), this.label.attr(m), this.label.added || this.label.add(a3));
            this.label.labelrank = l2.plotSizeY;
            H(this, "afterRender");
          }
          setOffset(a3, p, t, m, h, g) {
            const {
              alignOptions: e,
              axis: l2,
              label: v2,
              options: x2,
              textAlign: d
            } = this, k = l2.chart;
            t = this.getStackBox({ xOffset: a3, width: p, boxBottom: t, boxTop: m, defaultX: h, xAxis: g });
            var { verticalAlign: r } = e;
            if (v2 && t) {
              m = v2.getBBox();
              h = v2.padding;
              g = u(x2.overflow, "justify") === "justify";
              e.x = x2.x || 0;
              e.y = x2.y || 0;
              const { x: a4, y: p2 } = this.adjustStackPosition({ labelBox: m, verticalAlign: r, textAlign: d });
              t.x -= a4;
              t.y -= p2;
              v2.align(e, false, t);
              (r = k.isInsidePlot(v2.alignAttr.x + e.x + a4, v2.alignAttr.y + e.y + p2)) || (g = false);
              g && C.prototype.justifyDataLabel.call(l2, v2, e, v2.alignAttr, m, t);
              v2.attr({
                x: v2.alignAttr.x,
                y: v2.alignAttr.y,
                rotation: x2.rotation,
                rotationOriginX: m.width / 2,
                rotationOriginY: m.height / 2
              });
              u(!g && x2.crop, true) && (r = B(v2.x) && B(v2.y) && k.isInsidePlot(v2.x - h + v2.width, v2.y) && k.isInsidePlot(v2.x + h, v2.y));
              v2[r ? "show" : "hide"]();
            }
            H(this, "afterSetOffset", { xOffset: a3, width: p });
          }
          adjustStackPosition({ labelBox: a3, verticalAlign: p, textAlign: t }) {
            const l2 = { bottom: 0, middle: 1, top: 2, right: 1, center: 0, left: -1 };
            return { x: a3.width / 2 + a3.width / 2 * l2[t], y: a3.height / 2 * l2[p] };
          }
          getStackBox(a3) {
            var l2 = this.axis;
            const t = l2.chart, {
              boxTop: m,
              defaultX: h,
              xOffset: g,
              width: e,
              boxBottom: w
            } = a3;
            var v2 = l2.stacking.usePercentage ? 100 : u(m, this.total, 0);
            v2 = l2.toPixels(v2);
            a3 = a3.xAxis || t.xAxis[0];
            const x2 = u(h, a3.translate(this.x)) + g;
            l2 = l2.toPixels(w || B(l2.min) && l2.logarithmic && l2.logarithmic.lin2log(l2.min) || 0);
            l2 = Math.abs(v2 - l2);
            const d = this.isNegative;
            return t.inverted ? { x: (d ? v2 : v2 - l2) - t.plotLeft, y: a3.height - x2 - e, width: l2, height: e } : { x: x2 + a3.transB - t.plotLeft, y: (d ? v2 - l2 : v2) - t.plotTop, width: e, height: l2 };
          }
        }
        "";
        return v;
      });
      M(a, "Core/Axis/Stacking/StackingAxis.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Axis/Axis.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Axis/Stacking/StackItem.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, I, L, C) {
        function x() {
          const b2 = this, a3 = b2.inverted;
          b2.yAxis.forEach((b3) => {
            b3.stacking && b3.stacking.stacks && b3.hasVisibleSeries && (b3.stacking.oldStacks = b3.stacking.stacks);
          });
          b2.series.forEach((c) => {
            const d2 = c.xAxis && c.xAxis.options || {};
            !c.options.stacking || c.visible !== true && b2.options.chart.ignoreHiddenSeries !== false || (c.stackKey = [c.type, q(c.options.stack, ""), a3 ? d2.top : d2.left, a3 ? d2.height : d2.width].join());
          });
        }
        function H() {
          const b2 = this.stacking;
          if (b2) {
            var a3 = b2.stacks;
            r(a3, function(b3, c) {
              E(b3);
              a3[c] = null;
            });
            b2 && b2.stackTotalGroup && b2.stackTotalGroup.destroy();
          }
        }
        function B() {
          this.coll !== "yAxis" || this.stacking || (this.stacking = new G(this));
        }
        function u(b2, a3, d2, e2) {
          !w(b2) || b2.x !== a3 || e2 && b2.stackKey !== e2 ? b2 = { x: a3, index: 0, key: e2, stackKey: e2 } : b2.index++;
          b2.key = [d2, a3, b2.index].join();
          return b2;
        }
        function v() {
          const b2 = this, a3 = b2.stackKey, d2 = b2.yAxis.stacking.stacks, e2 = b2.processedXData, g2 = b2[b2.options.stacking + "Stacker"];
          let k2;
          g2 && [a3, "-" + a3].forEach((a4) => {
            let c = e2.length;
            let f;
            for (; c--; ) {
              var h3 = e2[c];
              k2 = b2.getStackIndicator(k2, h3, b2.index, a4);
              (f = (h3 = d2[a4] && d2[a4][h3]) && h3.points[k2.key]) && g2.call(b2, f, h3, c);
            }
          });
        }
        function l2(b2, a3, d2) {
          a3 = a3.total ? 100 / a3.total : 0;
          b2[0] = e(b2[0] * a3);
          b2[1] = e(b2[1] * a3);
          this.stackedYData[d2] = b2[1];
        }
        function p() {
          const b2 = this.yAxis.stacking;
          this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? h.setStackedPoints.call(this, "group") : b2 && r(b2.stacks, (a3, d2) => {
            d2.slice(-5) === "group" && (r(a3, (b3) => b3.destroy()), delete b2.stacks[d2]);
          });
        }
        function t(b2) {
          var a3 = this.chart;
          const f = b2 || this.options.stacking;
          if (f && (this.visible === true || a3.options.chart.ignoreHiddenSeries === false)) {
            var g2 = this.processedXData, k2 = this.processedYData, h3 = [], l3 = k2.length, m2 = this.options, p2 = m2.threshold, r2 = q(m2.startFromThreshold && p2, 0);
            m2 = m2.stack;
            b2 = b2 ? `${this.type},${f}` : this.stackKey;
            var t2 = "-" + b2, v2 = this.negStacks;
            a3 = f === "group" ? a3.yAxis[0] : this.yAxis;
            var u2 = a3.stacking.stacks, x2 = a3.stacking.oldStacks, E2, G2;
            a3.stacking.stacksTouched += 1;
            for (G2 = 0; G2 < l3; G2++) {
              var F2 = g2[G2];
              var B2 = k2[G2];
              var y2 = this.getStackIndicator(y2, F2, this.index);
              var C2 = y2.key;
              var z = (E2 = v2 && B2 < (r2 ? 0 : p2)) ? t2 : b2;
              u2[z] || (u2[z] = {});
              u2[z][F2] || (x2[z] && x2[z][F2] ? (u2[z][F2] = x2[z][F2], u2[z][F2].total = null) : u2[z][F2] = new L(a3, a3.options.stackLabels, !!E2, F2, m2));
              z = u2[z][F2];
              B2 !== null ? (z.points[C2] = z.points[this.index] = [q(z.cumulative, r2)], w(z.cumulative) || (z.base = C2), z.touched = a3.stacking.stacksTouched, 0 < y2.index && this.singleStacks === false && (z.points[C2][0] = z.points[this.index + "," + F2 + ",0"][0])) : z.points[C2] = z.points[this.index] = null;
              f === "percent" ? (E2 = E2 ? b2 : t2, v2 && u2[E2] && u2[E2][F2] ? (E2 = u2[E2][F2], z.total = E2.total = Math.max(E2.total, z.total) + Math.abs(B2) || 0) : z.total = e(z.total + (Math.abs(B2) || 0))) : f === "group" ? (d(B2) && (B2 = B2[0]), B2 !== null && (z.total = (z.total || 0) + 1)) : z.total = e(z.total + (B2 || 0));
              z.cumulative = f === "group" ? (z.total || 1) - 1 : e(q(z.cumulative, r2) + (B2 || 0));
              B2 !== null && (z.points[C2].push(z.cumulative), h3[G2] = z.cumulative, z.hasValidPoints = true);
            }
            f === "percent" && (a3.stacking.usePercentage = true);
            f !== "group" && (this.stackedYData = h3);
            a3.stacking.oldStacks = {};
          }
        }
        const { getDeferredAnimation: m } = a2, { series: { prototype: h } } = I, { addEvent: g, correctFloat: e, defined: w, destroyObjectProperties: E, fireEvent: F, isArray: d, isNumber: k, objectEach: r, pick: q } = C;
        class G {
          constructor(b2) {
            this.oldStacks = {};
            this.stacks = {};
            this.stacksTouched = 0;
            this.axis = b2;
          }
          buildStacks() {
            const b2 = this.axis, a3 = b2.series, d2 = b2.options.reversedStacks, e2 = a3.length;
            let g2, k2;
            this.usePercentage = false;
            for (k2 = e2; k2--; )
              g2 = a3[d2 ? k2 : e2 - k2 - 1], g2.setStackedPoints(), g2.setGroupedPoints();
            for (k2 = 0; k2 < e2; k2++)
              a3[k2].modifyStacks();
            F(b2, "afterBuildStacks");
          }
          cleanStacks() {
            let b2;
            this.oldStacks && (b2 = this.stacks = this.oldStacks);
            r(b2, function(b3) {
              r(b3, function(b4) {
                b4.cumulative = b4.total;
              });
            });
          }
          resetStacks() {
            r(this.stacks, (b2) => {
              r(b2, (a3, d2) => {
                k(a3.touched) && a3.touched < this.stacksTouched ? (a3.destroy(), delete b2[d2]) : (a3.total = null, a3.cumulative = null);
              });
            });
          }
          renderStackTotals() {
            var b2 = this.axis;
            const a3 = b2.chart, d2 = a3.renderer, e2 = this.stacks;
            b2 = m(a3, b2.options.stackLabels && b2.options.stackLabels.animation || false);
            const g2 = this.stackTotalGroup = this.stackTotalGroup || d2.g("stack-labels").attr({ zIndex: 6, opacity: 0 }).add();
            g2.translate(a3.plotLeft, a3.plotTop);
            r(e2, function(b3) {
              r(b3, function(b4) {
                b4.render(g2);
              });
            });
            g2.animate({ opacity: 1 }, b2);
          }
        }
        var b;
        (function(b2) {
          const a3 = [];
          b2.compose = function(b3, c, d2) {
            C.pushUnique(a3, b3) && (g(b3, "init", B), g(b3, "destroy", H));
            C.pushUnique(a3, c) && (c.prototype.getStacks = x);
            C.pushUnique(a3, d2) && (b3 = d2.prototype, b3.getStackIndicator = u, b3.modifyStacks = v, b3.percentStacker = l2, b3.setGroupedPoints = p, b3.setStackedPoints = t);
          };
        })(b || (b = {}));
        return b;
      });
      M(a, "Series/Line/LineSeries.js", [a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { defined: x, merge: C } = I;
        class z extends a2 {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          drawGraph() {
            const a3 = this, x2 = this.options, u = (this.gappedPath || this.getGraphPath).call(this), v = this.chart.styledMode;
            let l2 = [["graph", "highcharts-graph"]];
            v || l2[0].push(x2.lineColor || this.color || "#cccccc", x2.dashStyle);
            l2 = a3.getZonesGraphs(l2);
            l2.forEach(function(l3, t) {
              var m = l3[0];
              let h = a3[m];
              const g = h ? "animate" : "attr";
              h ? (h.endX = a3.preventGraphAnimation ? null : u.xMap, h.animate({ d: u })) : u.length && (a3[m] = h = a3.chart.renderer.path(u).addClass(l3[1]).attr({ zIndex: 1 }).add(a3.group));
              h && !v && (m = { stroke: l3[2], "stroke-width": x2.lineWidth || 0, fill: a3.fillGraph && a3.color || "none" }, l3[3] ? m.dashstyle = l3[3] : x2.linecap !== "square" && (m["stroke-linecap"] = m["stroke-linejoin"] = "round"), h[g](m).shadow(2 > t && x2.shadow));
              h && (h.startX = u.xMap, h.isArea = u.isArea);
            });
          }
          getGraphPath(a3, B, u) {
            const v = this, l2 = v.options, p = [], t = [];
            let m, h = l2.step;
            a3 = a3 || v.points;
            const g = a3.reversed;
            g && a3.reverse();
            (h = { right: 1, center: 2 }[h] || h && 3) && g && (h = 4 - h);
            a3 = this.getValidPoints(a3, false, !(l2.connectNulls && !B && !u));
            a3.forEach(function(e, g2) {
              const w = e.plotX, F = e.plotY, d = a3[g2 - 1], k = e.isNull || typeof F !== "number";
              (e.leftCliff || d && d.rightCliff) && !u && (m = true);
              k && !x(B) && 0 < g2 ? m = !l2.connectNulls : k && !B ? m = true : (g2 === 0 || m ? g2 = [["M", e.plotX, e.plotY]] : v.getPointSpline ? g2 = [v.getPointSpline(a3, e, g2)] : h ? (g2 = h === 1 ? [["L", d.plotX, F]] : h === 2 ? [["L", (d.plotX + w) / 2, d.plotY], ["L", (d.plotX + w) / 2, F]] : [["L", w, d.plotY]], g2.push(["L", w, F])) : g2 = [["L", w, F]], t.push(e.x), h && (t.push(e.x), h === 2 && t.push(e.x)), p.push.apply(p, g2), m = false);
            });
            p.xMap = t;
            return v.graphPath = p;
          }
          getZonesGraphs(a3) {
            this.zones.forEach(function(x2, u) {
              u = ["zone-graph-" + u, "highcharts-graph highcharts-zone-graph-" + u + " " + (x2.className || "")];
              this.chart.styledMode || u.push(x2.color || this.color, x2.dashStyle || this.options.dashStyle);
              a3.push(u);
            }, this);
            return a3;
          }
        }
        z.defaultOptions = C(a2.defaultOptions, { legendSymbol: "lineMarker" });
        y.registerSeriesType("line", z);
        "";
        return z;
      });
      M(a, "Series/Area/AreaSeries.js", [
        a["Core/Color/Color.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, I) {
        const { seriesTypes: { line: x } } = y, { extend: C, merge: z, objectEach: H, pick: B } = I;
        class u extends x {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          drawGraph() {
            this.areaPath = [];
            super.drawGraph.apply(this);
            const a3 = this, l2 = this.areaPath, p = this.options, t = [["area", "highcharts-area", this.color, p.fillColor]];
            this.zones.forEach(function(l3, h) {
              t.push(["zone-area-" + h, "highcharts-area highcharts-zone-area-" + h + " " + l3.className, l3.color || a3.color, l3.fillColor || p.fillColor]);
            });
            t.forEach(function(m) {
              const h = m[0], g = {};
              let e = a3[h];
              const t2 = e ? "animate" : "attr";
              e ? (e.endX = a3.preventGraphAnimation ? null : l2.xMap, e.animate({ d: l2 })) : (g.zIndex = 0, e = a3[h] = a3.chart.renderer.path(l2).addClass(m[1]).add(a3.group), e.isArea = true);
              a3.chart.styledMode || (m[3] ? g.fill = m[3] : (g.fill = m[2], g["fill-opacity"] = B(p.fillOpacity, 0.75)));
              e[t2](g);
              e.startX = l2.xMap;
              e.shiftUnit = p.step ? 2 : 1;
            });
          }
          getGraphPath(a3) {
            var l2 = x.prototype.getGraphPath, p = this.options;
            const t = p.stacking, m = this.yAxis, h = [], g = [], e = this.index, w = m.stacking.stacks[this.stackKey], v = p.threshold, u2 = Math.round(m.getThreshold(p.threshold));
            p = B(p.connectNulls, t === "percent");
            var d = function(d2, b, f) {
              var c = a3[d2];
              d2 = t && w[c.x].points[e];
              const n3 = c[f + "Null"] || 0;
              f = c[f + "Cliff"] || 0;
              let l3, q2;
              c = true;
              f || n3 ? (l3 = (n3 ? d2[0] : d2[1]) + f, q2 = d2[0] + f, c = !!n3) : !t && a3[b] && a3[b].isNull && (l3 = q2 = v);
              typeof l3 !== "undefined" && (g.push({ plotX: k, plotY: l3 === null ? u2 : m.getThreshold(l3), isNull: c, isCliff: true }), h.push({ plotX: k, plotY: q2 === null ? u2 : m.getThreshold(q2), doCurve: false }));
            };
            let k;
            a3 = a3 || this.points;
            t && (a3 = this.getStackPoints(a3));
            for (let e2 = 0, b = a3.length; e2 < b; ++e2) {
              t || (a3[e2].leftCliff = a3[e2].rightCliff = a3[e2].leftNull = a3[e2].rightNull = void 0);
              var r = a3[e2].isNull;
              k = B(a3[e2].rectPlotX, a3[e2].plotX);
              var q = t ? B(a3[e2].yBottom, u2) : u2;
              if (!r || p)
                p || d(e2, e2 - 1, "left"), r && !t && p || (g.push(a3[e2]), h.push({ x: e2, plotX: k, plotY: q })), p || d(e2, e2 + 1, "right");
            }
            d = l2.call(this, g, true, true);
            h.reversed = true;
            r = l2.call(this, h, true, true);
            (q = r[0]) && q[0] === "M" && (r[0] = ["L", q[1], q[2]]);
            r = d.concat(r);
            r.length && r.push(["Z"]);
            l2 = l2.call(this, g, false, p);
            r.xMap = d.xMap;
            this.areaPath = r;
            return l2;
          }
          getStackPoints(a3) {
            const l2 = this, p = [], t = [], m = this.xAxis, h = this.yAxis, g = h.stacking.stacks[this.stackKey], e = {}, w = h.series, v = w.length, u2 = h.options.reversedStacks ? 1 : -1, d = w.indexOf(l2);
            a3 = a3 || this.points;
            if (this.options.stacking) {
              for (let d2 = 0; d2 < a3.length; d2++)
                a3[d2].leftNull = a3[d2].rightNull = void 0, e[a3[d2].x] = a3[d2];
              H(g, function(a4, d2) {
                a4.total !== null && t.push(d2);
              });
              t.sort(function(a4, d2) {
                return a4 - d2;
              });
              const k = w.map((a4) => a4.visible);
              t.forEach(function(a4, q) {
                let r = 0, b, f;
                if (e[a4] && !e[a4].isNull)
                  p.push(e[a4]), [-1, 1].forEach(function(c) {
                    const h3 = c === 1 ? "rightNull" : "leftNull", m2 = g[t[q + c]];
                    let p2 = 0;
                    if (m2) {
                      let c2 = d;
                      for (; 0 <= c2 && c2 < v; ) {
                        const d2 = w[c2].index;
                        b = m2.points[d2];
                        b || (d2 === l2.index ? e[a4][h3] = true : k[c2] && (f = g[a4].points[d2]) && (p2 -= f[1] - f[0]));
                        c2 += u2;
                      }
                    }
                    e[a4][c === 1 ? "rightCliff" : "leftCliff"] = p2;
                  });
                else {
                  let c = d;
                  for (; 0 <= c && c < v; ) {
                    if (b = g[a4].points[w[c].index]) {
                      r = b[1];
                      break;
                    }
                    c += u2;
                  }
                  r = B(r, 0);
                  r = h.translate(r, 0, 1, 0, 1);
                  p.push({ isNull: true, plotX: m.translate(a4, 0, 0, 0, 1), x: a4, plotY: r, yBottom: r });
                }
              });
            }
            return p;
          }
        }
        u.defaultOptions = z(x.defaultOptions, { threshold: 0, legendSymbol: "rectangle" });
        C(u.prototype, { singleStacks: false });
        y.registerSeriesType("area", u);
        "";
        return u;
      });
      M(a, "Series/Spline/SplineSeries.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y) {
        const { line: x } = a2.seriesTypes, { merge: L, pick: C } = y;
        class z extends x {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          getPointSpline(a3, x2, u) {
            const v = x2.plotX || 0, l2 = x2.plotY || 0, p = a3[u - 1];
            u = a3[u + 1];
            let t, m;
            let h;
            if (p && !p.isNull && p.doCurve !== false && !x2.isCliff && u && !u.isNull && u.doCurve !== false && !x2.isCliff) {
              a3 = p.plotY || 0;
              var g = u.plotX || 0;
              u = u.plotY || 0;
              let e = 0;
              t = (1.5 * v + (p.plotX || 0)) / 2.5;
              m = (1.5 * l2 + a3) / 2.5;
              g = (1.5 * v + g) / 2.5;
              h = (1.5 * l2 + u) / 2.5;
              g !== t && (e = (h - m) * (g - v) / (g - t) + l2 - h);
              m += e;
              h += e;
              m > a3 && m > l2 ? (m = Math.max(a3, l2), h = 2 * l2 - m) : m < a3 && m < l2 && (m = Math.min(a3, l2), h = 2 * l2 - m);
              h > u && h > l2 ? (h = Math.max(u, l2), m = 2 * l2 - h) : h < u && h < l2 && (h = Math.min(u, l2), m = 2 * l2 - h);
              x2.rightContX = g;
              x2.rightContY = h;
            }
            x2 = ["C", C(p.rightContX, p.plotX, 0), C(p.rightContY, p.plotY, 0), C(t, v, 0), C(m, l2, 0), v, l2];
            p.rightContX = p.rightContY = void 0;
            return x2;
          }
        }
        z.defaultOptions = L(x.defaultOptions);
        a2.registerSeriesType("spline", z);
        "";
        return z;
      });
      M(a, "Series/AreaSpline/AreaSplineSeries.js", [a["Series/Spline/SplineSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { area: x, area: { prototype: C } } = y.seriesTypes, { extend: z, merge: H } = I;
        class B extends a2 {
          constructor() {
            super(...arguments);
            this.options = this.points = this.data = void 0;
          }
        }
        B.defaultOptions = H(a2.defaultOptions, x.defaultOptions);
        z(B.prototype, { getGraphPath: C.getGraphPath, getStackPoints: C.getStackPoints, drawGraph: C.drawGraph });
        y.registerSeriesType("areaspline", B);
        "";
        return B;
      });
      M(a, "Series/Column/ColumnSeriesDefaults.js", [], function() {
        "";
        return { borderRadius: 3, centerInCategory: false, groupPadding: 0.2, marker: null, pointPadding: 0.1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { halo: false, brightness: 0.1 }, select: { color: "#cccccc", borderColor: "#000000" } }, dataLabels: { align: void 0, verticalAlign: void 0, y: void 0 }, startFromThreshold: true, stickyTracking: false, tooltip: { distance: 6 }, threshold: 0, borderColor: "#ffffff" };
      });
      M(a, "Series/Column/ColumnSeries.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Color/Color.js"],
        a["Series/Column/ColumnSeriesDefaults.js"],
        a["Core/Globals.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, I, L, C, z, H) {
        const { animObject: x } = a2, { parse: u } = y, { hasTouch: v, noop: l2 } = L, { clamp: p, defined: t, extend: m, fireEvent: h, isArray: g, isNumber: e, merge: w, pick: E, objectEach: F } = H;
        class d extends C {
          constructor() {
            super(...arguments);
            this.points = this.options = this.group = this.data = this.borderWidth = void 0;
          }
          animate(a3) {
            const d2 = this, e2 = this.yAxis, g2 = e2.pos, b = d2.options, f = this.chart.inverted, c = {}, k = f ? "translateX" : "translateY";
            let h3;
            a3 ? (c.scaleY = 1e-3, a3 = p(e2.toPixels(b.threshold), g2, g2 + e2.len), f ? c.translateX = a3 - e2.len : c.translateY = a3, d2.clipBox && d2.setClip(), d2.group.attr(c)) : (h3 = Number(d2.group.attr(k)), d2.group.animate({ scaleY: 1 }, m(x(d2.options.animation), { step: function(b2, a4) {
              d2.group && (c[k] = h3 + a4.pos * (g2 - h3), d2.group.attr(c));
            } })));
          }
          init(a3, d2) {
            super.init.apply(this, arguments);
            const e2 = this;
            a3 = e2.chart;
            a3.hasRendered && a3.series.forEach(function(a4) {
              a4.type === e2.type && (a4.isDirty = true);
            });
          }
          getColumnMetrics() {
            const a3 = this;
            var d2 = a3.options;
            const e2 = a3.xAxis, g2 = a3.yAxis;
            var b = e2.options.reversedStacks;
            b = e2.reversed && !b || !e2.reversed && b;
            const f = {};
            let c, h3 = 0;
            d2.grouping === false ? h3 = 1 : a3.chart.series.forEach(function(b2) {
              const d3 = b2.yAxis, e3 = b2.options;
              let k;
              b2.type !== a3.type || !b2.visible && a3.chart.options.chart.ignoreHiddenSeries || g2.len !== d3.len || g2.pos !== d3.pos || (e3.stacking && e3.stacking !== "group" ? (c = b2.stackKey, typeof f[c] === "undefined" && (f[c] = h3++), k = f[c]) : e3.grouping !== false && (k = h3++), b2.columnIndex = k);
            });
            const l3 = Math.min(Math.abs(e2.transA) * (e2.ordinal && e2.ordinal.slope || d2.pointRange || e2.closestPointRange || e2.tickInterval || 1), e2.len), m2 = l3 * d2.groupPadding, p2 = (l3 - 2 * m2) / (h3 || 1);
            d2 = Math.min(d2.maxPointWidth || e2.len, E(d2.pointWidth, p2 * (1 - 2 * d2.pointPadding)));
            a3.columnMetrics = { width: d2, offset: (p2 - d2) / 2 + (m2 + ((a3.columnIndex || 0) + (b ? 1 : 0)) * p2 - l3 / 2) * (b ? -1 : 1), paddedWidth: p2, columnCount: h3 };
            return a3.columnMetrics;
          }
          crispCol(a3, d2, e2, g2) {
            var b = this.borderWidth, f = -(b % 2 ? 0.5 : 0);
            b = b % 2 ? 0.5 : 1;
            this.options.crisp && (e2 = Math.round(a3 + e2) + f, a3 = Math.round(a3) + f, e2 -= a3);
            g2 = Math.round(d2 + g2) + b;
            f = 0.5 >= Math.abs(d2) && 0.5 < g2;
            d2 = Math.round(d2) + b;
            g2 -= d2;
            f && g2 && (--d2, g2 += 1);
            return { x: a3, y: d2, width: e2, height: g2 };
          }
          adjustForMissingColumns(a3, d2, e2, h3) {
            const b = this.options.stacking;
            if (!e2.isNull && 1 < h3.columnCount) {
              const f = this.yAxis.options.reversedStacks;
              let c = 0, k = f ? 0 : -h3.columnCount;
              F(this.yAxis.stacking && this.yAxis.stacking.stacks, (a4) => {
                if (typeof e2.x === "number") {
                  const d3 = a4[e2.x.toString()];
                  d3 && (a4 = d3.points[this.index], b ? (a4 && (c = k), d3.hasValidPoints && (f ? k++ : k--)) : g(a4) && (a4 = Object.keys(d3.points).filter((b2) => !b2.match(",") && d3.points[b2] && 1 < d3.points[b2].length).map(parseFloat).sort((b2, a5) => a5 - b2), c = a4.indexOf(this.index), k = a4.length));
                }
              });
              a3 = (e2.plotX || 0) + ((k - 1) * h3.paddedWidth + d2) / 2 - d2 - c * h3.paddedWidth;
            }
            return a3;
          }
          translate() {
            const a3 = this, d2 = a3.chart, g2 = a3.options;
            var l3 = a3.dense = 2 > a3.closestPointRange * a3.xAxis.transA;
            l3 = a3.borderWidth = E(g2.borderWidth, l3 ? 0 : 1);
            const b = a3.xAxis, f = a3.yAxis, c = g2.threshold, n3 = E(g2.minPointLength, 5), m2 = a3.getColumnMetrics(), w2 = m2.width, v2 = a3.pointXOffset = m2.offset, u2 = a3.dataMin, x2 = a3.dataMax;
            let F2 = a3.barW = Math.max(w2, 1 + 2 * l3), y2 = a3.translatedThreshold = f.getThreshold(c);
            d2.inverted && (y2 -= 0.5);
            g2.pointPadding && (F2 = Math.ceil(F2));
            C.prototype.translate.apply(a3);
            a3.points.forEach(function(k) {
              const h3 = E(k.yBottom, y2);
              var l4 = 999 + Math.abs(h3), q = k.plotX || 0;
              l4 = p(k.plotY, -l4, f.len + l4);
              let r = Math.min(l4, h3), D = Math.max(l4, h3) - r, z2 = w2, B = q + v2, G = F2;
              n3 && Math.abs(D) < n3 && (D = n3, q = !f.reversed && !k.negative || f.reversed && k.negative, e(c) && e(x2) && k.y === c && x2 <= c && (f.min || 0) < c && (u2 !== x2 || (f.max || 0) <= c) && (q = !q, k.negative = !k.negative), r = Math.abs(r - y2) > n3 ? h3 - n3 : y2 - (q ? n3 : 0));
              t(k.options.pointWidth) && (z2 = G = Math.ceil(k.options.pointWidth), B -= Math.round((z2 - w2) / 2));
              g2.centerInCategory && (B = a3.adjustForMissingColumns(B, z2, k, m2));
              k.barX = B;
              k.pointWidth = z2;
              k.tooltipPos = d2.inverted ? [p(f.len + f.pos - d2.plotLeft - l4, f.pos - d2.plotLeft, f.len + f.pos - d2.plotLeft), b.len + b.pos - d2.plotTop - B - G / 2, D] : [b.left - d2.plotLeft + B + G / 2, p(l4 + f.pos - d2.plotTop, f.pos - d2.plotTop, f.len + f.pos - d2.plotTop), D];
              k.shapeType = a3.pointClass.prototype.shapeType || "roundedRect";
              k.shapeArgs = a3.crispCol(B, k.isNull ? y2 : r, G, k.isNull ? 0 : D);
            });
            h(this, "afterColumnTranslate");
          }
          drawGraph() {
            this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
          }
          pointAttribs(a3, d2) {
            const e2 = this.options;
            var g2 = this.pointAttrToOptions || {}, b = g2.stroke || "borderColor";
            const f = g2["stroke-width"] || "borderWidth";
            let c, k = a3 && a3.color || this.color, h3 = a3 && a3[b] || e2[b] || k;
            g2 = a3 && a3.options.dashStyle || e2.dashStyle;
            let l3 = a3 && a3[f] || e2[f] || this[f] || 0, m2 = E(a3 && a3.opacity, e2.opacity, 1);
            a3 && this.zones.length && (c = a3.getZone(), k = a3.options.color || c && (c.color || a3.nonZonedColor) || this.color, c && (h3 = c.borderColor || h3, g2 = c.dashStyle || g2, l3 = c.borderWidth || l3));
            d2 && a3 && (a3 = w(e2.states[d2], a3.options.states && a3.options.states[d2] || {}), d2 = a3.brightness, k = a3.color || typeof d2 !== "undefined" && u(k).brighten(a3.brightness).get() || k, h3 = a3[b] || h3, l3 = a3[f] || l3, g2 = a3.dashStyle || g2, m2 = E(a3.opacity, m2));
            b = { fill: k, stroke: h3, "stroke-width": l3, opacity: m2 };
            g2 && (b.dashstyle = g2);
            return b;
          }
          drawPoints(a3 = this.points) {
            const d2 = this, g2 = this.chart, k = d2.options, b = g2.renderer, f = k.animationLimit || 250;
            let c;
            a3.forEach(function(a4) {
              let h3 = a4.graphic, l3 = !!h3, n3 = h3 && g2.pointCount < f ? "animate" : "attr";
              if (e(a4.plotY) && a4.y !== null) {
                c = a4.shapeArgs;
                h3 && a4.hasNewShapeType() && (h3 = h3.destroy());
                d2.enabledDataSorting && (a4.startXPos = d2.xAxis.reversed ? -(c ? c.width || 0 : 0) : d2.xAxis.width);
                h3 || (a4.graphic = h3 = b[a4.shapeType](c).add(a4.group || d2.group)) && d2.enabledDataSorting && g2.hasRendered && g2.pointCount < f && (h3.attr({ x: a4.startXPos }), l3 = true, n3 = "animate");
                if (h3 && l3)
                  h3[n3](w(c));
                g2.styledMode || h3[n3](d2.pointAttribs(a4, a4.selected && "select")).shadow(a4.allowShadow !== false && k.shadow);
                h3 && (h3.addClass(a4.getClassName(), true), h3.attr({ visibility: a4.visible ? "inherit" : "hidden" }));
              } else
                h3 && (a4.graphic = h3.destroy());
            });
          }
          drawTracker(a3 = this.points) {
            const d2 = this, e2 = d2.chart, k = e2.pointer, b = function(a4) {
              const b2 = k.getPointFromEvent(a4);
              typeof b2 !== "undefined" && d2.options.enableMouseTracking && (k.isDirectTouch = true, b2.onMouseOver(a4));
            };
            let f;
            a3.forEach(function(a4) {
              f = g(a4.dataLabels) ? a4.dataLabels : a4.dataLabel ? [a4.dataLabel] : [];
              a4.graphic && (a4.graphic.element.point = a4);
              f.forEach(function(b2) {
                b2.div ? b2.div.point = a4 : b2.element.point = a4;
              });
            });
            d2._hasTracking || (d2.trackerGroups.forEach(function(a4) {
              if (d2[a4]) {
                d2[a4].addClass("highcharts-tracker").on("mouseover", b).on("mouseout", function(a5) {
                  k.onTrackerMouseOut(a5);
                });
                if (v)
                  d2[a4].on("touchstart", b);
                !e2.styledMode && d2.options.cursor && d2[a4].css({ cursor: d2.options.cursor });
              }
            }), d2._hasTracking = true);
            h(this, "afterDrawTracker");
          }
          remove() {
            const a3 = this, d2 = a3.chart;
            d2.hasRendered && d2.series.forEach(function(d3) {
              d3.type === a3.type && (d3.isDirty = true);
            });
            C.prototype.remove.apply(a3, arguments);
          }
        }
        d.defaultOptions = w(C.defaultOptions, I);
        m(d.prototype, { cropShoulder: 0, directTouch: true, getSymbol: l2, negStacks: true, trackerGroups: ["group", "dataLabelsGroup"] });
        z.registerSeriesType("column", d);
        "";
        return d;
      });
      M(a, "Core/Series/DataLabel.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Templating.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { getDeferredAnimation: x } = a2, { format: C } = y, { defined: z, extend: H, fireEvent: B, isArray: u, isString: v, merge: l2, objectEach: p, pick: t, splat: m } = I;
        var h;
        (function(a3) {
          function e(a4, d2, c, e2, g2) {
            const b = this.chart;
            var f = this.isCartesian && b.inverted;
            const k2 = this.enabledDataSorting;
            var h4 = a4.plotX, l3 = a4.plotY;
            const n3 = c.rotation;
            var m2 = c.align;
            l3 = z(h4) && z(l3) && b.isInsidePlot(h4, Math.round(l3), { inverted: f, paneCoordinates: true, series: this });
            let p2 = t(c.overflow, k2 ? "none" : "justify") === "justify";
            f = this.visible && a4.visible !== false && z(h4) && (a4.series.forceDL || k2 && !p2 || l3 || t(c.inside, !!this.options.stacking) && e2 && b.isInsidePlot(h4, f ? e2.x + 1 : e2.y + e2.height - 1, { inverted: f, paneCoordinates: true, series: this }));
            h4 = a4.pos();
            if (f && h4) {
              n3 && d2.attr({ align: m2 });
              m2 = d2.getBBox(true);
              var q2 = [0, 0];
              var r2 = b.renderer.fontMetrics(d2).b;
              e2 = H({ x: h4[0], y: Math.round(h4[1]), width: 0, height: 0 }, e2);
              H(c, { width: m2.width, height: m2.height });
              n3 ? (p2 = false, q2 = b.renderer.rotCorr(r2, n3), r2 = { x: e2.x + (c.x || 0) + e2.width / 2 + q2.x, y: e2.y + (c.y || 0) + { top: 0, middle: 0.5, bottom: 1 }[c.verticalAlign] * e2.height }, q2 = [m2.x - Number(d2.attr("x")), m2.y - Number(d2.attr("y"))], k2 && this.xAxis && !p2 && this.setDataLabelStartPos(a4, d2, g2, l3, r2), d2[g2 ? "attr" : "animate"](r2)) : (k2 && this.xAxis && !p2 && this.setDataLabelStartPos(a4, d2, g2, l3, e2), d2.align(c, void 0, e2), r2 = d2.alignAttr);
              if (p2 && 0 <= e2.height)
                this.justifyDataLabel(d2, c, r2, m2, e2, g2);
              else if (t(c.crop, true)) {
                let { x: a5, y: c2 } = r2;
                a5 += q2[0];
                c2 += q2[1];
                f = b.isInsidePlot(a5, c2, {
                  paneCoordinates: true,
                  series: this
                }) && b.isInsidePlot(a5 + m2.width, c2 + m2.height, { paneCoordinates: true, series: this });
              }
              if (c.shape && !n3)
                d2[g2 ? "attr" : "animate"]({ anchorX: h4[0], anchorY: h4[1] });
            }
            g2 && k2 && (d2.placed = false);
            f || k2 && !p2 ? d2.show() : (d2.hide(), d2.placed = false);
          }
          function g(a4, d2) {
            var b = d2.filter;
            return b ? (d2 = b.operator, a4 = a4[b.property], b = b.value, d2 === ">" && a4 > b || d2 === "<" && a4 < b || d2 === ">=" && a4 >= b || d2 === "<=" && a4 <= b || d2 === "==" && a4 == b || d2 === "===" && a4 === b ? true : false) : true;
          }
          function h3() {
            return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
          }
          function F(a4) {
            const b = this.hasRendered || 0, c = this.initDataLabelsGroup().attr({ opacity: +b });
            !b && c && (this.visible && c.show(), this.options.animation ? c.animate({ opacity: 1 }, a4) : c.attr({ opacity: 1 }));
            return c;
          }
          function d(a4 = this.points) {
            var b, c;
            const d2 = this, e2 = d2.chart, k2 = d2.options, h4 = e2.renderer, { backgroundColor: l3, plotBackgroundColor: q2 } = e2.options.chart, w = e2.options.plotOptions, E = h4.getContrast(v(q2) && q2 || v(l3) && l3 || "#000000");
            let F2 = k2.dataLabels, A, y3;
            var G = m(F2)[0];
            const H2 = G.animation;
            G = G.defer ? x(e2, H2, d2) : { defer: 0, duration: 0 };
            F2 = r(r((b = w === null || w === void 0 ? void 0 : w.series) === null || b === void 0 ? void 0 : b.dataLabels, (c = w === null || w === void 0 ? void 0 : w[d2.type]) === null || c === void 0 ? void 0 : c.dataLabels), F2);
            B(this, "drawDataLabels");
            if (u(F2) || F2.enabled || d2._hasPointLabels)
              y3 = this.initDataLabels(G), a4.forEach((a5) => {
                var b2;
                const c2 = a5.dataLabels || [];
                A = m(r(F2, a5.dlOptions || ((b2 = a5.options) === null || b2 === void 0 ? void 0 : b2.dataLabels)));
                A.forEach((b3, f) => {
                  var l4, m2 = b3.enabled && (!a5.isNull || a5.dataLabelOnNull) && g(a5, b3);
                  const n3 = a5.connectors ? a5.connectors[f] : a5.connector, q3 = b3.style || {};
                  let r2 = {}, w2 = c2[f], u2 = !w2;
                  const x2 = t(b3.distance, a5.labelDistance);
                  if (m2) {
                    var A2 = t(b3[a5.formatPrefix + "Format"], b3.format);
                    var F3 = a5.getLabelConfig();
                    F3 = z(A2) ? C(A2, F3, e2) : (b3[a5.formatPrefix + "Formatter"] || b3.formatter).call(F3, b3);
                    A2 = b3.rotation;
                    e2.styledMode || (q3.color = t(b3.color, q3.color, v(d2.color) ? d2.color : void 0, "#000000"), q3.color === "contrast" ? (a5.contrastColor = h4.getContrast(a5.color || d2.color), q3.color = !z(x2) && b3.inside || 0 > (x2 || 0) || k2.stacking ? a5.contrastColor : E) : delete a5.contrastColor, k2.cursor && (q3.cursor = k2.cursor));
                    r2 = { r: b3.borderRadius || 0, rotation: A2, padding: b3.padding, zIndex: 1 };
                    if (!e2.styledMode) {
                      const { backgroundColor: c3, borderColor: d3 } = b3;
                      r2.fill = c3 === "auto" ? a5.color : c3;
                      r2.stroke = d3 === "auto" ? a5.color : d3;
                      r2["stroke-width"] = b3.borderWidth;
                    }
                    p(r2, (a6, b4) => {
                      typeof a6 === "undefined" && delete r2[b4];
                    });
                  }
                  !w2 || m2 && z(F3) && !!w2.div === !!b3.useHTML && (w2.rotation && b3.rotation || w2.rotation === b3.rotation) || (w2 = void 0, u2 = true, n3 && a5.connector && (a5.connector = a5.connector.destroy(), a5.connectors && (a5.connectors.length === 1 ? delete a5.connectors : delete a5.connectors[f])));
                  m2 && z(F3) && (w2 ? r2.text = F3 : (w2 = A2 ? h4.text(F3, 0, 0, b3.useHTML).addClass("highcharts-data-label") : h4.label(F3, 0, 0, b3.shape, void 0, void 0, b3.useHTML, void 0, "data-label")) && w2.addClass(" highcharts-data-label-color-" + a5.colorIndex + " " + (b3.className || "") + (b3.useHTML ? " highcharts-tracker" : "")), w2 && (w2.options = b3, w2.attr(r2), e2.styledMode || w2.css(q3).shadow(b3.shadow), (m2 = b3[a5.formatPrefix + "TextPath"] || b3.textPath) && !b3.useHTML && (w2.setTextPath(((l4 = a5.getDataLabelPath) === null || l4 === void 0 ? void 0 : l4.call(a5, w2)) || a5.graphic, m2), a5.dataLabelPath && !m2.enabled && (a5.dataLabelPath = a5.dataLabelPath.destroy())), w2.added || w2.add(y3), d2.alignDataLabel(a5, w2, b3, void 0, u2), w2.isActive = true, c2[f] && c2[f] !== w2 && c2[f].destroy(), c2[f] = w2));
                });
                for (b2 = c2.length; b2--; )
                  c2[b2].isActive ? c2[b2].isActive = false : (c2[b2].destroy(), c2.splice(b2, 1));
                a5.dataLabel = c2[0];
                a5.dataLabels = c2;
              });
            B(this, "afterDrawDataLabels");
          }
          function k(a4, d2, c, e2, g2, k2) {
            const b = this.chart, f = d2.align, h4 = d2.verticalAlign, l3 = a4.box ? 0 : a4.padding || 0;
            let { x: m2 = 0, y: n3 = 0 } = d2, p2, q2;
            p2 = (c.x || 0) + l3;
            0 > p2 && (f === "right" && 0 <= m2 ? (d2.align = "left", d2.inside = true) : m2 -= p2, q2 = true);
            p2 = (c.x || 0) + e2.width - l3;
            p2 > b.plotWidth && (f === "left" && 0 >= m2 ? (d2.align = "right", d2.inside = true) : m2 += b.plotWidth - p2, q2 = true);
            p2 = c.y + l3;
            0 > p2 && (h4 === "bottom" && 0 <= n3 ? (d2.verticalAlign = "top", d2.inside = true) : n3 -= p2, q2 = true);
            p2 = (c.y || 0) + e2.height - l3;
            p2 > b.plotHeight && (h4 === "top" && 0 >= n3 ? (d2.verticalAlign = "bottom", d2.inside = true) : n3 += b.plotHeight - p2, q2 = true);
            q2 && (d2.x = m2, d2.y = n3, a4.placed = !k2, a4.align(d2, void 0, g2));
            return q2;
          }
          function r(a4, d2) {
            let b = [], f;
            if (u(a4) && !u(d2))
              b = a4.map(function(a5) {
                return l2(a5, d2);
              });
            else if (u(d2) && !u(a4))
              b = d2.map(function(b2) {
                return l2(a4, b2);
              });
            else if (!u(a4) && !u(d2))
              b = l2(a4, d2);
            else if (u(a4) && u(d2))
              for (f = Math.max(a4.length, d2.length); f--; )
                b[f] = l2(a4[f], d2[f]);
            return b;
          }
          function q(a4, d2, c, e2, g2) {
            const b = this.chart, f = b.inverted, k2 = this.xAxis, h4 = k2.reversed, l3 = f ? d2.height / 2 : d2.width / 2;
            a4 = (a4 = a4.pointWidth) ? a4 / 2 : 0;
            d2.startXPos = f ? g2.x : h4 ? -l3 - a4 : k2.width - l3 + a4;
            d2.startYPos = f ? h4 ? this.yAxis.height - l3 + a4 : -l3 - a4 : g2.y;
            e2 ? d2.visibility === "hidden" && (d2.show(), d2.attr({ opacity: 0 }).animate({ opacity: 1 })) : d2.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, d2.hide);
            b.hasRendered && (c && d2.attr({ x: d2.startXPos, y: d2.startYPos }), d2.placed = true);
          }
          const y2 = [];
          a3.compose = function(a4) {
            I.pushUnique(y2, a4) && (a4 = a4.prototype, a4.initDataLabelsGroup = h3, a4.initDataLabels = F, a4.alignDataLabel = e, a4.drawDataLabels = d, a4.justifyDataLabel = k, a4.setDataLabelStartPos = q);
          };
        })(h || (h = {}));
        "";
        return h;
      });
      M(a, "Series/Column/ColumnDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { series: x } = y, { merge: C, pick: z } = I;
        var H;
        (function(y2) {
          function u(a3, p, t, m, h) {
            let g = this.chart.inverted;
            var e = a3.series;
            let l2 = (e.xAxis ? e.xAxis.len : this.chart.plotSizeX) || 0;
            e = (e.yAxis ? e.yAxis.len : this.chart.plotSizeY) || 0;
            var v2 = a3.dlBox || a3.shapeArgs;
            let u2 = z(a3.below, a3.plotY > z(this.translatedThreshold, e)), d = z(t.inside, !!this.options.stacking);
            v2 && (m = C(v2), 0 > m.y && (m.height += m.y, m.y = 0), v2 = m.y + m.height - e, 0 < v2 && v2 < m.height && (m.height -= v2), g && (m = { x: e - m.y - m.height, y: l2 - m.x - m.width, width: m.height, height: m.width }), d || (g ? (m.x += u2 ? 0 : m.width, m.width = 0) : (m.y += u2 ? m.height : 0, m.height = 0)));
            t.align = z(t.align, !g || d ? "center" : u2 ? "right" : "left");
            t.verticalAlign = z(t.verticalAlign, g || d ? "middle" : u2 ? "top" : "bottom");
            x.prototype.alignDataLabel.call(this, a3, p, t, m, h);
            t.inside && a3.contrastColor && p.css({ color: a3.contrastColor });
          }
          const v = [];
          y2.compose = function(l2) {
            a2.compose(x);
            I.pushUnique(v, l2) && (l2.prototype.alignDataLabel = u);
          };
        })(H || (H = {}));
        return H;
      });
      M(a, "Series/Bar/BarSeries.js", [a["Series/Column/ColumnSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { extend: x, merge: C } = I;
        class z extends a2 {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
        }
        z.defaultOptions = C(a2.defaultOptions, {});
        x(z.prototype, { inverted: true });
        y.registerSeriesType("bar", z);
        "";
        return z;
      });
      M(a, "Series/Scatter/ScatterSeriesDefaults.js", [], function() {
        "";
        return { lineWidth: 0, findNearestPointBy: "xy", jitter: { x: 0, y: 0 }, marker: { enabled: true }, tooltip: { headerFormat: '<span style="color:{point.color}">\u25CF</span> <span style="font-size: 0.8em"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" } };
      });
      M(a, "Series/Scatter/ScatterSeries.js", [a["Series/Scatter/ScatterSeriesDefaults.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { column: x, line: C } = y.seriesTypes, { addEvent: z, extend: H, merge: B } = I;
        class u extends C {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          applyJitter() {
            const a3 = this, l2 = this.options.jitter, p = this.points.length;
            l2 && this.points.forEach(function(t, m) {
              ["x", "y"].forEach(function(h, g) {
                let e = "plot" + h.toUpperCase(), w, v;
                if (l2[h] && !t.isNull) {
                  var u2 = a3[h + "Axis"];
                  v = l2[h] * u2.transA;
                  u2 && !u2.isLog && (w = Math.max(0, t[e] - v), u2 = Math.min(u2.len, t[e] + v), g = 1e4 * Math.sin(m + g * p), g -= Math.floor(g), t[e] = w + (u2 - w) * g, h === "x" && (t.clientX = t.plotX));
                }
              });
            });
          }
          drawGraph() {
            this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
          }
        }
        u.defaultOptions = B(C.defaultOptions, a2);
        H(u.prototype, { drawTracker: x.prototype.drawTracker, sorted: false, requireSorting: false, noSharedTooltip: true, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], takeOrdinalPosition: false });
        z(u, "afterTranslate", function() {
          this.applyJitter();
        });
        y.registerSeriesType("scatter", u);
        return u;
      });
      M(a, "Series/CenteredUtilities.js", [a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { deg2rad: x } = a2, { fireEvent: C, isNumber: z, pick: H, relativeLength: B } = I;
        var u;
        (function(a3) {
          a3.getCenter = function() {
            var a4 = this.options, p = this.chart;
            const t = 2 * (a4.slicedOffset || 0), m = p.plotWidth - 2 * t, h = p.plotHeight - 2 * t;
            var g = a4.center;
            const e = Math.min(m, h), w = a4.thickness;
            var v = a4.size;
            let u2 = a4.innerSize || 0;
            typeof v === "string" && (v = parseFloat(v));
            typeof u2 === "string" && (u2 = parseFloat(u2));
            a4 = [H(g[0], "50%"), H(g[1], "50%"), H(v && 0 > v ? void 0 : a4.size, "100%"), H(u2 && 0 > u2 ? void 0 : a4.innerSize || 0, "0%")];
            !p.angular || this instanceof y || (a4[3] = 0);
            for (g = 0; 4 > g; ++g)
              v = a4[g], p = 2 > g || g === 2 && /%$/.test(v), a4[g] = B(v, [m, h, e, a4[2]][g]) + (p ? t : 0);
            a4[3] > a4[2] && (a4[3] = a4[2]);
            z(w) && 2 * w < a4[2] && 0 < w && (a4[3] = a4[2] - 2 * w);
            C(this, "afterGetCenter", { positions: a4 });
            return a4;
          };
          a3.getStartAndEndRadians = function(a4, p) {
            a4 = z(a4) ? a4 : 0;
            p = z(p) && p > a4 && 360 > p - a4 ? p : a4 + 360;
            return { start: x * (a4 + -90), end: x * (p + -90) };
          };
        })(u || (u = {}));
        "";
        return u;
      });
      M(a, "Series/Pie/PiePoint.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function(a2, y, I) {
        const { setAnimation: x } = a2, { addEvent: C, defined: z, extend: H, isNumber: B, pick: u, relativeLength: v } = I;
        class l2 extends y {
          constructor() {
            super(...arguments);
            this.series = this.options = this.labelDistance = void 0;
          }
          getConnectorPath() {
            const a3 = this.labelPosition, l3 = this.series.options.dataLabels, m = this.connectorShapes;
            let h = l3.connectorShape;
            m[h] && (h = m[h]);
            return h.call(this, { x: a3.computed.x, y: a3.computed.y, alignment: a3.alignment }, a3.connectorPosition, l3);
          }
          getTranslate() {
            return this.sliced ? this.slicedTranslation : { translateX: 0, translateY: 0 };
          }
          haloPath(a3) {
            const l3 = this.shapeArgs;
            return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(l3.x, l3.y, l3.r + a3, l3.r + a3, { innerR: l3.r - 1, start: l3.start, end: l3.end, borderRadius: l3.borderRadius });
          }
          init() {
            super.init.apply(this, arguments);
            this.name = u(this.name, "Slice");
            const a3 = (a4) => {
              this.slice(a4.type === "select");
            };
            C(this, "select", a3);
            C(this, "unselect", a3);
            return this;
          }
          isValid() {
            return B(this.y) && 0 <= this.y;
          }
          setVisible(a3, l3) {
            const m = this.series, h = m.chart, g = m.options.ignoreHiddenPoint;
            l3 = u(l3, g);
            a3 !== this.visible && (this.visible = this.options.visible = a3 = typeof a3 === "undefined" ? !this.visible : a3, m.options.data[m.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector"].forEach((e) => {
              if (this[e])
                this[e][a3 ? "show" : "hide"](a3);
            }), this.legendItem && h.legend.colorizeItem(this, a3), a3 || this.state !== "hover" || this.setState(""), g && (m.isDirty = true), l3 && h.redraw());
          }
          slice(a3, l3, m) {
            const h = this.series;
            x(m, h.chart);
            u(l3, true);
            this.sliced = this.options.sliced = z(a3) ? a3 : !this.sliced;
            h.options.data[h.data.indexOf(this)] = this.options;
            this.graphic && this.graphic.animate(this.getTranslate());
          }
        }
        H(l2.prototype, { connectorShapes: { fixedOffset: function(a3, l3, m) {
          const h = l3.breakAt;
          l3 = l3.touchingSliceAt;
          return [["M", a3.x, a3.y], m.softConnector ? ["C", a3.x + (a3.alignment === "left" ? -5 : 5), a3.y, 2 * h.x - l3.x, 2 * h.y - l3.y, h.x, h.y] : ["L", h.x, h.y], ["L", l3.x, l3.y]];
        }, straight: function(a3, l3) {
          l3 = l3.touchingSliceAt;
          return [
            ["M", a3.x, a3.y],
            ["L", l3.x, l3.y]
          ];
        }, crookedLine: function(a3, l3, m) {
          const { breakAt: h, touchingSliceAt: g } = l3;
          ({ series: l3 } = this);
          const [e, p, t] = l3.center, u2 = t / 2, d = l3.chart.plotWidth, k = l3.chart.plotLeft;
          l3 = a3.alignment === "left";
          const { x: r, y: q } = a3;
          m.crookDistance ? (a3 = v(m.crookDistance, 1), a3 = l3 ? e + u2 + (d + k - e - u2) * (1 - a3) : k + (e - u2) * a3) : a3 = e + (p - q) * Math.tan((this.angle || 0) - Math.PI / 2);
          m = [["M", r, q]];
          (l3 ? a3 <= r && a3 >= h.x : a3 >= r && a3 <= h.x) && m.push(["L", a3, q]);
          m.push(["L", h.x, h.y], ["L", g.x, g.y]);
          return m;
        } } });
        return l2;
      });
      M(a, "Series/Pie/PieSeriesDefaults.js", [], function() {
        "";
        return {
          borderRadius: 3,
          center: [null, null],
          clip: false,
          colorByPoint: true,
          dataLabels: { allowOverlap: true, connectorPadding: 5, connectorShape: "crookedLine", crookDistance: void 0, distance: 30, enabled: true, formatter: function() {
            return this.point.isNull ? void 0 : this.point.name;
          }, softConnector: true, x: 0 },
          fillColor: void 0,
          ignoreHiddenPoint: true,
          inactiveOtherPoints: true,
          legendType: "point",
          marker: null,
          size: null,
          showInLegend: false,
          slicedOffset: 10,
          stickyTracking: false,
          tooltip: { followPointer: true },
          borderColor: "#ffffff",
          borderWidth: 1,
          lineWidth: void 0,
          states: { hover: { brightness: 0.1 } }
        };
      });
      M(a, "Series/Pie/PieSeries.js", [a["Series/CenteredUtilities.js"], a["Series/Column/ColumnSeries.js"], a["Core/Globals.js"], a["Series/Pie/PiePoint.js"], a["Series/Pie/PieSeriesDefaults.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/Symbols.js"], a["Core/Utilities.js"]], function(a2, y, I, L, C, z, H, B, u) {
        const { getStartAndEndRadians: v } = a2;
        ({ noop: I } = I);
        const { clamp: l2, extend: p, fireEvent: t, merge: m, pick: h, relativeLength: g } = u;
        class e extends z {
          constructor() {
            super(...arguments);
            this.points = this.options = this.maxLabelDistance = this.data = this.center = void 0;
          }
          animate(a3) {
            const e2 = this, g2 = e2.points, d = e2.startAngleRad;
            a3 || g2.forEach(function(a4) {
              const g3 = a4.graphic, k = a4.shapeArgs;
              g3 && k && (g3.attr({ r: h(a4.startR, e2.center && e2.center[3] / 2), start: d, end: d }), g3.animate({ r: k.r, start: k.start, end: k.end }, e2.options.animation));
            });
          }
          drawEmpty() {
            const a3 = this.startAngleRad, e2 = this.endAngleRad, g2 = this.options;
            let d, k;
            this.total === 0 && this.center ? (d = this.center[0], k = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(d, k, this.center[1] / 2, 0, a3, e2).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({ d: B.arc(d, k, this.center[2] / 2, 0, { start: a3, end: e2, innerR: this.center[3] / 2 }) }), this.chart.styledMode || this.graph.attr({ "stroke-width": g2.borderWidth, fill: g2.fillColor || "none", stroke: g2.color || "#cccccc" })) : this.graph && (this.graph = this.graph.destroy());
          }
          drawPoints() {
            const a3 = this.chart.renderer;
            this.points.forEach(function(e2) {
              e2.graphic && e2.hasNewShapeType() && (e2.graphic = e2.graphic.destroy());
              e2.graphic || (e2.graphic = a3[e2.shapeType](e2.shapeArgs).add(e2.series.group), e2.delayedRendering = true);
            });
          }
          generatePoints() {
            super.generatePoints();
            this.updateTotals();
          }
          getX(a3, e2, g2) {
            const d = this.center, k = this.radii ? this.radii[g2.index] || 0 : d[2] / 2;
            a3 = Math.asin(l2((a3 - d[1]) / (k + g2.labelDistance), -1, 1));
            return d[0] + (e2 ? -1 : 1) * Math.cos(a3) * (k + g2.labelDistance) + (0 < g2.labelDistance ? (e2 ? -1 : 1) * this.options.dataLabels.padding : 0);
          }
          hasData() {
            return !!this.processedXData.length;
          }
          redrawPoints() {
            const a3 = this, e2 = a3.chart;
            let g2, d, k, h3;
            this.drawEmpty();
            a3.group && !e2.styledMode && a3.group.shadow(a3.options.shadow);
            a3.points.forEach(function(l3) {
              const q = {};
              d = l3.graphic;
              !l3.isNull && d ? (h3 = l3.shapeArgs, g2 = l3.getTranslate(), e2.styledMode || (k = a3.pointAttribs(l3, l3.selected && "select")), l3.delayedRendering ? (d.setRadialReference(a3.center).attr(h3).attr(g2), e2.styledMode || d.attr(k).attr({ "stroke-linejoin": "round" }), l3.delayedRendering = false) : (d.setRadialReference(a3.center), e2.styledMode || m(true, q, k), m(true, q, h3, g2), d.animate(q)), d.attr({ visibility: l3.visible ? "inherit" : "hidden" }), d.addClass(l3.getClassName(), true)) : d && (l3.graphic = d.destroy());
            });
          }
          sortByAngle(a3, e2) {
            a3.sort(function(a4, d) {
              return typeof a4.angle !== "undefined" && (d.angle - a4.angle) * e2;
            });
          }
          translate(a3) {
            t(this, "translate");
            this.generatePoints();
            var e2 = this.options;
            const l3 = e2.slicedOffset, d = l3 + (e2.borderWidth || 0);
            var k = v(e2.startAngle, e2.endAngle);
            const m2 = this.startAngleRad = k.start;
            k = (this.endAngleRad = k.end) - m2;
            const q = this.points, p2 = e2.dataLabels.distance;
            e2 = e2.ignoreHiddenPoint;
            const b = q.length;
            let f, c, n3, w = 0;
            a3 || (this.center = a3 = this.getCenter());
            for (c = 0; c < b; c++) {
              n3 = q[c];
              var u2 = m2 + w * k;
              !n3.isValid() || e2 && !n3.visible || (w += n3.percentage / 100);
              var x = m2 + w * k;
              var y2 = {
                x: a3[0],
                y: a3[1],
                r: a3[2] / 2,
                innerR: a3[3] / 2,
                start: Math.round(1e3 * u2) / 1e3,
                end: Math.round(1e3 * x) / 1e3
              };
              n3.shapeType = "arc";
              n3.shapeArgs = y2;
              n3.labelDistance = h(n3.options.dataLabels && n3.options.dataLabels.distance, p2);
              n3.labelDistance = g(n3.labelDistance, y2.r);
              this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, n3.labelDistance);
              x = (x + u2) / 2;
              x > 1.5 * Math.PI ? x -= 2 * Math.PI : x < -Math.PI / 2 && (x += 2 * Math.PI);
              n3.slicedTranslation = { translateX: Math.round(Math.cos(x) * l3), translateY: Math.round(Math.sin(x) * l3) };
              y2 = Math.cos(x) * a3[2] / 2;
              f = Math.sin(x) * a3[2] / 2;
              n3.tooltipPos = [a3[0] + 0.7 * y2, a3[1] + 0.7 * f];
              n3.half = x < -Math.PI / 2 || x > Math.PI / 2 ? 1 : 0;
              n3.angle = x;
              u2 = Math.min(d, n3.labelDistance / 5);
              n3.labelPosition = { natural: { x: a3[0] + y2 + Math.cos(x) * n3.labelDistance, y: a3[1] + f + Math.sin(x) * n3.labelDistance }, computed: {}, alignment: 0 > n3.labelDistance ? "center" : n3.half ? "right" : "left", connectorPosition: { breakAt: { x: a3[0] + y2 + Math.cos(x) * u2, y: a3[1] + f + Math.sin(x) * u2 }, touchingSliceAt: { x: a3[0] + y2, y: a3[1] + f } } };
            }
            t(this, "afterTranslate");
          }
          updateTotals() {
            const a3 = this.points, e2 = a3.length, g2 = this.options.ignoreHiddenPoint;
            let d, k, h3 = 0;
            for (d = 0; d < e2; d++)
              k = a3[d], !k.isValid() || g2 && !k.visible || (h3 += k.y);
            this.total = h3;
            for (d = 0; d < e2; d++)
              k = a3[d], k.percentage = 0 < h3 && (k.visible || !g2) ? k.y / h3 * 100 : 0, k.total = h3;
          }
        }
        e.defaultOptions = m(z.defaultOptions, C);
        p(e.prototype, { axisTypes: [], directTouch: true, drawGraph: void 0, drawTracker: y.prototype.drawTracker, getCenter: a2.getCenter, getSymbol: I, isCartesian: false, noSharedTooltip: true, pointAttribs: y.prototype.pointAttribs, pointClass: L, requireSorting: false, searchPoint: I, trackerGroups: ["group", "dataLabelsGroup"] });
        H.registerSeriesType("pie", e);
        return e;
      });
      M(a, "Series/Pie/PieDataLabel.js", [a["Core/Series/DataLabel.js"], a["Core/Globals.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, I, L, C) {
        const { noop: x } = y, { distribute: H } = I, { series: B } = L, { arrayMax: u, clamp: v, defined: l2, merge: p, pick: t, relativeLength: m } = C;
        var h;
        (function(g) {
          function e() {
            const a3 = this, d2 = a3.data, e2 = a3.chart, g2 = a3.options.dataLabels || {}, b = g2.connectorPadding, f = e2.plotWidth, c = e2.plotHeight, h4 = e2.plotLeft, m2 = Math.round(e2.chartWidth / 3), w = a3.center, v2 = w[2] / 2, x2 = w[1], y3 = [[], []], z2 = [0, 0, 0, 0], F = a3.dataLabelPositioners;
            let C2, A, E, I2, L2, M2, J, N, O, S, W, U2;
            a3.visible && (g2.enabled || a3._hasPointLabels) && (d2.forEach(function(a4) {
              a4.dataLabel && a4.visible && a4.dataLabel.shortened && (a4.dataLabel.attr({ width: "auto" }).css({ width: "auto", textOverflow: "clip" }), a4.dataLabel.shortened = false);
            }), B.prototype.drawDataLabels.apply(a3), d2.forEach(function(a4) {
              a4.dataLabel && (a4.visible ? (y3[a4.half].push(a4), a4.dataLabel._pos = null, !l2(g2.style.width) && !l2(a4.options.dataLabels && a4.options.dataLabels.style && a4.options.dataLabels.style.width) && a4.dataLabel.getBBox().width > m2 && (a4.dataLabel.css({ width: Math.round(0.7 * m2) + "px" }), a4.dataLabel.shortened = true)) : (a4.dataLabel = a4.dataLabel.destroy(), a4.dataLabels && a4.dataLabels.length === 1 && delete a4.dataLabels));
            }), y3.forEach((d3, k) => {
              const m3 = d3.length, n3 = [];
              let q, p2 = 0;
              if (m3) {
                a3.sortByAngle(d3, k - 0.5);
                if (0 < a3.maxLabelDistance) {
                  var r = Math.max(0, x2 - v2 - a3.maxLabelDistance);
                  q = Math.min(x2 + v2 + a3.maxLabelDistance, e2.plotHeight);
                  d3.forEach(function(a4) {
                    0 < a4.labelDistance && a4.dataLabel && (a4.top = Math.max(0, x2 - v2 - a4.labelDistance), a4.bottom = Math.min(x2 + v2 + a4.labelDistance, e2.plotHeight), p2 = a4.dataLabel.getBBox().height || 21, a4.distributeBox = { target: a4.labelPosition.natural.y - a4.top + p2 / 2, size: p2, rank: a4.y }, n3.push(a4.distributeBox));
                  });
                  r = q + p2 - r;
                  H(n3, r, r / 5);
                }
                for (W = 0; W < m3; W++) {
                  C2 = d3[W];
                  M2 = C2.labelPosition;
                  I2 = C2.dataLabel;
                  S = C2.visible === false ? "hidden" : "inherit";
                  O = r = M2.natural.y;
                  n3 && l2(C2.distributeBox) && (typeof C2.distributeBox.pos === "undefined" ? S = "hidden" : (J = C2.distributeBox.size, O = F.radialDistributionY(C2)));
                  delete C2.positionIndex;
                  if (g2.justify)
                    N = F.justify(C2, v2, w);
                  else
                    switch (g2.alignTo) {
                      case "connectors":
                        N = F.alignToConnectors(d3, k, f, h4);
                        break;
                      case "plotEdges":
                        N = F.alignToPlotEdges(I2, k, f, h4);
                        break;
                      default:
                        N = F.radialDistributionX(a3, C2, O, r);
                    }
                  I2._attr = { visibility: S, align: M2.alignment };
                  U2 = C2.options.dataLabels || {};
                  I2._pos = { x: N + t(U2.x, g2.x) + ({ left: b, right: -b }[M2.alignment] || 0), y: O + t(U2.y, g2.y) - I2.getBBox().height / 2 };
                  M2 && (M2.computed.x = N, M2.computed.y = O);
                  t(g2.crop, true) && (L2 = I2.getBBox().width, r = null, N - L2 < b && k === 1 ? (r = Math.round(L2 - N + b), z2[3] = Math.max(r, z2[3])) : N + L2 > f - b && k === 0 && (r = Math.round(N + L2 - f + b), z2[1] = Math.max(r, z2[1])), 0 > O - J / 2 ? z2[0] = Math.max(Math.round(-O + J / 2), z2[0]) : O + J / 2 > c && (z2[2] = Math.max(Math.round(O + J / 2 - c), z2[2])), I2.sideOverflow = r);
                }
              }
            }), u(z2) === 0 || this.verifyDataLabelOverflow(z2)) && (this.placeDataLabels(), this.points.forEach(function(b2) {
              U2 = p(g2, b2.options.dataLabels);
              if (A = t(U2.connectorWidth, 1)) {
                let c2;
                E = b2.connector;
                if ((I2 = b2.dataLabel) && I2._pos && b2.visible && 0 < b2.labelDistance) {
                  S = I2._attr.visibility;
                  if (c2 = !E)
                    b2.connector = E = e2.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + b2.colorIndex + (b2.className ? " " + b2.className : "")).add(a3.dataLabelsGroup), e2.styledMode || E.attr({ "stroke-width": A, stroke: U2.connectorColor || b2.color || "#666666" });
                  E[c2 ? "attr" : "animate"]({ d: b2.getConnectorPath() });
                  E.attr("visibility", S);
                } else
                  E && (b2.connector = E.destroy());
              }
            }));
          }
          function h3() {
            this.points.forEach(function(a3) {
              let d2 = a3.dataLabel, e2;
              d2 && a3.visible && ((e2 = d2._pos) ? (d2.sideOverflow && (d2._attr.width = Math.max(d2.getBBox().width - d2.sideOverflow, 0), d2.css({ width: d2._attr.width + "px", textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis" }), d2.shortened = true), d2.attr(d2._attr), d2[d2.moved ? "animate" : "attr"](e2), d2.moved = true) : d2 && d2.attr({ y: -9999 }));
              delete a3.distributeBox;
            }, this);
          }
          function y2(a3) {
            let d2 = this.center, e2 = this.options, g2 = e2.center, b = e2.minSize || 80, f, c = e2.size !== null;
            c || (g2[0] !== null ? f = Math.max(d2[2] - Math.max(a3[1], a3[3]), b) : (f = Math.max(d2[2] - a3[1] - a3[3], b), d2[0] += (a3[3] - a3[1]) / 2), g2[1] !== null ? f = v(f, b, d2[2] - Math.max(a3[0], a3[2])) : (f = v(f, b, d2[2] - a3[0] - a3[2]), d2[1] += (a3[0] - a3[2]) / 2), f < d2[2] ? (d2[2] = f, d2[3] = Math.min(e2.thickness ? Math.max(0, f - 2 * e2.thickness) : Math.max(0, m(e2.innerSize || 0, f)), f), this.translate(d2), this.drawDataLabels && this.drawDataLabels()) : c = true);
            return c;
          }
          const z = [], d = { radialDistributionY: function(a3) {
            return a3.top + a3.distributeBox.pos;
          }, radialDistributionX: function(a3, d2, e2, g2) {
            return a3.getX(e2 < d2.top + 2 || e2 > d2.bottom - 2 ? g2 : e2, d2.half, d2);
          }, justify: function(a3, d2, e2) {
            return e2[0] + (a3.half ? -1 : 1) * (d2 + a3.labelDistance);
          }, alignToPlotEdges: function(a3, d2, e2, g2) {
            a3 = a3.getBBox().width;
            return d2 ? a3 + g2 : e2 - a3 - g2;
          }, alignToConnectors: function(a3, d2, e2, g2) {
            let b = 0, f;
            a3.forEach(function(a4) {
              f = a4.dataLabel.getBBox().width;
              f > b && (b = f);
            });
            return d2 ? b + g2 : e2 - b - g2;
          } };
          g.compose = function(g2) {
            a2.compose(B);
            C.pushUnique(z, g2) && (g2 = g2.prototype, g2.dataLabelPositioners = d, g2.alignDataLabel = x, g2.drawDataLabels = e, g2.placeDataLabels = h3, g2.verifyDataLabelOverflow = y2);
          };
        })(h || (h = {}));
        return h;
      });
      M(a, "Extensions/OverlappingDataLabels.js", [a["Core/Chart/Chart.js"], a["Core/Utilities.js"]], function(a2, y) {
        function x(a3, l2) {
          let p, t = false;
          a3 && (p = a3.newOpacity, a3.oldOpacity !== p && (a3.alignAttr && a3.placed ? (a3[p ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), t = true, a3.alignAttr.opacity = p, a3[a3.isOld ? "animate" : "attr"](a3.alignAttr, null, function() {
            l2.styledMode || a3.css({ pointerEvents: p ? "auto" : "none" });
          }), C(l2, "afterHideOverlappingLabel")) : a3.attr({ opacity: p })), a3.isOld = true);
          return t;
        }
        const { addEvent: L, fireEvent: C, isArray: z, isNumber: H, objectEach: B, pick: u } = y;
        L(a2, "render", function() {
          let a3 = this, l2 = [];
          (this.labelCollectors || []).forEach(function(a4) {
            l2 = l2.concat(a4());
          });
          (this.yAxis || []).forEach(function(a4) {
            a4.stacking && a4.options.stackLabels && !a4.options.stackLabels.allowOverlap && B(a4.stacking.stacks, function(a5) {
              B(a5, function(a6) {
                a6.label && l2.push(a6.label);
              });
            });
          });
          (this.series || []).forEach(function(p) {
            var t = p.options.dataLabels;
            p.visible && (t.enabled !== false || p._hasPointLabels) && (t = (m) => m.forEach((h) => {
              h.visible && (z(h.dataLabels) ? h.dataLabels : h.dataLabel ? [h.dataLabel] : []).forEach(function(g) {
                const e = g.options;
                g.labelrank = u(e.labelrank, h.labelrank, h.shapeArgs && h.shapeArgs.height);
                e.allowOverlap ? (g.oldOpacity = g.opacity, g.newOpacity = 1, x(g, a3)) : l2.push(g);
              });
            }), t(p.nodes || []), t(p.points));
          });
          this.hideOverlappingLabels(l2);
        });
        a2.prototype.hideOverlappingLabels = function(a3) {
          let l2 = this, p = a3.length, t = l2.renderer;
          var m;
          let h;
          let g, e, w, u2 = false;
          var v = function(a4) {
            let d, e2;
            var g2;
            let h3 = a4.box ? 0 : a4.padding || 0, b = g2 = 0, f, c;
            if (a4 && (!a4.alignAttr || a4.placed))
              return d = a4.alignAttr || { x: a4.attr("x"), y: a4.attr("y") }, e2 = a4.parentGroup, a4.width || (g2 = a4.getBBox(), a4.width = g2.width, a4.height = g2.height, g2 = t.fontMetrics(a4.element).h), f = a4.width - 2 * h3, (c = { left: "0", center: "0.5", right: "1" }[a4.alignValue]) ? b = +c * f : H(a4.x) && Math.round(a4.x) !== a4.translateX && (b = a4.x - a4.translateX), { x: d.x + (e2.translateX || 0) + h3 - (b || 0), y: d.y + (e2.translateY || 0) + h3 - g2, width: a4.width - 2 * h3, height: a4.height - 2 * h3 };
          };
          for (h = 0; h < p; h++)
            if (m = a3[h])
              m.oldOpacity = m.opacity, m.newOpacity = 1, m.absoluteBox = v(m);
          a3.sort(function(a4, e2) {
            return (e2.labelrank || 0) - (a4.labelrank || 0);
          });
          for (h = 0; h < p; h++)
            for (e = (v = a3[h]) && v.absoluteBox, m = h + 1; m < p; ++m)
              w = (g = a3[m]) && g.absoluteBox, !e || !w || v === g || v.newOpacity === 0 || g.newOpacity === 0 || v.visibility === "hidden" || g.visibility === "hidden" || w.x >= e.x + e.width || w.x + w.width <= e.x || w.y >= e.y + e.height || w.y + w.height <= e.y || ((v.labelrank < g.labelrank ? v : g).newOpacity = 0);
          a3.forEach(function(a4) {
            x(a4, l2) && (u2 = true);
          });
          u2 && C(l2, "afterHideAllOverlappingLabels");
        };
      });
      M(a, "Extensions/BorderRadius.js", [a["Core/Defaults.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function(a2, y, I, L, C, z) {
        const { defaultOptions: x } = a2;
        ({ seriesTypes: a2 } = I);
        const { addEvent: B, extend: u, isObject: v, merge: l2, relativeLength: p } = z, t = {
          radius: 0,
          scope: "stack",
          where: void 0
        }, m = (a3, g) => {
          v(a3) || (a3 = { radius: a3 || 0 });
          return l2(t, g, a3);
        };
        if (L.symbolCustomAttribs.indexOf("borderRadius") === -1) {
          L.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY");
          const h = C.prototype.symbols.arc;
          C.prototype.symbols.arc = function(a3, g2, l3, m2, d = {}) {
            a3 = h(a3, g2, l3, m2, d);
            const { innerR: e = 0, r = l3, start: q = 0, end: t2 = 0 } = d;
            if (d.open || !d.borderRadius)
              return a3;
            l3 = t2 - q;
            g2 = Math.sin(l3 / 2);
            d = Math.max(Math.min(p(d.borderRadius || 0, r - e), (r - e) / 2, r * g2 / (1 + g2)), 0);
            l3 = Math.min(d, l3 / Math.PI * 2 * e);
            for (g2 = a3.length - 1; g2--; ) {
              {
                let e2 = void 0, h3 = void 0, k = void 0;
                m2 = a3;
                var b = g2, f = 1 < g2 ? l3 : d, c = m2[b], n3 = m2[b + 1];
                n3[0] === "Z" && (n3 = m2[0]);
                c[0] !== "M" && c[0] !== "L" || n3[0] !== "A" ? c[0] !== "A" || n3[0] !== "M" && n3[0] !== "L" || (k = n3, h3 = c) : (k = c, h3 = n3, e2 = true);
                if (k && h3 && h3.params) {
                  c = h3[1];
                  var w = h3[5];
                  n3 = h3.params;
                  const { start: a4, end: d2, cx: g3, cy: l4 } = n3;
                  var u2 = w ? c - f : c + f;
                  const p2 = u2 ? Math.asin(f / u2) : 0;
                  w = w ? p2 : -p2;
                  u2 *= Math.cos(p2);
                  e2 ? (n3.start = a4 + w, k[1] = g3 + u2 * Math.cos(a4), k[2] = l4 + u2 * Math.sin(a4), m2.splice(b + 1, 0, ["A", f, f, 0, 0, 1, g3 + c * Math.cos(n3.start), l4 + c * Math.sin(n3.start)])) : (n3.end = d2 - w, h3[6] = g3 + c * Math.cos(n3.end), h3[7] = l4 + c * Math.sin(n3.end), m2.splice(b + 1, 0, ["A", f, f, 0, 0, 1, g3 + u2 * Math.cos(d2), l4 + u2 * Math.sin(d2)]));
                  h3[4] = Math.abs(n3.end - n3.start) < Math.PI ? 0 : 1;
                }
              }
            }
            return a3;
          };
          const g = C.prototype.symbols.roundedRect;
          C.prototype.symbols.roundedRect = function(a3, h3, l3, m2, d = {}) {
            const e = g(a3, h3, l3, m2, d), { r: p2 = 0, brBoxHeight: q = m2, brBoxY: t2 = h3 } = d;
            var b = h3 - t2, f = t2 + q - (h3 + m2);
            d = -0.1 < b - p2 ? 0 : p2;
            const c = -0.1 < f - p2 ? 0 : p2;
            var n3 = Math.max(d && b, 0);
            const u2 = Math.max(c && f, 0);
            f = [a3 + d, h3];
            b = [a3 + l3 - d, h3];
            const w = [a3 + l3, h3 + d], v2 = [a3 + l3, h3 + m2 - c], x2 = [a3 + l3 - c, h3 + m2], y2 = [a3 + c, h3 + m2], z2 = [a3, h3 + m2 - c], B2 = [a3, h3 + d];
            if (n3) {
              const a4 = Math.sqrt(Math.pow(d, 2) - Math.pow(d - n3, 2));
              f[0] -= a4;
              b[0] += a4;
              w[1] = B2[1] = h3 + d - n3;
            }
            m2 < d - n3 && (n3 = Math.sqrt(Math.pow(d, 2) - Math.pow(d - n3 - m2, 2)), w[0] = v2[0] = a3 + l3 - d + n3, x2[0] = Math.min(w[0], x2[0]), y2[0] = Math.max(v2[0], y2[0]), z2[0] = B2[0] = a3 + d - n3, w[1] = B2[1] = h3 + m2);
            u2 && (n3 = Math.sqrt(Math.pow(c, 2) - Math.pow(c - u2, 2)), x2[0] += n3, y2[0] -= n3, v2[1] = z2[1] = h3 + m2 - c + u2);
            m2 < c - u2 && (m2 = Math.sqrt(Math.pow(c, 2) - Math.pow(c - u2 - m2, 2)), w[0] = v2[0] = a3 + l3 - c + m2, b[0] = Math.min(w[0], b[0]), f[0] = Math.max(v2[0], f[0]), z2[0] = B2[0] = a3 + c - m2, v2[1] = z2[1] = h3);
            e.length = 0;
            e.push(["M", ...f], ["L", ...b], [
              "A",
              d,
              d,
              0,
              0,
              1,
              ...w
            ], ["L", ...v2], ["A", c, c, 0, 0, 1, ...x2], ["L", ...y2], ["A", c, c, 0, 0, 1, ...z2], ["L", ...B2], ["A", d, d, 0, 0, 1, ...f], ["Z"]);
            return e;
          };
          B(a2.pie, "afterTranslate", function() {
            const a3 = m(this.options.borderRadius);
            for (const e of this.points) {
              const g2 = e.shapeArgs;
              g2 && (g2.borderRadius = p(a3.radius, (g2.r || 0) - (g2.innerR || 0)));
            }
          });
          B(y, "afterColumnTranslate", function() {
            var a3, g2;
            if (this.options.borderRadius && (!this.chart.is3d || !this.chart.is3d())) {
              const { options: e, yAxis: r } = this, q = e.stacking === "percent";
              var h3 = (g2 = (a3 = x.plotOptions) === null || a3 === void 0 ? void 0 : a3[this.type]) === null || g2 === void 0 ? void 0 : g2.borderRadius;
              a3 = m(e.borderRadius, v(h3) ? h3 : {});
              g2 = r.options.reversed;
              for (const k of this.points)
                if ({ shapeArgs: h3 } = k, k.shapeType === "roundedRect" && h3) {
                  const { width: b = 0, height: f = 0, y: c = 0 } = h3;
                  var l3 = c, d = f;
                  a3.scope === "stack" && k.stackTotal && (l3 = r.translate(q ? 100 : k.stackTotal, false, true, false, true), d = r.translate(e.threshold || 0, false, true, false, true), d = this.crispCol(0, Math.min(l3, d), 0, Math.abs(l3 - d)), l3 = d.y, d = d.height);
                  const m2 = (k.negative ? -1 : 1) * (g2 ? -1 : 1) === -1;
                  let t2 = a3.where;
                  !t2 && this.is("waterfall") && Math.abs((k.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (t2 = "all");
                  t2 || (t2 = "end");
                  const v2 = Math.min(p(a3.radius, b), b / 2, t2 === "all" ? f / 2 : Infinity) || 0;
                  t2 === "end" && (m2 && (l3 -= v2), d += v2);
                  u(h3, { brBoxHeight: d, brBoxY: l3, r: v2 });
                }
            }
          }, { order: 9 });
        }
        y = { optionsToObject: m };
        "";
        return y;
      });
      M(a, "Core/Responsive.js", [a["Core/Utilities.js"]], function(a2) {
        const { diffObjects: x, extend: I, find: L, merge: C, pick: z, uniqueKey: H } = a2;
        var B;
        (function(u) {
          function v(a3, l3) {
            const h = a3.condition;
            (h.callback || function() {
              return this.chartWidth <= z(h.maxWidth, Number.MAX_VALUE) && this.chartHeight <= z(h.maxHeight, Number.MAX_VALUE) && this.chartWidth >= z(h.minWidth, 0) && this.chartHeight >= z(h.minHeight, 0);
            }).call(this) && l3.push(a3._id);
          }
          function l2(a3, l3) {
            const h = this.options.responsive;
            var g = this.currentResponsive;
            let e = [];
            !l3 && h && h.rules && h.rules.forEach((a4) => {
              typeof a4._id === "undefined" && (a4._id = H());
              this.matchResponsiveRule(a4, e);
            }, this);
            l3 = C(...e.map((a4) => L((h || {}).rules || [], (e2) => e2._id === a4)).map((a4) => a4 && a4.chartOptions));
            l3.isResponsiveOptions = true;
            e = e.toString() || void 0;
            e !== (g && g.ruleIds) && (g && this.update(g.undoOptions, a3, true), e ? (g = x(l3, this.options, true, this.collectionsWithUpdate), g.isResponsiveOptions = true, this.currentResponsive = { ruleIds: e, mergedOptions: l3, undoOptions: g }, this.update(l3, a3, true)) : this.currentResponsive = void 0);
          }
          const p = [];
          u.compose = function(t) {
            a2.pushUnique(p, t) && I(t.prototype, { matchResponsiveRule: v, setResponsive: l2 });
            return t;
          };
        })(B || (B = {}));
        "";
        "";
        return B;
      });
      M(a, "masters/highcharts.src.js", [
        a["Core/Globals.js"],
        a["Core/Utilities.js"],
        a["Core/Defaults.js"],
        a["Core/Animation/Fx.js"],
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Renderer/HTML/AST.js"],
        a["Core/Templating.js"],
        a["Core/Renderer/RendererUtilities.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Renderer/HTML/HTMLElement.js"],
        a["Core/Renderer/HTML/HTMLRenderer.js"],
        a["Core/Axis/Axis.js"],
        a["Core/Axis/DateTimeAxis.js"],
        a["Core/Axis/LogarithmicAxis.js"],
        a["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"],
        a["Core/Axis/Tick.js"],
        a["Core/Tooltip.js"],
        a["Core/Series/Point.js"],
        a["Core/Pointer.js"],
        a["Core/Legend/Legend.js"],
        a["Core/Chart/Chart.js"],
        a["Core/Axis/Stacking/StackingAxis.js"],
        a["Core/Axis/Stacking/StackItem.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Series/Column/ColumnSeries.js"],
        a["Series/Column/ColumnDataLabel.js"],
        a["Series/Pie/PieSeries.js"],
        a["Series/Pie/PieDataLabel.js"],
        a["Core/Series/DataLabel.js"],
        a["Core/Responsive.js"],
        a["Core/Color/Color.js"],
        a["Core/Time.js"]
      ], function(a2, y, I, L, C, z, H, B, u, v, l2, p, t, m, h, g, e, w, E, F, d, k, r, q, G, b, f, c, n3, M2, D, K, U2, T) {
        a2.animate = C.animate;
        a2.animObject = C.animObject;
        a2.getDeferredAnimation = C.getDeferredAnimation;
        a2.setAnimation = C.setAnimation;
        a2.stop = C.stop;
        a2.timers = L.timers;
        a2.AST = z;
        a2.Axis = t;
        a2.Chart = k;
        a2.chart = k.chart;
        a2.Fx = L;
        a2.Legend = d;
        a2.PlotLineOrBand = g;
        a2.Point = E;
        a2.Pointer = F;
        a2.Series = G;
        a2.StackItem = q;
        a2.SVGElement = u;
        a2.SVGRenderer = v;
        a2.Templating = H;
        a2.Tick = e;
        a2.Time = T;
        a2.Tooltip = w;
        a2.Color = U2;
        a2.color = U2.parse;
        p.compose(v);
        l2.compose(u);
        F.compose(k);
        d.compose(k);
        a2.defaultOptions = I.defaultOptions;
        a2.getOptions = I.getOptions;
        a2.time = I.defaultTime;
        a2.setOptions = I.setOptions;
        a2.dateFormat = H.dateFormat;
        a2.format = H.format;
        a2.numberFormat = H.numberFormat;
        a2.addEvent = y.addEvent;
        a2.arrayMax = y.arrayMax;
        a2.arrayMin = y.arrayMin;
        a2.attr = y.attr;
        a2.clearTimeout = y.clearTimeout;
        a2.correctFloat = y.correctFloat;
        a2.createElement = y.createElement;
        a2.css = y.css;
        a2.defined = y.defined;
        a2.destroyObjectProperties = y.destroyObjectProperties;
        a2.discardElement = y.discardElement;
        a2.distribute = B.distribute;
        a2.erase = y.erase;
        a2.error = y.error;
        a2.extend = y.extend;
        a2.extendClass = y.extendClass;
        a2.find = y.find;
        a2.fireEvent = y.fireEvent;
        a2.getMagnitude = y.getMagnitude;
        a2.getStyle = y.getStyle;
        a2.inArray = y.inArray;
        a2.isArray = y.isArray;
        a2.isClass = y.isClass;
        a2.isDOMElement = y.isDOMElement;
        a2.isFunction = y.isFunction;
        a2.isNumber = y.isNumber;
        a2.isObject = y.isObject;
        a2.isString = y.isString;
        a2.keys = y.keys;
        a2.merge = y.merge;
        a2.normalizeTickInterval = y.normalizeTickInterval;
        a2.objectEach = y.objectEach;
        a2.offset = y.offset;
        a2.pad = y.pad;
        a2.pick = y.pick;
        a2.pInt = y.pInt;
        a2.relativeLength = y.relativeLength;
        a2.removeEvent = y.removeEvent;
        a2.seriesType = b.seriesType;
        a2.splat = y.splat;
        a2.stableSort = y.stableSort;
        a2.syncTimeout = y.syncTimeout;
        a2.timeUnits = y.timeUnits;
        a2.uniqueKey = y.uniqueKey;
        a2.useSerialIds = y.useSerialIds;
        a2.wrap = y.wrap;
        c.compose(f);
        D.compose(G);
        m.compose(t);
        h.compose(t);
        M2.compose(n3);
        g.compose(t);
        K.compose(k);
        r.compose(t, k, G);
        w.compose(F);
        return a2;
      });
      a["masters/highcharts.src.js"]._modules = a;
      return a["masters/highcharts.src.js"];
    });
  }
});

// node_modules/highcharts/modules/map.js
var require_map = __commonJS({
  "node_modules/highcharts/modules/map.js"(exports, module2) {
    "use strict";
    (function(a) {
      typeof module2 === "object" && module2.exports ? (a["default"] = a, module2.exports = a) : typeof define === "function" && define.amd ? define("highcharts/modules/map", ["highcharts"], function(y) {
        a(y);
        a.Highcharts = y;
        return a;
      }) : a(typeof Highcharts !== "undefined" ? Highcharts : void 0);
    })(function(a) {
      function y(a2, n3, q, z) {
        a2.hasOwnProperty(n3) || (a2[n3] = z.apply(null, q), typeof CustomEvent === "function" && window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: n3, module: a2[n3] } })));
      }
      a = a ? a._modules : {};
      y(a, "Core/Axis/Color/ColorAxisComposition.js", [a["Core/Color/Color.js"], a["Core/Utilities.js"]], function(a2, n3) {
        const { parse: q } = a2, { addEvent: g, extend: k, merge: l2, pick: A, splat: w } = n3;
        var x;
        (function(t) {
          function h() {
            const b2 = this.options;
            this.colorAxis = [];
            b2.colorAxis && (b2.colorAxis = w(b2.colorAxis), b2.colorAxis.forEach((b3) => {
              new v(this, b3);
            }));
          }
          function a3(b2) {
            const u = (u2) => {
              u2 = b2.allItems.indexOf(u2);
              u2 !== -1 && (this.destroyItem(b2.allItems[u2]), b2.allItems.splice(u2, 1));
            };
            let d2 = [], p2, e2;
            (this.chart.colorAxis || []).forEach(function(b3) {
              (p2 = b3.options) && p2.showInLegend && (p2.dataClasses && p2.visible ? d2 = d2.concat(b3.getDataClassLegendSymbols()) : p2.visible && d2.push(b3), b3.series.forEach(function(b4) {
                if (!b4.options.showInLegend || p2.dataClasses)
                  b4.options.legendType === "point" ? b4.points.forEach(function(b5) {
                    u(b5);
                  }) : u(b4);
              }));
            });
            for (e2 = d2.length; e2--; )
              b2.allItems.unshift(d2[e2]);
          }
          function f(b2) {
            b2.visible && b2.item.legendColor && b2.item.legendItem.symbol.attr({ fill: b2.item.legendColor });
          }
          function c() {
            const b2 = this.chart.colorAxis;
            b2 && b2.forEach(function(b3, d2, p2) {
              b3.update({}, p2);
            });
          }
          function e() {
            (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();
          }
          function b() {
            const b2 = this.axisTypes;
            b2 ? b2.indexOf("colorAxis") === -1 && b2.push("colorAxis") : this.axisTypes = ["colorAxis"];
          }
          function d(b2) {
            const u = this, d2 = b2 ? "show" : "hide";
            u.visible = u.options.visible = !!b2;
            ["graphic", "dataLabel"].forEach(function(b3) {
              if (u[b3])
                u[b3][d2]();
            });
            this.series.buildKDTree();
          }
          function E() {
            const b2 = this, u = this.options.nullColor, d2 = this.colorAxis, p2 = this.colorKey;
            (this.data.length ? this.data : this.points).forEach((e2) => {
              var c2 = e2.getNestedProperty(p2);
              (c2 = e2.options.color || (e2.isNull || e2.value === null ? u : d2 && typeof c2 !== "undefined" ? d2.toColor(c2, e2) : e2.color || b2.color)) && e2.color !== c2 && (e2.color = c2, b2.options.legendType === "point" && e2.legendItem && e2.legendItem.label && b2.chart.legend.colorizeItem(e2, e2.visible));
            });
          }
          function p(b2) {
            const u = b2.prototype.createAxis;
            b2.prototype.createAxis = function(b3, d2) {
              if (b3 !== "colorAxis")
                return u.apply(this, arguments);
              const e2 = new v(this, l2(d2.axis, { index: this[b3].length, isX: false }));
              this.isDirtyLegend = true;
              this.axes.forEach(function(b4) {
                b4.series = [];
              });
              this.series.forEach(function(b4) {
                b4.bindAxes();
                b4.isDirtyData = true;
              });
              A(d2.redraw, true) && this.redraw(d2.animation);
              return e2;
            };
          }
          function C() {
            this.elem.attr("fill", q(this.start).tweenTo(q(this.end), this.pos), void 0, true);
          }
          function m() {
            this.elem.attr("stroke", q(this.start).tweenTo(q(this.end), this.pos), void 0, true);
          }
          const r = [];
          let v;
          t.compose = function(t2, u, B, D, H) {
            v || (v = t2);
            n3.pushUnique(r, u) && (t2 = u.prototype, t2.collectionsWithUpdate.push("colorAxis"), t2.collectionsWithInit.colorAxis = [t2.addColorAxis], g(u, "afterGetAxes", h), p(u));
            n3.pushUnique(r, B) && (u = B.prototype, u.fillSetter = C, u.strokeSetter = m);
            n3.pushUnique(r, D) && (g(D, "afterGetAllItems", a3), g(D, "afterColorizeItem", f), g(D, "afterUpdate", c));
            n3.pushUnique(r, H) && (k(H.prototype, { optionalAxis: "colorAxis", translateColors: E }), k(H.prototype.pointClass.prototype, { setVisible: d }), g(H, "afterTranslate", e, { order: 1 }), g(H, "bindAxes", b));
          };
          t.pointSetVisible = d;
        })(x || (x = {}));
        return x;
      });
      y(a, "Core/Axis/Color/ColorAxisDefaults.js", [], function() {
        return {
          lineWidth: 0,
          minPadding: 0,
          maxPadding: 0,
          gridLineColor: "#ffffff",
          gridLineWidth: 1,
          tickPixelInterval: 72,
          startOnTick: true,
          endOnTick: true,
          offset: 0,
          marker: { animation: { duration: 50 }, width: 0.01, color: "#999999" },
          labels: { distance: 8, overflow: "justify", rotation: 0 },
          minColor: "#e6e9ff",
          maxColor: "#0022ff",
          tickLength: 5,
          showInLegend: true
        };
      });
      y(a, "Core/Axis/Color/ColorAxis.js", [a["Core/Axis/Axis.js"], a["Core/Color/Color.js"], a["Core/Axis/Color/ColorAxisComposition.js"], a["Core/Axis/Color/ColorAxisDefaults.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n3, q, z, k, l2, A) {
        const { parse: g } = n3, { series: x } = l2, { extend: t, isArray: h, isNumber: F, merge: f, pick: c } = A;
        class e extends a2 {
          static compose(b, d, c2, p) {
            q.compose(e, b, d, c2, p);
          }
          constructor(b, d) {
            super(b, d);
            this.beforePadding = false;
            this.chart = void 0;
            this.coll = "colorAxis";
            this.stops = this.options = this.dataClasses = void 0;
            this.visible = true;
            this.init(b, d);
          }
          init(b, d) {
            var c2 = b.options.legend || {};
            const p = d.layout ? d.layout !== "vertical" : c2.layout !== "vertical", C = d.visible;
            c2 = f(e.defaultColorAxisOptions, d, {
              showEmpty: false,
              title: null,
              visible: c2.enabled && C !== false
            });
            this.side = d.side || p ? 2 : 1;
            this.reversed = d.reversed || !p;
            this.opposite = !p;
            super.init(b, c2, "colorAxis");
            this.userOptions = d;
            h(b.userOptions.colorAxis) && (b.userOptions.colorAxis[this.index] = d);
            d.dataClasses && this.initDataClasses(d);
            this.initStops();
            this.horiz = p;
            this.zoomEnabled = false;
          }
          initDataClasses(b) {
            const d = this.chart, e2 = this.legendItem = this.legendItem || {}, p = b.dataClasses.length, c2 = this.options;
            let m, r = 0, v = d.options.chart.colorCount;
            this.dataClasses = m = [];
            e2.labels = [];
            (b.dataClasses || []).forEach(function(b2, u) {
              b2 = f(b2);
              m.push(b2);
              if (d.styledMode || !b2.color)
                c2.dataClassColor === "category" ? (d.styledMode || (u = d.options.colors, v = u.length, b2.color = u[r]), b2.colorIndex = r, r++, r === v && (r = 0)) : b2.color = g(c2.minColor).tweenTo(g(c2.maxColor), 2 > p ? 0.5 : u / (p - 1));
            });
          }
          hasData() {
            return !!(this.tickPositions || []).length;
          }
          setTickPositions() {
            if (!this.dataClasses)
              return super.setTickPositions();
          }
          initStops() {
            this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];
            this.stops.forEach(function(b) {
              b.color = g(b[1]);
            });
          }
          setOptions(b) {
            super.setOptions(b);
            this.options.crosshair = this.options.marker;
          }
          setAxisSize() {
            var b = this.legendItem && this.legendItem.symbol;
            const d = this.chart;
            var c2 = d.options.legend || {};
            let p, f2;
            b ? (this.left = c2 = b.attr("x"), this.top = p = b.attr("y"), this.width = f2 = b.attr("width"), this.height = b = b.attr("height"), this.right = d.chartWidth - c2 - f2, this.bottom = d.chartHeight - p - b, this.len = this.horiz ? f2 : b, this.pos = this.horiz ? c2 : p) : this.len = (this.horiz ? c2.symbolWidth : c2.symbolHeight) || e.defaultLegendLength;
          }
          normalizedValue(b) {
            this.logarithmic && (b = this.logarithmic.log2lin(b));
            return 1 - (this.max - b) / (this.max - this.min || 1);
          }
          toColor(b, d) {
            const e2 = this.dataClasses;
            var c2 = this.stops;
            let f2, m, r, v;
            if (e2)
              for (v = e2.length; v--; ) {
                if (r = e2[v], f2 = r.from, c2 = r.to, (typeof f2 === "undefined" || b >= f2) && (typeof c2 === "undefined" || b <= c2)) {
                  m = r.color;
                  d && (d.dataClass = v, d.colorIndex = r.colorIndex);
                  break;
                }
              }
            else {
              b = this.normalizedValue(b);
              for (v = c2.length; v-- && !(b > c2[v][0]); )
                ;
              f2 = c2[v] || c2[v + 1];
              c2 = c2[v + 1] || f2;
              b = 1 - (c2[0] - b) / (c2[0] - f2[0] || 1);
              m = f2.color.tweenTo(c2.color, b);
            }
            return m;
          }
          getOffset() {
            const b = this.legendItem && this.legendItem.group, d = this.chart.axisOffset[this.side];
            if (b) {
              this.axisParent = b;
              super.getOffset();
              const c2 = this.chart.legend;
              c2.allItems.forEach(function(b2) {
                b2 instanceof e && b2.drawLegendSymbol(c2, b2);
              });
              c2.render();
              this.chart.getMargins(true);
              this.added || (this.added = true, this.labelLeft = 0, this.labelRight = this.width);
              this.chart.axisOffset[this.side] = d;
            }
          }
          setLegendColor() {
            var b = this.reversed, d = b ? 1 : 0;
            b = b ? 0 : 1;
            d = this.horiz ? [d, 0, b, 0] : [0, b, 0, d];
            this.legendColor = { linearGradient: {
              x1: d[0],
              y1: d[1],
              x2: d[2],
              y2: d[3]
            }, stops: this.stops };
          }
          drawLegendSymbol(b, d) {
            var f2;
            d = d.legendItem || {};
            const p = b.padding, h3 = b.options, m = this.options.labels, r = c(h3.itemDistance, 10), v = this.horiz, t2 = c(h3.symbolWidth, v ? e.defaultLegendLength : 12), u = c(h3.symbolHeight, v ? 12 : e.defaultLegendLength), B = c(h3.labelPadding, v ? 16 : 30);
            this.setLegendColor();
            d.symbol || (d.symbol = this.chart.renderer.symbol("roundedRect", 0, b.baseline - 11, t2, u, { r: (f2 = h3.symbolRadius) !== null && f2 !== void 0 ? f2 : 3 }).attr({ zIndex: 1 }).add(d.group));
            d.labelWidth = t2 + p + (v ? r : c(m.x, m.distance) + this.maxLabelLength);
            d.labelHeight = u + p + (v ? B : 0);
          }
          setState(b) {
            this.series.forEach(function(d) {
              d.setState(b);
            });
          }
          setVisible() {
          }
          getSeriesExtremes() {
            const b = this.series;
            let d;
            let e2, p, f2 = b.length, m, r;
            this.dataMin = Infinity;
            for (this.dataMax = -Infinity; f2--; ) {
              p = b[f2];
              d = p.colorKey = c(p.options.colorKey, p.colorKey, p.pointValKey, p.zoneAxis, "y");
              var v = p.pointArrayMap;
              e2 = p[d + "Min"] && p[d + "Max"];
              if (p[d + "Data"])
                var h3 = p[d + "Data"];
              else if (v) {
                if (h3 = [], v = v.indexOf(d), m = p.yData, 0 <= v && m)
                  for (r = 0; r < m.length; r++)
                    h3.push(c(m[r][v], m[r]));
              } else
                h3 = p.yData;
              e2 ? (p.minColorValue = p[d + "Min"], p.maxColorValue = p[d + "Max"]) : (h3 = x.prototype.getExtremes.call(p, h3), p.minColorValue = h3.dataMin, p.maxColorValue = h3.dataMax);
              typeof p.minColorValue !== "undefined" && (this.dataMin = Math.min(this.dataMin, p.minColorValue), this.dataMax = Math.max(this.dataMax, p.maxColorValue));
              e2 || x.prototype.applyExtremes.call(p);
            }
          }
          drawCrosshair(b, d) {
            const c2 = this.legendItem || {}, e2 = d && d.plotX, f2 = d && d.plotY, m = this.pos, h3 = this.len;
            let v;
            d && (v = this.toPixels(d.getNestedProperty(d.series.colorKey)), v < m ? v = m - 2 : v > m + h3 && (v = m + h3 + 2), d.plotX = v, d.plotY = this.len - v, super.drawCrosshair(b, d), d.plotX = e2, d.plotY = f2, this.cross && !this.cross.addedToColorAxis && c2.group && (this.cross.addClass("highcharts-coloraxis-marker").add(c2.group), this.cross.addedToColorAxis = true, this.chart.styledMode || typeof this.crosshair !== "object" || this.cross.attr({ fill: this.crosshair.color })));
          }
          getPlotLinePath(b) {
            const d = this.left, c2 = b.translatedValue, e2 = this.top;
            return F(c2) ? this.horiz ? [["M", c2 - 4, e2 - 6], ["L", c2 + 4, e2 - 6], ["L", c2, e2], ["Z"]] : [["M", d, c2], [
              "L",
              d - 6,
              c2 + 6
            ], ["L", d - 6, c2 - 6], ["Z"]] : super.getPlotLinePath(b);
          }
          update(b, d) {
            const c2 = this.chart.legend;
            this.series.forEach((b2) => {
              b2.isDirtyData = true;
            });
            (b.dataClasses && c2.allItems || this.dataClasses) && this.destroyItems();
            super.update(b, d);
            this.legendItem && this.legendItem.label && (this.setLegendColor(), c2.colorizeItem(this, true));
          }
          destroyItems() {
            const b = this.chart, d = this.legendItem || {};
            if (d.label)
              b.legend.destroyItem(this);
            else if (d.labels)
              for (const c2 of d.labels)
                b.legend.destroyItem(c2);
            b.isDirtyLegend = true;
          }
          destroy() {
            this.chart.isDirtyLegend = true;
            this.destroyItems();
            super.destroy(...[].slice.call(arguments));
          }
          remove(b) {
            this.destroyItems();
            super.remove(b);
          }
          getDataClassLegendSymbols() {
            const b = this, d = b.chart, e2 = b.legendItem && b.legendItem.labels || [], f2 = d.options.legend, h3 = c(f2.valueDecimals, -1), m = c(f2.valueSuffix, ""), r = (d2) => b.series.reduce((b2, c2) => {
              b2.push(...c2.points.filter((b3) => b3.dataClass === d2));
              return b2;
            }, []);
            let v;
            e2.length || b.dataClasses.forEach((c2, u) => {
              const f3 = c2.from, p = c2.to, { numberFormatter: a3 } = d;
              let C = true;
              v = "";
              typeof f3 === "undefined" ? v = "< " : typeof p === "undefined" && (v = "> ");
              typeof f3 !== "undefined" && (v += a3(f3, h3) + m);
              typeof f3 !== "undefined" && typeof p !== "undefined" && (v += " - ");
              typeof p !== "undefined" && (v += a3(p, h3) + m);
              e2.push(t({ chart: d, name: v, options: {}, drawLegendSymbol: k.rectangle, visible: true, isDataClass: true, setState: (b2) => {
                for (const c3 of r(u))
                  c3.setState(b2);
              }, setVisible: function() {
                this.visible = C = b.visible = !C;
                for (const b2 of r(u))
                  b2.setVisible(C);
                d.legend.colorizeItem(this, C);
              } }, c2));
            });
            return e2;
          }
        }
        e.defaultColorAxisOptions = z;
        e.defaultLegendLength = 200;
        e.keepProps = ["legendItem"];
        Array.prototype.push.apply(a2.keepProps, e.keepProps);
        "";
        return e;
      });
      y(a, "Maps/MapNavigationDefaults.js", [a["Core/Defaults.js"], a["Core/Utilities.js"]], function(a2, n3) {
        ({ extend: n3 } = n3);
        const g = { buttonOptions: { alignTo: "plotBox", align: "left", verticalAlign: "top", x: 0, width: 18, height: 18, padding: 5, style: { color: "#666666", fontSize: "1em", fontWeight: "bold" }, theme: { fill: "#ffffff", stroke: "#e6e6e6", "stroke-width": 1, "text-align": "center" } }, buttons: { zoomIn: { onclick: function() {
          this.mapZoom(0.5);
        }, text: "+", y: 0 }, zoomOut: {
          onclick: function() {
            this.mapZoom(2);
          },
          text: "-",
          y: 28
        } }, mouseWheelSensitivity: 1.1 };
        n3(a2.defaultOptions.lang, { zoomIn: "Zoom in", zoomOut: "Zoom out" });
        return a2.defaultOptions.mapNavigation = g;
      });
      y(a, "Maps/MapNavigation.js", [a["Core/Chart/Chart.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, n3, q) {
        function g(f) {
          f && (f.preventDefault && f.preventDefault(), f.stopPropagation && f.stopPropagation(), f.cancelBubble = true);
        }
        function k(f) {
          this.navButtons = [];
          this.init(f);
        }
        const { doc: l2 } = n3, { addEvent: A, extend: w, isNumber: x, merge: t, objectEach: h, pick: F } = q;
        k.prototype.init = function(f) {
          this.chart = f;
        };
        k.prototype.update = function(f) {
          let c = this, e = this.chart, b = e.options.mapNavigation, d, a3 = function(b2) {
            this.handler.call(e, b2);
            g(b2);
          }, p = c.navButtons;
          f && (b = e.options.mapNavigation = t(e.options.mapNavigation, f));
          for (; p.length; )
            p.pop().destroy();
          F(b.enableButtons, b.enabled) && !e.renderer.forExport && (c.navButtonsGroup || (c.navButtonsGroup = e.renderer.g().attr({ zIndex: 4 }).add()), h(b.buttons, function(f2, m) {
            var h3;
            f2 = t(b.buttonOptions, f2);
            !e.styledMode && f2.theme && (d = f2.theme, d.style = t(f2.theme.style, f2.style));
            const { text: v, width: E = 0, height: u = 0, padding: B = 0 } = f2, D = e.renderer.button(v !== "+" && v !== "-" && v || "", 0, 0, a3, d, void 0, void 0, void 0, m === "zoomIn" ? "topbutton" : "bottombutton").addClass("highcharts-map-navigation highcharts-" + { zoomIn: "zoom-in", zoomOut: "zoom-out" }[m]).attr({ width: E, height: u, title: e.options.lang[m], padding: f2.padding, zIndex: 5 }).add(c.navButtonsGroup);
            if (v === "+" || v === "-") {
              m = E + 1;
              const b2 = [["M", B + 3, B + u / 2], ["L", B + m - 3, B + u / 2]];
              v === "+" && b2.push(["M", B + m / 2, B + 3], ["L", B + m / 2, B + u - 3]);
              e.renderer.path(b2).addClass("highcharts-button-symbol").attr(e.styledMode ? {} : { stroke: (h3 = f2.style) === null || h3 === void 0 ? void 0 : h3.color, "stroke-width": 3, "stroke-linecap": "round" }).add(D);
            }
            D.handler = f2.onclick;
            A(D.element, "dblclick", g);
            p.push(D);
            w(f2, { width: D.width, height: 2 * D.height });
            if (e.hasLoaded)
              D.align(f2, false, f2.alignTo);
            else {
              const b2 = A(e, "load", () => {
                D.element && D.align(f2, false, f2.alignTo);
                b2();
              });
            }
          }), f = function() {
            var d2 = e.exportingGroup && e.exportingGroup.getBBox();
            if (d2) {
              const e2 = c.navButtonsGroup.getBBox();
              if (!(e2.x >= d2.x + d2.width || e2.x + e2.width <= d2.x || e2.y >= d2.y + d2.height || e2.y + e2.height <= d2.y)) {
                const f2 = -e2.y - e2.height + d2.y - 5;
                d2 = d2.y + d2.height - e2.y + 5;
                c.navButtonsGroup.attr({ translateY: (b.buttonOptions && b.buttonOptions.verticalAlign) === "bottom" ? f2 : d2 });
              }
            }
          }, e.hasLoaded || A(e, "render", f));
          this.updateEvents(b);
        };
        k.prototype.updateEvents = function(f) {
          const c = this.chart;
          F(f.enableDoubleClickZoom, f.enabled) || f.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || A(c.container, "dblclick", function(e) {
            c.pointer.onContainerDblClick(e);
          }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick());
          F(f.enableMouseWheelZoom, f.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || A(c.container, l2.onwheel !== void 0 ? "wheel" : l2.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll", function(e) {
            c.pointer.inClass(e.target, "highcharts-no-mousewheel") || (c.pointer.onContainerMouseWheel(e), g(e));
            return false;
          }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());
        };
        w(a2.prototype, { fitToBox: function(f, c) {
          [["x", "width"], ["y", "height"]].forEach(function(e) {
            const b = e[0];
            e = e[1];
            f[b] + f[e] > c[b] + c[e] && (f[e] > c[e] ? (f[e] = c[e], f[b] = c[b]) : f[b] = c[b] + c[e] - f[e]);
            f[e] > c[e] && (f[e] = c[e]);
            f[b] < c[b] && (f[b] = c[b]);
          });
          return f;
        }, mapZoom: function(f, c, e, b, d) {
          this.mapView && (x(f) && (f = Math.log(f) / Math.log(0.5)), this.mapView.zoomBy(f, x(c) && x(e) ? this.mapView.projection.inverse([c, e]) : void 0, x(b) && x(d) ? [b, d] : void 0));
        } });
        A(a2, "beforeRender", function() {
          this.mapNavigation = new k(this);
          this.mapNavigation.update();
        });
        n3.MapNavigation = k;
      });
      y(a, "Maps/MapPointer.js", [a["Core/Pointer.js"], a["Core/Utilities.js"]], function(a2, n3) {
        const { defined: g, extend: z, pick: k, wrap: l2 } = n3, A = a2.prototype.normalize;
        let w = 0, x;
        z(a2.prototype, { normalize: function(t, h) {
          const a3 = this.chart;
          t = A.call(this, t, h);
          a3 && a3.mapView && (h = a3.mapView.pixelsToLonLat({ x: t.chartX - a3.plotLeft, y: t.chartY - a3.plotTop })) && z(t, h);
          return t;
        }, onContainerDblClick: function(a3) {
          const h = this.chart;
          a3 = this.normalize(a3);
          h.options.mapNavigation.enableDoubleClickZoomTo ? h.pointer.inClass(a3.target, "highcharts-tracker") && h.hoverPoint && h.hoverPoint.zoomTo() : h.isInsidePlot(a3.chartX - h.plotLeft, a3.chartY - h.plotTop) && h.mapZoom(0.5, void 0, void 0, a3.chartX, a3.chartY);
        }, onContainerMouseWheel: function(a3) {
          const h = this.chart;
          a3 = this.normalize(a3);
          const t = g(a3.wheelDelta) && -a3.wheelDelta / 120 || a3.deltaY || a3.detail;
          1 <= Math.abs(t) && (w += Math.abs(t), x && clearTimeout(x), x = setTimeout(() => {
            w = 0;
          }, 50));
          10 > w && h.isInsidePlot(a3.chartX - h.plotLeft, a3.chartY - h.plotTop) && h.mapView && h.mapView.zoomBy((h.options.mapNavigation.mouseWheelSensitivity - 1) * -t, void 0, [a3.chartX, a3.chartY], 1 > Math.abs(t) ? false : void 0);
        } });
        l2(a2.prototype, "zoomOption", function(a3) {
          const h = this.chart.options.mapNavigation;
          k(h.enableTouchZoom, h.enabled) && (this.chart.zooming.pinchType = "xy");
          a3.apply(this, [].slice.call(arguments, 1));
        });
        l2(a2.prototype, "pinchTranslate", function(a3, h, k2, f, c, e, b) {
          a3.call(this, h, k2, f, c, e, b);
          this.chart.options.chart.type === "map" && this.hasZoom && (a3 = f.scaleX > f.scaleY, this.pinchTranslateDirection(!a3, h, k2, f, c, e, b, a3 ? f.scaleX : f.scaleY));
        });
      });
      y(a, "Series/ColorMapComposition.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n3) {
        const { column: { prototype: g } } = a2.seriesTypes, { addEvent: z, defined: k } = n3;
        var l2;
        (function(a3) {
          function l3(a4) {
            this.moveToTopOnHover && this.graphic && this.graphic.attr({ zIndex: a4 && a4.state === "hover" ? 1 : 0 });
          }
          const q = [];
          a3.pointMembers = { dataLabelOnNull: true, moveToTopOnHover: true, isValid: function() {
            return this.value !== null && this.value !== Infinity && this.value !== -Infinity && (this.value === void 0 || !isNaN(this.value));
          } };
          a3.seriesMembers = {
            colorKey: "value",
            axisTypes: ["xAxis", "yAxis", "colorAxis"],
            parallelArrays: ["x", "y", "value"],
            pointArrayMap: ["value"],
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            colorAttribs: function(a4) {
              const h = {};
              !k(a4.color) || a4.state && a4.state !== "normal" || (h[this.colorProp || "fill"] = a4.color);
              return h;
            },
            pointAttribs: g.pointAttribs
          };
          a3.compose = function(a4) {
            const h = a4.prototype.pointClass;
            n3.pushUnique(q, h) && z(h, "afterSetState", l3);
            return a4;
          };
        })(l2 || (l2 = {}));
        return l2;
      });
      y(a, "Maps/MapSymbols.js", [a["Core/Renderer/SVG/SVGRenderer.js"]], function(a2) {
        const { prototype: { symbols: g } } = a2;
        g.bottombutton = function(a3, n3, k, l2, A) {
          if (A) {
            const a4 = (A === null || A === void 0 ? void 0 : A.r) || 0;
            A.brBoxY = n3 - a4;
            A.brBoxHeight = l2 + a4;
          }
          return g.roundedRect(a3, n3, k, l2, A);
        };
        g.topbutton = function(a3, n3, k, l2, A) {
          A && (A.brBoxHeight = l2 + ((A === null || A === void 0 ? void 0 : A.r) || 0));
          return g.roundedRect(a3, n3, k, l2, A);
        };
        return g;
      });
      y(a, "Core/Chart/MapChart.js", [a["Core/Chart/Chart.js"], a["Core/Defaults.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function(a2, n3, q, z) {
        const { getOptions: k } = n3, { merge: g, pick: A } = z;
        class w extends a2 {
          init(a3, t) {
            const h = k().credits;
            a3 = g({ chart: { panning: { enabled: true, type: "xy" }, type: "map" }, credits: { mapText: A(h.mapText, ' \xA9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>'), mapTextFull: A(h.mapTextFull, "{geojson.copyright}") }, mapView: {}, tooltip: { followTouchMove: false } }, a3);
            super.init(a3, t);
          }
        }
        (function(a3) {
          a3.maps = {};
          a3.mapChart = function(t, h, k2) {
            return new a3(t, h, k2);
          };
          a3.splitPath = function(a4) {
            typeof a4 === "string" && (a4 = a4.replace(/([A-Za-z])/g, " $1 ").replace(/^\s*/, "").replace(/\s*$/, ""), a4 = a4.split(/[ ,;]+/).map((a5) => /[A-za-z]/.test(a5) ? a5 : parseFloat(a5)));
            return q.prototype.pathToSegments(a4);
          };
        })(w || (w = {}));
        return w;
      });
      y(a, "Maps/MapUtilities.js", [], function() {
        return { boundsFromPath: function(a2) {
          let g = -Number.MAX_VALUE, q = Number.MAX_VALUE, z = -Number.MAX_VALUE, k = Number.MAX_VALUE, l2;
          a2.forEach((a3) => {
            const w = a3[a3.length - 2];
            a3 = a3[a3.length - 1];
            typeof w === "number" && typeof a3 === "number" && (q = Math.min(q, w), g = Math.max(g, w), k = Math.min(k, a3), z = Math.max(z, a3), l2 = true);
          });
          if (l2)
            return { x1: q, y1: k, x2: g, y2: z };
        }, pointInPolygon: function(a2, n3) {
          let g, z, k, l2 = false, A = a2.x, w = a2.y;
          a2 = 0;
          for (g = n3.length - 1; a2 < n3.length; g = a2++)
            z = n3[a2][1] > w, k = n3[g][1] > w, z !== k && A < (n3[g][0] - n3[a2][0]) * (w - n3[a2][1]) / (n3[g][1] - n3[a2][1]) + n3[a2][0] && (l2 = !l2);
          return l2;
        } };
      });
      y(a, "Series/Map/MapPoint.js", [a["Series/ColorMapComposition.js"], a["Maps/MapUtilities.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n3, q, z) {
        const { boundsFromPath: k } = n3;
        ({ seriesTypes: { scatter: n3 } } = q);
        const { extend: l2, isNumber: g, pick: w } = z;
        class x extends n3.prototype.pointClass {
          constructor() {
            super(...arguments);
            this.series = this.path = this.options = void 0;
          }
          static getProjectedPath(a3, h) {
            a3.projectedPath || (h && a3.geometry ? (h.hasCoordinates = true, a3.projectedPath = h.path(a3.geometry)) : a3.projectedPath = a3.path);
            return a3.projectedPath || [];
          }
          applyOptions(a3, h) {
            const k2 = this.series;
            a3 = super.applyOptions.call(this, a3, h);
            h = k2.joinBy;
            k2.mapData && k2.mapMap && (h = super.getNestedProperty.call(a3, h[1]), (h = typeof h !== "undefined" && k2.mapMap[h]) ? l2(a3, h) : k2.pointArrayMap.indexOf("value") !== -1 && (a3.value = a3.value || null));
            return a3;
          }
          getProjectedBounds(a3) {
            var h = x.getProjectedPath(this, a3);
            h = k(h);
            var l3 = this.properties;
            const f = this.series.chart.mapView;
            if (h) {
              const c = l3 && l3["hc-middle-lon"], e = l3 && l3["hc-middle-lat"];
              f && g(c) && g(e) ? (a3 = a3.forward([c, e]), h.midX = a3[0], h.midY = a3[1]) : (a3 = l3 && l3["hc-middle-x"], l3 = l3 && l3["hc-middle-y"], h.midX = h.x1 + (h.x2 - h.x1) * w(this.middleX, g(a3) ? a3 : 0.5), a3 = w(this.middleY, g(l3) ? l3 : 0.5), this.geometry || (a3 = 1 - a3), h.midY = h.y2 - (h.y2 - h.y1) * a3);
              return h;
            }
          }
          onMouseOver(a3) {
            z.clearTimeout(this.colorInterval);
            if (!this.isNull && this.visible || this.series.options.nullInteraction)
              super.onMouseOver.call(this, a3);
            else
              this.series.onMouseOut(a3);
          }
          setVisible(a3) {
            const h = a3 ? "show" : "hide";
            this.visible = this.options.visible = !!a3;
            if (this.dataLabel)
              this.dataLabel[h]();
            this.graphic && this.graphic.attr(this.series.pointAttribs(this));
          }
          zoomTo(a3) {
            const h = this.series.chart, k2 = h.mapView;
            var f = this.bounds;
            if (k2 && f) {
              const e = g(this.insetIndex) && k2.insets[this.insetIndex];
              if (e) {
                var c = e.projectedUnitsToPixels({ x: f.x1, y: f.y1 });
                f = e.projectedUnitsToPixels({ x: f.x2, y: f.y2 });
                c = k2.pixelsToProjectedUnits({ x: c.x, y: c.y });
                f = k2.pixelsToProjectedUnits({
                  x: f.x,
                  y: f.y
                });
                f = { x1: c.x, y1: c.y, x2: f.x, y2: f.y };
              }
              k2.fitToBounds(f, void 0, false);
              this.series.isDirty = true;
              h.redraw(a3);
            }
          }
        }
        l2(x.prototype, { dataLabelOnNull: a2.pointMembers.dataLabelOnNull, moveToTopOnHover: a2.pointMembers.moveToTopOnHover, isValid: a2.pointMembers.isValid });
        return x;
      });
      y(a, "Maps/MapViewOptionsDefault.js", [], function() {
        return { center: [0, 0], fitToGeometry: void 0, maxZoom: void 0, padding: 0, projection: { name: void 0, parallels: void 0, rotation: void 0 }, zoom: void 0 };
      });
      y(a, "Maps/MapViewInsetsOptionsDefault.js", [], function() {
        return {
          borderColor: "#cccccc",
          borderWidth: 1,
          center: [0, 0],
          padding: "10%",
          relativeTo: "mapBoundingBox",
          units: "percent"
        };
      });
      y(a, "Extensions/GeoJSON.js", [a["Core/Chart/Chart.js"], a["Core/Templating.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, n3, q, z) {
        function k(a3, c) {
          c || (c = Object.keys(a3.objects)[0]);
          c = a3.objects[c];
          if (c["hc-decoded-geojson"])
            return c["hc-decoded-geojson"];
          let e = a3.arcs;
          if (a3.transform) {
            const { scale: b2, translate: d2 } = a3.transform;
            e = a3.arcs.map((a4) => {
              let c2 = 0, e2 = 0;
              return a4.map((a5) => {
                a5 = a5.slice();
                a5[0] = (c2 += a5[0]) * b2[0] + d2[0];
                a5[1] = (e2 += a5[1]) * b2[1] + d2[1];
                return a5;
              });
            });
          }
          const b = (a4) => typeof a4[0] === "number" ? a4.reduce((b2, a5, d2) => {
            let c2 = 0 > a5 ? e[~a5] : e[a5];
            0 > a5 ? (c2 = c2.slice(0, d2 === 0 ? c2.length : c2.length - 1), c2.reverse()) : d2 && (c2 = c2.slice(1));
            return b2.concat(c2);
          }, []) : a4.map(b), d = c.geometries.map((a4) => ({ type: "Feature", properties: a4.properties, geometry: { type: a4.type, coordinates: a4.coordinates || b(a4.arcs) } }));
          a3 = {
            type: "FeatureCollection",
            copyright: a3.copyright,
            copyrightShort: a3.copyrightShort,
            copyrightUrl: a3.copyrightUrl,
            features: d,
            "hc-recommended-mapview": c["hc-recommended-mapview"],
            bbox: a3.bbox,
            title: a3.title
          };
          return c["hc-decoded-geojson"] = a3;
        }
        function l2(a3, c = "map", e) {
          const b = [];
          a3 = a3.type === "Topology" ? k(a3) : a3;
          a3.features.forEach(function(a4) {
            var d = a4.geometry || {}, e2 = d.type;
            d = d.coordinates;
            a4 = a4.properties;
            let f;
            c !== "map" && c !== "mapbubble" || e2 !== "Polygon" && e2 !== "MultiPolygon" ? c !== "mapline" || e2 !== "LineString" && e2 !== "MultiLineString" ? c === "mappoint" && e2 === "Point" && d.length && (f = { geometry: { coordinates: d, type: e2 } }) : d.length && (f = { geometry: { coordinates: d, type: e2 } }) : d.length && (f = { geometry: {
              coordinates: d,
              type: e2
            } });
            if (f) {
              e2 = a4 && (a4.name || a4.NAME);
              d = a4 && a4.lon;
              const c2 = a4 && a4.lat;
              b.push(t(f, { lat: typeof c2 === "number" ? c2 : void 0, lon: typeof d === "number" ? d : void 0, name: typeof e2 === "string" ? e2 : void 0, properties: a4 }));
            }
          });
          e && a3.copyrightShort && (e.chart.mapCredits = g(e.chart.options.credits.mapText, { geojson: a3 }), e.chart.mapCreditsFull = g(e.chart.options.credits.mapTextFull, { geojson: a3 }));
          return b;
        }
        const { format: g } = n3, { win: w } = q, { error: x, extend: t, merge: h, wrap: F } = z;
        "";
        a2.prototype.transformFromLatLon = function(a3, c) {
          var e = this.options.chart.proj4 || w.proj4;
          if (e) {
            var { jsonmarginX: b = 0, jsonmarginY: d = 0, jsonres: f = 1, scale: h3 = 1, xoffset: k2 = 0, xpan: m = 0, yoffset: r = 0, ypan: v = 0 } = c;
            a3 = e(c.crs, [a3.lon, a3.lat]);
            e = c.cosAngle || c.rotation && Math.cos(c.rotation);
            var l3 = c.sinAngle || c.rotation && Math.sin(c.rotation);
            c = c.rotation ? [a3[0] * e + a3[1] * l3, -a3[0] * l3 + a3[1] * e] : a3;
            return { x: ((c[0] - k2) * h3 + m) * f + b, y: -(((r - c[1]) * h3 + v) * f - d) };
          }
          x(21, false, this);
        };
        a2.prototype.transformToLatLon = function(a3, c) {
          const e = this.options.chart.proj4 || w.proj4;
          if (!e)
            x(21, false, this);
          else if (a3.y !== null) {
            var {
              jsonmarginX: b = 0,
              jsonmarginY: d = 0,
              jsonres: f = 1,
              scale: h3 = 1,
              xoffset: k2 = 0,
              xpan: m = 0,
              yoffset: r = 0,
              ypan: v = 0
            } = c;
            a3 = { x: ((a3.x - b) / f - m) / h3 + k2, y: ((a3.y - d) / f + v) / h3 + r };
            var l3 = c.cosAngle || c.rotation && Math.cos(c.rotation), u = c.sinAngle || c.rotation && Math.sin(c.rotation);
            c = e(c.crs, "WGS84", c.rotation ? { x: a3.x * l3 + a3.y * -u, y: a3.x * u + a3.y * l3 } : a3);
            return { lat: c.y, lon: c.x };
          }
        };
        a2.prototype.fromPointToLatLon = function(a3) {
          return this.mapView && this.mapView.projectedUnitsToLonLat(a3);
        };
        a2.prototype.fromLatLonToPoint = function(a3) {
          return this.mapView && this.mapView.lonLatToProjectedUnits(a3);
        };
        F(a2.prototype, "addCredits", function(a3, c) {
          c = h(true, this.options.credits, c);
          this.mapCredits && (c.href = null);
          a3.call(this, c);
          this.credits && this.mapCreditsFull && this.credits.attr({ title: this.mapCreditsFull });
        });
        q.geojson = l2;
        q.topo2geo = k;
        return { geojson: l2, topo2geo: k };
      });
      y(a, "Core/Geometry/PolygonClip.js", [], function() {
        const a2 = (a3, k, l2) => (k[0] - a3[0]) * (l2[1] - a3[1]) > (k[1] - a3[1]) * (l2[0] - a3[0]), n3 = (a3, k, l2, g) => {
          var w = [a3[0] - k[0], a3[1] - k[1]];
          const q2 = [l2[0] - g[0], l2[1] - g[1]];
          a3 = a3[0] * k[1] - a3[1] * k[0];
          l2 = l2[0] * g[1] - l2[1] * g[0];
          g = 1 / (w[0] * q2[1] - w[1] * q2[0]);
          w = [(a3 * q2[0] - l2 * w[0]) * g, (a3 * q2[1] - l2 * w[1]) * g];
          w.isIntersection = true;
          return w;
        };
        var q;
        (function(g) {
          g.clipLineString = (a3, l2) => {
            const k = [];
            a3 = g.clipPolygon(a3, l2, false);
            for (l2 = 1; l2 < a3.length; l2++)
              a3[l2].isIntersection && a3[l2 - 1].isIntersection && (k.push(a3.splice(0, l2)), l2 = 0), l2 === a3.length - 1 && k.push(a3);
            return k;
          };
          g.clipPolygon = (k, l2, g2 = true) => {
            let q2 = l2[l2.length - 1], x, t, h = k;
            for (let w = 0; w < l2.length; w++) {
              const f = h;
              k = l2[w];
              h = [];
              x = g2 ? f[f.length - 1] : f[0];
              for (let c = 0; c < f.length; c++)
                t = f[c], a2(q2, k, t) ? (a2(q2, k, x) || h.push(n3(q2, k, x, t)), h.push(t)) : a2(q2, k, x) && h.push(n3(q2, k, x, t)), x = t;
              q2 = k;
            }
            return h;
          };
        })(q || (q = {}));
        return q;
      });
      y(a, "Maps/Projections/LambertConformalConic.js", [], function() {
        const a2 = Math.sign || ((a3) => a3 === 0 ? 0 : 0 < a3 ? 1 : -1), n3 = Math.PI / 180, q = Math.PI / 2;
        class z {
          constructor(k) {
            var l2, g = (k.parallels || []).map((a3) => a3 * n3);
            const w = g[0] || 0;
            g = (l2 = g[1]) !== null && l2 !== void 0 ? l2 : w;
            l2 = Math.cos(w);
            typeof k.projectedBounds === "object" && (this.projectedBounds = k.projectedBounds);
            k = w === g ? Math.sin(w) : Math.log(l2 / Math.cos(g)) / Math.log(Math.tan((q + g) / 2) / Math.tan((q + w) / 2));
            1e-10 > Math.abs(k) && (k = 1e-10 * (a2(k) || 1));
            this.n = k;
            this.c = l2 * Math.pow(Math.tan((q + w) / 2), k) / k;
          }
          forward(a3) {
            var l2 = a3[0] * n3;
            const { c: k, n: g, projectedBounds: x } = this;
            a3 = a3[1] * n3;
            0 < k ? a3 < -q + 1e-6 && (a3 = -q + 1e-6) : a3 > q - 1e-6 && (a3 = q - 1e-6);
            var t = k / Math.pow(Math.tan((q + a3) / 2), g);
            a3 = t * Math.sin(g * l2) * 63.78137;
            l2 = 63.78137 * (k - t * Math.cos(g * l2));
            t = [a3, l2];
            x && (a3 < x.x1 || a3 > x.x2 || l2 < x.y1 || l2 > x.y2) && (t.outside = true);
            return t;
          }
          inverse(k) {
            const l2 = k[0] / 63.78137;
            k = k[1] / 63.78137;
            const { c: g, n: w } = this;
            k = g - k;
            const x = a2(w) * Math.sqrt(l2 * l2 + k * k);
            let t = Math.atan2(l2, Math.abs(k)) * a2(k);
            0 > k * w && (t -= Math.PI * a2(l2) * a2(k));
            return [t / w / n3, (2 * Math.atan(Math.pow(g / x, 1 / w)) - q) / n3];
          }
        }
        return z;
      });
      y(a, "Maps/Projections/EqualEarth.js", [], function() {
        const a2 = Math.sqrt(3) / 2;
        class n3 {
          constructor() {
            this.bounds = { x1: -200.37508342789243, x2: 200.37508342789243, y1: -97.52595454902263, y2: 97.52595454902263 };
          }
          forward(g) {
            const q = Math.PI / 180, k = Math.asin(a2 * Math.sin(g[1] * q)), l2 = k * k, n4 = l2 * l2 * l2;
            return [g[0] * q * Math.cos(k) * 74.03120656864502 / (a2 * (1.340264 + 3 * -0.081106 * l2 + n4 * (7 * 893e-6 + 0.034164 * l2))), 74.03120656864502 * k * (1.340264 + -0.081106 * l2 + n4 * (893e-6 + 3796e-6 * l2))];
          }
          inverse(g) {
            const q = g[0] / 74.03120656864502;
            g = g[1] / 74.03120656864502;
            const k = 180 / Math.PI;
            let l2 = g;
            let n4;
            let w;
            for (w = 0; 12 > w; ++w) {
              var x = l2 * l2;
              n4 = x * x * x;
              var t = l2 * (1.340264 + -0.081106 * x + n4 * (893e-6 + 3796e-6 * x)) - g;
              x = 1.340264 + 3 * -0.081106 * x + n4 * (7 * 893e-6 + 0.034164 * x);
              l2 -= t /= x;
              if (1e-9 > Math.abs(t))
                break;
            }
            x = l2 * l2;
            return [k * a2 * q * (1.340264 + 3 * -0.081106 * x + x * x * x * (7 * 893e-6 + 0.034164 * x)) / Math.cos(l2), k * Math.asin(Math.sin(l2) / a2)];
          }
        }
        return n3;
      });
      y(a, "Maps/Projections/Miller.js", [], function() {
        const a2 = Math.PI / 4, n3 = Math.PI / 180;
        class q {
          constructor() {
            this.bounds = { x1: -200.37508342789243, x2: 200.37508342789243, y1: -146.91480769173063, y2: 146.91480769173063 };
          }
          forward(g) {
            return [g[0] * n3 * 63.78137, 79.7267125 * Math.log(Math.tan(a2 + 0.4 * g[1] * n3))];
          }
          inverse(g) {
            return [g[0] / 63.78137 / n3, 2.5 * (Math.atan(Math.exp(g[1] / 63.78137 * 0.8)) - a2) / n3];
          }
        }
        return q;
      });
      y(a, "Maps/Projections/Orthographic.js", [], function() {
        const a2 = Math.PI / 180;
        class n3 {
          constructor() {
            this.antimeridianCutting = false;
            this.bounds = {
              x1: -63.78460826781007,
              x2: 63.78460826781007,
              y1: -63.78460826781007,
              y2: 63.78460826781007
            };
          }
          forward(g) {
            const n4 = g[0];
            g = g[1] * a2;
            g = [Math.cos(g) * Math.sin(n4 * a2) * 63.78460826781007, 63.78460826781007 * Math.sin(g)];
            if (-90 > n4 || 90 < n4)
              g.outside = true;
            return g;
          }
          inverse(g) {
            const n4 = g[0] / 63.78460826781007;
            g = g[1] / 63.78460826781007;
            const k = Math.sqrt(n4 * n4 + g * g), l2 = Math.asin(k), q = Math.sin(l2);
            return [Math.atan2(n4 * q, k * Math.cos(l2)) / a2, Math.asin(k && g * q / k) / a2];
          }
        }
        return n3;
      });
      y(a, "Maps/Projections/WebMercator.js", [], function() {
        const a2 = Math.PI / 180;
        class n3 {
          constructor() {
            this.bounds = {
              x1: -200.37508342789243,
              x2: 200.37508342789243,
              y1: -200.3750834278071,
              y2: 200.3750834278071
            };
            this.maxLatitude = 85.0511287798;
          }
          forward(g) {
            var n4 = Math.sin(g[1] * a2);
            n4 = [63.78137 * g[0] * a2, 63.78137 * Math.log((1 + n4) / (1 - n4)) / 2];
            85.0511287798 < Math.abs(g[1]) && (n4.outside = true);
            return n4;
          }
          inverse(g) {
            return [g[0] / (63.78137 * a2), (2 * Math.atan(Math.exp(g[1] / 63.78137)) - Math.PI / 2) / a2];
          }
        }
        return n3;
      });
      y(a, "Maps/Projections/ProjectionRegistry.js", [
        a["Maps/Projections/LambertConformalConic.js"],
        a["Maps/Projections/EqualEarth.js"],
        a["Maps/Projections/Miller.js"],
        a["Maps/Projections/Orthographic.js"],
        a["Maps/Projections/WebMercator.js"]
      ], function(a2, n3, q, z, k) {
        return { EqualEarth: n3, LambertConformalConic: a2, Miller: q, Orthographic: z, WebMercator: k };
      });
      y(a, "Maps/Projection.js", [a["Core/Geometry/PolygonClip.js"], a["Maps/Projections/ProjectionRegistry.js"], a["Core/Utilities.js"]], function(a2, n3, q) {
        const { clipLineString: g, clipPolygon: k } = a2, { clamp: l2, erase: A } = q, w = 2 * Math.PI / 360, x = (a3) => {
          -180 > a3 && (a3 += 360);
          180 < a3 && (a3 -= 360);
          return a3;
        };
        class t {
          static add(a3, g2) {
            t.registry[a3] = g2;
          }
          static greatCircle(a3, g2, f) {
            const {
              atan2: c,
              cos: e,
              sin: b,
              sqrt: d
            } = Math, h = a3[1] * w, p = a3[0] * w, l3 = g2[1] * w, m = g2[0] * w;
            var r = l3 - h, v = m - p;
            r = b(r / 2) * b(r / 2) + e(h) * e(l3) * b(v / 2) * b(v / 2);
            r = 2 * c(d(r), d(1 - r));
            var k2 = Math.round(6371e3 * r / 5e5);
            v = [];
            f && v.push(a3);
            if (1 < k2)
              for (a3 = 1 / k2, k2 = a3; 0.999 > k2; k2 += a3) {
                var u = b((1 - k2) * r) / b(r);
                const a4 = b(k2 * r) / b(r);
                var B = u * e(h) * e(p) + a4 * e(l3) * e(m);
                const f2 = u * e(h) * b(p) + a4 * e(l3) * b(m);
                u = u * b(h) + a4 * b(l3);
                u = c(u, d(B * B + f2 * f2));
                B = c(f2, B);
                v.push([B / w, u / w]);
              }
            f && v.push(g2);
            return v;
          }
          static insertGreatCircles(a3) {
            let h = a3.length - 1;
            for (; h--; )
              if (10 < Math.max(Math.abs(a3[h][0] - a3[h + 1][0]), Math.abs(a3[h][1] - a3[h + 1][1]))) {
                const f = t.greatCircle(a3[h], a3[h + 1]);
                f.length && a3.splice(h + 1, 0, ...f);
              }
          }
          static toString(a3) {
            const { name: h, rotation: f } = a3 || {};
            return [h, f && f.join(",")].join(";");
          }
          constructor(a3 = {}) {
            this.hasGeoProjection = this.hasCoordinates = false;
            this.maxLatitude = 90;
            this.options = a3;
            const { name: h, projectedBounds: f, rotation: c } = a3;
            this.rotator = c ? this.getRotator(c) : void 0;
            const e = h ? t.registry[h] : void 0;
            e && (this.def = new e(a3));
            const { def: b, rotator: d } = this;
            b && (this.maxLatitude = b.maxLatitude || 90, this.hasGeoProjection = true);
            d && b ? (this.forward = (a4) => b.forward(d.forward(a4)), this.inverse = (a4) => d.inverse(b.inverse(a4))) : b ? (this.forward = (a4) => b.forward(a4), this.inverse = (a4) => b.inverse(a4)) : d && (this.forward = d.forward, this.inverse = d.inverse);
            this.bounds = f === "world" ? b && b.bounds : f;
          }
          lineIntersectsBounds(a3) {
            const { x1: h, x2: f, y1: c, y2: e } = this.bounds || {}, b = (a4, b2, d2) => {
              const [c2, e2] = a4;
              a4 = b2 ? 0 : 1;
              if (typeof d2 === "number" && c2[b2] >= d2 !== e2[b2] >= d2)
                return a4 = c2[a4] + (d2 - c2[b2]) / (e2[b2] - c2[b2]) * (e2[a4] - c2[a4]), b2 ? [a4, d2] : [d2, a4];
            };
            let d, g2 = a3[0];
            if (d = b(a3, 0, h))
              g2 = d, a3[1] = d;
            else if (d = b(a3, 0, f))
              g2 = d, a3[1] = d;
            if (d = b(a3, 1, c))
              g2 = d;
            else if (d = b(a3, 1, e))
              g2 = d;
            return g2;
          }
          getRotator(a3) {
            const h = a3[0] * w, f = (a3[1] || 0) * w;
            a3 = (a3[2] || 0) * w;
            const c = Math.cos(f), e = Math.sin(f), b = Math.cos(a3), d = Math.sin(a3);
            if (h !== 0 || f !== 0 || a3 !== 0)
              return { forward: (a4) => {
                var f2 = a4[0] * w + h, g2 = a4[1] * w, m = Math.cos(g2);
                a4 = Math.cos(f2) * m;
                f2 = Math.sin(f2) * m;
                g2 = Math.sin(g2);
                m = g2 * c + a4 * e;
                return [Math.atan2(f2 * b - m * d, a4 * c - g2 * e) / w, Math.asin(m * b + f2 * d) / w];
              }, inverse: (a4) => {
                var f2 = a4[0] * w, g2 = a4[1] * w, m = Math.cos(g2);
                a4 = Math.cos(f2) * m;
                f2 = Math.sin(f2) * m;
                g2 = Math.sin(g2);
                m = g2 * b - f2 * d;
                return [(Math.atan2(f2 * b + g2 * d, a4 * c + m * e) - h) / w, Math.asin(m * c - a4 * e) / w];
              } };
          }
          forward(a3) {
            return a3;
          }
          inverse(a3) {
            return a3;
          }
          cutOnAntimeridian(a3, g2) {
            const f = [], c = [a3];
            a3.forEach((b2, d2) => {
              let c2 = a3[d2 - 1];
              if (!d2) {
                if (!g2)
                  return;
                c2 = a3[a3.length - 1];
              }
              const e2 = c2[0];
              var u = b2[0];
              (-90 > e2 || 90 < e2) && (-90 > u || 90 < u) && 0 < e2 !== 0 < u && (u = l2((180 - (e2 + 360) % 360) / ((u + 360) % 360 - (e2 + 360) % 360), 0, 1), f.push({ i: d2, lat: c2[1] + u * (b2[1] - c2[1]), direction: 0 > e2 ? 1 : -1, previousLonLat: c2, lonLat: b2 }));
            });
            if (f.length)
              if (g2) {
                if (f.length % 2 === 1) {
                  var e = f.slice().sort((a4, b2) => Math.abs(b2.lat) - Math.abs(a4.lat))[0];
                  A(f, e);
                }
                for (var b = f.length - 2; 0 <= b; ) {
                  var d = f[b].i, h = x(180 + 1e-6 * f[b].direction), p = x(180 - 1e-6 * f[b].direction);
                  d = a3.splice(d, f[b + 1].i - d, ...t.greatCircle([h, f[b].lat], [h, f[b + 1].lat], true));
                  d.push(...t.greatCircle([p, f[b + 1].lat], [p, f[b].lat], true));
                  c.push(d);
                  b -= 2;
                }
                if (e)
                  for (d = 0; d < c.length; d++) {
                    const { direction: a4, lat: f2 } = e;
                    b = c[d];
                    p = b.indexOf(e.lonLat);
                    if (-1 < p) {
                      d = (0 > f2 ? -1 : 1) * this.maxLatitude;
                      var k2 = x(180 + 1e-6 * a4);
                      h = x(180 - 1e-6 * a4);
                      const c2 = t.greatCircle([k2, f2], [k2, d], true);
                      for (k2 += 120 * a4; -180 < k2 && 180 > k2; k2 += 120 * a4)
                        c2.push([k2, d]);
                      c2.push(...t.greatCircle([
                        h,
                        d
                      ], [h, e.lat], true));
                      b.splice(p, 0, ...c2);
                      break;
                    }
                  }
              } else
                for (e = f.length; e--; )
                  b = a3.splice(f[e].i, a3.length, [x(180 + 1e-6 * f[e].direction), f[e].lat]), b.unshift([x(180 - 1e-6 * f[e].direction), f[e].lat]), c.push(b);
            return c;
          }
          path(a3) {
            const { bounds: h, def: f, rotator: c } = this, e = [], b = a3.type === "Polygon" || a3.type === "MultiPolygon", d = this.hasGeoProjection, l3 = !f || f.antimeridianCutting !== false, p = l3 ? c : void 0, n4 = l3 ? f || this : this;
            let m;
            h && (m = [[h.x1, h.y1], [h.x2, h.y1], [h.x2, h.y2], [h.x1, h.y2]]);
            const r = (a4) => {
              a4 = a4.map((a5) => {
                if (l3) {
                  p && (a5 = p.forward(a5));
                  let b2 = a5[0];
                  1e-6 > Math.abs(b2 - 180) && (b2 = 180 > b2 ? 179.999999 : 180.000001);
                  a5 = [b2, a5[1]];
                }
                return a5;
              });
              let c2 = [a4];
              d && (t.insertGreatCircles(a4), l3 && (c2 = this.cutOnAntimeridian(a4, b)));
              c2.forEach((a5) => {
                if (!(2 > a5.length)) {
                  var c3 = false, u = false, f2 = (a6) => {
                    c3 ? e.push(["L", a6[0], a6[1]]) : (e.push(["M", a6[0], a6[1]]), c3 = true);
                  }, v = false, p2 = false, r2 = a5.map((a6) => {
                    a6 = n4.forward(a6);
                    a6.outside ? v = true : p2 = true;
                    a6[1] === Infinity ? a6[1] = 1e10 : a6[1] === -Infinity && (a6[1] = -1e10);
                    return a6;
                  });
                  if (l3) {
                    b && r2.push(r2[0]);
                    if (v) {
                      if (!p2)
                        return;
                      if (m) {
                        if (b)
                          r2 = k(r2, m);
                        else if (h) {
                          g(r2, m).forEach((a6) => {
                            c3 = false;
                            a6.forEach(f2);
                          });
                          return;
                        }
                      }
                    }
                    r2.forEach(f2);
                  } else
                    for (let e2 = 0; e2 < r2.length; e2++) {
                      const g2 = a5[e2], h3 = r2[e2];
                      if (h3.outside)
                        u = true;
                      else {
                        if (b && !w2) {
                          var w2 = g2;
                          a5.push(g2);
                          r2.push(h3);
                        }
                        u && q2 && (b && d ? t.greatCircle(q2, g2).forEach((a6) => f2(n4.forward(a6))) : c3 = false);
                        f2(h3);
                        var q2 = g2;
                        u = false;
                      }
                    }
                }
              });
            };
            a3.type === "LineString" ? r(a3.coordinates) : a3.type === "MultiLineString" ? a3.coordinates.forEach((a4) => r(a4)) : a3.type === "Polygon" ? (a3.coordinates.forEach((a4) => r(a4)), e.length && e.push(["Z"])) : a3.type === "MultiPolygon" && (a3.coordinates.forEach((a4) => {
              a4.forEach((a5) => r(a5));
            }), e.length && e.push(["Z"]));
            return e;
          }
        }
        t.registry = n3;
        return t;
      });
      y(a, "Maps/MapView.js", [a["Maps/MapViewOptionsDefault.js"], a["Maps/MapViewInsetsOptionsDefault.js"], a["Extensions/GeoJSON.js"], a["Core/Chart/MapChart.js"], a["Maps/MapUtilities.js"], a["Maps/Projection.js"], a["Core/Utilities.js"]], function(a2, n3, q, z, k, l2, A) {
        const { topo2geo: g } = q, { maps: x } = z, { boundsFromPath: t, pointInPolygon: h } = k, { addEvent: F, clamp: f, fireEvent: c, isArray: e, isNumber: b, isObject: d, isString: E, merge: p, pick: C, relativeLength: m } = A, r = (a3, b2) => {
          const { width: c2, height: d2 } = b2;
          return Math.log(400.979322 / Math.max((a3.x2 - a3.x1) / (c2 / 256), (a3.y2 - a3.y1) / (d2 / 256))) / Math.log(2);
        };
        class v {
          static mergeInsets(a3, b2) {
            const c2 = (a4) => {
              const b3 = {};
              a4.forEach((a5, c3) => {
                b3[a5 && a5.id || `i${c3}`] = a5;
              });
              return b3;
            }, d2 = p(c2(a3), c2(b2));
            return Object.keys(d2).map((a4) => d2[a4]);
          }
          createInsets() {
            const a3 = this.options, b2 = a3.insets;
            b2 && b2.forEach((b3) => {
              b3 = new G(this, p(a3.insetOptions, b3));
              this.insets.push(b3);
            });
          }
          constructor(d2, e2) {
            this.allowTransformAnimation = true;
            this.insets = [];
            this.padding = [0, 0, 0, 0];
            this.eventsToUnbind = [];
            let u, f2;
            if (!(this instanceof G)) {
              var g2 = [
                d2.options.chart.map,
                ...(d2.options.series || []).map((a4) => a4.mapData)
              ].map((a4) => this.getGeoMap(a4));
              const a3 = [];
              g2.forEach((b3) => {
                if (b3 && (u || (u = b3["hc-recommended-mapview"]), b3.bbox)) {
                  const [c2, d3, e3, u2] = b3.bbox;
                  a3.push({ x1: c2, y1: d3, x2: e3, y2: u2 });
                }
              });
              const b2 = a3.length && v.compositeBounds(a3);
              c(d2, "beforeMapViewInit", { geoBounds: b2 }, function() {
                if (b2) {
                  const { x1: a4, y1: c2, x2: d3, y2: e3 } = b2;
                  f2 = 180 < d3 - a4 && 90 < e3 - c2 ? { name: "EqualEarth" } : { name: "LambertConformalConic", parallels: [c2, e3], rotation: [-(a4 + d3) / 2] };
                }
              });
              this.geoMap = g2[0];
            }
            this.userOptions = e2 || {};
            d2.options.mapView && d2.options.mapView.recommendedMapView && (u = d2.options.mapView.recommendedMapView);
            g2 = p(a2, { projection: f2 }, u, e2);
            const h3 = u && u.insets;
            e2 = e2 && e2.insets;
            h3 && e2 && (g2.insets = v.mergeInsets(h3, e2));
            this.chart = d2;
            this.center = g2.center;
            this.options = g2;
            this.projection = new l2(g2.projection);
            this.playingField = d2.plotBox;
            this.zoom = g2.zoom || 0;
            this.minZoom = g2.minZoom;
            this.createInsets();
            this.eventsToUnbind.push(F(d2, "afterSetChartSize", () => {
              this.playingField = this.getField();
              if (this.minZoom === void 0 || this.minZoom === this.zoom)
                this.fitToBounds(void 0, void 0, false), !this.chart.hasRendered && b(this.userOptions.zoom) && (this.zoom = this.userOptions.zoom), this.userOptions.center && p(true, this.center, this.userOptions.center);
            }));
            this.setUpEvents();
          }
          fitToBounds(a3, b2, c2 = true, d2) {
            const u = a3 || this.getProjectedBounds();
            if (u) {
              var f2 = C(b2, a3 ? 0 : this.options.padding);
              b2 = this.getField(false);
              f2 = e(f2) ? f2 : [f2, f2, f2, f2];
              this.padding = [m(f2[0], b2.height), m(f2[1], b2.width), m(f2[2], b2.height), m(f2[3], b2.width)];
              this.playingField = this.getField();
              b2 = r(u, this.playingField);
              a3 || (this.minZoom = b2);
              a3 = this.projection.inverse([(u.x2 + u.x1) / 2, (u.y2 + u.y1) / 2]);
              this.setView(a3, b2, c2, d2);
            }
          }
          getField(a3 = true) {
            a3 = a3 ? this.padding : [0, 0, 0, 0];
            return { x: a3[3], y: a3[0], width: this.chart.plotWidth - a3[1] - a3[3], height: this.chart.plotHeight - a3[0] - a3[2] };
          }
          getGeoMap(a3) {
            if (E(a3))
              return x[a3] && x[a3].type === "Topology" ? g(x[a3]) : x[a3];
            if (d(a3, true)) {
              if (a3.type === "FeatureCollection")
                return a3;
              if (a3.type === "Topology")
                return g(a3);
            }
          }
          getMapBBox() {
            const a3 = this.getProjectedBounds(), b2 = this.getScale();
            if (a3) {
              const c2 = this.padding, d2 = this.projectedUnitsToPixels({ x: a3.x1, y: a3.y2 });
              return {
                width: (a3.x2 - a3.x1) * b2 + c2[1] + c2[3],
                height: (a3.y2 - a3.y1) * b2 + c2[0] + c2[2],
                x: d2.x - c2[3],
                y: d2.y - c2[0]
              };
            }
          }
          getProjectedBounds() {
            const a3 = this.projection;
            var b2 = this.chart.series.reduce((a4, b3) => {
              const c3 = b3.getProjectedBounds && b3.getProjectedBounds();
              c3 && b3.options.affectsMapView !== false && a4.push(c3);
              return a4;
            }, []), c2 = this.options.fitToGeometry;
            return c2 ? (this.fitToGeometryCache || (c2.type === "MultiPoint" ? (c2 = c2.coordinates.map((b3) => a3.forward(b3)), b2 = c2.map((a4) => a4[0]), c2 = c2.map((a4) => a4[1]), this.fitToGeometryCache = {
              x1: Math.min.apply(0, b2),
              x2: Math.max.apply(0, b2),
              y1: Math.min.apply(0, c2),
              y2: Math.max.apply(0, c2)
            }) : this.fitToGeometryCache = t(a3.path(c2))), this.fitToGeometryCache) : this.projection.bounds || v.compositeBounds(b2);
          }
          getScale() {
            return 256 / 400.979322 * Math.pow(2, this.zoom);
          }
          getSVGTransform() {
            const { x: a3, y: b2, width: c2, height: d2 } = this.playingField, e2 = this.projection.forward(this.center);
            var f2 = this.projection.hasCoordinates ? -1 : 1;
            const g2 = this.getScale();
            f2 *= g2;
            return { scaleX: g2, scaleY: f2, translateX: a3 + c2 / 2 - e2[0] * g2, translateY: b2 + d2 / 2 - e2[1] * f2 };
          }
          lonLatToPixels(a3) {
            if (a3 = this.lonLatToProjectedUnits(a3))
              return this.projectedUnitsToPixels(a3);
          }
          lonLatToProjectedUnits(a3) {
            const b2 = this.chart, c2 = b2.mapTransforms;
            if (c2) {
              for (const e2 in c2)
                if (Object.hasOwnProperty.call(c2, e2) && c2[e2].hitZone) {
                  var d2 = b2.transformFromLatLon(a3, c2[e2]);
                  if (d2 && h(d2, c2[e2].hitZone.coordinates[0]))
                    return d2;
                }
              return b2.transformFromLatLon(a3, c2["default"]);
            }
            for (d2 of this.insets)
              if (d2.options.geoBounds && h({ x: a3.lon, y: a3.lat }, d2.options.geoBounds.coordinates[0]))
                return a3 = d2.projection.forward([a3.lon, a3.lat]), a3 = d2.projectedUnitsToPixels({ x: a3[0], y: a3[1] }), this.pixelsToProjectedUnits(a3);
            a3 = this.projection.forward([a3.lon, a3.lat]);
            if (!a3.outside)
              return {
                x: a3[0],
                y: a3[1]
              };
          }
          projectedUnitsToLonLat(a3) {
            var b2 = this.chart;
            const c2 = b2.mapTransforms;
            if (c2) {
              for (const d3 in c2)
                if (Object.hasOwnProperty.call(c2, d3) && c2[d3].hitZone && h(a3, c2[d3].hitZone.coordinates[0]))
                  return b2.transformToLatLon(a3, c2[d3]);
              return b2.transformToLatLon(a3, c2["default"]);
            }
            b2 = this.projectedUnitsToPixels(a3);
            for (var d2 of this.insets)
              if (d2.hitZone && h(b2, d2.hitZone.coordinates[0]))
                return a3 = d2.pixelsToProjectedUnits(b2), d2 = d2.projection.inverse([a3.x, a3.y]), { lon: d2[0], lat: d2[1] };
            d2 = this.projection.inverse([a3.x, a3.y]);
            return {
              lon: d2[0],
              lat: d2[1]
            };
          }
          redraw(a3) {
            this.chart.series.forEach((a4) => {
              a4.useMapGeometry && (a4.isDirty = true);
            });
            this.chart.redraw(a3);
          }
          setView(a3, d2, e2 = true, f2) {
            a3 && (this.center = a3);
            typeof d2 === "number" && (typeof this.minZoom === "number" && (d2 = Math.max(d2, this.minZoom)), typeof this.options.maxZoom === "number" && (d2 = Math.min(d2, this.options.maxZoom)), b(d2) && (this.zoom = d2));
            var g2 = this.getProjectedBounds();
            if (g2) {
              a3 = this.projection.forward(this.center);
              const { x: b2, y: c2, width: e3, height: f3 } = this.playingField;
              d2 = this.getScale();
              var h3 = this.projectedUnitsToPixels({
                x: g2.x1,
                y: g2.y1
              }), u = this.projectedUnitsToPixels({ x: g2.x2, y: g2.y2 });
              g2 = [(g2.x1 + g2.x2) / 2, (g2.y1 + g2.y2) / 2];
              if (!this.chart.series.some((a4) => a4.isDrilling)) {
                const m2 = h3.x, r2 = u.y;
                u = u.x;
                h3 = h3.y;
                u - m2 < e3 ? a3[0] = g2[0] : m2 < b2 && u < b2 + e3 ? a3[0] += Math.max(m2 - b2, u - e3 - b2) / d2 : u > b2 + e3 && m2 > b2 && (a3[0] += Math.min(u - e3 - b2, m2 - b2) / d2);
                h3 - r2 < f3 ? a3[1] = g2[1] : r2 < c2 && h3 < c2 + f3 ? a3[1] -= Math.max(r2 - c2, h3 - f3 - c2) / d2 : h3 > c2 + f3 && r2 > c2 && (a3[1] -= Math.min(h3 - f3 - c2, r2 - c2) / d2);
                this.center = this.projection.inverse(a3);
              }
              this.insets.forEach((a4) => {
                a4.options.field && (a4.hitZone = a4.getHitZone(), a4.playingField = a4.getField());
              });
              this.render();
            }
            c(this, "afterSetView");
            e2 && this.redraw(f2);
          }
          projectedUnitsToPixels(a3) {
            const b2 = this.getScale(), c2 = this.projection.forward(this.center), d2 = this.playingField;
            return { x: d2.x + d2.width / 2 - b2 * (c2[0] - a3.x), y: d2.y + d2.height / 2 + b2 * (c2[1] - a3.y) };
          }
          pixelsToLonLat(a3) {
            return this.projectedUnitsToLonLat(this.pixelsToProjectedUnits(a3));
          }
          pixelsToProjectedUnits(a3) {
            const { x: b2, y: c2 } = a3;
            a3 = this.getScale();
            const d2 = this.projection.forward(this.center), e2 = this.playingField;
            return { x: d2[0] + (b2 - (e2.x + e2.width / 2)) / a3, y: d2[1] - (c2 - (e2.y + e2.height / 2)) / a3 };
          }
          setUpEvents() {
            const { chart: a3 } = this;
            let c2, d2, e2;
            const g2 = (g3) => {
              var h3 = a3.pointer.pinchDown, m2 = this.projection;
              let { mouseDownX: u, mouseDownY: p2 } = a3;
              h3.length === 1 && (u = h3[0].chartX, p2 = h3[0].chartY);
              if (typeof u === "number" && typeof p2 === "number") {
                h3 = `${u},${p2}`;
                const { chartX: v2, chartY: k2 } = g3.originalEvent;
                h3 !== d2 && (d2 = h3, c2 = this.projection.forward(this.center), e2 = (this.projection.options.rotation || [0, 0]).slice());
                h3 = (h3 = m2.def && m2.def.bounds) && r(h3, this.playingField) || -Infinity;
                if (m2.options.name === "Orthographic" && (this.minZoom || Infinity) < 1.3 * h3) {
                  if (h3 = 440 / (this.getScale() * Math.min(a3.plotWidth, a3.plotHeight)), e2) {
                    m2 = (u - v2) * h3 - e2[0];
                    h3 = f(-e2[1] - (p2 - k2) * h3, -80, 80);
                    const b2 = this.zoom;
                    this.update({ projection: { rotation: [-m2, -h3] } }, false);
                    this.fitToBounds(void 0, void 0, false);
                    this.zoom = b2;
                    a3.redraw(false);
                  }
                } else
                  b(v2) && b(k2) && (m2 = this.getScale(), m2 = this.projection.inverse([c2[0] + (u - v2) / m2, c2[1] - (p2 - k2) / m2 * (this.projection.hasCoordinates ? 1 : -1)]), this.setView(m2, void 0, true, false));
                g3.preventDefault();
              }
            };
            F(a3, "pan", g2);
            F(a3, "touchpan", g2);
            F(a3, "selection", (b2) => {
              if (b2.resetSelection)
                this.zoomBy();
              else {
                const c3 = b2.x - a3.plotLeft, d3 = b2.y - a3.plotTop, { y: e3, x: f2 } = this.pixelsToProjectedUnits({ x: c3, y: d3 }), { y: g3, x: h3 } = this.pixelsToProjectedUnits({ x: c3 + b2.width, y: d3 + b2.height });
                this.fitToBounds({ x1: f2, y1: e3, x2: h3, y2: g3 }, void 0, true, b2.originalEvent.touches ? false : void 0);
                /^touch/.test(b2.originalEvent.type) || a3.showResetZoom();
                b2.preventDefault();
              }
            });
          }
          render() {
            this.group || (this.group = this.chart.renderer.g("map-view").attr({ zIndex: 4 }).add());
          }
          update(a3, c2 = true, d2) {
            var e2 = a3.projection;
            e2 = e2 && l2.toString(e2) !== l2.toString(this.options.projection);
            let f2 = false;
            p(true, this.userOptions, a3);
            p(true, this.options, a3);
            "insets" in a3 && (this.insets.forEach((a4) => a4.destroy()), this.insets.length = 0, f2 = true);
            (e2 || "fitToGeometry" in a3) && delete this.fitToGeometryCache;
            if (e2 || f2)
              this.chart.series.forEach((a4) => {
                const b2 = a4.transformGroups;
                a4.clearBounds && a4.clearBounds();
                a4.isDirty = true;
                a4.isDirtyData = true;
                if (f2 && b2)
                  for (; 1 < b2.length; )
                    (a4 = b2.pop()) && a4.destroy();
              }), e2 && (this.projection = new l2(this.options.projection)), f2 && this.createInsets(), a3.center || !Object.hasOwnProperty.call(a3, "zoom") || b(a3.zoom) || this.fitToBounds(void 0, void 0, false);
            a3.center || b(a3.zoom) ? this.setView(this.options.center, a3.zoom, false) : "fitToGeometry" in a3 && this.fitToBounds(void 0, void 0, false);
            c2 && this.chart.redraw(d2);
          }
          zoomBy(a3, b2, c2, d2) {
            var e2 = this.chart;
            const f2 = this.projection.forward(this.center);
            let [g2, h3] = b2 ? this.projection.forward(b2) : [];
            if (typeof a3 === "number") {
              a3 = this.zoom + a3;
              if (c2) {
                const [a4, d3] = c2;
                c2 = this.getScale();
                b2 = d3 - e2.plotTop - e2.plotHeight / 2;
                g2 = f2[0] + (a4 - e2.plotLeft - e2.plotWidth / 2) / c2;
                h3 = f2[1] + b2 / c2;
              }
              if (typeof g2 === "number" && typeof h3 === "number") {
                e2 = 1 - Math.pow(2, this.zoom) / Math.pow(2, a3);
                var m2 = f2[1] - h3;
                f2[0] -= (f2[0] - g2) * e2;
                f2[1] += m2 * e2;
                m2 = this.projection.inverse(f2);
              }
              this.setView(m2, a3, void 0, d2);
            } else
              this.fitToBounds(void 0, void 0, void 0, d2);
          }
        }
        v.compositeBounds = (a3) => {
          if (a3.length)
            return a3.slice(1).reduce((a4, b2) => {
              a4.x1 = Math.min(a4.x1, b2.x1);
              a4.y1 = Math.min(a4.y1, b2.y1);
              a4.x2 = Math.max(a4.x2, b2.x2);
              a4.y2 = Math.max(a4.y2, b2.y2);
              return a4;
            }, p(a3[0]));
        };
        class G extends v {
          constructor(a3, b2) {
            super(a3.chart, b2);
            this.id = b2.id;
            this.mapView = a3;
            this.options = p(n3, b2);
            this.allBounds = [];
            this.options.geoBounds && (a3 = a3.projection.path(this.options.geoBounds), this.geoBoundsProjectedBox = t(a3), this.geoBoundsProjectedPolygon = a3.map((a4) => [a4[1] || 0, a4[2] || 0]));
          }
          getField(a3 = true) {
            var c2 = this.hitZone;
            if (c2) {
              var d2 = a3 ? this.padding : [0, 0, 0, 0];
              c2 = c2.coordinates[0];
              var e2 = c2.map((a4) => a4[0]);
              const f2 = c2.map((a4) => a4[1]);
              c2 = Math.min.apply(0, e2) + d2[3];
              e2 = Math.max.apply(0, e2) - d2[1];
              const g2 = Math.min.apply(0, f2) + d2[0];
              d2 = Math.max.apply(0, f2) - d2[2];
              if (b(c2) && b(g2))
                return { x: c2, y: g2, width: e2 - c2, height: d2 - g2 };
            }
            return super.getField.call(this, a3);
          }
          getHitZone() {
            const { chart: a3, mapView: b2, options: c2 } = this;
            var { coordinates: d2 } = c2.field || {};
            if (d2) {
              d2 = d2[0];
              if (c2.units === "percent") {
                const e2 = c2.relativeTo === "mapBoundingBox" && b2.getMapBBox() || p(a3.plotBox, { x: 0, y: 0 });
                d2 = d2.map((a4) => [m(`${a4[0]}%`, e2.width, e2.x), m(`${a4[1]}%`, e2.height, e2.y)]);
              }
              return { type: "Polygon", coordinates: [d2] };
            }
          }
          getProjectedBounds() {
            return v.compositeBounds(this.allBounds);
          }
          isInside(a3) {
            const { geoBoundsProjectedBox: b2, geoBoundsProjectedPolygon: c2 } = this;
            return !!(b2 && a3.x >= b2.x1 && a3.x <= b2.x2 && a3.y >= b2.y1 && a3.y <= b2.y2 && c2 && h(a3, c2));
          }
          render() {
            const { chart: a3, mapView: b2, options: c2 } = this;
            var d2 = c2.borderPath || c2.field;
            if (d2 && b2.group) {
              let e2 = true;
              this.border || (this.border = a3.renderer.path().addClass("highcharts-mapview-inset-border").add(b2.group), e2 = false);
              a3.styledMode || this.border.attr({ stroke: c2.borderColor, "stroke-width": c2.borderWidth });
              const f2 = Math.round(this.border.strokeWidth()) % 2 / 2, g2 = c2.relativeTo === "mapBoundingBox" && b2.getMapBBox() || b2.playingField;
              d2 = (d2.coordinates || []).reduce((b3, d3) => d3.reduce((b4, d4, e3) => {
                let [h3, r2] = d4;
                c2.units === "percent" && (h3 = a3.plotLeft + m(`${h3}%`, g2.width, g2.x), r2 = a3.plotTop + m(`${r2}%`, g2.height, g2.y));
                h3 = Math.floor(h3) + f2;
                r2 = Math.floor(r2) + f2;
                b4.push(e3 === 0 ? ["M", h3, r2] : ["L", h3, r2]);
                return b4;
              }, b3), []);
              this.border[e2 ? "animate" : "attr"]({ d: d2 });
            }
          }
          destroy() {
            this.border && (this.border = this.border.destroy());
            this.eventsToUnbind.forEach((a3) => a3());
          }
          setUpEvents() {
          }
        }
        F(z, "afterInit", function() {
          this.mapView = new v(this, this.options.mapView);
        });
        return v;
      });
      y(a, "Series/Map/MapSeries.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Series/ColorMapComposition.js"],
        a["Series/CenteredUtilities.js"],
        a["Core/Globals.js"],
        a["Core/Chart/MapChart.js"],
        a["Series/Map/MapPoint.js"],
        a["Maps/MapView.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Utilities.js"]
      ], function(a2, n3, q, z, k, l2, A, w, x, t, h) {
        const { animObject: g, stop: f } = a2;
        ({ noop: a2 } = z);
        const { splitPath: c } = k, { seriesTypes: { column: e, scatter: b } } = x, { extend: d, find: E, fireEvent: p, getNestedProperty: C, isArray: m, defined: r, isNumber: v, isObject: G, merge: u, objectEach: B, pick: D, splat: H } = h;
        class y2 extends b {
          constructor() {
            super(...arguments);
            this.points = this.options = this.joinBy = this.group = this.data = this.chart = void 0;
            this.processedData = [];
          }
          animate(a3) {
            const { chart: b2, group: c2 } = this, d2 = g(this.options.animation);
            a3 ? c2.attr({ translateX: b2.plotLeft + b2.plotWidth / 2, translateY: b2.plotTop + b2.plotHeight / 2, scaleX: 1e-3, scaleY: 1e-3 }) : c2.animate({ translateX: b2.plotLeft, translateY: b2.plotTop, scaleX: 1, scaleY: 1 }, d2);
          }
          clearBounds() {
            this.points.forEach((a3) => {
              delete a3.bounds;
              delete a3.insetIndex;
              delete a3.projectedPath;
            });
            delete this.bounds;
          }
          doFullTranslate() {
            return !(!this.isDirtyData && !this.chart.isResizing && this.hasRendered);
          }
          drawMapDataLabels() {
            w.prototype.drawDataLabels.call(this);
            this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
          }
          drawPoints() {
            const a3 = this, { chart: b2, group: c2, transformGroups: d2 = [] } = this, { mapView: h3, renderer: m2 } = b2;
            h3 && (this.transformGroups = d2, d2[0] || (d2[0] = m2.g().add(c2)), h3.insets.forEach((a4, b3) => {
              d2[b3 + 1] || d2.push(m2.g().add(c2));
            }), this.doFullTranslate() && (this.points.forEach((a4) => {
              const { graphic: c3, shapeArgs: e2 } = a4;
              a4.group = d2[typeof a4.insetIndex === "number" ? a4.insetIndex + 1 : 0];
              c3 && c3.parentGroup !== a4.group && c3.add(a4.group);
              e2 && b2.hasRendered && !b2.styledMode && (e2.fill = this.pointAttribs(a4, a4.state).fill);
            }), e.prototype.drawPoints.apply(this), this.points.forEach((c3) => {
              const d3 = c3.graphic;
              if (d3) {
                const e2 = d3.animate;
                let f2 = "";
                c3.name && (f2 += "highcharts-name-" + c3.name.replace(/ /g, "-").toLowerCase());
                c3.properties && c3.properties["hc-key"] && (f2 += " highcharts-key-" + c3.properties["hc-key"].toString().toLowerCase());
                f2 && d3.addClass(f2);
                b2.styledMode && d3.css(this.pointAttribs(c3, c3.selected && "select" || void 0));
                d3.animate = function(c4, f3, g2) {
                  const h4 = v(c4["stroke-width"]) && !v(d3["stroke-width"]), m3 = v(d3["stroke-width"]) && !v(c4["stroke-width"]);
                  if (h4 || m3) {
                    const e3 = D(a3.getStrokeWidth(a3.options), 1) / (b2.mapView && b2.mapView.getScale() || 1);
                    h4 && (d3["stroke-width"] = e3);
                    m3 && (c4["stroke-width"] = e3);
                  }
                  return e2.call(d3, c4, f3, m3 ? function() {
                    d3.element.removeAttribute("stroke-width");
                    delete d3["stroke-width"];
                    g2 && g2.apply(this, arguments);
                  } : g2);
                };
              }
            })), d2.forEach((c3, d3) => {
              const e2 = (d3 === 0 ? h3 : h3.insets[d3 - 1]).getSVGTransform(), r2 = D(this.getStrokeWidth(this.options), 1), p2 = e2.scaleX, v2 = 0 < e2.scaleY ? 1 : -1, k2 = (b3) => {
                (a3.points || []).forEach((a4) => {
                  const c4 = a4.graphic;
                  let d4;
                  c4 && c4["stroke-width"] && (d4 = this.getStrokeWidth(a4.options)) && c4.attr({ "stroke-width": d4 / b3 });
                });
              };
              if (m2.globalAnimation && b2.hasRendered && h3.allowTransformAnimation) {
                const a4 = Number(c3.attr("translateX")), b3 = Number(c3.attr("translateY")), f2 = Number(c3.attr("scaleX")), h4 = (d4, g2) => {
                  d4 = f2 + (p2 - f2) * g2.pos;
                  c3.attr({ translateX: a4 + (e2.translateX - a4) * g2.pos, translateY: b3 + (e2.translateY - b3) * g2.pos, scaleX: d4, scaleY: d4 * v2, "stroke-width": r2 / d4 });
                  k2(d4);
                };
                d3 = u(g(m2.globalAnimation));
                const l3 = d3.step;
                d3.step = function(a5) {
                  l3 && l3.apply(this, arguments);
                  h4.apply(this, arguments);
                };
                c3.attr({ animator: 0 }).animate({ animator: 1 }, d3, function() {
                  typeof m2.globalAnimation !== "boolean" && m2.globalAnimation.complete && m2.globalAnimation.complete({ applyDrilldown: true });
                });
              } else
                f(c3), c3.attr(u(e2, { "stroke-width": r2 / p2 })), k2(p2);
            }), this.isDrilling || this.drawMapDataLabels());
          }
          getProjectedBounds() {
            if (!this.bounds && this.chart.mapView) {
              const { insets: a3, projection: b2 } = this.chart.mapView, d2 = [];
              (this.points || []).forEach(function(e2) {
                if (e2.path || e2.geometry) {
                  typeof e2.path === "string" ? e2.path = c(e2.path) : m(e2.path) && e2.path[0] === "M" && (e2.path = t.prototype.pathToSegments(e2.path));
                  if (!e2.bounds) {
                    let c2 = e2.getProjectedBounds(b2);
                    if (c2) {
                      e2.labelrank = D(e2.labelrank, (c2.x2 - c2.x1) * (c2.y2 - c2.y1));
                      const { midX: b3, midY: d3 } = c2;
                      if (a3 && v(b3) && v(d3)) {
                        const f2 = E(a3, (a4) => a4.isInside({ x: b3, y: d3 }));
                        f2 && (delete e2.projectedPath, (c2 = e2.getProjectedBounds(f2.projection)) && f2.allBounds.push(c2), e2.insetIndex = a3.indexOf(f2));
                      }
                      e2.bounds = c2;
                    }
                  }
                  e2.bounds && e2.insetIndex === void 0 && d2.push(e2.bounds);
                }
              });
              this.bounds = A.compositeBounds(d2);
            }
            return this.bounds;
          }
          getStrokeWidth(a3) {
            const b2 = this.pointAttrToOptions;
            return a3[b2 && b2["stroke-width"] || "borderWidth"];
          }
          hasData() {
            return !!this.processedXData.length;
          }
          pointAttribs(a3, b2) {
            var c2;
            const { mapView: d2, styledMode: f2 } = a3.series.chart, g2 = f2 ? this.colorAttribs(a3) : e.prototype.pointAttribs.call(this, a3, b2);
            let h3 = this.getStrokeWidth(a3.options);
            if (b2) {
              b2 = u(this.options.states[b2], a3.options.states && a3.options.states[b2] || {});
              const d3 = this.getStrokeWidth(b2);
              r(d3) && (h3 = d3);
              g2.stroke = (c2 = b2.borderColor) !== null && c2 !== void 0 ? c2 : a3.color;
            }
            h3 && d2 && (h3 /= d2.getScale());
            c2 = this.getStrokeWidth(this.options);
            g2.dashstyle && d2 && v(c2) && (h3 = c2 / d2.getScale());
            a3.visible || (g2.fill = this.options.nullColor);
            r(h3) ? g2["stroke-width"] = h3 : delete g2["stroke-width"];
            g2["stroke-linecap"] = g2["stroke-linejoin"] = this.options.linecap;
            return g2;
          }
          updateData() {
            return this.processedData ? false : super.updateData.apply(this, arguments);
          }
          setData(a3, b2 = true, c2, d2) {
            delete this.bounds;
            super.setData.call(this, a3, false, void 0, d2);
            this.processData();
            this.generatePoints();
            b2 && this.chart.redraw(c2);
          }
          processData() {
            const a3 = this.options, b2 = a3.data;
            var c2 = this.chart.options.chart;
            const d2 = this.joinBy, e2 = a3.keys || this.pointArrayMap, f2 = [], g2 = {};
            var h3 = this.chart.mapView;
            h3 = h3 && (G(a3.mapData, true) ? h3.getGeoMap(a3.mapData) : h3.geoMap);
            var r2 = this.chart.mapTransforms;
            (this.chart.mapTransforms = r2 = c2.mapTransforms || h3 && h3["hc-transform"] || r2) && B(r2, function(a4) {
              a4.rotation && (a4.cosAngle = Math.cos(a4.rotation), a4.sinAngle = Math.sin(a4.rotation));
            });
            let p2;
            m(a3.mapData) ? p2 = a3.mapData : h3 && h3.type === "FeatureCollection" && (this.mapTitle = h3.title, p2 = z.geojson(h3, this.type, this));
            const k2 = this.processedData = [];
            b2 && b2.forEach(function(c3, f3) {
              let h4 = 0;
              if (v(c3))
                k2[f3] = { value: c3 };
              else if (m(c3)) {
                k2[f3] = {};
                !a3.keys && c3.length > e2.length && typeof c3[0] === "string" && (k2[f3]["hc-key"] = c3[0], ++h4);
                for (let a4 = 0; a4 < e2.length; ++a4, ++h4)
                  e2[a4] && typeof c3[h4] !== "undefined" && (0 < e2[a4].indexOf(".") ? l2.prototype.setNestedProperty(k2[f3], c3[h4], e2[a4]) : k2[f3][e2[a4]] = c3[h4]);
              } else
                k2[f3] = b2[f3];
              d2 && d2[0] === "_i" && (k2[f3]._i = f3);
            });
            if (p2) {
              this.mapData = p2;
              this.mapMap = {};
              for (r2 = 0; r2 < p2.length; r2++)
                c2 = p2[r2], h3 = c2.properties, c2._i = r2, d2[0] && h3 && h3[d2[0]] && (c2[d2[0]] = h3[d2[0]]), g2[c2[d2[0]]] = c2;
              this.mapMap = g2;
              if (d2[1]) {
                const a4 = d2[1];
                k2.forEach(function(b3) {
                  b3 = C(a4, b3);
                  g2[b3] && f2.push(g2[b3]);
                });
              }
              if (a3.allAreas) {
                if (d2[1]) {
                  const a5 = d2[1];
                  k2.forEach(function(b3) {
                    f2.push(C(a5, b3));
                  });
                }
                const a4 = "|" + f2.map(function(a5) {
                  return a5 && a5[d2[0]];
                }).join("|") + "|";
                p2.forEach(function(b3) {
                  d2[0] && a4.indexOf("|" + b3[d2[0]] + "|") !== -1 || k2.push(u(b3, { value: null }));
                });
              }
            }
            this.processedXData = Array(k2.length);
          }
          setOptions(a3) {
            a3 = w.prototype.setOptions.call(this, a3);
            let b2 = a3.joinBy;
            b2 === null && (b2 = "_i");
            b2 = this.joinBy = H(b2);
            b2[1] || (b2[1] = b2[0]);
            return a3;
          }
          translate() {
            const a3 = this.doFullTranslate(), b2 = this.chart.mapView, c2 = b2 && b2.projection;
            !this.chart.hasRendered || !this.isDirtyData && this.hasRendered || (this.processData(), this.generatePoints(), delete this.bounds, !b2 || b2.userOptions.center || v(b2.userOptions.zoom) || b2.zoom !== b2.minZoom ? this.getProjectedBounds() : b2.fitToBounds(void 0, void 0, false));
            if (b2) {
              const d2 = b2.getSVGTransform();
              this.points.forEach(function(e2) {
                const f2 = v(e2.insetIndex) && b2.insets[e2.insetIndex].getSVGTransform() || d2;
                f2 && e2.bounds && v(e2.bounds.midX) && v(e2.bounds.midY) && (e2.plotX = e2.bounds.midX * f2.scaleX + f2.translateX, e2.plotY = e2.bounds.midY * f2.scaleY + f2.translateY);
                a3 && (e2.shapeType = "path", e2.shapeArgs = { d: l2.getProjectedPath(e2, c2) });
                e2.projectedPath && !e2.projectedPath.length ? e2.setVisible(false) : e2.setVisible(true);
              });
            }
            p(this, "afterTranslate");
          }
        }
        y2.defaultOptions = u(b.defaultOptions, {
          affectsMapView: true,
          animation: false,
          dataLabels: { crop: false, formatter: function() {
            const { numberFormatter: a3 } = this.series.chart, { value: b2 } = this.point;
            return v(b2) ? a3(b2, -1) : "";
          }, inside: true, overflow: false, padding: 0, verticalAlign: "middle" },
          linecap: "round",
          marker: null,
          nullColor: "#f7f7f7",
          stickyTracking: false,
          tooltip: { followPointer: true, pointFormat: "{point.name}: {point.value}<br/>" },
          turboThreshold: 0,
          allAreas: true,
          borderColor: "#e6e6e6",
          borderWidth: 1,
          joinBy: "hc-key",
          states: { hover: { halo: void 0, borderColor: "#666666", borderWidth: 2 }, normal: { animation: true }, select: { color: "#cccccc" } },
          legendSymbol: "rectangle"
        });
        d(y2.prototype, {
          type: "map",
          axisTypes: n3.seriesMembers.axisTypes,
          colorAttribs: n3.seriesMembers.colorAttribs,
          colorKey: n3.seriesMembers.colorKey,
          directTouch: true,
          drawDataLabels: a2,
          drawGraph: a2,
          forceDL: true,
          getCenter: q.getCenter,
          getExtremesFromAll: true,
          getSymbol: a2,
          isCartesian: false,
          parallelArrays: n3.seriesMembers.parallelArrays,
          pointArrayMap: n3.seriesMembers.pointArrayMap,
          pointClass: l2,
          preserveAspectRatio: true,
          searchPoint: a2,
          trackerGroups: n3.seriesMembers.trackerGroups,
          useMapGeometry: true
        });
        n3.compose(y2);
        x.registerSeriesType("map", y2);
        "";
        return y2;
      });
      y(a, "Series/MapLine/MapLineSeries.js", [a["Series/Map/MapSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n3, q) {
        const { extend: g, merge: k } = q;
        class l2 extends a2 {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          pointAttribs(g2, k2) {
            g2 = a2.prototype.pointAttribs.call(this, g2, k2);
            g2.fill = this.options.fillColor;
            return g2;
          }
        }
        l2.defaultOptions = k(a2.defaultOptions, { lineWidth: 1, fillColor: "none", legendSymbol: "lineMarker" });
        g(l2.prototype, { type: "mapline", colorProp: "stroke", pointAttrToOptions: { stroke: "color", "stroke-width": "lineWidth" } });
        n3.registerSeriesType("mapline", l2);
        "";
        return l2;
      });
      y(a, "Series/MapPoint/MapPointPoint.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n3) {
        ({ seriesTypes: { scatter: a2 } } = a2);
        const { isNumber: g } = n3;
        class z extends a2.prototype.pointClass {
          constructor() {
            super(...arguments);
            this.series = this.options = void 0;
          }
          isValid() {
            return !!(this.options.geometry || g(this.x) && g(this.y) || g(this.options.lon) && g(this.options.lat));
          }
        }
        return z;
      });
      y(a, "Series/MapPoint/MapPointSeries.js", [a["Core/Globals.js"], a["Series/MapPoint/MapPointPoint.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function(a2, n3, q, z, k) {
        ({ noop: a2 } = a2);
        const { seriesTypes: { map: g, scatter: A } } = q, { extend: w, fireEvent: x, isNumber: t, merge: h } = k;
        class y2 extends A {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = this.chart = void 0;
            this.clearBounds = g.prototype.clearBounds;
          }
          drawDataLabels() {
            super.drawDataLabels();
            this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
          }
          projectPoint(a3) {
            const c = this.chart.mapView;
            if (c) {
              const { geometry: e, lon: b, lat: d } = a3;
              a3 = e && e.type === "Point" && e.coordinates;
              t(b) && t(d) && (a3 = [b, d]);
              if (a3)
                return c.lonLatToProjectedUnits({
                  lon: a3[0],
                  lat: a3[1]
                });
            }
          }
          translate() {
            const a3 = this.chart.mapView;
            this.processedXData || this.processData();
            this.generatePoints();
            this.getProjectedBounds && this.isDirtyData && (delete this.bounds, this.getProjectedBounds());
            if (a3) {
              const c = a3.getSVGTransform(), { hasCoordinates: e } = a3.projection;
              this.points.forEach((b) => {
                let { x: d, y: f } = b;
                var h3 = t(b.insetIndex) && a3.insets[b.insetIndex].getSVGTransform() || c;
                const g2 = this.projectPoint(b.options) || b.properties && this.projectPoint(b.properties);
                let m;
                g2 ? (d = g2.x, f = g2.y) : b.bounds && (d = b.bounds.midX, f = b.bounds.midY, h3 && t(d) && t(f) && (b.plotX = d * h3.scaleX + h3.translateX, b.plotY = f * h3.scaleY + h3.translateY, m = true));
                t(d) && t(f) ? m || (h3 = a3.projectedUnitsToPixels({ x: d, y: f }), b.plotX = h3.x, b.plotY = e ? h3.y : this.chart.plotHeight - h3.y) : b.y = b.plotX = b.plotY = void 0;
                b.isInside = this.isPointInside(b);
                b.zone = this.zones.length ? b.getZone() : void 0;
              });
            }
            x(this, "afterTranslate");
          }
        }
        y2.defaultOptions = h(A.defaultOptions, { dataLabels: { crop: false, defer: false, enabled: true, formatter: function() {
          return this.point.name;
        }, overflow: false, style: { color: "#000000" } }, legendSymbol: "lineMarker" });
        z.prototype.symbols.mapmarker = (a3, c, e, b, d) => {
          const f = d && d.context === "legend";
          f ? (a3 += e / 2, d = c + b) : d && typeof d.anchorX === "number" && typeof d.anchorY === "number" ? (a3 = d.anchorX, d = d.anchorY) : (a3 += e / 2, d = c + b / 2, c -= b);
          b = f ? b / 3 : b / 2;
          return [["M", a3, d], ["C", a3, d, a3 - b, c + 1.5 * b, a3 - b, c + b], ["A", b, b, 1, 1, 1, a3 + b, c + b], ["C", a3 + b, c + 1.5 * b, a3, d, a3, d], ["Z"]];
        };
        w(y2.prototype, { type: "mappoint", axisTypes: ["colorAxis"], forceDL: true, isCartesian: false, pointClass: n3, searchPoint: a2, useMapGeometry: true });
        q.registerSeriesType("mappoint", y2);
        "";
        return y2;
      });
      y(a, "Series/Bubble/BubbleLegendDefaults.js", [], function() {
        return { borderColor: void 0, borderWidth: 2, className: void 0, color: void 0, connectorClassName: void 0, connectorColor: void 0, connectorDistance: 60, connectorWidth: 1, enabled: false, labels: { className: void 0, allowOverlap: false, format: "", formatter: void 0, align: "right", style: { fontSize: "0.9em", color: "#000000" }, x: 0, y: 0 }, maxSize: 60, minSize: 10, legendIndex: 0, ranges: { value: void 0, borderColor: void 0, color: void 0, connectorColor: void 0 }, sizeBy: "area", sizeByAbsoluteValue: false, zIndex: 1, zThreshold: 0 };
      });
      y(a, "Series/Bubble/BubbleLegendItem.js", [a["Core/Color/Color.js"], a["Core/Templating.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, n3, q, z) {
        const { parse: g } = a2, { noop: l2 } = q, { arrayMax: A, arrayMin: w, isNumber: x, merge: t, pick: h, stableSort: y2 } = z;
        class f {
          constructor(a3, e) {
            this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legend = this.chart = void 0;
            this.setState = l2;
            this.init(a3, e);
          }
          init(a3, e) {
            this.options = a3;
            this.visible = true;
            this.chart = e.chart;
            this.legend = e;
          }
          addToLegend(a3) {
            a3.splice(this.options.legendIndex, 0, this);
          }
          drawLegendSymbol(a3) {
            const c = h(a3.options.itemDistance, 20), b = this.legendItem || {}, d = this.options;
            var f2 = d.ranges, g2 = d.connectorDistance;
            if (f2 && f2.length && x(f2[0].value)) {
              y2(f2, function(a4, b2) {
                return b2.value - a4.value;
              });
              this.ranges = f2;
              this.setOptions();
              this.render();
              a3 = this.getMaxLabelSize();
              var k = this.ranges[0].radius;
              f2 = 2 * k;
              g2 = g2 - k + a3.width;
              g2 = 0 < g2 ? g2 : 0;
              this.maxLabel = a3;
              this.movementX = d.labels.align === "left" ? g2 : 0;
              b.labelWidth = f2 + g2 + c;
              b.labelHeight = f2 + a3.height / 2;
            } else
              a3.options.bubbleLegend.autoRanges = true;
          }
          setOptions() {
            const a3 = this.ranges, e = this.options, b = this.chart.series[e.seriesIndex], d = this.legend.baseline, f2 = { zIndex: e.zIndex, "stroke-width": e.borderWidth }, k = { zIndex: e.zIndex, "stroke-width": e.connectorWidth }, l3 = { align: this.legend.options.rtl || e.labels.align === "left" ? "right" : "left", zIndex: e.zIndex }, m = b.options.marker.fillOpacity, r = this.chart.styledMode;
            a3.forEach(function(c, p) {
              r || (f2.stroke = h(c.borderColor, e.borderColor, b.color), f2.fill = h(c.color, e.color, m !== 1 ? g(b.color).setOpacity(m).get("rgba") : b.color), k.stroke = h(c.connectorColor, e.connectorColor, b.color));
              a3[p].radius = this.getRangeRadius(c.value);
              a3[p] = t(a3[p], { center: a3[0].radius - a3[p].radius + d });
              r || t(true, a3[p], { bubbleAttribs: t(f2), connectorAttribs: t(k), labelAttribs: l3 });
            }, this);
          }
          getRangeRadius(a3) {
            const c = this.options;
            return this.chart.series[this.options.seriesIndex].getRadius.call(this, c.ranges[c.ranges.length - 1].value, c.ranges[0].value, c.minSize, c.maxSize, a3);
          }
          render() {
            const a3 = this.legendItem || {}, e = this.chart.renderer, b = this.options.zThreshold;
            this.symbols || (this.symbols = {
              connectors: [],
              bubbleItems: [],
              labels: []
            });
            a3.symbol = e.g("bubble-legend");
            a3.label = e.g("bubble-legend-item").css(this.legend.itemStyle || {});
            a3.symbol.translateX = 0;
            a3.symbol.translateY = 0;
            a3.symbol.add(a3.label);
            a3.label.add(a3.group);
            for (const a4 of this.ranges)
              a4.value >= b && this.renderRange(a4);
            this.hideOverlappingLabels();
          }
          renderRange(a3) {
            var c = this.options;
            const b = c.labels;
            var d = this.chart;
            const f2 = d.series[c.seriesIndex], h3 = d.renderer, g2 = this.symbols;
            d = g2.labels;
            const m = a3.center, r = Math.abs(a3.radius);
            var k = c.connectorDistance || 0;
            const l3 = b.align, n4 = c.connectorWidth, w2 = this.ranges[0].radius || 0, t2 = m - r - c.borderWidth / 2 + n4 / 2, q2 = h3.styledMode;
            k = this.legend.options.rtl || l3 === "left" ? -k : k;
            l3 === "center" && (k = 0, c.connectorDistance = 0, a3.labelAttribs.align = "center");
            g2.bubbleItems.push(h3.circle(w2, m + ((t2 % 1 ? 1 : 0.5) - (n4 % 2 ? 0 : 0.5)), r).attr(q2 ? {} : a3.bubbleAttribs).addClass((q2 ? "highcharts-color-" + f2.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (c.className || "")).add(this.legendItem.symbol));
            g2.connectors.push(h3.path(h3.crispLine([["M", w2, t2], ["L", w2 + k, t2]], c.connectorWidth)).attr(q2 ? {} : a3.connectorAttribs).addClass((q2 ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (c.connectorClassName || "")).add(this.legendItem.symbol));
            a3 = h3.text(this.formatLabel(a3)).attr(q2 ? {} : a3.labelAttribs).css(q2 ? {} : b.style).addClass("highcharts-bubble-legend-labels " + (c.labels.className || "")).add(this.legendItem.symbol);
            c = { x: w2 + k + c.labels.x, y: t2 + c.labels.y + 0.4 * a3.getBBox().height };
            a3.attr(c);
            d.push(a3);
            a3.placed = true;
            a3.alignAttr = c;
          }
          getMaxLabelSize() {
            let a3, e;
            this.symbols.labels.forEach(function(b) {
              e = b.getBBox(true);
              a3 = a3 ? e.width > a3.width ? e : a3 : e;
            });
            return a3 || {};
          }
          formatLabel(a3) {
            var c = this.options;
            const b = c.labels.formatter;
            c = c.labels.format;
            const { numberFormatter: d } = this.chart;
            return c ? n3.format(c, a3) : b ? b.call(a3) : d(a3.value, 1);
          }
          hideOverlappingLabels() {
            const a3 = this.chart, e = this.symbols;
            !this.options.labels.allowOverlap && e && (a3.hideOverlappingLabels(e.labels), e.labels.forEach(function(a4, d) {
              a4.newOpacity ? a4.newOpacity !== a4.oldOpacity && e.connectors[d].show() : e.connectors[d].hide();
            }));
          }
          getRanges() {
            const a3 = this.legend.bubbleLegend, e = a3.options.ranges;
            let b, d, f2 = Number.MAX_VALUE, g2 = -Number.MAX_VALUE;
            a3.chart.series.forEach(function(a4) {
              a4.isBubble && !a4.ignoreSeries && (d = a4.zData.filter(x), d.length && (f2 = h(a4.options.zMin, Math.min(f2, Math.max(w(d), a4.options.displayNegative === false ? a4.options.zThreshold : -Number.MAX_VALUE))), g2 = h(a4.options.zMax, Math.max(g2, A(d)))));
            });
            b = f2 === g2 ? [{ value: g2 }] : [{ value: f2 }, { value: (f2 + g2) / 2 }, { value: g2, autoRanges: true }];
            e.length && e[0].radius && b.reverse();
            b.forEach(function(a4, d2) {
              e && e[d2] && (b[d2] = t(e[d2], a4));
            });
            return b;
          }
          predictBubbleSizes() {
            var a3 = this.chart, e = a3.legend.options, b = e.floating;
            const d = (e = e.layout === "horizontal") ? a3.legend.lastLineHeight : 0, f2 = a3.plotSizeX, g2 = a3.plotSizeY;
            var h3 = a3.series[this.options.seriesIndex], m = h3.getPxExtremes();
            a3 = Math.ceil(m.minPxSize);
            m = Math.ceil(m.maxPxSize);
            const r = Math.min(g2, f2);
            h3 = h3.options.maxSize;
            if (b || !/%$/.test(h3))
              b = m;
            else if (h3 = parseFloat(h3), b = (r + d) * h3 / 100 / (h3 / 100 + 1), e && g2 - b >= f2 || !e && f2 - b >= g2)
              b = m;
            return [a3, Math.ceil(b)];
          }
          updateRanges(a3, e) {
            const b = this.legend.options.bubbleLegend;
            b.minSize = a3;
            b.maxSize = e;
            b.ranges = this.getRanges();
          }
          correctSizes() {
            const a3 = this.legend, e = this.chart.series[this.options.seriesIndex].getPxExtremes();
            1 < Math.abs(Math.ceil(e.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, e.maxPxSize), a3.render());
          }
        }
        "";
        return f;
      });
      y(a, "Series/Bubble/BubbleLegendComposition.js", [a["Series/Bubble/BubbleLegendDefaults.js"], a["Series/Bubble/BubbleLegendItem.js"], a["Core/Defaults.js"], a["Core/Utilities.js"]], function(a2, n3, q, z) {
        function g(a3, d, c2) {
          const b = this.legend;
          var e2 = 0 <= l2(this);
          let h3, g2;
          b && b.options.enabled && b.bubbleLegend && b.options.bubbleLegend.autoRanges && e2 ? (h3 = b.bubbleLegend.options, e2 = b.bubbleLegend.predictBubbleSizes(), b.bubbleLegend.updateRanges(e2[0], e2[1]), h3.placed || (b.group.placed = false, b.allItems.forEach((a4) => {
            g2 = a4.legendItem || {};
            g2.group && (g2.group.translateY = null);
          })), b.render(), this.getMargins(), this.axes.forEach(function(a4) {
            a4.visible && a4.render();
            h3.placed || (a4.setScale(), a4.updateNames(), f(a4.ticks, function(a5) {
              a5.isNew = true;
              a5.isNewLabel = true;
            }));
          }), h3.placed = true, this.getMargins(), a3.call(this, d, c2), b.bubbleLegend.correctSizes(), t(b, A(b))) : (a3.call(this, d, c2), b && b.options.enabled && b.bubbleLegend && (b.render(), t(b, A(b))));
        }
        function l2(a3) {
          a3 = a3.series;
          let b = 0;
          for (; b < a3.length; ) {
            if (a3[b] && a3[b].isBubble && a3[b].visible && a3[b].zData.length)
              return b;
            b++;
          }
          return -1;
        }
        function A(a3) {
          a3 = a3.allItems;
          const b = [], c2 = a3.length;
          let e2, f2, h3 = 0;
          for (f2 = 0; f2 < c2; f2++) {
            var g2 = a3[f2].legendItem || {};
            e2 = (a3[f2 + 1] || {}).legendItem || {};
            g2.labelHeight && (a3[f2].itemHeight = g2.labelHeight);
            if (a3[f2] === a3[c2 - 1] || g2.y !== e2.y) {
              b.push({ height: 0 });
              g2 = b[b.length - 1];
              for (h3; h3 <= f2; h3++)
                a3[h3].itemHeight > g2.height && (g2.height = a3[h3].itemHeight);
              g2.step = f2;
            }
          }
          return b;
        }
        function w(a3) {
          const b = this.bubbleLegend, c2 = this.options, e2 = c2.bubbleLegend, f2 = l2(this.chart);
          b && b.ranges && b.ranges.length && (e2.ranges.length && (e2.autoRanges = !!e2.ranges[0].autoRanges), this.destroyItem(b));
          0 <= f2 && c2.enabled && e2.enabled && (e2.seriesIndex = f2, this.bubbleLegend = new n3(e2, this), this.bubbleLegend.addToLegend(a3.allItems));
        }
        function x(a3) {
          if (a3.defaultPrevented)
            return false;
          var b = this.chart;
          a3 = this.visible;
          const c2 = this.chart.legend;
          c2 && c2.bubbleLegend && (this.visible = !a3, this.ignoreSeries = a3, b = 0 <= l2(b), c2.bubbleLegend.visible !== b && (c2.update({ bubbleLegend: { enabled: b } }), c2.bubbleLegend.visible = b), this.visible = a3);
        }
        function t(a3, c2) {
          const b = a3.options.rtl;
          let d, e2, f2, h3, g2 = 0;
          a3.allItems.forEach((a4, m) => {
            h3 = a4.legendItem || {};
            if (h3.group) {
              d = h3.group.translateX || 0;
              e2 = h3.y || 0;
              if ((f2 = a4.movementX) || b && a4.ranges)
                f2 = b ? d - a4.options.maxSize / 2 : d + f2, h3.group.attr({ translateX: f2 });
              m > c2[g2].step && g2++;
              h3.group.attr({ translateY: Math.round(e2 + c2[g2].height / 2) });
              h3.y = e2 + c2[g2].height / 2;
            }
          });
        }
        const { setOptions: h } = q, { addEvent: y2, objectEach: f, wrap: c } = z, e = [];
        return { compose: function(b, d, f2) {
          z.pushUnique(e, b) && (h({ legend: { bubbleLegend: a2 } }), c(b.prototype, "drawChartBox", g));
          z.pushUnique(e, d) && y2(d, "afterGetAllItems", w);
          z.pushUnique(e, f2) && y2(f2, "legendItemClick", x);
        } };
      });
      y(a, "Series/Bubble/BubblePoint.js", [a["Core/Series/Point.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n3, q) {
        ({ seriesTypes: { scatter: { prototype: { pointClass: n3 } } } } = n3);
        ({ extend: q } = q);
        class g extends n3 {
          constructor() {
            super(...arguments);
            this.series = this.options = void 0;
          }
          haloPath(g2) {
            return a2.prototype.haloPath.call(this, g2 === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + g2);
          }
        }
        q(g.prototype, { ttBelow: false });
        return g;
      });
      y(a, "Series/Bubble/BubbleSeries.js", [a["Series/Bubble/BubbleLegendComposition.js"], a["Series/Bubble/BubblePoint.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n3, q, z, k, l2) {
        function g() {
          const a3 = this.len, b2 = this.chart, c2 = this.isXAxis, e2 = c2 ? "xData" : "yData", f2 = this.min, h3 = this.max - f2;
          let g2 = 0, m2 = a3, k2 = a3 / h3, l3;
          this.series.forEach((a4) => {
            if (a4.bubblePadding && (a4.visible || !b2.options.chart.ignoreHiddenSeries)) {
              l3 = this.allowZoomOutside = true;
              const b3 = a4[e2];
              c2 && ((a4.onPoint || a4).getRadii(0, 0, a4), a4.onPoint && (a4.radii = a4.onPoint.radii));
              if (0 < h3) {
                let c3 = b3.length;
                for (; c3--; )
                  if (d(b3[c3]) && this.dataMin <= b3[c3] && b3[c3] <= this.max) {
                    const d2 = a4.radii && a4.radii[c3] || 0;
                    g2 = Math.min((b3[c3] - f2) * k2 - d2, g2);
                    m2 = Math.max((b3[c3] - f2) * k2 + d2, m2);
                  }
              }
            }
          });
          l3 && 0 < h3 && !this.logarithmic && (m2 -= a3, k2 *= (a3 + Math.max(0, g2) - Math.min(m2, a3)) / a3, [
            ["min", "userMin", g2],
            ["max", "userMax", m2]
          ].forEach((a4) => {
            typeof p(this.options[a4[0]], this[a4[1]]) === "undefined" && (this[a4[0]] += a4[2] / k2);
          }));
        }
        const { parse: w } = q;
        ({ noop: q } = z);
        const { series: x, seriesTypes: { column: { prototype: t }, scatter: h } } = k, { addEvent: y2, arrayMax: f, arrayMin: c, clamp: e, extend: b, isNumber: d, merge: E, pick: p } = l2, C = [];
        class m extends h {
          constructor() {
            super(...arguments);
            this.zData = this.yData = this.radii = this.points = this.options = this.minPxSize = this.maxPxSize = this.data = void 0;
          }
          static compose(b2, c2, d2, e2) {
            a2.compose(c2, d2, e2);
            l2.pushUnique(C, b2) && (b2.prototype.beforePadding = g);
          }
          animate(a3) {
            !a3 && this.points.length < this.options.animationLimit && this.points.forEach(function(a4) {
              const { graphic: b2 } = a4;
              b2 && b2.width && (this.hasRendered || b2.attr({ x: a4.plotX, y: a4.plotY, width: 1, height: 1 }), b2.animate(this.markerAttribs(a4), this.options.animation));
            }, this);
          }
          getRadii() {
            const a3 = this.zData, b2 = this.yData, c2 = [];
            let d2, e2, f2, h3 = this.chart.bubbleZExtremes;
            const { minPxSize: g2, maxPxSize: m2 } = this.getPxExtremes();
            if (!h3) {
              let a4 = Number.MAX_VALUE, b3 = -Number.MAX_VALUE, c3;
              this.chart.series.forEach((d3) => {
                d3.bubblePadding && (d3.visible || !this.chart.options.chart.ignoreHiddenSeries) && (d3 = (d3.onPoint || d3).getZExtremes()) && (a4 = Math.min(p(a4, d3.zMin), d3.zMin), b3 = Math.max(p(b3, d3.zMax), d3.zMax), c3 = true);
              });
              c3 ? (h3 = { zMin: a4, zMax: b3 }, this.chart.bubbleZExtremes = h3) : h3 = { zMin: 0, zMax: 0 };
            }
            e2 = 0;
            for (d2 = a3.length; e2 < d2; e2++)
              f2 = a3[e2], c2.push(this.getRadius(h3.zMin, h3.zMax, g2, m2, f2, b2 && b2[e2]));
            this.radii = c2;
          }
          getRadius(a3, b2, c2, e2, f2, h3) {
            const g2 = this.options, m2 = g2.sizeBy !== "width", k2 = g2.zThreshold;
            let l3 = b2 - a3, r = 0.5;
            if (h3 === null || f2 === null)
              return null;
            if (d(f2)) {
              g2.sizeByAbsoluteValue && (f2 = Math.abs(f2 - k2), l3 = Math.max(b2 - k2, Math.abs(a3 - k2)), a3 = 0);
              if (f2 < a3)
                return c2 / 2 - 1;
              0 < l3 && (r = (f2 - a3) / l3);
            }
            m2 && 0 <= r && (r = Math.sqrt(r));
            return Math.ceil(c2 + r * (e2 - c2)) / 2;
          }
          hasData() {
            return !!this.processedXData.length;
          }
          pointAttribs(a3, b2) {
            const c2 = this.options.marker.fillOpacity;
            a3 = x.prototype.pointAttribs.call(this, a3, b2);
            c2 !== 1 && (a3.fill = w(a3.fill).setOpacity(c2).get("rgba"));
            return a3;
          }
          translate() {
            super.translate.call(this);
            this.getRadii();
            this.translateBubble();
          }
          translateBubble() {
            const { data: a3, options: c2, radii: e2 } = this, { minPxSize: f2 } = this.getPxExtremes();
            let h3 = a3.length;
            for (; h3--; ) {
              const g2 = a3[h3], m2 = e2 ? e2[h3] : 0;
              this.zoneAxis === "z" && (g2.negative = (g2.z || 0) < (c2.zThreshold || 0));
              d(m2) && m2 >= f2 / 2 ? (g2.marker = b(g2.marker, { radius: m2, width: 2 * m2, height: 2 * m2 }), g2.dlBox = { x: g2.plotX - m2, y: g2.plotY - m2, width: 2 * m2, height: 2 * m2 }) : (g2.shapeArgs = g2.plotY = g2.dlBox = void 0, g2.isInside = false);
            }
          }
          getPxExtremes() {
            const a3 = Math.min(this.chart.plotWidth, this.chart.plotHeight);
            var b2 = (b3) => {
              let c3;
              typeof b3 === "string" && (c3 = /%$/.test(b3), b3 = parseInt(b3, 10));
              return c3 ? a3 * b3 / 100 : b3;
            };
            const c2 = b2(p(this.options.minSize, 8));
            b2 = Math.max(b2(p(this.options.maxSize, "20%")), c2);
            return { minPxSize: c2, maxPxSize: b2 };
          }
          getZExtremes() {
            var a3 = this.options;
            const b2 = (this.zData || []).filter(d);
            if (b2.length) {
              const g2 = p(a3.zMin, e(c(b2), a3.displayNegative === false ? a3.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));
              a3 = p(a3.zMax, f(b2));
              if (d(g2) && d(a3))
                return { zMin: g2, zMax: a3 };
            }
          }
        }
        m.defaultOptions = E(h.defaultOptions, { dataLabels: { formatter: function() {
          const { numberFormatter: a3 } = this.series.chart, { z: b2 } = this.point;
          return d(b2) ? a3(b2, -1) : "";
        }, inside: true, verticalAlign: "middle" }, animationLimit: 250, marker: {
          lineColor: null,
          lineWidth: 1,
          fillOpacity: 0.5,
          radius: null,
          states: { hover: { radiusPlus: 0 } },
          symbol: "circle"
        }, minSize: 8, maxSize: "20%", softThreshold: false, states: { hover: { halo: { size: 5 } } }, tooltip: { pointFormat: "({point.x}, {point.y}), Size: {point.z}" }, turboThreshold: 0, zThreshold: 0, zoneAxis: "z" });
        b(m.prototype, {
          alignDataLabel: t.alignDataLabel,
          applyZones: q,
          bubblePadding: true,
          buildKDTree: q,
          directTouch: true,
          isBubble: true,
          pointArrayMap: ["y", "z"],
          pointClass: n3,
          parallelArrays: ["x", "y", "z"],
          trackerGroups: ["group", "dataLabelsGroup"],
          specialGroup: "group",
          zoneAxis: "z"
        });
        y2(m, "updatedData", (a3) => {
          delete a3.target.chart.bubbleZExtremes;
        });
        y2(m, "remove", (a3) => {
          delete a3.target.chart.bubbleZExtremes;
        });
        k.registerSeriesType("bubble", m);
        "";
        "";
        return m;
      });
      y(a, "Series/MapBubble/MapBubblePoint.js", [a["Series/Bubble/BubblePoint.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n3, q) {
        ({ seriesTypes: { map: { prototype: { pointClass: { prototype: n3 } } } } } = n3);
        ({ extend: q } = q);
        class g extends a2 {
          isValid() {
            return typeof this.z === "number";
          }
        }
        q(g.prototype, {
          applyOptions: n3.applyOptions,
          getProjectedBounds: n3.getProjectedBounds
        });
        return g;
      });
      y(a, "Series/MapBubble/MapBubbleSeries.js", [a["Series/Bubble/BubbleSeries.js"], a["Series/MapBubble/MapBubblePoint.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n3, q, y2) {
        const { seriesTypes: { map: { prototype: g }, mappoint: { prototype: l2 } } } = q, { extend: z, merge: w } = y2;
        class x extends a2 {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
            this.clearBounds = g.clearBounds;
          }
          searchPoint(a3, g2) {
            return this.searchKDTree({ clientX: a3.chartX - this.chart.plotLeft, plotY: a3.chartY - this.chart.plotTop }, g2, a3);
          }
          translate() {
            l2.translate.call(this);
            this.getRadii();
            this.translateBubble();
          }
          updateParallelArrays(a3, g2, k) {
            super.updateParallelArrays.call(this, a3, g2, k);
            a3 = this.processedXData;
            g2 = this.xData;
            a3 && g2 && (a3.length = g2.length);
          }
        }
        x.defaultOptions = w(a2.defaultOptions, { lineWidth: 0, animationLimit: 500, joinBy: "hc-key", tooltip: { pointFormat: "{point.name}: {point.z}" } });
        z(x.prototype, {
          type: "mapbubble",
          axisTypes: ["colorAxis"],
          getProjectedBounds: g.getProjectedBounds,
          isCartesian: false,
          pointArrayMap: ["z"],
          pointClass: n3,
          processData: g.processData,
          projectPoint: l2.projectPoint,
          setData: g.setData,
          setOptions: g.setOptions,
          updateData: g.updateData,
          useMapGeometry: true,
          xyFromShape: true
        });
        q.registerSeriesType("mapbubble", x);
        "";
        return x;
      });
      y(a, "Series/Heatmap/HeatmapPoint.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n3) {
        ({ seriesTypes: { scatter: { prototype: { pointClass: a2 } } } } = a2);
        const { clamp: g, defined: y2, extend: k, pick: l2 } = n3;
        class A extends a2 {
          constructor() {
            super(...arguments);
            this.y = this.x = this.value = this.series = this.options = void 0;
          }
          applyOptions(a3, g2) {
            (this.isNull || this.value === null) && delete this.color;
            super.applyOptions(a3, g2);
            this.formatPrefix = this.isNull || this.value === null ? "null" : "point";
            return this;
          }
          getCellAttributes() {
            var a3 = this.series;
            const k2 = a3.options, n4 = (k2.colsize || 1) / 2, h = (k2.rowsize || 1) / 2, q = a3.xAxis, f = a3.yAxis, c = this.options.marker || a3.options.marker;
            a3 = a3.pointPlacementToXValue();
            const e = l2(this.pointPadding, k2.pointPadding, 0), b = { x1: g(Math.round(q.len - q.translate(this.x - n4, false, true, false, true, -a3)), -q.len, 2 * q.len), x2: g(Math.round(q.len - q.translate(this.x + n4, false, true, false, true, -a3)), -q.len, 2 * q.len), y1: g(Math.round(f.translate(this.y - h, false, true, false, true)), -f.len, 2 * f.len), y2: g(Math.round(f.translate(this.y + h, false, true, false, true)), -f.len, 2 * f.len) };
            [["width", "x"], ["height", "y"]].forEach(function(a4) {
              var d = a4[0];
              a4 = a4[1];
              let g2 = a4 + "1", h3 = a4 + "2";
              const m = Math.abs(b[g2] - b[h3]), k3 = c && c.lineWidth || 0, l3 = Math.abs(b[g2] + b[h3]) / 2;
              d = c && c[d];
              y2(d) && d < m && (d = d / 2 + k3 / 2, b[g2] = l3 - d, b[h3] = l3 + d);
              if (e) {
                if (a4 === "x" && q.reversed || a4 === "y" && !f.reversed)
                  g2 = h3, h3 = a4 + "1";
                b[g2] += e;
                b[h3] -= e;
              }
            });
            return b;
          }
          haloPath(a3) {
            if (!a3)
              return [];
            const { x: g2 = 0, y: k2 = 0, width: h = 0, height: l3 = 0 } = this.shapeArgs || {};
            return [["M", g2 - a3, k2 - a3], ["L", g2 - a3, k2 + l3 + a3], ["L", g2 + h + a3, k2 + l3 + a3], ["L", g2 + h + a3, k2 - a3], ["Z"]];
          }
          isValid() {
            return this.value !== Infinity && this.value !== -Infinity;
          }
        }
        k(A.prototype, { dataLabelOnNull: true, moveToTopOnHover: true, ttBelow: false });
        return A;
      });
      y(a, "Series/Heatmap/HeatmapSeries.js", [
        a["Core/Color/Color.js"],
        a["Series/ColorMapComposition.js"],
        a["Core/Globals.js"],
        a["Series/Heatmap/HeatmapPoint.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Utilities.js"]
      ], function(a2, n3, q, y2, k, l2, A) {
        const { doc: g } = q, { series: x, seriesTypes: { column: t, scatter: h } } = k, { prototype: { symbols: z } } = l2, { clamp: f, extend: c, fireEvent: e, isNumber: b, merge: d, pick: E, defined: p } = A;
        class C extends h {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = this.context = this.colorAxis = this.canvas = void 0;
            this.valueMin = this.valueMax = NaN;
          }
          drawPoints() {
            const a3 = this;
            var b2 = a3.options, c2 = b2.marker || {};
            if (b2.interpolation) {
              const { image: h3, chart: k2, xAxis: m, yAxis: l3, points: n4 } = a3;
              c2 = n4.length - 1;
              const { len: r, reversed: v } = m, { len: q2, reversed: u } = l3, { min: t2, max: w } = m.getExtremes(), { min: x2, max: y3 } = l3.getExtremes(), [z2, A2] = [E(b2.colsize, 1), E(b2.rowsize, 1)];
              var d2 = k2.inverted, e2 = z2 / 2;
              b2 = m.userOptions.minPadding;
              var g2 = p(b2) && !(0 < b2);
              b2 = d2 || g2;
              e2 = g2 && e2 || 0;
              const [B, G, C2] = [t2 - e2, w + 2 * e2, t2 + z2].map((b3) => f(Math.round(m.len - m.translate(b3, false, true, false, true, -a3.pointPlacementToXValue())), -m.len, 2 * m.len)), [F, I] = v ? [G, B] : [B, G];
              e2 = r / C2 / 2 / 2 / 2;
              d2 = d2 ? {
                width: r,
                height: q2,
                x: 0,
                y: 0
              } : { x: F - e2, width: I - e2, height: q2, y: 0 };
              if (!h3 || a3.isDirtyData) {
                const f2 = k2.colorAxis && k2.colorAxis[0];
                e2 = a3.getContext();
                if ((g2 = a3.canvas) && e2 && f2) {
                  const m2 = g2.width = ~~((w - t2) / z2) + 1, l4 = g2.height = ~~((y3 - x2) / A2) + 1, r2 = m2 * l4, p2 = new Uint8ClampedArray(4 * r2), q3 = m2 - (b2 && 1 || 0), D = l4 - 1;
                  b2 = (a4) => {
                    a4 = f2.toColor(a4.value || 0, E(a4)).split(")")[0].split("(")[1].split(",").map((a5) => E(parseFloat(a5), parseInt(a5, 10)));
                    a4[3] = 255 * E(a4[3], 1);
                    return a4;
                  };
                  const B2 = v ? (a4) => q3 - a4 : (a4) => a4, G2 = u ? (a4) => D - a4 : (a4) => a4, C3 = (a4, b3) => Math.ceil(m2 * G2(~~((D - 0) / (y3 - x2) * (y3 - b3 - x2))) + B2(~~((q3 - 0) / (w - t2) * (a4 - t2))));
                  a3.buildKDTree();
                  a3.directTouch = false;
                  for (let a4 = 0; a4 < r2; a4++) {
                    const d3 = n4[~~((c2 - 0) / (p2.length - 4) * a4 * 4)], e3 = new Uint8ClampedArray(b2(d3));
                    p2.set(e3, 4 * C3(d3.x, d3.y));
                  }
                  e2.putImageData(new ImageData(p2, m2, l4), 0, 0);
                  h3 ? h3.attr(Object.assign(Object.assign({}, d2), { href: g2.toDataURL() })) : a3.image = k2.renderer.image(g2.toDataURL()).attr(d2).add(a3.group);
                }
              } else
                h3.width === d2.width && h3.height === d2.height || h3.attr(d2);
            } else if (c2.enabled || a3._hasPointMarkers)
              x.prototype.drawPoints.call(a3), a3.points.forEach((b3) => {
                b3.graphic && (b3.graphic[a3.chart.styledMode ? "css" : "animate"](a3.colorAttribs(b3)), b3.value === null && b3.graphic.addClass("highcharts-null-point"));
              });
          }
          getContext() {
            const { canvas: a3, context: b2 } = this;
            if (a3 && b2)
              b2.clearRect(0, 0, a3.width, a3.height);
            else
              return this.canvas = g.createElement("canvas"), this.context = this.canvas.getContext("2d") || void 0;
            return b2;
          }
          getExtremes() {
            const { dataMin: a3, dataMax: c2 } = x.prototype.getExtremes.call(this, this.valueData);
            b(a3) && (this.valueMin = a3);
            b(c2) && (this.valueMax = c2);
            return x.prototype.getExtremes.call(this);
          }
          getValidPoints(a3, b2) {
            return x.prototype.getValidPoints.call(this, a3, b2, true);
          }
          hasData() {
            return !!this.processedXData.length;
          }
          init() {
            super.init.apply(this, arguments);
            const a3 = this.options;
            a3.pointRange = E(a3.pointRange, a3.colsize || 1);
            this.yAxis.axisPointRange = a3.rowsize || 1;
            z.ellipse = z.circle;
            a3.marker && b(a3.borderRadius) && (a3.marker.r = a3.borderRadius);
          }
          markerAttribs(a3, b2) {
            const c2 = a3.shapeArgs || {};
            if (a3.hasImage)
              return { x: a3.plotX, y: a3.plotY };
            if (b2 && b2 !== "normal") {
              var d2 = a3.options.marker || {};
              a3 = this.options.marker || {};
              a3 = a3.states && a3.states[b2] || {};
              d2 = d2.states && d2.states[b2] || {};
              b2 = (d2.width || a3.width || c2.width || 0) + (d2.widthPlus || a3.widthPlus || 0);
              a3 = (d2.height || a3.height || c2.height || 0) + (d2.heightPlus || a3.heightPlus || 0);
              return { x: (c2.x || 0) + ((c2.width || 0) - b2) / 2, y: (c2.y || 0) + ((c2.height || 0) - a3) / 2, width: b2, height: a3 };
            }
            return c2;
          }
          pointAttribs(b2, c2) {
            const e2 = x.prototype.pointAttribs.call(this, b2, c2), f2 = this.options || {};
            var g2 = this.chart.options.plotOptions || {}, h3 = g2.series || {};
            const k2 = g2.heatmap || {};
            g2 = b2 && b2.options.borderColor || f2.borderColor || k2.borderColor || h3.borderColor;
            h3 = b2 && b2.options.borderWidth || f2.borderWidth || k2.borderWidth || h3.borderWidth || e2["stroke-width"];
            e2.stroke = b2 && b2.marker && b2.marker.lineColor || f2.marker && f2.marker.lineColor || g2 || this.color;
            e2["stroke-width"] = h3;
            c2 && c2 !== "normal" && (b2 = d(f2.states && f2.states[c2], f2.marker && f2.marker.states && f2.marker.states[c2], b2 && b2.options.states && b2.options.states[c2] || {}), e2.fill = b2.color || a2.parse(e2.fill).brighten(b2.brightness || 0).get(), e2.stroke = b2.lineColor || e2.stroke);
            return e2;
          }
          translate() {
            const { borderRadius: a3, marker: c2 } = this.options, f2 = c2 && c2.symbol || "rect", g2 = z[f2] ? f2 : "rect", h3 = ["circle", "square"].indexOf(g2) !== -1;
            this.generatePoints();
            this.points.forEach(function(c3) {
              const e2 = c3.getCellAttributes();
              let k2 = Math.min(e2.x1, e2.x2);
              var l3 = Math.min(e2.y1, e2.y2);
              let m = Math.max(Math.abs(e2.x2 - e2.x1), 0), n4 = Math.max(Math.abs(e2.y2 - e2.y1), 0);
              c3.hasImage = (c3.marker && c3.marker.symbol || f2 || "").indexOf("url") === 0;
              h3 && (l3 = Math.abs(m - n4), k2 = Math.min(e2.x1, e2.x2) + (m < n4 ? 0 : l3 / 2), l3 = Math.min(e2.y1, e2.y2) + (m < n4 ? l3 / 2 : 0), m = n4 = Math.min(m, n4));
              c3.hasImage && (c3.marker = { width: m, height: n4 });
              c3.plotX = c3.clientX = (e2.x1 + e2.x2) / 2;
              c3.plotY = (e2.y1 + e2.y2) / 2;
              c3.shapeType = "path";
              c3.shapeArgs = d(true, {
                x: k2,
                y: l3,
                width: m,
                height: n4
              }, { d: z[g2](k2, l3, m, n4, { r: b(a3) ? a3 : 0 }) });
            });
            e(this, "afterTranslate");
          }
        }
        C.defaultOptions = d(h.defaultOptions, {
          animation: false,
          borderRadius: 0,
          borderWidth: 0,
          interpolation: false,
          nullColor: "#f7f7f7",
          dataLabels: { formatter: function() {
            const { numberFormatter: a3 } = this.series.chart, { value: c2 } = this.point;
            return b(c2) ? a3(c2, -1) : "";
          }, inside: true, verticalAlign: "middle", crop: false, overflow: "allow", padding: 0 },
          marker: { symbol: "rect", radius: 0, lineColor: void 0, states: { hover: { lineWidthPlus: 0 }, select: {} } },
          clip: true,
          pointRange: null,
          tooltip: { pointFormat: "{point.x}, {point.y}: {point.value}<br/>" },
          states: { hover: { halo: false, brightness: 0.2 } },
          legendSymbol: "rectangle"
        });
        c(C.prototype, { axisTypes: n3.seriesMembers.axisTypes, colorKey: n3.seriesMembers.colorKey, directTouch: true, getExtremesFromAll: true, parallelArrays: n3.seriesMembers.parallelArrays, pointArrayMap: ["y", "value"], pointClass: y2, specialGroup: "group", trackerGroups: n3.seriesMembers.trackerGroups, alignDataLabel: t.prototype.alignDataLabel, colorAttribs: n3.seriesMembers.colorAttribs, getSymbol: x.prototype.getSymbol });
        n3.compose(C);
        k.registerSeriesType("heatmap", C);
        "";
        "";
        return C;
      });
      y(a, "masters/modules/map.src.js", [a["Core/Globals.js"], a["Core/Axis/Color/ColorAxis.js"], a["Series/MapBubble/MapBubbleSeries.js"], a["Core/Chart/MapChart.js"], a["Maps/MapView.js"], a["Maps/Projection.js"]], function(a2, n3, q, y2, k, l2) {
        a2.ColorAxis = n3;
        a2.MapChart = y2;
        a2.mapChart = a2.Map = y2.mapChart;
        a2.MapView = k;
        a2.maps = y2.maps;
        a2.Projection = l2;
        n3.compose(a2.Chart, a2.Fx, a2.Legend, a2.Series);
        q.compose(a2.Axis, a2.Chart, a2.Legend, a2.Series);
      });
    });
  }
});

// js/luminous.js
__export(exports, {
  ChartJSHook: () => chartjs_hook_default,
  MapHook: () => map_hook_default,
  TableHook: () => table_hook_default,
  TimeRangeHook: () => time_range_hook_default
});

// node_modules/chart.js/dist/chunks/helpers.segment.mjs
function noop() {
}
var uid = function() {
  let id = 0;
  return function() {
    return id++;
  };
}();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
var isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i2, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i2 = len - 1; i2 >= 0; i2--) {
        fn.call(thisArg, loopable[i2], i2);
      }
    } else {
      for (i2 = 0; i2 < len; i2++) {
        fn.call(thisArg, loopable[i2], i2);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i2 = 0; i2 < len; i2++) {
      fn.call(thisArg, loopable[keys[i2]], keys[i2]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i2, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
    v0 = a0[i2];
    v1 = a1[i2];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone$1(source) {
  if (isArray(source)) {
    return source.map(clone$1);
  }
  if (isObject(source)) {
    const target = Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone$1(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone$1(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  for (let i2 = 0; i2 < ilen; ++i2) {
    source = sources[i2];
    if (!isObject(source)) {
      continue;
    }
    const keys = Object.keys(source);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, source, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, { merger: _mergerIf });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1(sval);
  }
}
var keyResolvers = {
  "": (v) => v,
  x: (o) => o.x,
  y: (o) => o.y
};
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function niceNum(range2) {
  const roundedRange = Math.round(range2);
  range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
  const niceRange = Math.pow(10, Math.floor(log10(range2)));
  const fraction = range2 / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i2;
  for (i2 = 1; i2 < sqrt; i2++) {
    if (value % i2 === 0) {
      result.push(i2);
      result.push(value / i2);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n3) {
  return !isNaN(parseFloat(n3)) && isFinite(n3);
}
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array2, target, property) {
  let i2, ilen, value;
  for (i2 = 0, ilen = array2.length; i2 < ilen; i2++) {
    value = array2[i2][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s2 = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s2 - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s2);
  const endToAngle = _normalizeAngle(a - e);
  return a === s2 || a === e || sameAngleIsFullCircle && s2 === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return { lo, hi };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => table[index2][key] <= value : (index2) => table[index2][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values2, min, max) {
  let start = 0;
  let end = values2.length;
  while (start < end && values2[start] < min) {
    start++;
  }
  while (end > start && values2[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values2.length ? values2.slice(start, end) : values2;
}
var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
function listenArrayEvents(array2, listener) {
  if (array2._chartjs) {
    array2._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array2, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array2[key];
    Object.defineProperty(array2, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array2._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array2, listener) {
  const stub = array2._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array2[key];
  });
  delete array2._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set();
  let i2, ilen;
  for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
    set2.add(items[i2]);
  }
  if (set2.size === ilen) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg, updateFn) {
  const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
  let ticking = false;
  let args = [];
  return function(...rest) {
    args = updateArgs(rest);
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return { start, count };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var atEdge = (t) => t === 0 || t === 1;
var elasticIn = (t, s2, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s2) * TAU / p));
var elasticOut = (t, s2, p) => Math.pow(2, -10 * t) * Math.sin((t - s2) * TAU / p) + 1;
var effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s2 = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s2, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s2, p);
  },
  easeInBack(t) {
    const s2 = 1.70158;
    return t * t * ((s2 + 1) * t - s2);
  },
  easeOutBack(t) {
    const s2 = 1.70158;
    return (t -= 1) * t * ((s2 + 1) * t + s2) + 1;
  },
  easeInOutBack(t) {
    let s2 = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s2 *= 1.525) + 1) * t - s2));
    }
    return 0.5 * ((t -= 2) * t * (((s2 *= 1.525) + 1) * t + s2) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l2, h) => Math.max(Math.min(v, h), l2);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s2, l2) {
  const a = s2 * Math.min(l2, 1 - l2);
  const f = (n3, k = (n3 + h / 30) % 12) => l2 - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s2, v) {
  const f = (n3, k = (n3 + h / 60) % 6) => v - v * s2 * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i2;
  if (w + b > 1) {
    i2 = 1 / (w + b);
    w *= i2;
    b *= i2;
  }
  for (i2 = 0; i2 < 3; i2++) {
    rgb[i2] *= 1 - w - b;
    rgb[i2] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range2 = 255;
  const r = v.r / range2;
  const g = v.g / range2;
  const b = v.b / range2;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l2 = (max + min) / 2;
  let h, s2, d;
  if (max !== min) {
    d = max - min;
    s2 = l2 > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s2 || 0, l2];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s2, l2) {
  return calln(hsl2rgbn, h, s2, l2);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s2, v) {
  return calln(hsv2rgbn, h, s2, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s2 = n2p(a[1]);
  const l2 = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s2}%, ${l2}%, ${b2n(v.a)})` : `hsl(${h}, ${s2}%, ${l2}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i2, j, k, ok, nk;
  for (i2 = 0; i2 < keys.length; i2++) {
    ok = nk = keys[i2];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i2, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i2] = Math.max(0, Math.min(tmp[i2] + tmp[i2] * ratio, i2 === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input2) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input2)) {
    if (input2.length >= 3) {
      v = { r: input2[0], g: input2[1], b: input2[2], a: 255 };
      if (input2.length > 3) {
        v.a = n2b(input2[3]);
      }
    }
  } else {
    v = clone(input2, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input2) {
    if (input2 instanceof Color) {
      return input2;
    }
    const type = typeof input2;
    let v;
    if (type === "object") {
      v = fromObject(input2);
    } else if (type === "string") {
      v = hexParse(input2) || nameParse(input2) || functionParse(input2);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color3, weight) {
    if (color3) {
      const c1 = this.rgb;
      const c2 = color3.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color3, t) {
    if (color3) {
      this._rgb = interpolate(this._rgb, color3._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};
function index_esm(input2) {
  return new Color(input2);
}
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
}
var overrides = Object.create(null);
var descriptors = Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i2 = 0, n3 = keys.length; i2 < n3; ++i2) {
    const k = keys[i2];
    node = node[k] || (node[k] = Object.create(null));
  }
  return node;
}
function set(root, scope, values2) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values2);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
  }
  set(scope, values2) {
    return set(this, scope, values2);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values2) {
    return set(descriptors, scope, values2);
  }
  override(scope, values2) {
    return set(overrides, scope, values2);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
};
var defaults = new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
});
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string2) {
  let textWidth = data[string2];
  if (!textWidth) {
    textWidth = data[string2] = ctx.measureText(string2).width;
    gc.push(string2);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i2, j, jlen, thing, nestedThing;
  for (i2 = 0; i2 < ilen; i2++) {
    thing = arrayOfThings[i2];
    if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i2 = 0; i2 < gcLen; i2++) {
      delete data[gc[i2]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + yOffset, y - xOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "star":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      rad += QUARTER_PI;
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [text];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i2, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i2 = 0; i2 < lines.length; ++i2) {
    line = lines[i2];
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
var FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = "";
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i2, ilen, value;
  for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
    value = inputs[i2];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults3 = { scriptable: true, indexable: true }) {
  const { _scriptable = defaults3.scriptable, _indexable = defaults3.indexable, _allKeys = defaults3.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s2) => s2 !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set2 = new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i2, ilen, index2, item;
  for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
    index2 = i2 + start;
    item = data[index2];
    parsed[i2] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i2) => i2 < points.length && !points[i2].skip && points[i2];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i2 = 0; i2 < pointsLen - 1; ++i2) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i2], 0, EPSILON)) {
      mK[i2] = mK[i2 + 1] = 0;
      continue;
    }
    alphaK = mK[i2] / deltaK[i2];
    betaK = mK[i2 + 1] / deltaK[i2];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i2] = alphaK * tauK * deltaK[i2];
    mK[i2 + 1] = betaK * tauK * deltaK[i2];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i2 = 0; i2 < pointsLen; ++i2) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i2];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i2];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i2, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i2 = 0; i2 < pointsLen; ++i2) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i2] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i2] = !pointBefore ? deltaK[i2] : !pointAfter ? deltaK[i2 - 1] : sign(deltaK[i2 - 1]) !== sign(deltaK[i2]) ? 0 : (deltaK[i2 - 1] + deltaK[i2]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i2, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i2 < ilen - 1 && _isPointInArea(points[i2 + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i2];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i2, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
      point = points[i2];
      controlPoints = splineCurve(prev, point, points[Math.min(i2 + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle = (element) => window.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
var positions = ["top", "right", "bottom", "left"];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i2 = 0; i2 < 4; i2++) {
    const pos = positions[i2];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return { x, y, box };
}
function getRelativePosition(evt, chart) {
  if ("native" in evt) {
    return evt;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(evt, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = { x: p1.cp2x, y: p1.cp2y };
  const cp2 = { x: p2.cp1x, y: p2.cp1y };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
var intlCache = new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i2, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return { start, end, loop, style: segment.style };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i2 = start, prev = start; i2 <= end; ++i2) {
    point = points[i2 % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i2 : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({ start: subStart, end: i2, loop, count, style }));
      subStart = null;
    }
    prev = i2;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i2 = 0; i2 < segments.length; i2++) {
    const sub = _boundSegment(segments[i2], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return { start, end };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({ start: start % count, end: (end - 1) % count, loop });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({ start: start % count, end: last % count, loop });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i2 = start;
  function addStyle(s2, e, l2, st) {
    const dir = spanGaps ? -1 : 1;
    if (s2 === e) {
      return;
    }
    s2 += count;
    while (points[s2 % count].skip) {
      s2 -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s2 % count !== e % count) {
      result.push({ start: s2 % count, end: e % count, loop: l2, style: st });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i2 = start + 1; i2 <= segment.end; i2++) {
      const pt = points[i2 % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i2 - 1) % count,
        p1DataIndex: i2 % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i2 - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i2 - 1) {
      addStyle(start, i2 - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}

// node_modules/chart.js/dist/chart.mjs
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date2, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date2 - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date2 = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i2 = items.length - 1;
      let draw2 = false;
      let item;
      for (; i2 >= 0; --i2) {
        item = items[i2];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date2);
          draw2 = true;
        } else {
          items[i2] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date2, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date2, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date2;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i2 = items.length - 1;
    for (; i2 >= 0; --i2) {
      items[i2].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
    const from2 = resolve([cfg.from, currentValue, to2]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date2) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date2 - this._start;
      const remain = this._duration - elapsed;
      this._start = date2;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
      this._from = resolve([cfg.from, currentValue, to2]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date2) {
    const elapsed = date2 - this._start;
    const duration2 = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration2);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration2 % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({ res, rej });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i2 = 0; i2 < promises.length; i2++) {
      promises[i2][method]();
    }
  }
};
var numbers = ["x", "y", "borderWidth", "radius", "tension"];
var colors = ["color", "borderColor", "backgroundColor"];
defaults.set("animation", {
  delay: void 0,
  duration: 1e3,
  easing: "easeOutQuart",
  fn: void 0,
  from: void 0,
  loop: void 0,
  to: void 0,
  type: void 0
});
var animationOptions = Object.keys(defaults.animation);
defaults.describe("animation", {
  _fallback: false,
  _indexable: false,
  _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
});
defaults.set("animations", {
  colors: {
    type: "color",
    properties: colors
  },
  numbers: {
    type: "number",
    properties: numbers
  }
});
defaults.describe("animations", {
  _fallback: "animation"
});
defaults.set("transitions", {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: "transparent"
      },
      visible: {
        type: "boolean",
        duration: 0
      }
    }
  },
  hide: {
    animations: {
      colors: {
        to: "transparent"
      },
      visible: {
        type: "boolean",
        easing: "linear",
        fn: (v) => v | 0
      }
    }
  }
});
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values2) {
    const newOptions = values2.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values2) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values2);
    const date2 = Date.now();
    let i2;
    for (i2 = props.length - 1; i2 >= 0; --i2) {
      const prop = props[i2];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values2));
        continue;
      }
      const value = values2[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date2);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values2) {
    if (this._properties.size === 0) {
      Object.assign(target, values2);
      return;
    }
    const animations = this._createAnimations(target, values2);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i2 = 0; i2 < keys.length; i2++) {
    const anim = animations[keys[i2]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l2;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l2 = value.left;
  } else {
    t = r = b = l2 = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l2,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i2, ilen;
  for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
    keys.push(metasets[i2].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i2, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
    datasetIndex = +keys[i2];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i2, ilen, key;
  for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
    key = keys[i2];
    adata[i2] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i2 = 0; i2 < ilen; ++i2) {
    const item = parsed[i2];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart, true), values: null };
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i2, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i2 = 0; i2 < count; ++i2) {
        meta._parsed[i2 + start] = cur = parsed[i2];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels2 = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i2, ilen, index2;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start;
      parsed[i2] = {
        [iAxis]: singleScale || iScale.parse(labels2[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start;
      item = data[index2];
      parsed[i2] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start;
      item = data[index2];
      parsed[i2] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta.index, { mode });
  }
  updateRangeFromParsed(range2, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values2 = stack && parsed._stacks[scale.axis];
    if (stack && values2) {
      stack.values = values2;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range2.min = Math.min(range2.min, value);
    range2.max = Math.max(range2.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i2, parsed;
    function _skip() {
      parsed = _parsed[i2];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i2 = 0; i2 < ilen; ++i2) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range2, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i2 = ilen - 1; i2 >= 0; --i2) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range2, scale, parsed, stack);
        break;
      }
    }
    return range2;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values2 = [];
    let i2, ilen, value;
    for (i2 = 0, ilen = parsed.length; i2 < ilen; ++i2) {
      value = parsed[i2][scale.axis];
      if (isNumberFinite(value)) {
        values2.push(value);
      }
    }
    return values2;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i2;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i2 = start; i2 < start + count; ++i2) {
      const element = elements2[i2];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i2 = 0; i2 < active.length; ++i2) {
      active[i2].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active);
    const values2 = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values2.$shared) {
      values2.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values2, sharing));
    }
    return values2;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return { sharedOptions, includeOptions };
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active) {
    element.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i2;
    const move = (arr) => {
      arr.length += count;
      for (i2 = arr.length - 1; i2 >= end; i2--) {
        arr[i2] = arr[i2 - count];
      }
    };
    move(data);
    for (i2 = start; i2 < end; ++i2) {
      data[i2] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([this.index, ...args]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(["_insertElements", this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(["_removeElements", 0, 1]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync(["_removeElements", start, count]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync(["_insertElements", start, newCount]);
    }
  }
  _onDataUnshift() {
    this._sync(["_insertElements", 0, arguments.length]);
  }
};
DatasetController.defaults = {};
DatasetController.prototype.datasetElementType = null;
DatasetController.prototype.dataElementType = null;
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values2 = [];
    for (let i2 = 0, ilen = visibleMetas.length; i2 < ilen; i2++) {
      values2 = values2.concat(visibleMetas[i2].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values2.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values2 = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i2, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i2 = 0, ilen = values2.length; i2 < ilen; ++i2) {
    curr = scale.getPixelForValue(values2[i2]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i2 = 0, ilen = scale.ticks.length; i2 < ilen; ++i2) {
    curr = scale.getPixelForTick(i2);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i2) {
  const startValue = vScale.parse(entry[0], i2);
  const endValue = vScale.parse(entry[1], i2);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i2) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i2);
  } else {
    item[vScale.axis] = vScale.parse(entry, i2);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels2 = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i2, ilen, item, entry;
  for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
    entry = data[i2];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels2[i2], i2);
    parsed.push(parseValue(entry, item, vScale, i2));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return { start, end, reverse, top, bottom };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = { top: true, right: true, bottom: true, left: true };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i2, ilen, item, obj;
    for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
      obj = data[i2];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i2);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i2));
    }
    return parsed;
  }
  updateRangeFromParsed(range2, scale, parsed, stack) {
    super.updateRangeFromParsed(range2, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range2.min = Math.min(range2.min, custom.min);
      range2.max = Math.max(range2.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i2 = start; i2 < start + count; i2++) {
      const parsed = this.getParsed(i2);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i2);
      const ipixels = this._calculateBarIndexPixels(i2, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index2 === stack._top || index2 === stack._bottom),
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, bars[i2].active ? "active" : mode);
      }
      const options = properties.options || bars[i2].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i2], i2, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i2, ilen;
    for (i2 = 0, ilen = meta.data.length; i2 < ilen; ++i2) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i2)[iScale.axis], i2));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
      size = Math.min(maxBarThickness, range2.chunk * range2.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i2 = 0;
    for (; i2 < ilen; ++i2) {
      if (this.getParsed(i2)[vScale.axis] !== null) {
        rects[i2].draw(this._ctx);
      }
    }
  }
};
BarController.id = "bar";
BarController.defaults = {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "base", "width", "height"]
    }
  }
};
BarController.overrides = {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
};
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i2 = 0; i2 < parsed.length; i2++) {
      parsed[i2]._custom = this.resolveDataElementOptions(i2 + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i2 = 0; i2 < parsed.length; i2++) {
      const item = data[start + i2];
      parsed[i2]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i2 + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i2 = 0; i2 < parsed.length; i2++) {
      const item = data[start + i2];
      parsed[i2]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i2 + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i2 = data.length - 1; i2 >= 0; --i2) {
      max = Math.max(max, data[i2].size(this.resolveDataElementOptions(i2)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: meta.label,
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i2 = start; i2 < start + count; i2++) {
      const point = points[i2];
      const parsed = !reset && this.getParsed(i2);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i2, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values2 = super.resolveDataElementOptions(index2, mode);
    if (values2.$shared) {
      values2 = Object.assign({}, values2, { $shared: false });
    }
    const radius = values2.radius;
    if (mode !== "active") {
      values2.radius = 0;
    }
    values2.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values2;
  }
};
BubbleController.id = "bubble";
BubbleController.defaults = {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "borderWidth", "radius"]
    }
  }
};
BubbleController.overrides = {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        }
      }
    }
  }
};
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return { ratioX, ratioY, offsetX, offsetY };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i3) => +data[i3];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i3) => +resolveObjectKey(data[i3], key);
      }
      let i2, ilen;
      for (i2 = start, ilen = start + count; i2 < ilen; ++i2) {
        meta._parsed[i2] = getter(i2);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i2 = 0; i2 < this.chart.data.datasets.length; ++i2) {
      if (this.chart.isDatasetVisible(i2)) {
        const controller = this.chart.getDatasetMeta(i2).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i2, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i2) || meta._parsed[i2] === null || meta.data[i2].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i2] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i2;
    for (i2 = 0; i2 < start; ++i2) {
      startAngle += this._circumference(i2, reset);
    }
    for (i2 = start; i2 < start + count; ++i2) {
      const circumference = this._circumference(i2, reset);
      const arc = arcs[i2];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i2, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i2;
    for (i2 = 0; i2 < metaData.length; i2++) {
      const value = meta._parsed[i2];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i2) && !metaData[i2].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels2 = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels2[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i2, ilen, meta, controller, options;
    if (!arcs) {
      for (i2 = 0, ilen = chart.data.datasets.length; i2 < ilen; ++i2) {
        if (chart.isDatasetVisible(i2)) {
          meta = chart.getDatasetMeta(i2);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
      options = controller.resolveDataElementOptions(i2);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
      const options = this.resolveDataElementOptions(i2);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i2 = 0; i2 < datasetIndex; ++i2) {
      if (this.chart.isDatasetVisible(i2)) {
        ringWeightOffset += this._getRingWeight(i2);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
DoughnutController.id = "doughnut";
DoughnutController.defaults = {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
};
DoughnutController.descriptors = {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing"
};
DoughnutController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i2) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i2);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i2),
                index: i2
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(tooltipItem) {
          let dataLabel = tooltipItem.label;
          const value = ": " + tooltipItem.formattedValue;
          if (isArray(dataLabel)) {
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }
          return dataLabel;
        }
      }
    }
  }
};
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i2 = start; i2 < start + count; ++i2) {
      const point = points[i2];
      const parsed = this.getParsed(i2);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i2];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i2, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
LineController.id = "line";
LineController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
};
LineController.overrides = {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
};
var PolarAreaController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels2 = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
    return {
      label: labels2[index2] || "",
      value
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    meta.data.forEach((element, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range2.min) {
          range2.min = parsed;
        }
        if (parsed > range2.max) {
          range2.max = parsed;
        }
      }
    });
    return range2;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i2;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i2 = 0; i2 < start; ++i2) {
      angle += this._computeAngle(i2, mode, defaultAngle);
    }
    for (i2 = start; i2 < start + count; i2++) {
      const arc = arcs[i2];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i2, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i2) ? scale.getDistanceFromCenterForValue(this.getParsed(i2).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i2, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i2, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
};
PolarAreaController.id = "polarArea";
PolarAreaController.defaults = {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
    }
  },
  indexAxis: "r",
  startAngle: 0
};
PolarAreaController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i2) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i2);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i2),
                index: i2
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(context) {
          return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
};
var PieController = class extends DoughnutController {
};
PieController.id = "pie";
PieController.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
};
var RadarController = class extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels2 = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels2.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i2 = start; i2 < start + count; i2++) {
      const point = points[i2];
      const options = this.resolveDataElementOptions(i2, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i2, this.getParsed(i2).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i2, properties, mode);
    }
  }
};
RadarController.id = "radar";
RadarController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
};
RadarController.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
};
var Element = class {
  constructor() {
    this.x = void 0;
    this.y = void 0;
    this.active = false;
    this.options = void 0;
    this.$animations = void 0;
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
Element.defaults = {};
Element.defaultRoutes = void 0;
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks2) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks2.length > 1) {
      const maxTick = Math.max(Math.abs(ticks2[0].value), Math.abs(ticks2[ticks2.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks2);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index2, ticks2) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if (remain === 1 || remain === 2 || remain === 5) {
      return formatters.numeric.call(this, tickValue, index2, ticks2);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks2) {
  let delta = ticks2.length > 3 ? ticks2[2].value - ticks2[1].value : ticks2[1].value - ticks2[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = { formatters };
defaults.set("scale", {
  display: true,
  offset: false,
  reverse: false,
  beginAtZero: false,
  bounds: "ticks",
  grace: 0,
  grid: {
    display: true,
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickLength: 8,
    tickWidth: (_ctx, options) => options.lineWidth,
    tickColor: (_ctx, options) => options.color,
    offset: false,
    borderDash: [],
    borderDashOffset: 0,
    borderWidth: 1
  },
  title: {
    display: false,
    text: "",
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    textStrokeWidth: 0,
    textStrokeColor: "",
    padding: 3,
    display: true,
    autoSkip: true,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
    align: "center",
    crossAlign: "near",
    showLabelBackdrop: false,
    backdropColor: "rgba(255, 255, 255, 0.75)",
    backdropPadding: 2
  }
});
defaults.route("scale.ticks", "color", "", "color");
defaults.route("scale.grid", "color", "", "borderColor");
defaults.route("scale.grid", "borderColor", "", "borderColor");
defaults.route("scale.title", "color", "", "color");
defaults.describe("scale", {
  _fallback: false,
  _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
  _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
});
defaults.describe("scales", {
  _fallback: "scale"
});
defaults.describe("scale.ticks", {
  _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
  _indexable: (name) => name !== "backdropPadding"
});
function autoSkip(scale, ticks2) {
  const tickOpts = scale.options.ticks;
  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks2) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks2, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks2, ticksLimit);
  if (numMajorIndices > 0) {
    let i2, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks2, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
      skip(ticks2, newTicks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
    }
    skip(ticks2, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks2.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks2, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset2 = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset2 ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks2, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks2.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
    const factor = factors[i2];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks2) {
  const result = [];
  let i2, ilen;
  for (i2 = 0, ilen = ticks2.length; i2 < ilen; i2++) {
    if (ticks2[i2].major) {
      result.push(i2);
    }
  }
  return result;
}
function skipMajors(ticks2, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i2;
  spacing = Math.ceil(spacing);
  for (i2 = 0; i2 < ticks2.length; i2++) {
    if (i2 === next) {
      newTicks.push(ticks2[i2]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks2, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks2.length), ticks2.length);
  let count = 0;
  let length, i2, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i2 = Math.max(start, 0); i2 < end; i2++) {
    if (i2 === next) {
      newTicks.push(ticks2[i2]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i2, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i2 = 1; i2 < len; ++i2) {
    if (arr[i2] - arr[i2 - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset2) => edge === "top" || edge === "left" ? scale[edge] + offset2 : scale[edge] - offset2;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i2 = 0;
  for (; i2 < len; i2 += increment) {
    result.push(arr[Math.floor(i2)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset2;
  if (offsetGridLines) {
    if (length === 1) {
      offset2 = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset2 = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset2 = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset2 : -offset2;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i2;
    if (gcLen > length) {
      for (i2 = 0; i2 < gcLen; ++i2) {
        delete cache.data[gc[i2]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset2, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset2;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset2;
    } else {
      titleY = offsetFromEdge(scale, position, offset2);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset2;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset2;
    } else {
      titleX = offsetFromEdge(scale, position, offset2);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return { titleX, titleY, maxWidth, rotation };
}
var Scale = class extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range2;
    if (minDefined && maxDefined) {
      return { min, max };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      range2 = metas[i2].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range2.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range2.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [this]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks2) {
    const tickOpts = this.options.ticks;
    let i2, ilen, tick;
    for (i2 = 0, ilen = ticks2.length; i2 < ilen; i2++) {
      tick = ticks2[i2];
      tick.label = callback(tickOpts.callback, [tick.value, i2, ticks2], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks2) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks2);
    let i2, ilen;
    for (i2 = 0, ilen = ticks2.length; i2 < ilen; i2++) {
      if (isNullOrUndef(ticks2[i2].label)) {
        ticks2.splice(i2, 1);
        ilen--;
        i2--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks2 = this.ticks;
      if (sampleSize < ticks2.length) {
        ticks2 = sample(ticks2, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks2, ticks2.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks2, length) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i2, j, jlen, label, tickFont, fontString2, cache, lineHeight, width, height, nestedLabel;
    for (i2 = 0; i2 < length; ++i2) {
      label = ticks2[i2].label;
      tickFont = this._resolveTickFontOptions(i2);
      ctx.font = fontString2 = tickFont.string;
      cache = caches[fontString2] = caches[fontString2] || { data: {}, gc: [] };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks2 = this.ticks;
    if (index2 < 0 || index2 > ticks2.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks2[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks2 = this.ticks || [];
    if (index2 >= 0 && index2 < ticks2.length) {
      const tick = ticks2[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position } = options;
    const offset2 = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks2 = this.ticks;
    const ticksLength = ticks2.length + (offset2 ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i2, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i2 = 0; i2 < ticksLength; i2 += step) {
      const optsAtIndex = grid.setContext(this.getContext(i2));
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndex.borderDash || [];
      const borderDashOffset = optsAtIndex.borderDashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i2, offset2);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks2 = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i2, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i2 = 0, ilen = ticks2.length; i2 < ilen; ++i2) {
      tick = ticks2[i2];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i2));
      pixel = this.getPixelForTick(i2) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i2);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color3 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i2 === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i2 === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i2];
        const width = labelSizes.widths[i2];
        let top = y + textOffset - labelPadding.top;
        let left = x - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        rotation,
        label,
        font,
        color: color3,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign: tickTextAlign,
        textBaseline,
        translation: [x, y],
        backdrop
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks: ticks2 } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks2.align === "start") {
      align = "left";
    } else if (ticks2.align === "end") {
      align = "right";
    } else if (ticks2.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return { textAlign, x };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return { top: 0, left: this.left, bottom: chart.height, right: this.right };
    }
    if (position === "top" || position === "bottom") {
      return { top: this.top, left: 0, bottom: this.bottom, right: chart.width };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks2 = this.ticks;
    const index2 = ticks2.findIndex((t) => t.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i2, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
        const item = items[i2];
        if (grid.drawOnChartArea) {
          drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
        }
        if (grid.drawTicks) {
          drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { grid } } = this;
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.borderWidth;
    ctx.strokeStyle = borderOpts.borderColor;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i2, ilen;
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      const item = items[i2];
      const tickFont = item.font;
      const label = item.label;
      if (item.backdrop) {
        ctx.fillStyle = item.backdrop.color;
        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
      }
      let y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset2 = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset2 += padding.bottom;
      if (isArray(title.text)) {
        offset2 += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset2 += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset2, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw: (chartArea) => {
          this.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw: (chartArea) => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: gz + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: (chartArea) => {
        this.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      const meta = metas[i2];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [...args].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i2 = 0; i2 < this._typedRegistries.length; i2++) {
      const reg = this._typedRegistries[i2];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = new Registry();
var ScatterController = class extends DatasetController {
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i2 = start; i2 < start + count; ++i2) {
      const point = points[i2];
      const parsed = this.getParsed(i2);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i2];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i2, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i2 = data.length - 1; i2 >= 0; --i2) {
        max = Math.max(max, data[i2].size(this.resolveDataElementOptions(i2)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
};
ScatterController.id = "scatter";
ScatterController.defaults = {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
};
ScatterController.overrides = {
  interaction: {
    mode: "point"
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(item) {
          return "(" + item.label + ", " + item.formattedValue + ")";
        }
      }
    }
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
};
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PolarAreaController,
  PieController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapter = class {
  constructor(options) {
    this.options = options || {};
  }
  init(chartOptions) {
  }
  formats() {
    return abstract();
  }
  parse(value, format) {
    return abstract();
  }
  format(timestamp, format) {
    return abstract();
  }
  add(timestamp, amount, unit) {
    return abstract();
  }
  diff(a, b, unit) {
    return abstract();
  }
  startOf(timestamp, unit, weekday) {
    return abstract();
  }
  endOf(timestamp, unit) {
    return abstract();
  }
};
DateAdapter.override = function(members) {
  Object.assign(DateAdapter.prototype, members);
};
var adapters = {
  _date: DateAdapter
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range2 = typeof el.getRange === "function" && el.getRange(axis);
      if (range2) {
        const start = lookupMethod(data, axis, value - range2);
        const end = lookupMethod(data, axis, value + range2);
        return { lo: start.lo, hi: end.hi };
      }
    }
  }
  return { lo: 0, hi: data.length - 1 };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
    const { index: index2, data } = metasets[i2];
    const { lo, hi } = binarySearch(metasets[i2], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({ element, datasetIndex, index: index2 });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
    const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({ element, datasetIndex, index: index2 });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{ element, datasetIndex, index: index2 }];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({ element, datasetIndex, index: index2 });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({ element, datasetIndex, index: index2 });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element = meta.data[index2];
        if (element && !element.skip) {
          elements2.push({ element, datasetIndex: meta.index, index: index2 });
        }
      });
      return elements2;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i2 = 0; i2 < data.length; ++i2) {
          items.push({ element: data[i2], datasetIndex, index: i2 });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = ["left", "top", "right", "bottom"];
function filterByPosition(array2, position) {
  return array2.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array2, axis) {
  return array2.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array2, reverse) {
  return array2.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i2, ilen, box, pos, stack, stackWeight;
  for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
    box = boxes[i2];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i2,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i2, ilen, layout;
  for (i2 = 0, ilen = layouts2.length; i2 < ilen; ++i2) {
    layout = layouts2[i2];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || { size: 0, count: 1 };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = { left: 0, top: 0, right: 0, bottom: 0 };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i2, ilen, layout, box, refit, changed;
  for (i2 = 0, ilen = boxes.length, refit = 0; i2 < ilen; ++i2) {
    layout = boxes[i2];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
defaults.set("layout", {
  autoPadding: true,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
var drpListeningCharts = new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart, (args) => {
    const event = args[0];
    return [event, event.offsetX, event.offsetY];
  });
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    ["height", "width"].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin2 = descriptor.plugin;
      const method = plugin2[hook];
      const params = [chart, args, descriptor.options];
      if (callback(method, params, plugin2) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i2 = 0; i2 < keys.length; i2++) {
    plugins2.push(registry.getPlugin(keys[i2]));
  }
  const local = config.plugins || [];
  for (let i2 = 0; i2 < local.length; i2++) {
    const plugin2 = local[i2];
    if (plugins2.indexOf(plugin2) === -1) {
      plugins2.push(plugin2);
      localIds[plugin2.id] = true;
    }
  }
  return { plugins: plugins2, localIds };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin2 of plugins2) {
    const id = plugin2.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin: plugin2,
      options: pluginOpts(chart.config, { plugin: plugin2, local: localIds[id] }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin: plugin2, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin2);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin2.defaults) {
    scopes.push(plugin2.defaults);
  }
  return config.createResolver(scopes, context, [""], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, scaleOptions) {
  if (id === "x" || id === "y") {
    return id;
  }
  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || { scales: {} };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const firstIDs = Object.create(null);
  const scales2 = Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    firstIDs[axis] = firstIDs[axis] || id;
    scales2[id] = mergeIf(Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
      scales2[id] = scales2[id] || Object.create(null);
      mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = new Map();
var keysCached = new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = new Map();
    this._resolverCache = new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [[
      `datasets.${datasetType}`,
      ""
    ]]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [[
      `datasets.${datasetType}.elements.${elementType}`,
      `datasets.${datasetType}`,
      `elements.${elementType}`,
      ""
    ]]);
  }
  pluginScopeKeys(plugin2) {
    const id = plugin2.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [[
      `plugins.${id}`,
      ...plugin2.additionalOptionScopes || []
    ]]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array2 = Array.from(scopes);
    if (array2.length === 0) {
      array2.push(Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array2);
    }
    return array2;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      { type },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
    const result = { $shared: true };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "3.9.1";
var KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions2 && animationOptions2.onComplete, [context], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  callback(animationOptions2 && animationOptions2.onProgress, [context], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
var Chart = class {
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = { width, height };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", { size: newSize });
    callback(options.onResize, [this, newSize], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i2 = numData; i2 < numMeta; ++i2) {
        this._destroyDatasetMeta(i2);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets: datasets2 } } = this;
    if (metasets.length > datasets2.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets2.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets2 = this.data.datasets;
    let i2, ilen;
    this._removeUnreferencedMetasets();
    for (i2 = 0, ilen = datasets2.length; i2 < ilen; i2++) {
      const dataset = datasets2[i2];
      let meta = this.getDatasetMeta(i2);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i2);
        meta = this.getDatasetMeta(i2);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i2;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i2);
      if (meta.controller) {
        meta.controller.updateIndex(i2);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass.prototype, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i2);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; i2++) {
      const { controller } = this.getDatasetMeta(i2);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", { mode });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i2) => i2 + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i2 = 1; i2 < datasetCount; i2++) {
      if (!setsEqual(changeSet, makeSet(i2))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this.getDatasetMeta(i2).controller.configure();
    }
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this._updateDataset(i2, isFunction(mode) ? mode({ datasetIndex: i2 }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", { mode });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = { meta, index: index2, mode, cancelable: true };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({ chart: this });
    }
  }
  draw() {
    let i2;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
      return;
    }
    const layers = this._layers;
    for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
      layers[i2].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i2 < layers.length; ++i2) {
      layers[i2].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      const meta = metasets[i2];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
      this._drawDataset(metasets[i2]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, { visible });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i2, ilen;
    this.stop();
    animator.remove(this);
    for (i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this._destroyDatasetMeta(i2);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    this.notifyPlugins("destroy");
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i2, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      item = items[i2];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin2) => (plugin2.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [e, active, this], this);
      if (isClick) {
        callback(options.onClick, [e, active, this], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
var invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
var enumerable = true;
Object.defineProperties(Chart, {
  defaults: {
    enumerable,
    value: defaults
  },
  instances: {
    enumerable,
    value: instances
  },
  overrides: {
    enumerable,
    value: overrides
  },
  registry: {
    enumerable,
    value: registry
  },
  version: {
    enumerable,
    value: version
  },
  getChart: {
    enumerable,
    value: getChart
  },
  register: {
    enumerable,
    value: (...items) => {
      registry.add(...items);
      invalidatePlugins();
    }
  },
  unregister: {
    enumerable,
    value: (...items) => {
      registry.remove(...items);
      invalidatePlugins();
    }
  }
});
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset2, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset2 - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset2 + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset2 / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset2, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset2, spacing, startAngle + TAU, circular);
    for (let i2 = 0; i2 < fullCircles; ++i2) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + circumference % TAU;
      if (circumference % TAU === 0) {
        endAngle += TAU;
      }
    }
  }
  pathArc(ctx, element, offset2, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawFullCircleBorders(ctx, element, inner) {
  const { x, y, startAngle, pixelMargin, fullCircles } = element;
  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
  const innerRadius = element.innerRadius + pixelMargin;
  let i2;
  if (inner) {
    clipArc(ctx, element, startAngle + TAU);
  }
  ctx.beginPath();
  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
  for (i2 = 0; i2 < fullCircles; ++i2) {
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
  for (i2 = 0; i2 < fullCircles; ++i2) {
    ctx.stroke();
  }
}
function drawBorder(ctx, element, offset2, spacing, endAngle, circular) {
  const { options } = element;
  const { borderWidth, borderJoinStyle } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  if (element.fullCircles) {
    drawFullCircleBorders(ctx, element, inner);
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  pathArc(ctx, element, offset2, spacing, endAngle, circular);
  ctx.stroke();
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(["x", "y"], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const { offset: offset2, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset2) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset2 = (options.offset || 0) / 2;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    let radiusOffset = 0;
    if (offset2) {
      radiusOffset = offset2 / 2;
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
      if (this.circumference >= PI) {
        radiusOffset = offset2;
      }
    }
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
    ctx.restore();
  }
};
ArcElement.id = "arc";
ArcElement.defaults = {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
};
ArcElement.defaultRoutes = {
  backgroundColor: "backgroundColor"
};
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i2, point, prev;
  for (i2 = 0; i2 <= ilen; ++i2) {
    point = points[(start + (reverse ? ilen - i2 : i2)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i2, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i2 = 0; i2 <= ilen; ++i2) {
    point = points[pointIndex(i2)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
var LineElement = class extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, { property, start: value, end: value });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i2, ilen;
    for (i2 = 0, ilen = segments.length; i2 < ilen; ++i2) {
      const { start, end } = segments[i2];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
LineElement.id = "line";
LineElement.defaults = {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
};
LineElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
LineElement.descriptors = {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
};
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([axis], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
PointElement.id = "point";
PointElement.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
};
PointElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return { left, top, right, bottom };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
BarElement.id = "bar";
BarElement.defaults = {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
};
BarElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  LineElement,
  PointElement,
  BarElement
});
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i2, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i2 = 0; i2 < samples - 2; i2++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i2 + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i2 + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i2 * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i2 + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i2, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i2 = start; i2 < start + count; ++i2) {
    point = data[i2];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i2;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i2;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i2 - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {
            x: avgX
          }));
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {
            x: avgX
          }));
        }
      }
      if (i2 > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i2;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", { value: data });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return { start, count };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([indexAxis, chart.options.indexAxis]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return { property, start, end };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({ x: first.x, y });
      points.push({ x: last.x, y });
    } else if (x !== null) {
      points.push({ x, y: first.y });
      points.push({ x, y: last.y });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: { tension: 0 },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [index2];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return ["origin", "start", "end", "stack", "shape"].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({ x: null, y: scale.bottom }, line));
  for (let i2 = 0; i2 < segments.length; i2++) {
    const segment = segments[i2];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({ points, options: {} });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i2 = 0; i2 < metas.length; i2++) {
    const meta = metas[i2];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i2 = 0; i2 < segments.length; i2++) {
    const segment = segments[i2];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return { first, last, point };
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || { start: 0, end: TAU };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
};
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta = chart.getDatasetMeta(index2);
  const visible = meta && chart.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i2 = 0; i2 < length; ++i2) {
    target.push(scale.getPointPositionForValue(i2, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const { line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color3 = lineOpts.backgroundColor;
  const { above = color3, below = color3 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, { line, target, above, below, area, scale, axis });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, { line, target, color: above, scale, property });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, { line, target, color: below, scale, property });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property, color: color3, scale } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color3 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i2, line, source;
    for (i2 = 0; i2 < count; ++i2) {
      meta = chart.getDatasetMeta(i2);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i2),
          index: i2,
          fill: _decodeFill(line, i2, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i2 = 0; i2 < count; ++i2) {
      source = sources[i2];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i2, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
      const source = metasets[i2].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
      const source = metasets[i2].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row2 = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i2) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i2 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row2++;
      }
      hitboxes[i2] = { left: 0, top, row: row2, width: itemWidth, height: itemHeight };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i2) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i2 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({ width: currentColWidth, height: currentColHeight });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i2] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({ width: currentColWidth, height: currentColHeight });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row2 = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row2]);
      for (const hitbox of hitboxes) {
        if (row2 !== hitbox.row) {
          row2 = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row2]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { color: fontColor, padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i2) => {
      ctx.strokeStyle = legendItem.fontColor || fontColor;
      ctx.fillStyle = legendItem.fontColor || fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i2 > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i2 > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i2, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i2 = 0; i2 < lh.length; ++i2) {
        hitBox = lh[i2];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i2];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [e, previous, this], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [e, hoveredItem, this], this);
    }
  }
};
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({ ctx: chart.ctx, options, chart });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets2 = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color3 } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets2[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color3,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: 0,
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset2) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset2;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset2;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset2;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return { titleX, titleY, maxWidth, rotation };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset2 = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset2);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i2, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i2 = 0, len = items.length; i2 < len; ++i2) {
      const el = items[i2].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i2, len, nearestElement;
    for (i2 = 0, len = items.length; i2 < len; ++i2) {
      const el = items[i2].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return { width, height };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart || config._chart;
    this._chart = this.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
    const title = callbacks.title.apply(this, [context]);
    const afterTitle = callbacks.afterTitle.apply(this, [context]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
    const footer = callbacks.footer.apply(this, [tooltipItems]);
    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i2, len;
    for (i2 = 0, len = active.length; i2 < len; ++i2) {
      tooltipItems.push(createTooltipItem(this.chart, active[i2]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array2) => options.filter(element, index2, array2, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(scoped.labelColor.call(this, context));
      labelPointStyles.push(scoped.labelPointStyle.call(this, context));
      labelTextColors.push(scoped.labelTextColor.call(this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, { chart: this.chart, tooltip: this, replay });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return { x1, x2, x3, y1, y2, y3 };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i2;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i2 = 0; i2 < length; ++i2) {
        ctx.fillText(title[i2], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i2 + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i2, rtlHelper, options) {
    const labelColors = this.labelColors[i2];
    const labelPointStyle = this.labelPointStyles[i2];
    const { boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i2];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i2, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
      bodyItem = body[i2];
      textColor = this.labelTextColors[i2];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i2, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i2;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i2 = 0; i2 < length; ++i2) {
        ctx.fillText(footer[i2], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
Tooltip.positioners = positioners;
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({ chart, options });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "width", "height", "caretX", "caretY"]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: noop,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels2 = item.chart.data.labels;
          const labelCount = labels2 ? labels2.length : 0;
          if (this && this.options && this.options.mode === "dataset") {
            return item.dataset.label || "";
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels2[item.dataIndex];
          }
        }
        return "";
      },
      afterTitle: noop,
      beforeBody: noop,
      beforeLabel: noop,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") {
          return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || "";
        if (label) {
          label += ": ";
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation
        };
      },
      afterLabel: noop,
      afterBody: noop,
      beforeFooter: noop,
      footer: noop,
      afterFooter: noop
    }
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: ["interaction"]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels2, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels2.push(raw) - 1;
    addedLabels.unshift({ index: index2, label: raw });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels2, raw, index2, addedLabels) {
  const first = labels2.indexOf(raw);
  if (first === -1) {
    return addIfString(labels2, raw, index2, addedLabels);
  }
  const last = labels2.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels2 = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels2[index2] === label) {
          labels2.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels2 = this.getLabels();
    index2 = isFinite(index2) && labels2[index2] === raw ? index2 : findOrAddLabel(labels2, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels2.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset2 = this.options.offset;
    const ticks2 = [];
    let labels2 = this.getLabels();
    labels2 = min === 0 && max === labels2.length - 1 ? labels2 : labels2.slice(min, max + 1);
    this._valueRange = Math.max(labels2.length - (offset2 ? 0 : 1), 1);
    this._startValue = this.min - (offset2 ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks2.push({ value });
    }
    return ticks2;
  }
  getLabelForValue(value) {
    const labels2 = this.getLabels();
    if (value >= 0 && value < labels2.length) {
      return labels2[value];
    }
    return value;
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks2 = this.ticks;
    if (index2 < 0 || index2 > ticks2.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks2[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
CategoryScale.id = "category";
CategoryScale.defaults = {
  ticks: {
    callback: CategoryScale.prototype.getLabelForValue
  }
};
function generateTicks$1(generationOptions, dataRange) {
  const ticks2 = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{ value: rmin }, { value: rmax }];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks2.push({ value: min });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks2.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks2.length && almostEquals(ticks2[ticks2.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks2[ticks2.length - 1].value = max;
    } else {
      ticks2.push({ value: max });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks2.push({ value: niceMax });
  }
  return ticks2;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset2 = 1;
      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
        offset2 = Math.abs(max * 0.05);
      }
      setMax(max + offset2);
      if (!beginAtZero) {
        setMin(min - offset2);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks2 = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks2, this, "value");
    }
    if (opts.reverse) {
      ticks2.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks2;
  }
  configure() {
    const ticks2 = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks2.length) {
      const offset2 = (end - start) / Math.max(ticks2.length - 1, 1) / 2;
      start -= offset2;
      end += offset2;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
LinearScale.id = "linear";
LinearScale.defaults = {
  ticks: {
    callback: Ticks.formatters.numeric
  }
};
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
  return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
  const endExp = Math.floor(log10(dataRange.max));
  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  const ticks2 = [];
  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
  let exp = Math.floor(log10(tickVal));
  let significand = Math.floor(tickVal / Math.pow(10, exp));
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  do {
    ticks2.push({ value: tickVal, major: isMajor(tickVal) });
    ++significand;
    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }
    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || exp === endExp && significand < endSignificand);
  const lastTick = finiteOrDefault(generationOptions.max, tickVal);
  ticks2.push({ value: lastTick, major: isMajor(tickVal) });
  return ticks2;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index2]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(exp(min, -1));
        setMax(exp(max, 1));
      }
    }
    if (min <= 0) {
      setMin(exp(max, -1));
    }
    if (max <= 0) {
      setMax(exp(min, 1));
    }
    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
      setMin(exp(min, -1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks2 = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks2, this, "value");
    }
    if (opts.reverse) {
      ticks2.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks2;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
LogarithmicScale.id = "logarithmic";
LogarithmicScale.defaults = {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
};
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [label];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i2 = 0; i2 < valueCount; i2++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i2));
    padding[i2] = opts.padding;
    const pointPosition = scale.getPointPosition(i2, scale.drawingArea + padding[i2], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i2]);
    labelSizes[i2] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i2) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i2 = 0; i2 < valueCount; i2++) {
    const pointLabelPosition = scale.getPointPosition(i2, outerDistance + extra + padding[i2], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i2];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i2 = labelCount - 1; i2 >= 0; i2--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i2));
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i2];
    const { backdropColor } = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
    renderText(ctx, scale._pointLabels[i2], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i2 = 1; i2 < labelCount; i2++) {
      pointPosition = scale.getPointPosition(i2, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color3, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color3 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color3;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(gridLineOpts.borderDash);
  ctx.lineDashOffset = gridLineOpts.borderDashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks2) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks2);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [value, index2], this);
      return label || label === 0 ? label : "";
    }).filter((v, i2) => this.chart.getDataVisibility(i2));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid } = opts;
    const labelCount = this._pointLabels.length;
    let i2, offset2, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0) {
          offset2 = this.getDistanceFromCenterForValue(tick.value);
          const optsAtIndex = grid.setContext(this.getContext(index2 - 1));
          drawRadiusLine(this, optsAtIndex, offset2, labelCount);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i2 = labelCount - 1; i2 >= 0; i2--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i2));
        const { color: color3, lineWidth } = optsAtIndex;
        if (!lineWidth || !color3) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color3;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset2 = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i2, offset2);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset2, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset2 = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset2 - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset2, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
RadialLinearScale.id = "radialLinear";
RadialLinearScale.defaults = {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
};
RadialLinearScale.defaultRoutes = {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
};
RadialLinearScale.descriptors = {
  angleLines: {
    _fallback: "grid"
  }
};
var INTERVALS = {
  millisecond: { common: true, size: 1, steps: 1e3 },
  second: { common: true, size: 1e3, steps: 60 },
  minute: { common: true, size: 6e4, steps: 60 },
  hour: { common: true, size: 36e5, steps: 24 },
  day: { common: true, size: 864e5, steps: 30 },
  week: { common: false, size: 6048e5, steps: 4 },
  month: { common: true, size: 2628e6, steps: 12 },
  quarter: { common: false, size: 7884e6, steps: 4 },
  year: { common: true, size: 3154e7 }
};
var UNITS = Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input2) {
  if (isNullOrUndef(input2)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input2;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
    const interval = INTERVALS[UNITS[i2]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i2];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
    const unit = UNITS[i2];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
    if (INTERVALS[UNITS[i2]].common) {
      return UNITS[i2];
    }
  }
}
function addTick(ticks2, time2, timestamps) {
  if (!timestamps) {
    ticks2[time2] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time2);
    const timestamp = timestamps[lo] >= time2 ? timestamps[lo] : timestamps[hi];
    ticks2[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks2, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks2[0].value, majorUnit);
  const last = ticks2[ticks2.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map3[major];
    if (index2 >= 0) {
      ticks2[index2].major = true;
    }
  }
  return ticks2;
}
function ticksFromTimestamps(scale, values2, majorUnit) {
  const ticks2 = [];
  const map3 = {};
  const ilen = values2.length;
  let i2, value;
  for (i2 = 0; i2 < ilen; ++i2) {
    value = values2[i2];
    map3[value] = i2;
    ticks2.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks2 : setMajorTicks(scale, ticks2, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts) {
    const time2 = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time2.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time2.parser,
      round: time2.round,
      isoWeekday: time2.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return { min, max };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks2 = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks2.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks2.reverse();
    }
    return ticksFromTimestamps(this, ticks2, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = { start, end, factor: 1 / (start + 1 + end) };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(timeOpts.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks2 = {};
    let first = min;
    let time2, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time2 = first, count = 0; time2 < max; time2 = +adapter.add(time2, stepSize, minor), count++) {
      addTick(ticks2, time2, timestamps);
    }
    if (time2 === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks2, time2, timestamps);
    }
    return Object.keys(ticks2).sort((a, b) => a - b).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time2, index2, ticks2, format) {
    const options = this.options;
    const formats2 = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats2[unit];
    const majorFormat = majorUnit && formats2[majorUnit];
    const tick = ticks2[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    const label = this._adapter.format(time2, format || (major ? majorFormat : minorFormat));
    const formatter = options.ticks.callback;
    return formatter ? callback(formatter, [label, index2, ticks2], this) : label;
  }
  generateTickLabels(ticks2) {
    let i2, ilen, tick;
    for (i2 = 0, ilen = ticks2.length; i2 < ilen; ++i2) {
      tick = ticks2[i2];
      tick.label = this._tickFormatFunction(tick.value, i2, ticks2);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i2, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      timestamps = timestamps.concat(metas[i2].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i2, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels2 = this.getLabels();
    for (i2 = 0, ilen = labels2.length; i2 < ilen; ++i2) {
      timestamps.push(parse(this, labels2[i2]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values2) {
    return _arrayUnique(values2.sort(sorter));
  }
};
TimeScale.id = "time";
TimeScale.defaults = {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    major: {
      enabled: false
    }
  }
};
function interpolate2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate2(table, this.min);
    this._tableRange = interpolate2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i2, ilen, prev, curr, next;
    for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
      curr = timestamps[i2];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        { time: min, pos: 0 },
        { time: max, pos: 1 }
      ];
    }
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      next = items[i2 + 1];
      prev = items[i2 - 1];
      curr = items[i2];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({ time: curr, pos: i2 / (ilen - 1) });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
TimeSeriesScale.id = "timeseries";
TimeSeriesScale.defaults = TimeScale.defaults;
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// node_modules/luxon/src/errors.js
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// node_modules/luxon/src/impl/formats.js
var n2 = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n2,
  month: n2,
  day: n2
};
var DATE_MED = {
  year: n2,
  month: s,
  day: n2
};
var DATE_MED_WITH_WEEKDAY = {
  year: n2,
  month: s,
  day: n2,
  weekday: s
};
var DATE_FULL = {
  year: n2,
  month: l,
  day: n2
};
var DATE_HUGE = {
  year: n2,
  month: l,
  day: n2,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n2,
  minute: n2
};
var TIME_WITH_SECONDS = {
  hour: n2,
  minute: n2,
  second: n2
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n2,
  minute: n2,
  second: n2,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n2,
  minute: n2,
  second: n2,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n2,
  minute: n2,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n2,
  minute: n2,
  second: n2,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n2,
  minute: n2,
  second: n2,
  hourCycle: "h23",
  timeZoneName: s
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n2,
  minute: n2,
  second: n2,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n2,
  month: n2,
  day: n2,
  hour: n2,
  minute: n2
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n2,
  month: n2,
  day: n2,
  hour: n2,
  minute: n2,
  second: n2
};
var DATETIME_MED = {
  year: n2,
  month: s,
  day: n2,
  hour: n2,
  minute: n2
};
var DATETIME_MED_WITH_SECONDS = {
  year: n2,
  month: s,
  day: n2,
  hour: n2,
  minute: n2,
  second: n2
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n2,
  month: s,
  day: n2,
  weekday: s,
  hour: n2,
  minute: n2
};
var DATETIME_FULL = {
  year: n2,
  month: l,
  day: n2,
  hour: n2,
  minute: n2,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n2,
  month: l,
  day: n2,
  hour: n2,
  minute: n2,
  second: n2,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n2,
  month: l,
  day: n2,
  weekday: l,
  hour: n2,
  minute: n2,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n2,
  month: l,
  day: n2,
  weekday: l,
  hour: n2,
  minute: n2,
  second: n2,
  timeZoneName: l
};

// node_modules/luxon/src/zone.js
var Zone = class {
  get type() {
    throw new ZoneIsAbstractError();
  }
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class extends Zone {
  static get instance() {
    if (singleton === null) {
      singleton = new SystemZone();
    }
    return singleton;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return false;
  }
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  equals(otherZone) {
    return otherZone.type === "system";
  }
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/IANAZone.js
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date2) {
  const formatted = dtf.format(date2).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date2) {
  const formatted = dtf.formatToParts(date2);
  const filled = [];
  for (let i2 = 0; i2 < formatted.length; i2++) {
    const { type, value } = formatted[i2];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class extends Zone {
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = IANAZone.isValidZone(name);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  offset(ts) {
    const date2 = new Date(ts);
    if (isNaN(date2))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date2) : hackyOffset(dtf, date2);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date2;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
};

// node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const _a = opts, { base } = _a, cacheKeyOpts = __objRest(_a, ["base"]);
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i2 = 1; i2 <= 12; i2++) {
    const dt = DateTime.utc(2016, i2, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i2 = 1; i2 <= 7; i2++) {
    const dt = DateTime.utc(2016, 11, 13 + i2);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const _a = opts, { padTo, floor } = _a, otherOpts = __objRest(_a, ["padTo", "floor"]);
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = __spreadValues({ useGrouping: false }, opts);
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i2) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i2) : i2;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i2) : roundTo(i2, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = __spreadValues({}, this.opts);
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return __spreadProps(__spreadValues({}, part), {
            value: offsetName
          });
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = __spreadValues({ style: "long" }, opts);
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var Locale = class {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }
  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar);
  }
  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone(__spreadProps(__spreadValues({}, alts), { defaultToEN: true }));
  }
  redefaultToSystem(alts = {}) {
    return this.clone(__spreadProps(__spreadValues({}, alts), { defaultToEN: false }));
  }
  months(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) => this.extract(dt, intl, "weekday"));
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems(defaultOK = true) {
    return listStuff(this, void 0, defaultOK, () => meridiems, () => {
      if (!this.meridiemCache) {
        const intl = { hour: "numeric", hourCycle: "h12" };
        this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map((dt) => this.extract(dt, intl, "dayperiod"));
      }
      return this.meridiemCache;
    });
  }
  eras(length, defaultOK = true) {
    return listStuff(this, length, defaultOK, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) => this.extract(dt, intl, "era"));
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
};

// node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class extends Zone {
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new FixedOffsetZone(0);
    }
    return singleton2;
  }
  static instance(offset2) {
    return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
  }
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  offsetName() {
    return this.name;
  }
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  get isUniversal() {
    return true;
  }
  offset() {
    return this.fixed;
  }
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return false;
  }
  get isValid() {
    return false;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input2, defaultZone2) {
  let offset2;
  if (isUndefined(input2) || input2 === null) {
    return defaultZone2;
  } else if (input2 instanceof Zone) {
    return input2;
  } else if (isString(input2)) {
    const lowered = input2.toLowerCase();
    if (lowered === "default")
      return defaultZone2;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input2);
  } else if (isNumber2(input2)) {
    return FixedOffsetZone.instance(input2);
  } else if (typeof input2 === "object" && input2.offset && typeof input2.offset === "number") {
    return input2;
  } else {
    return new InvalidZone(input2);
  }
}

// node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var twoDigitCutoffYear = 60;
var throwOnInvalid;
var Settings = class {
  static get now() {
    return now;
  }
  static set now(n3) {
    now = n3;
  }
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  static get defaultLocale() {
    return defaultLocale;
  }
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
};

// node_modules/luxon/src/impl/util.js
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber2(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n3) {
  return x - n3 * Math.floor(x / n3);
}
function padStart(input2, n3 = 2) {
  const isNeg = input2 < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input2).padStart(n3, "0");
  } else {
    padded = ("" + input2).padStart(n3, "0");
  }
  return padded;
}
function parseInteger(string2) {
  if (isUndefined(string2) || string2 === null || string2 === "") {
    return void 0;
  } else {
    return parseInt(string2, 10);
  }
}
function parseFloating(string2) {
  if (isUndefined(string2) || string2 === null || string2 === "") {
    return void 0;
  } else {
    return parseFloat(string2);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number2, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number2 * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}
function weeksInWeekYear(weekYear) {
  const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date2 = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = __spreadValues({ timeZoneName: offsetFormat }, intlOpts);
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date2).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null)
        continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset2, format) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign2 = offset2 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign2}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign2}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign2}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}

// node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i2 = 0; i2 < fmt.length; i2++) {
      const c = fmt.charAt(i2);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
    return df.format();
  }
  formatDateTime(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
    return df.format();
  }
  formatDateTimeParts(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
    return df.formatToParts();
  }
  formatInterval(interval, opts = {}) {
    const df = this.loc.dtFormatter(interval.start, __spreadValues(__spreadValues({}, this.opts), opts));
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
    return df.resolvedOptions();
  }
  num(n3, p = 0) {
    if (this.opts.forceSimple) {
      return padStart(n3, p);
    }
    const opts = __spreadValues({}, this.opts);
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n3);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string2 = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string2({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string2(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string2(standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" }, "weekday"), maybeMacro = (token) => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string2({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string2({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string2({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string2({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string2({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string2({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string2({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string2({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce((found, { literal, val }) => literal ? found : found.concat(val), []), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// node_modules/luxon/src/impl/regexParser.js
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
    const [val, zone, next] = ex(m, cursor);
    return [__spreadValues(__spreadValues({}, mergedVals), val), zone || mergedZone, next];
  }, [{}, null, 1]).slice(0, 2);
}
function parse2(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i2;
    for (i2 = 0; i2 < keys.length; i2++) {
      ret[keys[i2]] = parseInteger(match2[cursor + i2]);
    }
    return [ret, null, cursor + i2];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m = match2[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseISODate(s2) {
  return parse2(s2, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
}
function parseRFC2822Date(s2) {
  return parse2(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse2(s2, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
}
function parseISODuration(s2) {
  return parse2(s2, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse2(s2, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(s2) {
  return parse2(s2, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
}

// node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = __spreadValues({
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  }
}, lowOrderMatrix);
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = __spreadValues({
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  }
}, lowOrderMatrix);
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone2(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : __spreadValues(__spreadValues({}, dur.values), alts.values || {}),
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function antiTrunc(n3) {
  return n3 < 0 ? Math.floor(n3) : Math.ceil(n3);
}
function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
}
function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
var Duration = class {
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  static fromMillis(count, opts) {
    return Duration.fromObject({ milliseconds: count }, opts);
  }
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  static fromDurationLike(durationLike) {
    if (isNumber2(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
    }
  }
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  }
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(fmt, opts = {}) {
    const fmtOpts = __spreadProps(__spreadValues({}, opts), {
      floor: opts.round !== false && opts.floor !== false
    });
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  toHuman(opts = {}) {
    const l2 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter(__spreadProps(__spreadValues({ style: "unit", unitDisplay: "long" }, opts), { unit: unit.slice(0, -1) })).format(val);
    }).filter((n3) => n3);
    return this.loc.listFormatter(__spreadValues({ type: "conjunction", style: opts.listStyle || "narrow" }, opts)).format(l2);
  }
  toObject() {
    if (!this.isValid)
      return {};
    return __spreadValues({}, this.values);
  }
  toISO() {
    if (!this.isValid)
      return null;
    let s2 = "P";
    if (this.years !== 0)
      s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s2 += this.weeks + "W";
    if (this.days !== 0)
      s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0)
      s2 += this.hours + "H";
    if (this.minutes !== 0)
      s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P")
      s2 += "T0S";
    return s2;
  }
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = __spreadValues({
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended"
    }, opts);
    const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
      fmt += opts.format === "basic" ? "ss" : ":ss";
      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }
    let str = value.toFormat(fmt);
    if (opts.includePrefix) {
      str = "T" + str;
    }
    return str;
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  toMillis() {
    return this.as("milliseconds");
  }
  valueOf() {
    return this.toMillis();
  }
  plus(duration2) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration2), result = {};
    for (const k of orderedUnits) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone2(this, { values: result }, true);
  }
  minus(duration2) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration2);
    return this.plus(dur.negate());
  }
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone2(this, { values: result }, true);
  }
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  set(values2) {
    if (!this.isValid)
      return this;
    const mixed = __spreadValues(__spreadValues({}, this.values), normalizeObject(values2, Duration.normalizeUnit));
    return clone2(this, { values: mixed });
  }
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone2(this, opts);
  }
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone2(this, { values: vals }, true);
  }
  rescale() {
    if (!this.isValid)
      return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone2(this, { values: vals }, true);
  }
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber2(vals[k])) {
          own += vals[k];
        }
        const i2 = Math.trunc(own);
        built[k] = i2;
        accumulated[k] = (own * 1e3 - i2 * 1e3) / 1e3;
        for (const down in vals) {
          if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {
            convert(this.matrix, vals, down, built, k);
          }
        }
      } else if (isNumber2(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    return clone2(this, { values: built }, true).normalize();
  }
  shiftToAll() {
    if (!this.isValid)
      return this;
    return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
  }
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone2(this, { values: negated }, true);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq2(v1, v2) {
      if (v1 === void 0 || v1 === 0)
        return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq2(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/luxon/src/interval.js
var INVALID2 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
  } else {
    return null;
  }
}
var Interval = class {
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  static after(start, duration2) {
    const dur = Duration.fromDurationLike(duration2), dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  static before(end, duration2) {
    const dur = Duration.fromDurationLike(duration2), dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  static fromISO(text, opts) {
    const [s2, e] = (text || "").split("/", 2);
    if (s2 && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e2) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e2) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  count(unit = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const start = this.start.startOf(unit), end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  set({ start, end } = {}) {
    if (!this.isValid)
      return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort(), results = [];
    let { s: s2 } = this, i2 = 0;
    while (s2 < this.e) {
      const added = sorted[i2] || this.e, next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      i2 += 1;
    }
    return results;
  }
  splitBy(duration2) {
    const dur = Duration.fromDurationLike(duration2);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  intersection(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
    if (s2 >= e) {
      return null;
    } else {
      return Interval.fromDateTimes(s2, e);
    }
  }
  union(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s2, e);
  }
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(([sofar, current], item) => {
      if (!current) {
        return [sofar, item];
      } else if (current.overlaps(item) || current.abutsStart(item)) {
        return [sofar, current.union(item)];
      } else {
        return [sofar.concat([current]), item];
      }
    }, [[], null]);
    if (final) {
      found.push(final);
    }
    return found;
  }
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i2) => [
      { time: i2.s, type: "s" },
      { time: i2.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
    for (const i2 of arr) {
      currentCount += i2.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i2.time;
      } else {
        if (start && +start !== +i2.time) {
          results.push(Interval.fromDateTimes(start, i2.time));
        }
        start = null;
      }
    }
    return Interval.merge(results);
  }
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i2) => this.intersection(i2)).filter((i2) => i2 && !i2.isEmpty());
  }
  toString() {
    if (!this.isValid)
      return INVALID2;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID2;
  }
  toISO(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  toISODate() {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// node_modules/luxon/src/info.js
var Info = class {
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  static normalizeZone(input2) {
    return normalizeZone(input2, Settings.defaultZone);
  }
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  static features() {
    return { relative: hasRelative() };
  }
};

// node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter((u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0);
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration2 = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration2);
  } else {
    return duration2;
  }
}

// node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i2 = 0; i2 < str.length; i2++) {
      const code = str.charCodeAt(i2);
      if (str[i2].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i2]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}

// node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i2) => i2) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i2) => stripInsensitivities(s2) === stripInsensitivities(i2)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
    if (token.literal) {
      return literal(t);
    }
    switch (t.val) {
      case "G":
        return oneOf(loc.eras("short", false), 0);
      case "GG":
        return oneOf(loc.eras("long", false), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true, false), 1);
      case "MMMM":
        return oneOf(loc.months("long", true, false), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false, false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false, false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false, false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false, false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true, false), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true, false), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal(t);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts) {
  const { type, value } = part;
  if (type === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type];
  let val = partTypeStyleToTokenVal[type];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input2, regex, handlers) {
  const matches = input2.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i2 in handlers) {
      if (hasOwnProperty(handlers, i2)) {
        const h = handlers[i2], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
}
function explainFromTokens(locale, input2, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t) => unitForToken(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
  if (disqualifyingUnit) {
    return { input: input2, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input2, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
    }
    return { input: input2, tokens, regex, rawMatches, matches, result, zone, specificOffset };
  }
}
function parseFromTokens(locale, input2, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input2, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  return parts.map((p) => tokenForPart(p, formatOpts));
}

// node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid("unit out of range", `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`);
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i2) => i2 < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return __spreadValues({ weekYear, weekNumber, weekday }, timeObject(gregObj));
}
function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return __spreadValues({ year, month, day }, timeObject(weekData));
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return __spreadValues({ year, ordinal }, timeObject(gregData));
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return __spreadValues({ year, month, day }, timeObject(ordinalData));
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}

// node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function clone3(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime(__spreadProps(__spreadValues(__spreadValues({}, current), alts), { old: current }));
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = __spreadProps(__spreadValues({}, inst.c), {
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }), millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, __spreadProps(__spreadValues({}, opts), {
      zone: interpretationZone,
      specificOffset
    }));
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`));
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0)
    c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit);
  return normalized;
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits2) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start, end, opts) {
  const round2 = isUndefined(opts.round) ? true : opts.round, format = (c, unit) => {
    c = roundTo(c, round2 || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else
        return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var DateTime = class {
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null, o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  static now() {
    return new DateTime({});
  }
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  static fromJSDate(date2, options = {}) {
    const ts = isDate(date2) ? date2.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber2(milliseconds)) {
      throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  static fromSeconds(seconds, options = {}) {
    if (!isNumber2(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
    }
    return inst;
  }
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
  }
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t) => t.val).join("");
  }
  get(unit) {
    return this[unit];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone3(this, { ts: newTS, zone });
    }
  }
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone3(this, { loc });
  }
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  set(values2) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values2, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(__spreadValues(__spreadValues({}, gregorianToWeek(this.c)), normalized));
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian(__spreadValues(__spreadValues({}, gregorianToOrdinal(this.c)), normalized));
    } else {
      mixed = __spreadValues(__spreadValues({}, this.toObject()), normalized);
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone3(this, { ts, o });
  }
  plus(duration2) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration2);
    return clone3(this, adjustTime(this, dur));
  }
  minus(duration2) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration2).negate();
    return clone3(this, adjustTime(this, dur));
  }
  startOf(unit) {
    if (!this.isValid)
      return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  endOf(unit) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
  }
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
  }
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base = __spreadValues({}, this.c);
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = __spreadValues({ locale: this.locale, numberingSystem: this.numberingSystem }, opts);
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  hasSame(otherDateTime, unit) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
  }
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base, this.plus(padding), __spreadProps(__spreadValues({}, options), {
      numeric: "always",
      units,
      unit
    }));
  }
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, __spreadProps(__spreadValues({}, options), {
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    }));
  }
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i2) => i2.valueOf(), Math.min);
  }
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i2) => i2.valueOf(), Math.max);
  }
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  static get DATE_MED() {
    return DATE_MED;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  static get DATE_FULL() {
    return DATE_FULL;
  }
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
  }
}

// node_modules/chartjs-adapter-luxon/dist/chartjs-adapter-luxon.esm.js
var FORMATS = {
  datetime: DateTime.DATETIME_MED_WITH_SECONDS,
  millisecond: "h:mm:ss.SSS a",
  second: DateTime.TIME_WITH_SECONDS,
  minute: DateTime.TIME_SIMPLE,
  hour: { hour: "numeric" },
  day: { day: "numeric", month: "short" },
  week: "DD",
  month: { month: "short", year: "numeric" },
  quarter: "'Q'q - yyyy",
  year: { year: "numeric" }
};
adapters._date.override({
  _id: "luxon",
  _create: function(time2) {
    return DateTime.fromMillis(time2, this.options);
  },
  init(chartOptions) {
    if (!this.options.locale) {
      this.options.locale = chartOptions.locale;
    }
  },
  formats: function() {
    return FORMATS;
  },
  parse: function(value, format) {
    const options = this.options;
    const type = typeof value;
    if (value === null || type === "undefined") {
      return null;
    }
    if (type === "number") {
      value = this._create(value);
    } else if (type === "string") {
      if (typeof format === "string") {
        value = DateTime.fromFormat(value, format, options);
      } else {
        value = DateTime.fromISO(value, options);
      }
    } else if (value instanceof Date) {
      value = DateTime.fromJSDate(value, options);
    } else if (type === "object" && !(value instanceof DateTime)) {
      value = DateTime.fromObject(value, options);
    }
    return value.isValid ? value.valueOf() : null;
  },
  format: function(time2, format) {
    const datetime2 = this._create(time2);
    return typeof format === "string" ? datetime2.toFormat(format) : datetime2.toLocaleString(format);
  },
  add: function(time2, amount, unit) {
    const args = {};
    args[unit] = amount;
    return this._create(time2).plus(args).valueOf();
  },
  diff: function(max, min, unit) {
    return this._create(max).diff(this._create(min)).as(unit).valueOf();
  },
  startOf: function(time2, unit, weekday) {
    if (unit === "isoWeek") {
      weekday = Math.trunc(Math.min(Math.max(0, weekday), 6));
      const dateTime = this._create(time2);
      return dateTime.minus({ days: (dateTime.weekday - weekday + 7) % 7 }).startOf("day").valueOf();
    }
    return unit ? this._create(time2).startOf(unit).valueOf() : time2;
  },
  endOf: function(time2, unit) {
    return this._create(time2).endOf(unit).valueOf();
  }
});

// node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js
var import_hammerjs = __toModule(require_hammer());
var getModifierKey = (opts) => opts && opts.enabled && opts.modifierKey;
var keyPressed = (key, event) => key && event[key + "Key"];
var keyNotPressed = (key, event) => key && !event[key + "Key"];
function directionEnabled(mode, dir, chart) {
  if (mode === void 0) {
    return true;
  } else if (typeof mode === "string") {
    return mode.indexOf(dir) !== -1;
  } else if (typeof mode === "function") {
    return mode({ chart }).indexOf(dir) !== -1;
  }
  return false;
}
function debounce2(fn, delay) {
  let timeout;
  return function() {
    clearTimeout(timeout);
    timeout = setTimeout(fn, delay);
    return delay;
  };
}
function getScaleUnderPoint({ x, y }, chart) {
  const scales2 = chart.scales;
  const scaleIds = Object.keys(scales2);
  for (let i2 = 0; i2 < scaleIds.length; i2++) {
    const scale = scales2[scaleIds[i2]];
    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {
      return scale;
    }
  }
  return null;
}
function getEnabledScalesByPoint(mode, point, chart) {
  const scale = getScaleUnderPoint(point, chart);
  if (scale && directionEnabled(mode, scale.axis, chart)) {
    return [scale];
  }
  const enabledScales = [];
  each(chart.scales, function(scaleItem) {
    if (!directionEnabled(mode, scaleItem.axis, chart)) {
      enabledScales.push(scaleItem);
    }
  });
  return enabledScales;
}
var chartStates = new WeakMap();
function getState(chart) {
  let state = chartStates.get(chart);
  if (!state) {
    state = {
      originalScaleLimits: {},
      updatedScaleLimits: {},
      handlers: {},
      panDelta: {}
    };
    chartStates.set(chart, state);
  }
  return state;
}
function removeState(chart) {
  chartStates.delete(chart);
}
function zoomDelta(scale, zoom2, center) {
  const range2 = scale.max - scale.min;
  const newRange = range2 * (zoom2 - 1);
  const centerPoint = scale.isHorizontal() ? center.x : center.y;
  const minPercent = Math.max(0, Math.min(1, (scale.getValueForPixel(centerPoint) - scale.min) / range2 || 0));
  const maxPercent = 1 - minPercent;
  return {
    min: newRange * minPercent,
    max: newRange * maxPercent
  };
}
function getLimit(state, scale, scaleLimits, prop, fallback) {
  let limit = scaleLimits[prop];
  if (limit === "original") {
    const original = state.originalScaleLimits[scale.id][prop];
    limit = valueOrDefault(original.options, original.scale);
  }
  return valueOrDefault(limit, fallback);
}
function updateRange(scale, { min, max }, limits, zoom2 = false) {
  const state = getState(scale.chart);
  const { id, axis, options: scaleOpts } = scale;
  const scaleLimits = limits && (limits[id] || limits[axis]) || {};
  const { minRange = 0 } = scaleLimits;
  const minLimit = getLimit(state, scale, scaleLimits, "min", -Infinity);
  const maxLimit = getLimit(state, scale, scaleLimits, "max", Infinity);
  const cmin = Math.max(min, minLimit);
  const cmax = Math.min(max, maxLimit);
  const range2 = zoom2 ? Math.max(cmax - cmin, minRange) : scale.max - scale.min;
  if (cmax - cmin !== range2) {
    if (minLimit > cmax - range2) {
      min = cmin;
      max = cmin + range2;
    } else if (maxLimit < cmin + range2) {
      max = cmax;
      min = cmax - range2;
    } else {
      const offset2 = (range2 - cmax + cmin) / 2;
      min = cmin - offset2;
      max = cmax + offset2;
    }
  } else {
    min = cmin;
    max = cmax;
  }
  scaleOpts.min = min;
  scaleOpts.max = max;
  state.updatedScaleLimits[scale.id] = { min, max };
  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;
}
function zoomNumericalScale(scale, zoom2, center, limits) {
  const delta = zoomDelta(scale, zoom2, center);
  const newRange = { min: scale.min + delta.min, max: scale.max - delta.max };
  return updateRange(scale, newRange, limits, true);
}
var integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);
function existCategoryFromMaxZoom(scale) {
  const labels2 = scale.getLabels();
  const maxIndex = labels2.length - 1;
  if (scale.min > 0) {
    scale.min -= 1;
  }
  if (scale.max < maxIndex) {
    scale.max += 1;
  }
}
function zoomCategoryScale(scale, zoom2, center, limits) {
  const delta = zoomDelta(scale, zoom2, center);
  if (scale.min === scale.max && zoom2 < 1) {
    existCategoryFromMaxZoom(scale);
  }
  const newRange = { min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max) };
  return updateRange(scale, newRange, limits, true);
}
function scaleLength(scale) {
  return scale.isHorizontal() ? scale.width : scale.height;
}
function panCategoryScale(scale, delta, limits) {
  const labels2 = scale.getLabels();
  const lastLabelIndex = labels2.length - 1;
  let { min, max } = scale;
  const range2 = Math.max(max - min, 1);
  const stepDelta = Math.round(scaleLength(scale) / Math.max(range2, 10));
  const stepSize = Math.round(Math.abs(delta / stepDelta));
  let applied;
  if (delta < -stepDelta) {
    max = Math.min(max + stepSize, lastLabelIndex);
    min = range2 === 1 ? max : max - range2;
    applied = max === lastLabelIndex;
  } else if (delta > stepDelta) {
    min = Math.max(0, min - stepSize);
    max = range2 === 1 ? min : min + range2;
    applied = min === 0;
  }
  return updateRange(scale, { min, max }, limits) || applied;
}
var OFFSETS = {
  second: 500,
  minute: 30 * 1e3,
  hour: 30 * 60 * 1e3,
  day: 12 * 60 * 60 * 1e3,
  week: 3.5 * 24 * 60 * 60 * 1e3,
  month: 15 * 24 * 60 * 60 * 1e3,
  quarter: 60 * 24 * 60 * 60 * 1e3,
  year: 182 * 24 * 60 * 60 * 1e3
};
function panNumericalScale(scale, delta, limits, canZoom = false) {
  const { min: prevStart, max: prevEnd, options } = scale;
  const round2 = options.time && options.time.round;
  const offset2 = OFFSETS[round2] || 0;
  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset2) - delta);
  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset2) - delta);
  const { min: minLimit = -Infinity, max: maxLimit = Infinity } = canZoom && limits && limits[scale.axis] || {};
  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {
    return true;
  }
  return updateRange(scale, { min: newMin, max: newMax }, limits, canZoom);
}
function panNonLinearScale(scale, delta, limits) {
  return panNumericalScale(scale, delta, limits, true);
}
var zoomFunctions = {
  category: zoomCategoryScale,
  default: zoomNumericalScale
};
var panFunctions = {
  category: panCategoryScale,
  default: panNumericalScale,
  logarithmic: panNonLinearScale,
  timeseries: panNonLinearScale
};
function shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {
  const { id, options: { min, max } } = scale;
  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {
    return true;
  }
  const previous = updatedScaleLimits[id];
  return previous.min !== min || previous.max !== max;
}
function removeMissingScales(limits, scales2) {
  each(limits, (opt, key) => {
    if (!scales2[key]) {
      delete limits[key];
    }
  });
}
function storeOriginalScaleLimits(chart, state) {
  const { scales: scales2 } = chart;
  const { originalScaleLimits, updatedScaleLimits } = state;
  each(scales2, function(scale) {
    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {
      originalScaleLimits[scale.id] = {
        min: { scale: scale.min, options: scale.options.min },
        max: { scale: scale.max, options: scale.options.max }
      };
    }
  });
  removeMissingScales(originalScaleLimits, scales2);
  removeMissingScales(updatedScaleLimits, scales2);
  return originalScaleLimits;
}
function doZoom(scale, amount, center, limits) {
  const fn = zoomFunctions[scale.type] || zoomFunctions.default;
  callback(fn, [scale, amount, center, limits]);
}
function getCenter(chart) {
  const ca = chart.chartArea;
  return {
    x: (ca.left + ca.right) / 2,
    y: (ca.top + ca.bottom) / 2
  };
}
function zoom(chart, amount, transition = "none") {
  const { x = 1, y = 1, focalPoint = getCenter(chart) } = typeof amount === "number" ? { x: amount, y: amount } : amount;
  const state = getState(chart);
  const { options: { limits, zoom: zoomOptions } } = state;
  const { mode = "xy", overScaleMode } = zoomOptions || {};
  storeOriginalScaleLimits(chart, state);
  const xEnabled = x !== 1 && directionEnabled(mode, "x", chart);
  const yEnabled = y !== 1 && directionEnabled(mode, "y", chart);
  const enabledScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, focalPoint, chart);
  each(enabledScales || chart.scales, function(scale) {
    if (scale.isHorizontal() && xEnabled) {
      doZoom(scale, x, focalPoint, limits);
    } else if (!scale.isHorizontal() && yEnabled) {
      doZoom(scale, y, focalPoint, limits);
    }
  });
  chart.update(transition);
  callback(zoomOptions.onZoom, [{ chart }]);
}
function getRange(scale, pixel0, pixel1) {
  const v0 = scale.getValueForPixel(pixel0);
  const v1 = scale.getValueForPixel(pixel1);
  return {
    min: Math.min(v0, v1),
    max: Math.max(v0, v1)
  };
}
function zoomRect(chart, p0, p1, transition = "none") {
  const state = getState(chart);
  const { options: { limits, zoom: zoomOptions } } = state;
  const { mode = "xy" } = zoomOptions;
  storeOriginalScaleLimits(chart, state);
  const xEnabled = directionEnabled(mode, "x", chart);
  const yEnabled = directionEnabled(mode, "y", chart);
  each(chart.scales, function(scale) {
    if (scale.isHorizontal() && xEnabled) {
      updateRange(scale, getRange(scale, p0.x, p1.x), limits, true);
    } else if (!scale.isHorizontal() && yEnabled) {
      updateRange(scale, getRange(scale, p0.y, p1.y), limits, true);
    }
  });
  chart.update(transition);
  callback(zoomOptions.onZoom, [{ chart }]);
}
function zoomScale(chart, scaleId, range2, transition = "none") {
  storeOriginalScaleLimits(chart, getState(chart));
  const scale = chart.scales[scaleId];
  updateRange(scale, range2, void 0, true);
  chart.update(transition);
}
function resetZoom(chart, transition = "default") {
  const state = getState(chart);
  const originalScaleLimits = storeOriginalScaleLimits(chart, state);
  each(chart.scales, function(scale) {
    const scaleOptions = scale.options;
    if (originalScaleLimits[scale.id]) {
      scaleOptions.min = originalScaleLimits[scale.id].min.options;
      scaleOptions.max = originalScaleLimits[scale.id].max.options;
    } else {
      delete scaleOptions.min;
      delete scaleOptions.max;
    }
  });
  chart.update(transition);
  callback(state.options.zoom.onZoomComplete, [{ chart }]);
}
function getOriginalRange(state, scaleId) {
  const original = state.originalScaleLimits[scaleId];
  if (!original) {
    return;
  }
  const { min, max } = original;
  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);
}
function getZoomLevel(chart) {
  const state = getState(chart);
  let min = 1;
  let max = 1;
  each(chart.scales, function(scale) {
    const origRange = getOriginalRange(state, scale.id);
    if (origRange) {
      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;
      min = Math.min(min, level);
      max = Math.max(max, level);
    }
  });
  return min < 1 ? min : max;
}
function panScale(scale, delta, limits, state) {
  const { panDelta } = state;
  const storedDelta = panDelta[scale.id] || 0;
  if (sign(storedDelta) === sign(delta)) {
    delta += storedDelta;
  }
  const fn = panFunctions[scale.type] || panFunctions.default;
  if (callback(fn, [scale, delta, limits])) {
    panDelta[scale.id] = 0;
  } else {
    panDelta[scale.id] = delta;
  }
}
function pan(chart, delta, enabledScales, transition = "none") {
  const { x = 0, y = 0 } = typeof delta === "number" ? { x: delta, y: delta } : delta;
  const state = getState(chart);
  const { options: { pan: panOptions, limits } } = state;
  const { mode = "xy", onPan } = panOptions || {};
  storeOriginalScaleLimits(chart, state);
  const xEnabled = x !== 0 && directionEnabled(mode, "x", chart);
  const yEnabled = y !== 0 && directionEnabled(mode, "y", chart);
  each(enabledScales || chart.scales, function(scale) {
    if (scale.isHorizontal() && xEnabled) {
      panScale(scale, x, limits, state);
    } else if (!scale.isHorizontal() && yEnabled) {
      panScale(scale, y, limits, state);
    }
  });
  chart.update(transition);
  callback(onPan, [{ chart }]);
}
function getInitialScaleBounds(chart) {
  const state = getState(chart);
  const scaleBounds = {};
  for (const scaleId of Object.keys(chart.scales)) {
    const { min, max } = state.originalScaleLimits[scaleId] || { min: {}, max: {} };
    scaleBounds[scaleId] = { min: min.scale, max: max.scale };
  }
  return scaleBounds;
}
function isZoomedOrPanned(chart) {
  const scaleBounds = getInitialScaleBounds(chart);
  for (const scaleId of Object.keys(chart.scales)) {
    const { min: originalMin, max: originalMax } = scaleBounds[scaleId];
    if (originalMin !== void 0 && chart.scales[scaleId].min !== originalMin) {
      return true;
    }
    if (originalMax !== void 0 && chart.scales[scaleId].max !== originalMax) {
      return true;
    }
  }
  return false;
}
function removeHandler(chart, type) {
  const { handlers } = getState(chart);
  const handler = handlers[type];
  if (handler && handler.target) {
    handler.target.removeEventListener(type, handler);
    delete handlers[type];
  }
}
function addHandler(chart, target, type, handler) {
  const { handlers, options } = getState(chart);
  const oldHandler = handlers[type];
  if (oldHandler && oldHandler.target === target) {
    return;
  }
  removeHandler(chart, type);
  handlers[type] = (event) => handler(chart, event, options);
  handlers[type].target = target;
  target.addEventListener(type, handlers[type]);
}
function mouseMove(chart, event) {
  const state = getState(chart);
  if (state.dragStart) {
    state.dragging = true;
    state.dragEnd = event;
    chart.update("none");
  }
}
function zoomStart(chart, event, zoomOptions) {
  const { onZoomStart, onZoomRejected } = zoomOptions;
  if (onZoomStart) {
    const { left: offsetX, top: offsetY } = event.target.getBoundingClientRect();
    const point = {
      x: event.clientX - offsetX,
      y: event.clientY - offsetY
    };
    if (callback(onZoomStart, [{ chart, event, point }]) === false) {
      callback(onZoomRejected, [{ chart, event }]);
      return false;
    }
  }
}
function mouseDown(chart, event) {
  const state = getState(chart);
  const { pan: panOptions, zoom: zoomOptions = {} } = state.options;
  if (keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {
    return callback(zoomOptions.onZoomRejected, [{ chart, event }]);
  }
  if (zoomStart(chart, event, zoomOptions) === false) {
    return;
  }
  state.dragStart = event;
  addHandler(chart, chart.canvas, "mousemove", mouseMove);
}
function computeDragRect(chart, mode, beginPoint, endPoint) {
  const { left: offsetX, top: offsetY } = beginPoint.target.getBoundingClientRect();
  const xEnabled = directionEnabled(mode, "x", chart);
  const yEnabled = directionEnabled(mode, "y", chart);
  let { top, left, right, bottom, width: chartWidth, height: chartHeight } = chart.chartArea;
  if (xEnabled) {
    left = Math.min(beginPoint.clientX, endPoint.clientX) - offsetX;
    right = Math.max(beginPoint.clientX, endPoint.clientX) - offsetX;
  }
  if (yEnabled) {
    top = Math.min(beginPoint.clientY, endPoint.clientY) - offsetY;
    bottom = Math.max(beginPoint.clientY, endPoint.clientY) - offsetY;
  }
  const width = right - left;
  const height = bottom - top;
  return {
    left,
    top,
    right,
    bottom,
    width,
    height,
    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,
    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1
  };
}
function mouseUp(chart, event) {
  const state = getState(chart);
  if (!state.dragStart) {
    return;
  }
  removeHandler(chart, "mousemove");
  const { mode, onZoomComplete, drag: { threshold = 0 } } = state.options.zoom;
  const rect = computeDragRect(chart, mode, state.dragStart, event);
  const distanceX = directionEnabled(mode, "x", chart) ? rect.width : 0;
  const distanceY = directionEnabled(mode, "y", chart) ? rect.height : 0;
  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
  state.dragStart = state.dragEnd = null;
  if (distance <= threshold) {
    state.dragging = false;
    chart.update("none");
    return;
  }
  zoomRect(chart, { x: rect.left, y: rect.top }, { x: rect.right, y: rect.bottom }, "zoom");
  setTimeout(() => state.dragging = false, 500);
  callback(onZoomComplete, [{ chart }]);
}
function wheelPreconditions(chart, event, zoomOptions) {
  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {
    callback(zoomOptions.onZoomRejected, [{ chart, event }]);
    return;
  }
  if (zoomStart(chart, event, zoomOptions) === false) {
    return;
  }
  if (event.cancelable) {
    event.preventDefault();
  }
  if (event.deltaY === void 0) {
    return;
  }
  return true;
}
function wheel(chart, event) {
  const { handlers: { onZoomComplete }, options: { zoom: zoomOptions } } = getState(chart);
  if (!wheelPreconditions(chart, event, zoomOptions)) {
    return;
  }
  const rect = event.target.getBoundingClientRect();
  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);
  const amount = {
    x: speed,
    y: speed,
    focalPoint: {
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    }
  };
  zoom(chart, amount);
  if (onZoomComplete) {
    onZoomComplete();
  }
}
function addDebouncedHandler(chart, name, handler, delay) {
  if (handler) {
    getState(chart).handlers[name] = debounce2(() => callback(handler, [{ chart }]), delay);
  }
}
function addListeners(chart, options) {
  const canvas = chart.canvas;
  const { wheel: wheelOptions, drag: dragOptions, onZoomComplete } = options.zoom;
  if (wheelOptions.enabled) {
    addHandler(chart, canvas, "wheel", wheel);
    addDebouncedHandler(chart, "onZoomComplete", onZoomComplete, 250);
  } else {
    removeHandler(chart, "wheel");
  }
  if (dragOptions.enabled) {
    addHandler(chart, canvas, "mousedown", mouseDown);
    addHandler(chart, canvas.ownerDocument, "mouseup", mouseUp);
  } else {
    removeHandler(chart, "mousedown");
    removeHandler(chart, "mousemove");
    removeHandler(chart, "mouseup");
  }
}
function removeListeners(chart) {
  removeHandler(chart, "mousedown");
  removeHandler(chart, "mousemove");
  removeHandler(chart, "mouseup");
  removeHandler(chart, "wheel");
  removeHandler(chart, "click");
}
function createEnabler(chart, state) {
  return function(recognizer, event) {
    const { pan: panOptions, zoom: zoomOptions = {} } = state.options;
    if (!panOptions || !panOptions.enabled) {
      return false;
    }
    const srcEvent = event && event.srcEvent;
    if (!srcEvent) {
      return true;
    }
    if (!state.panning && event.pointerType === "mouse" && (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))) {
      callback(panOptions.onPanRejected, [{ chart, event }]);
      return false;
    }
    return true;
  };
}
function pinchAxes(p0, p1) {
  const pinchX = Math.abs(p0.clientX - p1.clientX);
  const pinchY = Math.abs(p0.clientY - p1.clientY);
  const p = pinchX / pinchY;
  let x, y;
  if (p > 0.3 && p < 1.7) {
    x = y = true;
  } else if (pinchX > pinchY) {
    x = true;
  } else {
    y = true;
  }
  return { x, y };
}
function handlePinch(chart, state, e) {
  if (state.scale) {
    const { center, pointers } = e;
    const zoomPercent = 1 / state.scale * e.scale;
    const rect = e.target.getBoundingClientRect();
    const pinch = pinchAxes(pointers[0], pointers[1]);
    const mode = state.options.zoom.mode;
    const amount = {
      x: pinch.x && directionEnabled(mode, "x", chart) ? zoomPercent : 1,
      y: pinch.y && directionEnabled(mode, "y", chart) ? zoomPercent : 1,
      focalPoint: {
        x: center.x - rect.left,
        y: center.y - rect.top
      }
    };
    zoom(chart, amount);
    state.scale = e.scale;
  }
}
function startPinch(chart, state) {
  if (state.options.zoom.pinch.enabled) {
    state.scale = 1;
  }
}
function endPinch(chart, state, e) {
  if (state.scale) {
    handlePinch(chart, state, e);
    state.scale = null;
    callback(state.options.zoom.onZoomComplete, [{ chart }]);
  }
}
function handlePan(chart, state, e) {
  const delta = state.delta;
  if (delta) {
    state.panning = true;
    pan(chart, { x: e.deltaX - delta.x, y: e.deltaY - delta.y }, state.panScales);
    state.delta = { x: e.deltaX, y: e.deltaY };
  }
}
function startPan(chart, state, event) {
  const { enabled, overScaleMode, onPanStart, onPanRejected } = state.options.pan;
  if (!enabled) {
    return;
  }
  const rect = event.target.getBoundingClientRect();
  const point = {
    x: event.center.x - rect.left,
    y: event.center.y - rect.top
  };
  if (callback(onPanStart, [{ chart, event, point }]) === false) {
    return callback(onPanRejected, [{ chart, event }]);
  }
  state.panScales = overScaleMode && getEnabledScalesByPoint(overScaleMode, point, chart);
  state.delta = { x: 0, y: 0 };
  clearTimeout(state.panEndTimeout);
  handlePan(chart, state, event);
}
function endPan(chart, state) {
  state.delta = null;
  if (state.panning) {
    state.panEndTimeout = setTimeout(() => state.panning = false, 500);
    callback(state.options.pan.onPanComplete, [{ chart }]);
  }
}
var hammers = new WeakMap();
function startHammer(chart, options) {
  const state = getState(chart);
  const canvas = chart.canvas;
  const { pan: panOptions, zoom: zoomOptions } = options;
  const mc = new import_hammerjs.default.Manager(canvas);
  if (zoomOptions && zoomOptions.pinch.enabled) {
    mc.add(new import_hammerjs.default.Pinch());
    mc.on("pinchstart", () => startPinch(chart, state));
    mc.on("pinch", (e) => handlePinch(chart, state, e));
    mc.on("pinchend", (e) => endPinch(chart, state, e));
  }
  if (panOptions && panOptions.enabled) {
    mc.add(new import_hammerjs.default.Pan({
      threshold: panOptions.threshold,
      enable: createEnabler(chart, state)
    }));
    mc.on("panstart", (e) => startPan(chart, state, e));
    mc.on("panmove", (e) => handlePan(chart, state, e));
    mc.on("panend", () => endPan(chart, state));
  }
  hammers.set(chart, mc);
}
function stopHammer(chart) {
  const mc = hammers.get(chart);
  if (mc) {
    mc.remove("pinchstart");
    mc.remove("pinch");
    mc.remove("pinchend");
    mc.remove("panstart");
    mc.remove("pan");
    mc.remove("panend");
    mc.destroy();
    hammers.delete(chart);
  }
}
var version2 = "1.2.1";
var plugin = {
  id: "zoom",
  version: version2,
  defaults: {
    pan: {
      enabled: false,
      mode: "xy",
      threshold: 10,
      modifierKey: null
    },
    zoom: {
      wheel: {
        enabled: false,
        speed: 0.1,
        modifierKey: null
      },
      drag: {
        enabled: false,
        modifierKey: null
      },
      pinch: {
        enabled: false
      },
      mode: "xy"
    }
  },
  start: function(chart, _args, options) {
    const state = getState(chart);
    state.options = options;
    if (Object.prototype.hasOwnProperty.call(options.zoom, "enabled")) {
      console.warn("The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.");
    }
    if (import_hammerjs.default) {
      startHammer(chart, options);
    }
    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);
    chart.zoom = (args, transition) => zoom(chart, args, transition);
    chart.zoomScale = (id, range2, transition) => zoomScale(chart, id, range2, transition);
    chart.resetZoom = (transition) => resetZoom(chart, transition);
    chart.getZoomLevel = () => getZoomLevel(chart);
    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);
    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);
  },
  beforeEvent(chart) {
    const state = getState(chart);
    if (state.panning || state.dragging) {
      return false;
    }
  },
  beforeUpdate: function(chart, args, options) {
    const state = getState(chart);
    state.options = options;
    addListeners(chart, options);
  },
  beforeDatasetsDraw: function(chart, args, options) {
    const { dragStart, dragEnd } = getState(chart);
    if (dragEnd) {
      const { left, top, width, height } = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);
      const dragOptions = options.zoom.drag;
      const ctx = chart.ctx;
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = dragOptions.backgroundColor || "rgba(225,225,225,0.3)";
      ctx.fillRect(left, top, width, height);
      if (dragOptions.borderWidth > 0) {
        ctx.lineWidth = dragOptions.borderWidth;
        ctx.strokeStyle = dragOptions.borderColor || "rgba(225,225,225)";
        ctx.strokeRect(left, top, width, height);
      }
      ctx.restore();
    }
  },
  stop: function(chart) {
    removeListeners(chart);
    if (import_hammerjs.default) {
      stopHammer(chart);
    }
    removeState(chart);
  },
  panFunctions,
  zoomFunctions
};

// js/components/utils.js
function sendFileToClient(url2, filename) {
  var link2 = document.createElement("a");
  link2.setAttribute("href", url2);
  link2.setAttribute("download", filename);
  link2.style.visibility = "hidden";
  link2.setAttribute("target", "_blank");
  document.body.appendChild(link2);
  link2.click();
  document.body.removeChild(link2);
}

// js/components/chartjs_hook.js
var colors2 = ["#fd7f6f", "#7eb0d5", "#b2e061", "#bd7ebe", "#ffb55a", "#ffee65", "#beb9db", "#fdcce5", "#8bd3c7"];
plugin_tooltip.positioners.cursor = function(elements2, eventPosition) {
  return eventPosition;
};
Chart.register(plugin);
Chart.register({
  id: "nodata",
  afterDraw: function(chart, args, options) {
    var _a, _b;
    if (chart.data.datasets.length === 0) {
      chart.ctx.save();
      chart.ctx.textAlign = "center";
      chart.ctx.textBaseline = "middle";
      chart.ctx.font = "22px Arial";
      chart.ctx.fillStyle = "gray";
      chart.ctx.fillText("No data available", chart.chartArea.width / 2, chart.chartArea.height / 2);
      chart.ctx.restore();
    }
    if ((_b = (_a = chart.tooltip) == null ? void 0 : _a._active) == null ? void 0 : _b.length) {
      let x = chart.tooltip._active[0].element.x;
      let yAxis = chart.scales.y;
      let ctx = chart.ctx;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(x, yAxis.top);
      ctx.lineTo(x, yAxis.bottom);
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(0, 0, 0, 0.4)";
      ctx.stroke();
      ctx.restore();
    }
  }
});
function ChartJSHook() {
  this.mounted = function() {
    Chart.register(...registerables);
    let config = {
      type: "line",
      data: {
        datasets: []
      },
      options: {
        animation: false,
        interaction: {
          mode: "x"
        },
        scales: {
          x: {
            type: "time",
            grid: {
              display: false
            },
            time: {
              minUnit: "hour",
              tooltipFormat: "yyyy-MM-dd HH:mm",
              displayFormats: {
                hour: "HH:mm",
                day: "MMM dd"
              }
            },
            ticks: {
              source: "data",
              major: {
                enabled: true
              },
              autoSkipPadding: 10,
              font: {
                size: 12
              }
            },
            adapters: {
              date: {
                setZone: true
              }
            }
          },
          y: {
            title: {
              font: {
                size: 16
              }
            },
            ticks: {
              font: {
                size: 14
              }
            },
            grid: {
              display: true
            }
          }
        },
        plugins: {
          tooltip: {
            position: "cursor",
            intersect: false,
            callbacks: {
              label: function(context) {
                let label = context.dataset.label || "";
                if (label) {
                  label += ": ";
                }
                if (context.parsed.y !== null) {
                  label += context.parsed.y + " " + context.dataset.unit;
                }
                return label;
              }
            }
          },
          legend: {
            onClick: this.legendClickHandler
          }
        }
      }
    };
    let canvas = document.getElementById(this.el.id);
    let ctx = canvas.getContext("2d");
    let time_range_selector_id = canvas.getAttribute("time-range-selector-id");
    if (time_range_selector_id !== null) {
      config.options.plugins.zoom = {
        zoom: {
          wheel: {
            enabled: false
          },
          pinch: {
            enabled: true
          },
          drag: {
            enabled: true
          },
          mode: "x",
          onZoomComplete: function(chart) {
            if (chart.chart.triggerZoomCallbacks) {
              ticks = chart.chart.scales.x.ticks;
              if (ticks.length > 0) {
                let from2 = DateTime.fromMillis(ticks[0].value).toFormat("yyyy-MM-dd'T'HH:mm:ssZZ");
                let to2 = DateTime.fromMillis(ticks[ticks.length - 1].value).plus({ hours: 1 }).toFormat("yyyy-MM-dd'T'HH:mm:ssZZ");
                let e = new CustomEvent("zoomCompleted", { detail: { from: from2, to: to2 } });
                document.getElementById(time_range_selector_id).dispatchEvent(e);
              }
              chart.chart.triggerZoomCallbacks = false;
              chart.chart.resetZoom();
              chart.chart.triggerZoomCallbacks = true;
            }
          }
        }
      };
    }
    this.chart = new Chart(ctx, config);
    this.chart.triggerZoomCallbacks = true;
    this.handleEvent(this.el.id + "::refresh-data", this.handler());
    canvas.addEventListener("panel:" + this.el.id + ":download:csv", this.downloadCSV());
    canvas.addEventListener("panel:" + this.el.id + ":download:png", this.downloadPNG());
    document.addEventListener("keydown", (e) => {
      if (e.key === "Control") {
        this.chart.isCtrlPressed = true;
      }
    });
    document.addEventListener("keyup", (e) => {
      if (e.key === "Control") {
        this.chart.isCtrlPressed = false;
      }
    });
  };
  this.legendClickHandler = (e, legendItem, legend) => {
    if (legend.chart.isCtrlPressed) {
      this.toggleLegendItem(legendItem, legend);
      return;
    }
    if (this.allLegendItemsHidden(legend)) {
      legend.legendItems.forEach((item) => this.toggleLegendItem(item, legend));
      return;
    }
    if (legend.chart.isDatasetVisible(legendItem.datasetIndex)) {
      this.toggleOtherLegendItems(legendItem, legend);
      return;
    }
    this.highlightLegendItem(legendItem, legend);
  };
  this.toggleOtherLegendItems = (legendItem, legend) => {
    legend.legendItems.forEach((item) => {
      if (item.datasetIndex != legendItem.datasetIndex) {
        this.toggleLegendItem(item, legend);
      }
    });
  };
  this.toggleLegendItem = (legendItem, legend) => {
    if (legendItem.hidden) {
      legend.chart.show(legendItem.datasetIndex);
    } else {
      legend.chart.hide(legendItem.datasetIndex);
    }
    legendItem.hidden = !legendItem.hidden;
  };
  this.highlightLegendItem = (legendItem, legend) => {
    legend.legendItems.forEach((item) => {
      if (item.datasetIndex == legendItem.datasetIndex) {
        legend.chart.show(item.datasetIndex);
        item.hidden = false;
      } else {
        legend.chart.hide(item.datasetIndex);
        item.hidden = true;
      }
    });
  };
  this.allLegendItemsHidden = (legend) => {
    let result = true;
    for (i = 0; i < legend.legendItems.length; i++) {
      if (!legend.legendItems[i].hidden) {
        result = false;
        break;
      }
    }
    return result;
  };
  this.downloadCSV = function() {
    return (event) => {
      labels = this.chart.data.datasets.map((dataset) => {
        return '"' + dataset.label + '"';
      });
      rows = new Map();
      n = this.chart.data.datasets.length;
      this.chart.data.datasets.forEach((dataset, idx) => {
        dataset.data.forEach((row2) => {
          values = rows.get(row2.x) || Array(n).fill("");
          values[idx] = row2.y;
          rows.set(row2.x, values);
        });
      });
      csvRows = ["sep=,", '"time",' + labels.join(",")];
      rows.forEach((values2, time2) => {
        row = DateTime.fromMillis(time2).toFormat("yyyy/MM/dd'T'HH:mm:ssZZZ");
        csvRows.push(row + "," + values2.join(","));
      });
      csv = csvRows.join("\r\n");
      var blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      var url2 = URL.createObjectURL(blob);
      sendFileToClient(url2, this.el.id + ".csv");
    };
  };
  this.downloadPNG = function() {
    return (event) => {
      url = this.el.toDataURL("image/png");
      sendFileToClient(url, this.el.id + ".png");
    };
  };
  this.handler = function() {
    return (payload) => {
      n = payload.datasets.length;
      datasets = payload.datasets.map(function(dataset, idx) {
        return {
          label: dataset.label,
          unit: dataset.attrs.unit,
          borderColor: colors2[idx % colors2.length] + "FF",
          backgroundColor: colors2[idx % colors2.length] + "40",
          borderWidth: 1,
          pointRadius: 1,
          fill: dataset.attrs.fill ? "origin" : false,
          type: dataset.attrs.type,
          data: dataset.rows
        };
      });
      this.chart.data = { datasets };
      if (Array.isArray(datasets) && datasets.length > 0 && datasets[0].type === "bar") {
        this.chart.options.scales.x.offset = true;
      }
      this.chart.options.scales.x.adapters.date.zone = payload.time_zone;
      this.chart.options.scales.y.title.display = true;
      this.chart.options.scales.y.title.text = payload.ylabel;
      this.chart.options.scales.y.suggestedMin = payload.y_min_value;
      this.chart.options.scales.y.suggestedMax = payload.y_max_value;
      this.chart.options.scales.y.stacked = payload.stacked_x;
      this.chart.options.scales.x.stacked = payload.stacked_y;
      this.chart.options.scales.y.grid.display = n > 0;
      this.chart.options.scales.y.display = n > 0;
      this.chart.options.scales.x.display = n > 0;
      this.chart.update();
    };
  };
}
var chartjs_hook_default = ChartJSHook;

// node_modules/tabulator-tables/dist/js/tabulator_esm.js
var CoreFeature = class {
  constructor(table) {
    this.table = table;
  }
  reloadData(data, silent, columnsChanged) {
    return this.table.dataLoader.load(data, void 0, void 0, void 0, silent, columnsChanged);
  }
  langText() {
    return this.table.modules.localize.getText(...arguments);
  }
  langBind() {
    return this.table.modules.localize.bind(...arguments);
  }
  langLocale() {
    return this.table.modules.localize.getLocale(...arguments);
  }
  commsConnections() {
    return this.table.modules.comms.getConnections(...arguments);
  }
  commsSend() {
    return this.table.modules.comms.send(...arguments);
  }
  layoutMode() {
    return this.table.modules.layout.getMode();
  }
  layoutRefresh(force) {
    return this.table.modules.layout.layout(force);
  }
  subscribe() {
    return this.table.eventBus.subscribe(...arguments);
  }
  unsubscribe() {
    return this.table.eventBus.unsubscribe(...arguments);
  }
  subscribed(key) {
    return this.table.eventBus.subscribed(key);
  }
  subscriptionChange() {
    return this.table.eventBus.subscriptionChange(...arguments);
  }
  dispatch() {
    return this.table.eventBus.dispatch(...arguments);
  }
  chain() {
    return this.table.eventBus.chain(...arguments);
  }
  confirm() {
    return this.table.eventBus.confirm(...arguments);
  }
  dispatchExternal() {
    return this.table.externalEvents.dispatch(...arguments);
  }
  subscribedExternal(key) {
    return this.table.externalEvents.subscribed(key);
  }
  subscriptionChangeExternal() {
    return this.table.externalEvents.subscriptionChange(...arguments);
  }
  options(key) {
    return this.table.options[key];
  }
  setOption(key, value) {
    if (typeof value !== "undefined") {
      this.table.options[key] = value;
    }
    return this.table.options[key];
  }
  deprecationCheck(oldOption, newOption) {
    return this.table.deprecationAdvisor.check(oldOption, newOption);
  }
  deprecationCheckMsg(oldOption, msg) {
    return this.table.deprecationAdvisor.checkMsg(oldOption, msg);
  }
  deprecationMsg(msg) {
    return this.table.deprecationAdvisor.msg(msg);
  }
  module(key) {
    return this.table.module(key);
  }
};
var Helpers = class {
  static elVisible(el) {
    return !(el.offsetWidth <= 0 && el.offsetHeight <= 0);
  }
  static elOffset(el) {
    var box = el.getBoundingClientRect();
    return {
      top: box.top + window.pageYOffset - document.documentElement.clientTop,
      left: box.left + window.pageXOffset - document.documentElement.clientLeft
    };
  }
  static deepClone(obj, clone4, list2 = []) {
    var objectProto = {}.__proto__, arrayProto = [].__proto__;
    if (!clone4) {
      clone4 = Object.assign(Array.isArray(obj) ? [] : {}, obj);
    }
    for (var i2 in obj) {
      let subject = obj[i2], match2, copy;
      if (subject != null && typeof subject === "object" && (subject.__proto__ === objectProto || subject.__proto__ === arrayProto)) {
        match2 = list2.findIndex((item) => {
          return item.subject === subject;
        });
        if (match2 > -1) {
          clone4[i2] = list2[match2].copy;
        } else {
          copy = Object.assign(Array.isArray(subject) ? [] : {}, subject);
          list2.unshift({ subject, copy });
          clone4[i2] = this.deepClone(subject, copy, list2);
        }
      }
    }
    return clone4;
  }
};
var Popup = class extends CoreFeature {
  constructor(table, element, parent) {
    super(table);
    this.element = element;
    this.container = this._lookupContainer();
    this.parent = parent;
    this.reversedX = false;
    this.childPopup = null;
    this.blurable = false;
    this.blurCallback = null;
    this.blurEventsBound = false;
    this.renderedCallback = null;
    this.visible = false;
    this.hideable = true;
    this.element.classList.add("tabulator-popup-container");
    this.blurEvent = this.hide.bind(this, false);
    this.escEvent = this._escapeCheck.bind(this);
    this.destroyBinding = this.tableDestroyed.bind(this);
    this.destroyed = false;
  }
  tableDestroyed() {
    this.destroyed = true;
    this.hide(true);
  }
  _lookupContainer() {
    var container = this.table.options.popupContainer;
    if (typeof container === "string") {
      container = document.querySelector(container);
      if (!container) {
        console.warn("Menu Error - no container element found matching selector:", this.table.options.popupContainer, "(defaulting to document body)");
      }
    } else if (container === true) {
      container = this.table.element;
    }
    if (container && !this._checkContainerIsParent(container)) {
      container = false;
      console.warn("Menu Error - container element does not contain this table:", this.table.options.popupContainer, "(defaulting to document body)");
    }
    if (!container) {
      container = document.body;
    }
    return container;
  }
  _checkContainerIsParent(container, element = this.table.element) {
    if (container === element) {
      return true;
    } else {
      return element.parentNode ? this._checkContainerIsParent(container, element.parentNode) : false;
    }
  }
  renderCallback(callback2) {
    this.renderedCallback = callback2;
  }
  containerEventCoords(e) {
    var touch = !(e instanceof MouseEvent);
    var x = touch ? e.touches[0].pageX : e.pageX;
    var y = touch ? e.touches[0].pageY : e.pageY;
    if (this.container !== document.body) {
      let parentOffset = Helpers.elOffset(this.container);
      x -= parentOffset.left;
      y -= parentOffset.top;
    }
    return { x, y };
  }
  elementPositionCoords(element, position = "right") {
    var offset2 = Helpers.elOffset(element), containerOffset, x, y;
    if (this.container !== document.body) {
      containerOffset = Helpers.elOffset(this.container);
      offset2.left -= containerOffset.left;
      offset2.top -= containerOffset.top;
    }
    switch (position) {
      case "right":
        x = offset2.left + element.offsetWidth;
        y = offset2.top - 1;
        break;
      case "bottom":
        x = offset2.left;
        y = offset2.top + element.offsetHeight;
        break;
      case "left":
        x = offset2.left;
        y = offset2.top - 1;
        break;
      case "top":
        x = offset2.left;
        y = offset2.top;
        break;
      case "center":
        x = offset2.left + element.offsetWidth / 2;
        y = offset2.top + element.offsetHeight / 2;
        break;
    }
    return { x, y, offset: offset2 };
  }
  show(origin, position) {
    var x, y, parentEl, parentOffset, coords;
    if (this.destroyed || this.table.destroyed) {
      return this;
    }
    if (origin instanceof HTMLElement) {
      parentEl = origin;
      coords = this.elementPositionCoords(origin, position);
      parentOffset = coords.offset;
      x = coords.x;
      y = coords.y;
    } else if (typeof origin === "number") {
      parentOffset = { top: 0, left: 0 };
      x = origin;
      y = position;
    } else {
      coords = this.containerEventCoords(origin);
      x = coords.x;
      y = coords.y;
      this.reversedX = false;
    }
    this.element.style.top = y + "px";
    this.element.style.left = x + "px";
    this.container.appendChild(this.element);
    if (typeof this.renderedCallback === "function") {
      this.renderedCallback();
    }
    this._fitToScreen(x, y, parentEl, parentOffset, position);
    this.visible = true;
    this.subscribe("table-destroy", this.destroyBinding);
    this.element.addEventListener("mousedown", (e) => {
      e.stopPropagation();
    });
    return this;
  }
  _fitToScreen(x, y, parentEl, parentOffset, position) {
    var scrollTop = this.container === document.body ? document.documentElement.scrollTop : this.container.scrollTop;
    if (x + this.element.offsetWidth >= this.container.offsetWidth || this.reversedX) {
      this.element.style.left = "";
      if (parentEl) {
        this.element.style.right = this.container.offsetWidth - parentOffset.left + "px";
      } else {
        this.element.style.right = this.container.offsetWidth - x + "px";
      }
      this.reversedX = true;
    }
    if (y + this.element.offsetHeight > Math.max(this.container.offsetHeight, scrollTop ? this.container.scrollHeight : 0)) {
      if (parentEl) {
        switch (position) {
          case "bottom":
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight - parentEl.offsetHeight - 1 + "px";
            break;
          default:
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + parentEl.offsetHeight + 1 + "px";
        }
      } else {
        this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + "px";
      }
    }
  }
  isVisible() {
    return this.visible;
  }
  hideOnBlur(callback2) {
    this.blurable = true;
    if (this.visible) {
      setTimeout(() => {
        if (this.visible) {
          this.table.rowManager.element.addEventListener("scroll", this.blurEvent);
          this.subscribe("cell-editing", this.blurEvent);
          document.body.addEventListener("click", this.blurEvent);
          document.body.addEventListener("contextmenu", this.blurEvent);
          document.body.addEventListener("mousedown", this.blurEvent);
          window.addEventListener("resize", this.blurEvent);
          document.body.addEventListener("keydown", this.escEvent);
          this.blurEventsBound = true;
        }
      }, 100);
      this.blurCallback = callback2;
    }
    return this;
  }
  _escapeCheck(e) {
    if (e.keyCode == 27) {
      this.hide();
    }
  }
  blockHide() {
    this.hideable = false;
  }
  restoreHide() {
    this.hideable = true;
  }
  hide(silent = false) {
    if (this.visible && this.hideable) {
      if (this.blurable && this.blurEventsBound) {
        document.body.removeEventListener("keydown", this.escEvent);
        document.body.removeEventListener("click", this.blurEvent);
        document.body.removeEventListener("contextmenu", this.blurEvent);
        document.body.removeEventListener("mousedown", this.blurEvent);
        window.removeEventListener("resize", this.blurEvent);
        this.table.rowManager.element.removeEventListener("scroll", this.blurEvent);
        this.unsubscribe("cell-editing", this.blurEvent);
        this.blurEventsBound = false;
      }
      if (this.childPopup) {
        this.childPopup.hide();
      }
      if (this.parent) {
        this.parent.childPopup = null;
      }
      if (this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }
      this.visible = false;
      if (this.blurCallback && !silent) {
        this.blurCallback();
      }
      this.unsubscribe("table-destroy", this.destroyBinding);
    }
    return this;
  }
  child(element) {
    if (this.childPopup) {
      this.childPopup.hide();
    }
    this.childPopup = new Popup(this.table, element, this);
    return this.childPopup;
  }
};
var Module = class extends CoreFeature {
  constructor(table, name) {
    super(table);
    this._handler = null;
  }
  initialize() {
  }
  registerTableOption(key, value) {
    this.table.optionsList.register(key, value);
  }
  registerColumnOption(key, value) {
    this.table.columnManager.optionsList.register(key, value);
  }
  registerTableFunction(name, func) {
    if (typeof this.table[name] === "undefined") {
      this.table[name] = (...args) => {
        this.table.initGuard(name);
        return func(...args);
      };
    } else {
      console.warn("Unable to bind table function, name already in use", name);
    }
  }
  registerComponentFunction(component, func, handler) {
    return this.table.componentFunctionBinder.bind(component, func, handler);
  }
  registerDataHandler(handler, priority) {
    this.table.rowManager.registerDataPipelineHandler(handler, priority);
    this._handler = handler;
  }
  registerDisplayHandler(handler, priority) {
    this.table.rowManager.registerDisplayPipelineHandler(handler, priority);
    this._handler = handler;
  }
  displayRows(adjust) {
    var index2 = this.table.rowManager.displayRows.length - 1, lookupIndex;
    if (this._handler) {
      lookupIndex = this.table.rowManager.displayPipeline.findIndex((item) => {
        return item.handler === this._handler;
      });
      if (lookupIndex > -1) {
        index2 = lookupIndex;
      }
    }
    if (adjust) {
      index2 = index2 + adjust;
    }
    if (this._handler) {
      if (index2 > -1) {
        return this.table.rowManager.getDisplayRows(index2);
      } else {
        return this.activeRows();
      }
    }
  }
  activeRows() {
    return this.table.rowManager.activeRows;
  }
  refreshData(renderInPosition, handler) {
    if (!handler) {
      handler = this._handler;
    }
    if (handler) {
      this.table.rowManager.refreshActiveData(handler, false, renderInPosition);
    }
  }
  footerAppend(element) {
    return this.table.footerManager.append(element);
  }
  footerPrepend(element) {
    return this.table.footerManager.prepend(element);
  }
  footerRemove(element) {
    return this.table.footerManager.remove(element);
  }
  popup(menuEl, menuContainer) {
    return new Popup(this.table, menuEl, menuContainer);
  }
  alert(content, type) {
    return this.table.alertManager.alert(content, type);
  }
  clearAlert() {
    return this.table.alertManager.clear();
  }
};
var defaultAccessors = {};
var Accessor = class extends Module {
  constructor(table) {
    super(table);
    this.allowedTypes = ["", "data", "download", "clipboard", "print", "htmlOutput"];
    this.registerColumnOption("accessor");
    this.registerColumnOption("accessorParams");
    this.registerColumnOption("accessorData");
    this.registerColumnOption("accessorDataParams");
    this.registerColumnOption("accessorDownload");
    this.registerColumnOption("accessorDownloadParams");
    this.registerColumnOption("accessorClipboard");
    this.registerColumnOption("accessorClipboardParams");
    this.registerColumnOption("accessorPrint");
    this.registerColumnOption("accessorPrintParams");
    this.registerColumnOption("accessorHtmlOutput");
    this.registerColumnOption("accessorHtmlOutputParams");
  }
  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this));
    this.subscribe("row-data-retrieve", this.transformRow.bind(this));
  }
  initializeColumn(column) {
    var match2 = false, config = {};
    this.allowedTypes.forEach((type) => {
      var key = "accessor" + (type.charAt(0).toUpperCase() + type.slice(1)), accessor;
      if (column.definition[key]) {
        accessor = this.lookupAccessor(column.definition[key]);
        if (accessor) {
          match2 = true;
          config[key] = {
            accessor,
            params: column.definition[key + "Params"] || {}
          };
        }
      }
    });
    if (match2) {
      column.modules.accessor = config;
    }
  }
  lookupAccessor(value) {
    var accessor = false;
    switch (typeof value) {
      case "string":
        if (Accessor.accessors[value]) {
          accessor = Accessor.accessors[value];
        } else {
          console.warn("Accessor Error - No such accessor found, ignoring: ", value);
        }
        break;
      case "function":
        accessor = value;
        break;
    }
    return accessor;
  }
  transformRow(row2, type) {
    var key = "accessor" + (type.charAt(0).toUpperCase() + type.slice(1)), rowComponent = row2.getComponent();
    var data = Helpers.deepClone(row2.data || {});
    this.table.columnManager.traverse(function(column) {
      var value, accessor, params, colComponent;
      if (column.modules.accessor) {
        accessor = column.modules.accessor[key] || column.modules.accessor.accessor || false;
        if (accessor) {
          value = column.getFieldValue(data);
          if (value != "undefined") {
            colComponent = column.getComponent();
            params = typeof accessor.params === "function" ? accessor.params(value, data, type, colComponent, rowComponent) : accessor.params;
            column.setFieldValue(data, accessor.accessor(value, data, type, params, colComponent, rowComponent));
          }
        }
      }
    });
    return data;
  }
};
Accessor.moduleName = "accessor";
Accessor.accessors = defaultAccessors;
var defaultConfig = {
  method: "GET"
};
function generateParamsList(data, prefix) {
  var output = [];
  prefix = prefix || "";
  if (Array.isArray(data)) {
    data.forEach((item, i2) => {
      output = output.concat(generateParamsList(item, prefix ? prefix + "[" + i2 + "]" : i2));
    });
  } else if (typeof data === "object") {
    for (var key in data) {
      output = output.concat(generateParamsList(data[key], prefix ? prefix + "[" + key + "]" : key));
    }
  } else {
    output.push({ key: prefix, value: data });
  }
  return output;
}
function serializeParams(params) {
  var output = generateParamsList(params), encoded = [];
  output.forEach(function(item) {
    encoded.push(encodeURIComponent(item.key) + "=" + encodeURIComponent(item.value));
  });
  return encoded.join("&");
}
function urlBuilder(url2, config, params) {
  if (url2) {
    if (params && Object.keys(params).length) {
      if (!config.method || config.method.toLowerCase() == "get") {
        config.method = "get";
        url2 += (url2.includes("?") ? "&" : "?") + serializeParams(params);
      }
    }
  }
  return url2;
}
function defaultLoaderPromise(url2, config, params) {
  var contentType;
  return new Promise((resolve2, reject) => {
    url2 = this.urlGenerator.call(this.table, url2, config, params);
    if (config.method.toUpperCase() != "GET") {
      contentType = typeof this.table.options.ajaxContentType === "object" ? this.table.options.ajaxContentType : this.contentTypeFormatters[this.table.options.ajaxContentType];
      if (contentType) {
        for (var key in contentType.headers) {
          if (!config.headers) {
            config.headers = {};
          }
          if (typeof config.headers[key] === "undefined") {
            config.headers[key] = contentType.headers[key];
          }
        }
        config.body = contentType.body.call(this, url2, config, params);
      } else {
        console.warn("Ajax Error - Invalid ajaxContentType value:", this.table.options.ajaxContentType);
      }
    }
    if (url2) {
      if (typeof config.headers === "undefined") {
        config.headers = {};
      }
      if (typeof config.headers.Accept === "undefined") {
        config.headers.Accept = "application/json";
      }
      if (typeof config.headers["X-Requested-With"] === "undefined") {
        config.headers["X-Requested-With"] = "XMLHttpRequest";
      }
      if (typeof config.mode === "undefined") {
        config.mode = "cors";
      }
      if (config.mode == "cors") {
        if (typeof config.headers["Origin"] === "undefined") {
          config.headers["Origin"] = window.location.origin;
        }
        if (typeof config.credentials === "undefined") {
          config.credentials = "same-origin";
        }
      } else {
        if (typeof config.credentials === "undefined") {
          config.credentials = "include";
        }
      }
      fetch(url2, config).then((response) => {
        if (response.ok) {
          response.json().then((data) => {
            resolve2(data);
          }).catch((error) => {
            reject(error);
            console.warn("Ajax Load Error - Invalid JSON returned", error);
          });
        } else {
          console.error("Ajax Load Error - Connection Error: " + response.status, response.statusText);
          reject(response);
        }
      }).catch((error) => {
        console.error("Ajax Load Error - Connection Error: ", error);
        reject(error);
      });
    } else {
      console.warn("Ajax Load Error - No URL Set");
      resolve2([]);
    }
  });
}
function generateParamsList$1(data, prefix) {
  var output = [];
  prefix = prefix || "";
  if (Array.isArray(data)) {
    data.forEach((item, i2) => {
      output = output.concat(generateParamsList$1(item, prefix ? prefix + "[" + i2 + "]" : i2));
    });
  } else if (typeof data === "object") {
    for (var key in data) {
      output = output.concat(generateParamsList$1(data[key], prefix ? prefix + "[" + key + "]" : key));
    }
  } else {
    output.push({ key: prefix, value: data });
  }
  return output;
}
var defaultContentTypeFormatters = {
  "json": {
    headers: {
      "Content-Type": "application/json"
    },
    body: function(url2, config, params) {
      return JSON.stringify(params);
    }
  },
  "form": {
    headers: {},
    body: function(url2, config, params) {
      var output = generateParamsList$1(params), form = new FormData();
      output.forEach(function(item) {
        form.append(item.key, item.value);
      });
      return form;
    }
  }
};
var Ajax = class extends Module {
  constructor(table) {
    super(table);
    this.config = {};
    this.url = "";
    this.urlGenerator = false;
    this.params = false;
    this.loaderPromise = false;
    this.registerTableOption("ajaxURL", false);
    this.registerTableOption("ajaxURLGenerator", false);
    this.registerTableOption("ajaxParams", {});
    this.registerTableOption("ajaxConfig", "get");
    this.registerTableOption("ajaxContentType", "form");
    this.registerTableOption("ajaxRequestFunc", false);
    this.registerTableOption("ajaxRequesting", function() {
    });
    this.registerTableOption("ajaxResponse", false);
    this.contentTypeFormatters = Ajax.contentTypeFormatters;
  }
  initialize() {
    this.loaderPromise = this.table.options.ajaxRequestFunc || Ajax.defaultLoaderPromise;
    this.urlGenerator = this.table.options.ajaxURLGenerator || Ajax.defaultURLGenerator;
    if (this.table.options.ajaxURL) {
      this.setUrl(this.table.options.ajaxURL);
    }
    this.setDefaultConfig(this.table.options.ajaxConfig);
    this.registerTableFunction("getAjaxUrl", this.getUrl.bind(this));
    this.subscribe("data-loading", this.requestDataCheck.bind(this));
    this.subscribe("data-params", this.requestParams.bind(this));
    this.subscribe("data-load", this.requestData.bind(this));
  }
  requestParams(data, config, silent, params) {
    var ajaxParams = this.table.options.ajaxParams;
    if (ajaxParams) {
      if (typeof ajaxParams === "function") {
        ajaxParams = ajaxParams.call(this.table);
      }
      params = Object.assign(params, ajaxParams);
    }
    return params;
  }
  requestDataCheck(data, params, config, silent) {
    return !!(!data && this.url || typeof data === "string");
  }
  requestData(url2, params, config, silent, previousData) {
    var ajaxConfig;
    if (!previousData && this.requestDataCheck(url2)) {
      if (url2) {
        this.setUrl(url2);
      }
      ajaxConfig = this.generateConfig(config);
      return this.sendRequest(this.url, params, ajaxConfig);
    } else {
      return previousData;
    }
  }
  setDefaultConfig(config = {}) {
    this.config = Object.assign({}, Ajax.defaultConfig);
    if (typeof config == "string") {
      this.config.method = config;
    } else {
      Object.assign(this.config, config);
    }
  }
  generateConfig(config = {}) {
    var ajaxConfig = Object.assign({}, this.config);
    if (typeof config == "string") {
      ajaxConfig.method = config;
    } else {
      Object.assign(ajaxConfig, config);
    }
    return ajaxConfig;
  }
  setUrl(url2) {
    this.url = url2;
  }
  getUrl() {
    return this.url;
  }
  sendRequest(url2, params, config) {
    if (this.table.options.ajaxRequesting.call(this.table, url2, params) !== false) {
      return this.loaderPromise(url2, config, params).then((data) => {
        if (this.table.options.ajaxResponse) {
          data = this.table.options.ajaxResponse.call(this.table, url2, params, data);
        }
        return data;
      });
    } else {
      return Promise.reject();
    }
  }
};
Ajax.moduleName = "ajax";
Ajax.defaultConfig = defaultConfig;
Ajax.defaultURLGenerator = urlBuilder;
Ajax.defaultLoaderPromise = defaultLoaderPromise;
Ajax.contentTypeFormatters = defaultContentTypeFormatters;
var defaultPasteActions = {
  replace: function(rows3) {
    return this.table.setData(rows3);
  },
  update: function(rows3) {
    return this.table.updateOrAddData(rows3);
  },
  insert: function(rows3) {
    return this.table.addData(rows3);
  }
};
var defaultPasteParsers = {
  table: function(clipboard) {
    var data = [], headerFindSuccess = true, columns = this.table.columnManager.columns, columnMap = [], rows3 = [];
    clipboard = clipboard.split("\n");
    clipboard.forEach(function(row2) {
      data.push(row2.split("	"));
    });
    if (data.length && !(data.length === 1 && data[0].length < 2)) {
      data[0].forEach(function(value) {
        var column = columns.find(function(column2) {
          return value && column2.definition.title && value.trim() && column2.definition.title.trim() === value.trim();
        });
        if (column) {
          columnMap.push(column);
        } else {
          headerFindSuccess = false;
        }
      });
      if (!headerFindSuccess) {
        headerFindSuccess = true;
        columnMap = [];
        data[0].forEach(function(value) {
          var column = columns.find(function(column2) {
            return value && column2.field && value.trim() && column2.field.trim() === value.trim();
          });
          if (column) {
            columnMap.push(column);
          } else {
            headerFindSuccess = false;
          }
        });
        if (!headerFindSuccess) {
          columnMap = this.table.columnManager.columnsByIndex;
        }
      }
      if (headerFindSuccess) {
        data.shift();
      }
      data.forEach(function(item) {
        var row2 = {};
        item.forEach(function(value, i2) {
          if (columnMap[i2]) {
            row2[columnMap[i2].field] = value;
          }
        });
        rows3.push(row2);
      });
      return rows3;
    } else {
      return false;
    }
  }
};
var Clipboard = class extends Module {
  constructor(table) {
    super(table);
    this.mode = true;
    this.pasteParser = function() {
    };
    this.pasteAction = function() {
    };
    this.customSelection = false;
    this.rowRange = false;
    this.blocked = true;
    this.registerTableOption("clipboard", false);
    this.registerTableOption("clipboardCopyStyled", true);
    this.registerTableOption("clipboardCopyConfig", false);
    this.registerTableOption("clipboardCopyFormatter", false);
    this.registerTableOption("clipboardCopyRowRange", "active");
    this.registerTableOption("clipboardPasteParser", "table");
    this.registerTableOption("clipboardPasteAction", "insert");
    this.registerColumnOption("clipboard");
    this.registerColumnOption("titleClipboard");
  }
  initialize() {
    this.mode = this.table.options.clipboard;
    this.rowRange = this.table.options.clipboardCopyRowRange;
    if (this.mode === true || this.mode === "copy") {
      this.table.element.addEventListener("copy", (e) => {
        var plain, html2, list2;
        if (!this.blocked) {
          e.preventDefault();
          if (this.customSelection) {
            plain = this.customSelection;
            if (this.table.options.clipboardCopyFormatter) {
              plain = this.table.options.clipboardCopyFormatter("plain", plain);
            }
          } else {
            list2 = this.table.modules.export.generateExportList(this.table.options.clipboardCopyConfig, this.table.options.clipboardCopyStyled, this.rowRange, "clipboard");
            html2 = this.table.modules.export.generateHTMLTable(list2);
            plain = html2 ? this.generatePlainContent(list2) : "";
            if (this.table.options.clipboardCopyFormatter) {
              plain = this.table.options.clipboardCopyFormatter("plain", plain);
              html2 = this.table.options.clipboardCopyFormatter("html", html2);
            }
          }
          if (window.clipboardData && window.clipboardData.setData) {
            window.clipboardData.setData("Text", plain);
          } else if (e.clipboardData && e.clipboardData.setData) {
            e.clipboardData.setData("text/plain", plain);
            if (html2) {
              e.clipboardData.setData("text/html", html2);
            }
          } else if (e.originalEvent && e.originalEvent.clipboardData.setData) {
            e.originalEvent.clipboardData.setData("text/plain", plain);
            if (html2) {
              e.originalEvent.clipboardData.setData("text/html", html2);
            }
          }
          this.dispatchExternal("clipboardCopied", plain, html2);
          this.reset();
        }
      });
    }
    if (this.mode === true || this.mode === "paste") {
      this.table.element.addEventListener("paste", (e) => {
        this.paste(e);
      });
    }
    this.setPasteParser(this.table.options.clipboardPasteParser);
    this.setPasteAction(this.table.options.clipboardPasteAction);
    this.registerTableFunction("copyToClipboard", this.copy.bind(this));
  }
  reset() {
    this.blocked = true;
    this.customSelection = false;
  }
  generatePlainContent(list2) {
    var output = [];
    list2.forEach((row2) => {
      var rowData = [];
      row2.columns.forEach((col) => {
        var value = "";
        if (col) {
          if (row2.type === "group") {
            col.value = col.component.getKey();
          }
          if (col.value === null) {
            value = "";
          } else {
            switch (typeof col.value) {
              case "object":
                value = JSON.stringify(col.value);
                break;
              case "undefined":
                value = "";
                break;
              default:
                value = col.value;
            }
          }
        }
        rowData.push(value);
      });
      output.push(rowData.join("	"));
    });
    return output.join("\n");
  }
  copy(range2, internal) {
    var sel, textRange;
    this.blocked = false;
    this.customSelection = false;
    if (this.mode === true || this.mode === "copy") {
      this.rowRange = range2 || this.table.options.clipboardCopyRowRange;
      if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
        range2 = document.createRange();
        range2.selectNodeContents(this.table.element);
        sel = window.getSelection();
        if (sel.toString() && internal) {
          this.customSelection = sel.toString();
        }
        sel.removeAllRanges();
        sel.addRange(range2);
      } else if (typeof document.selection != "undefined" && typeof document.body.createTextRange != "undefined") {
        textRange = document.body.createTextRange();
        textRange.moveToElementText(this.table.element);
        textRange.select();
      }
      document.execCommand("copy");
      if (sel) {
        sel.removeAllRanges();
      }
    }
  }
  setPasteAction(action) {
    switch (typeof action) {
      case "string":
        this.pasteAction = Clipboard.pasteActions[action];
        if (!this.pasteAction) {
          console.warn("Clipboard Error - No such paste action found:", action);
        }
        break;
      case "function":
        this.pasteAction = action;
        break;
    }
  }
  setPasteParser(parser) {
    switch (typeof parser) {
      case "string":
        this.pasteParser = Clipboard.pasteParsers[parser];
        if (!this.pasteParser) {
          console.warn("Clipboard Error - No such paste parser found:", parser);
        }
        break;
      case "function":
        this.pasteParser = parser;
        break;
    }
  }
  paste(e) {
    var data, rowData, rows3;
    if (this.checkPaseOrigin(e)) {
      data = this.getPasteData(e);
      rowData = this.pasteParser.call(this, data);
      if (rowData) {
        e.preventDefault();
        if (this.table.modExists("mutator")) {
          rowData = this.mutateData(rowData);
        }
        rows3 = this.pasteAction.call(this, rowData);
        this.dispatchExternal("clipboardPasted", data, rowData, rows3);
      } else {
        this.dispatchExternal("clipboardPasteError", data);
      }
    }
  }
  mutateData(data) {
    var output = [];
    if (Array.isArray(data)) {
      data.forEach((row2) => {
        output.push(this.table.modules.mutator.transformRow(row2, "clipboard"));
      });
    } else {
      output = data;
    }
    return output;
  }
  checkPaseOrigin(e) {
    var valid = true;
    if (e.target.tagName != "DIV" || this.table.modules.edit.currentCell) {
      valid = false;
    }
    return valid;
  }
  getPasteData(e) {
    var data;
    if (window.clipboardData && window.clipboardData.getData) {
      data = window.clipboardData.getData("Text");
    } else if (e.clipboardData && e.clipboardData.getData) {
      data = e.clipboardData.getData("text/plain");
    } else if (e.originalEvent && e.originalEvent.clipboardData.getData) {
      data = e.originalEvent.clipboardData.getData("text/plain");
    }
    return data;
  }
};
Clipboard.moduleName = "clipboard";
Clipboard.pasteActions = defaultPasteActions;
Clipboard.pasteParsers = defaultPasteParsers;
var CalcComponent = class {
  constructor(row2) {
    this._row = row2;
    return new Proxy(this, {
      get: function(target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._row.table.componentFunctionBinder.handle("row", target._row, name);
        }
      }
    });
  }
  getData(transform) {
    return this._row.getData(transform);
  }
  getElement() {
    return this._row.getElement();
  }
  getTable() {
    return this._row.table;
  }
  getCells() {
    var cells = [];
    this._row.getCells().forEach(function(cell) {
      cells.push(cell.getComponent());
    });
    return cells;
  }
  getCell(column) {
    var cell = this._row.getCell(column);
    return cell ? cell.getComponent() : false;
  }
  _getSelf() {
    return this._row;
  }
};
var CellComponent = class {
  constructor(cell) {
    this._cell = cell;
    return new Proxy(this, {
      get: function(target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._cell.table.componentFunctionBinder.handle("cell", target._cell, name);
        }
      }
    });
  }
  getValue() {
    return this._cell.getValue();
  }
  getOldValue() {
    return this._cell.getOldValue();
  }
  getInitialValue() {
    return this._cell.initialValue;
  }
  getElement() {
    return this._cell.getElement();
  }
  getRow() {
    return this._cell.row.getComponent();
  }
  getData() {
    return this._cell.row.getData();
  }
  getField() {
    return this._cell.column.getField();
  }
  getColumn() {
    return this._cell.column.getComponent();
  }
  setValue(value, mutate) {
    if (typeof mutate == "undefined") {
      mutate = true;
    }
    this._cell.setValue(value, mutate);
  }
  restoreOldValue() {
    this._cell.setValueActual(this._cell.getOldValue());
  }
  restoreInitialValue() {
    this._cell.setValueActual(this._cell.initialValue);
  }
  checkHeight() {
    this._cell.checkHeight();
  }
  getTable() {
    return this._cell.table;
  }
  _getSelf() {
    return this._cell;
  }
};
var Cell = class extends CoreFeature {
  constructor(column, row2) {
    super(column.table);
    this.table = column.table;
    this.column = column;
    this.row = row2;
    this.element = null;
    this.value = null;
    this.initialValue;
    this.oldValue = null;
    this.modules = {};
    this.height = null;
    this.width = null;
    this.minWidth = null;
    this.component = null;
    this.loaded = false;
    this.build();
  }
  build() {
    this.generateElement();
    this.setWidth();
    this._configureCell();
    this.setValueActual(this.column.getFieldValue(this.row.data));
    this.initialValue = this.value;
  }
  generateElement() {
    this.element = document.createElement("div");
    this.element.className = "tabulator-cell";
    this.element.setAttribute("role", "gridcell");
  }
  _configureCell() {
    var element = this.element, field = this.column.getField(), vertAligns = {
      top: "flex-start",
      bottom: "flex-end",
      middle: "center"
    }, hozAligns = {
      left: "flex-start",
      right: "flex-end",
      center: "center"
    };
    element.style.textAlign = this.column.hozAlign;
    if (this.column.vertAlign) {
      element.style.display = "inline-flex";
      element.style.alignItems = vertAligns[this.column.vertAlign] || "";
      if (this.column.hozAlign) {
        element.style.justifyContent = hozAligns[this.column.hozAlign] || "";
      }
    }
    if (field) {
      element.setAttribute("tabulator-field", field);
    }
    if (this.column.definition.cssClass) {
      var classNames = this.column.definition.cssClass.split(" ");
      classNames.forEach((className) => {
        element.classList.add(className);
      });
    }
    this.dispatch("cell-init", this);
    if (!this.column.visible) {
      this.hide();
    }
  }
  _generateContents() {
    var val;
    val = this.chain("cell-format", this, null, () => {
      return this.element.innerHTML = this.value;
    });
    switch (typeof val) {
      case "object":
        if (val instanceof Node) {
          while (this.element.firstChild)
            this.element.removeChild(this.element.firstChild);
          this.element.appendChild(val);
        } else {
          this.element.innerHTML = "";
          if (val != null) {
            console.warn("Format Error - Formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", val);
          }
        }
        break;
      case "undefined":
        this.element.innerHTML = "";
        break;
      default:
        this.element.innerHTML = val;
    }
  }
  cellRendered() {
    this.dispatch("cell-rendered", this);
  }
  getElement(containerOnly) {
    if (!this.loaded) {
      this.loaded = true;
      if (!containerOnly) {
        this.layoutElement();
      }
    }
    return this.element;
  }
  getValue() {
    return this.value;
  }
  getOldValue() {
    return this.oldValue;
  }
  setValue(value, mutate, force) {
    var changed = this.setValueProcessData(value, mutate, force);
    if (changed) {
      this.dispatch("cell-value-updated", this);
      this.cellRendered();
      if (this.column.definition.cellEdited) {
        this.column.definition.cellEdited.call(this.table, this.getComponent());
      }
      this.dispatchExternal("cellEdited", this.getComponent());
      if (this.subscribedExternal("dataChanged")) {
        this.dispatchExternal("dataChanged", this.table.rowManager.getData());
      }
    }
  }
  setValueProcessData(value, mutate, force) {
    var changed = false;
    if (this.value !== value || force) {
      changed = true;
      if (mutate) {
        value = this.chain("cell-value-changing", [this, value], null, value);
      }
    }
    this.setValueActual(value);
    if (changed) {
      this.dispatch("cell-value-changed", this);
    }
    return changed;
  }
  setValueActual(value) {
    this.oldValue = this.value;
    this.value = value;
    this.dispatch("cell-value-save-before", this);
    this.column.setFieldValue(this.row.data, value);
    this.dispatch("cell-value-save-after", this);
    if (this.loaded) {
      this.layoutElement();
    }
  }
  layoutElement() {
    this._generateContents();
    this.dispatch("cell-layout", this);
  }
  setWidth() {
    this.width = this.column.width;
    this.element.style.width = this.column.widthStyled;
  }
  clearWidth() {
    this.width = "";
    this.element.style.width = "";
  }
  getWidth() {
    return this.width || this.element.offsetWidth;
  }
  setMinWidth() {
    this.minWidth = this.column.minWidth;
    this.element.style.minWidth = this.column.minWidthStyled;
  }
  setMaxWidth() {
    this.maxWidth = this.column.maxWidth;
    this.element.style.maxWidth = this.column.maxWidthStyled;
  }
  checkHeight() {
    this.row.reinitializeHeight();
  }
  clearHeight() {
    this.element.style.height = "";
    this.height = null;
    this.dispatch("cell-height", this, "");
  }
  setHeight() {
    this.height = this.row.height;
    this.element.style.height = this.row.heightStyled;
    this.dispatch("cell-height", this, this.row.heightStyled);
  }
  getHeight() {
    return this.height || this.element.offsetHeight;
  }
  show() {
    this.element.style.display = this.column.vertAlign ? "inline-flex" : "";
  }
  hide() {
    this.element.style.display = "none";
  }
  delete() {
    this.dispatch("cell-delete", this);
    if (!this.table.rowManager.redrawBlock && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
    this.element = false;
    this.column.deleteCell(this);
    this.row.deleteCell(this);
    this.calcs = {};
  }
  getIndex() {
    return this.row.getCellIndex(this);
  }
  getComponent() {
    if (!this.component) {
      this.component = new CellComponent(this);
    }
    return this.component;
  }
};
var ColumnComponent = class {
  constructor(column) {
    this._column = column;
    this.type = "ColumnComponent";
    return new Proxy(this, {
      get: function(target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._column.table.componentFunctionBinder.handle("column", target._column, name);
        }
      }
    });
  }
  getElement() {
    return this._column.getElement();
  }
  getDefinition() {
    return this._column.getDefinition();
  }
  getField() {
    return this._column.getField();
  }
  getTitleDownload() {
    return this._column.getTitleDownload();
  }
  getCells() {
    var cells = [];
    this._column.cells.forEach(function(cell) {
      cells.push(cell.getComponent());
    });
    return cells;
  }
  isVisible() {
    return this._column.visible;
  }
  show() {
    if (this._column.isGroup) {
      this._column.columns.forEach(function(column) {
        column.show();
      });
    } else {
      this._column.show();
    }
  }
  hide() {
    if (this._column.isGroup) {
      this._column.columns.forEach(function(column) {
        column.hide();
      });
    } else {
      this._column.hide();
    }
  }
  toggle() {
    if (this._column.visible) {
      this.hide();
    } else {
      this.show();
    }
  }
  delete() {
    return this._column.delete();
  }
  getSubColumns() {
    var output = [];
    if (this._column.columns.length) {
      this._column.columns.forEach(function(column) {
        output.push(column.getComponent());
      });
    }
    return output;
  }
  getParentColumn() {
    return this._column.parent instanceof Column ? this._column.parent.getComponent() : false;
  }
  _getSelf() {
    return this._column;
  }
  scrollTo() {
    return this._column.table.columnManager.scrollToColumn(this._column);
  }
  getTable() {
    return this._column.table;
  }
  move(to2, after) {
    var toColumn = this._column.table.columnManager.findColumn(to2);
    if (toColumn) {
      this._column.table.columnManager.moveColumn(this._column, toColumn, after);
    } else {
      console.warn("Move Error - No matching column found:", toColumn);
    }
  }
  getNextColumn() {
    var nextCol = this._column.nextColumn();
    return nextCol ? nextCol.getComponent() : false;
  }
  getPrevColumn() {
    var prevCol = this._column.prevColumn();
    return prevCol ? prevCol.getComponent() : false;
  }
  updateDefinition(updates) {
    return this._column.updateDefinition(updates);
  }
  getWidth() {
    return this._column.getWidth();
  }
  setWidth(width) {
    var result;
    if (width === true) {
      result = this._column.reinitializeWidth(true);
    } else {
      result = this._column.setWidth(width);
    }
    this._column.table.columnManager.rerenderColumns(true);
    return result;
  }
};
var defaultColumnOptions = {
  "title": void 0,
  "field": void 0,
  "columns": void 0,
  "visible": void 0,
  "hozAlign": void 0,
  "vertAlign": void 0,
  "width": void 0,
  "minWidth": 40,
  "maxWidth": void 0,
  "maxInitialWidth": void 0,
  "cssClass": void 0,
  "variableHeight": void 0,
  "headerVertical": void 0,
  "headerHozAlign": void 0,
  "headerWordWrap": false,
  "editableTitle": void 0
};
var Column = class extends CoreFeature {
  constructor(def, parent) {
    super(parent.table);
    this.definition = def;
    this.parent = parent;
    this.type = "column";
    this.columns = [];
    this.cells = [];
    this.element = this.createElement();
    this.contentElement = false;
    this.titleHolderElement = false;
    this.titleElement = false;
    this.groupElement = this.createGroupElement();
    this.isGroup = false;
    this.hozAlign = "";
    this.vertAlign = "";
    this.field = "";
    this.fieldStructure = "";
    this.getFieldValue = "";
    this.setFieldValue = "";
    this.titleDownload = null;
    this.titleFormatterRendered = false;
    this.mapDefinitions();
    this.setField(this.definition.field);
    this.modules = {};
    this.width = null;
    this.widthStyled = "";
    this.maxWidth = null;
    this.maxWidthStyled = "";
    this.maxInitialWidth = null;
    this.minWidth = null;
    this.minWidthStyled = "";
    this.widthFixed = false;
    this.visible = true;
    this.component = null;
    if (this.definition.columns) {
      this.isGroup = true;
      this.definition.columns.forEach((def2, i2) => {
        var newCol = new Column(def2, this);
        this.attachColumn(newCol);
      });
      this.checkColumnVisibility();
    } else {
      parent.registerColumnField(this);
    }
    this._initialize();
  }
  createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-col");
    el.setAttribute("role", "columnheader");
    el.setAttribute("aria-sort", "none");
    switch (this.table.options.columnHeaderVertAlign) {
      case "middle":
        el.style.justifyContent = "center";
        break;
      case "bottom":
        el.style.justifyContent = "flex-end";
        break;
    }
    return el;
  }
  createGroupElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-col-group-cols");
    return el;
  }
  mapDefinitions() {
    var defaults3 = this.table.options.columnDefaults;
    if (defaults3) {
      for (let key in defaults3) {
        if (typeof this.definition[key] === "undefined") {
          this.definition[key] = defaults3[key];
        }
      }
    }
    this.definition = this.table.columnManager.optionsList.generate(Column.defaultOptionList, this.definition);
  }
  checkDefinition() {
    Object.keys(this.definition).forEach((key) => {
      if (Column.defaultOptionList.indexOf(key) === -1) {
        console.warn("Invalid column definition option in '" + (this.field || this.definition.title) + "' column:", key);
      }
    });
  }
  setField(field) {
    this.field = field;
    this.fieldStructure = field ? this.table.options.nestedFieldSeparator ? field.split(this.table.options.nestedFieldSeparator) : [field] : [];
    this.getFieldValue = this.fieldStructure.length > 1 ? this._getNestedData : this._getFlatData;
    this.setFieldValue = this.fieldStructure.length > 1 ? this._setNestedData : this._setFlatData;
  }
  registerColumnPosition(column) {
    this.parent.registerColumnPosition(column);
  }
  registerColumnField(column) {
    this.parent.registerColumnField(column);
  }
  reRegisterPosition() {
    if (this.isGroup) {
      this.columns.forEach(function(column) {
        column.reRegisterPosition();
      });
    } else {
      this.registerColumnPosition(this);
    }
  }
  _initialize() {
    var def = this.definition;
    while (this.element.firstChild)
      this.element.removeChild(this.element.firstChild);
    if (def.headerVertical) {
      this.element.classList.add("tabulator-col-vertical");
      if (def.headerVertical === "flip") {
        this.element.classList.add("tabulator-col-vertical-flip");
      }
    }
    this.contentElement = this._buildColumnHeaderContent();
    this.element.appendChild(this.contentElement);
    if (this.isGroup) {
      this._buildGroupHeader();
    } else {
      this._buildColumnHeader();
    }
    this.dispatch("column-init", this);
  }
  _buildColumnHeader() {
    var def = this.definition;
    this.dispatch("column-layout", this);
    if (typeof def.visible != "undefined") {
      if (def.visible) {
        this.show(true);
      } else {
        this.hide(true);
      }
    }
    if (def.cssClass) {
      var classNames = def.cssClass.split(" ");
      classNames.forEach((className) => {
        this.element.classList.add(className);
      });
    }
    if (def.field) {
      this.element.setAttribute("tabulator-field", def.field);
    }
    this.setMinWidth(parseInt(def.minWidth));
    if (def.maxInitialWidth) {
      this.maxInitialWidth = parseInt(def.maxInitialWidth);
    }
    if (def.maxWidth) {
      this.setMaxWidth(parseInt(def.maxWidth));
    }
    this.reinitializeWidth();
    this.hozAlign = this.definition.hozAlign;
    this.vertAlign = this.definition.vertAlign;
    this.titleElement.style.textAlign = this.definition.headerHozAlign;
  }
  _buildColumnHeaderContent() {
    var contentElement = document.createElement("div");
    contentElement.classList.add("tabulator-col-content");
    this.titleHolderElement = document.createElement("div");
    this.titleHolderElement.classList.add("tabulator-col-title-holder");
    contentElement.appendChild(this.titleHolderElement);
    this.titleElement = this._buildColumnHeaderTitle();
    this.titleHolderElement.appendChild(this.titleElement);
    return contentElement;
  }
  _buildColumnHeaderTitle() {
    var def = this.definition;
    var titleHolderElement = document.createElement("div");
    titleHolderElement.classList.add("tabulator-col-title");
    if (def.headerWordWrap) {
      titleHolderElement.classList.add("tabulator-col-title-wrap");
    }
    if (def.editableTitle) {
      var titleElement = document.createElement("input");
      titleElement.classList.add("tabulator-title-editor");
      titleElement.addEventListener("click", (e) => {
        e.stopPropagation();
        titleElement.focus();
      });
      titleElement.addEventListener("change", () => {
        def.title = titleElement.value;
        this.dispatchExternal("columnTitleChanged", this.getComponent());
      });
      titleHolderElement.appendChild(titleElement);
      if (def.field) {
        this.langBind("columns|" + def.field, (text) => {
          titleElement.value = text || (def.title || "&nbsp;");
        });
      } else {
        titleElement.value = def.title || "&nbsp;";
      }
    } else {
      if (def.field) {
        this.langBind("columns|" + def.field, (text) => {
          this._formatColumnHeaderTitle(titleHolderElement, text || (def.title || "&nbsp;"));
        });
      } else {
        this._formatColumnHeaderTitle(titleHolderElement, def.title || "&nbsp;");
      }
    }
    return titleHolderElement;
  }
  _formatColumnHeaderTitle(el, title) {
    var contents = this.chain("column-format", [this, title, el], null, () => {
      return title;
    });
    switch (typeof contents) {
      case "object":
        if (contents instanceof Node) {
          el.appendChild(contents);
        } else {
          el.innerHTML = "";
          console.warn("Format Error - Title formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", contents);
        }
        break;
      case "undefined":
        el.innerHTML = "";
        break;
      default:
        el.innerHTML = contents;
    }
  }
  _buildGroupHeader() {
    this.element.classList.add("tabulator-col-group");
    this.element.setAttribute("role", "columngroup");
    this.element.setAttribute("aria-title", this.definition.title);
    if (this.definition.cssClass) {
      var classNames = this.definition.cssClass.split(" ");
      classNames.forEach((className) => {
        this.element.classList.add(className);
      });
    }
    this.titleElement.style.textAlign = this.definition.headerHozAlign;
    this.element.appendChild(this.groupElement);
  }
  _getFlatData(data) {
    return data[this.field];
  }
  _getNestedData(data) {
    var dataObj = data, structure = this.fieldStructure, length = structure.length, output;
    for (let i2 = 0; i2 < length; i2++) {
      dataObj = dataObj[structure[i2]];
      output = dataObj;
      if (!dataObj) {
        break;
      }
    }
    return output;
  }
  _setFlatData(data, value) {
    if (this.field) {
      data[this.field] = value;
    }
  }
  _setNestedData(data, value) {
    var dataObj = data, structure = this.fieldStructure, length = structure.length;
    for (let i2 = 0; i2 < length; i2++) {
      if (i2 == length - 1) {
        dataObj[structure[i2]] = value;
      } else {
        if (!dataObj[structure[i2]]) {
          if (typeof value !== "undefined") {
            dataObj[structure[i2]] = {};
          } else {
            break;
          }
        }
        dataObj = dataObj[structure[i2]];
      }
    }
  }
  attachColumn(column) {
    if (this.groupElement) {
      this.columns.push(column);
      this.groupElement.appendChild(column.getElement());
      column.columnRendered();
    } else {
      console.warn("Column Warning - Column being attached to another column instead of column group");
    }
  }
  verticalAlign(alignment, height) {
    var parentHeight = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : height || this.parent.getHeadersElement().clientHeight;
    this.element.style.height = parentHeight + "px";
    this.dispatch("column-height", this, this.element.style.height);
    if (this.isGroup) {
      this.groupElement.style.minHeight = parentHeight - this.contentElement.offsetHeight + "px";
    }
    this.columns.forEach(function(column) {
      column.verticalAlign(alignment);
    });
  }
  clearVerticalAlign() {
    this.element.style.paddingTop = "";
    this.element.style.height = "";
    this.element.style.minHeight = "";
    this.groupElement.style.minHeight = "";
    this.columns.forEach(function(column) {
      column.clearVerticalAlign();
    });
    this.dispatch("column-height", this, "");
  }
  getElement() {
    return this.element;
  }
  getGroupElement() {
    return this.groupElement;
  }
  getField() {
    return this.field;
  }
  getTitleDownload() {
    return this.titleDownload;
  }
  getFirstColumn() {
    if (!this.isGroup) {
      return this;
    } else {
      if (this.columns.length) {
        return this.columns[0].getFirstColumn();
      } else {
        return false;
      }
    }
  }
  getLastColumn() {
    if (!this.isGroup) {
      return this;
    } else {
      if (this.columns.length) {
        return this.columns[this.columns.length - 1].getLastColumn();
      } else {
        return false;
      }
    }
  }
  getColumns(traverse) {
    var columns = [];
    if (traverse) {
      this.columns.forEach((column) => {
        columns.push(column);
        columns = columns.concat(column.getColumns(true));
      });
    } else {
      columns = this.columns;
    }
    return columns;
  }
  getCells() {
    return this.cells;
  }
  getTopColumn() {
    if (this.parent.isGroup) {
      return this.parent.getTopColumn();
    } else {
      return this;
    }
  }
  getDefinition(updateBranches) {
    var colDefs = [];
    if (this.isGroup && updateBranches) {
      this.columns.forEach(function(column) {
        colDefs.push(column.getDefinition(true));
      });
      this.definition.columns = colDefs;
    }
    return this.definition;
  }
  checkColumnVisibility() {
    var visible = false;
    this.columns.forEach(function(column) {
      if (column.visible) {
        visible = true;
      }
    });
    if (visible) {
      this.show();
      this.dispatchExternal("columnVisibilityChanged", this.getComponent(), false);
    } else {
      this.hide();
    }
  }
  show(silent, responsiveToggle) {
    if (!this.visible) {
      this.visible = true;
      this.element.style.display = "";
      if (this.parent.isGroup) {
        this.parent.checkColumnVisibility();
      }
      this.cells.forEach(function(cell) {
        cell.show();
      });
      if (!this.isGroup && this.width === null) {
        this.reinitializeWidth();
      }
      this.table.columnManager.verticalAlignHeaders();
      this.dispatch("column-show", this, responsiveToggle);
      if (!silent) {
        this.dispatchExternal("columnVisibilityChanged", this.getComponent(), true);
      }
      if (this.parent.isGroup) {
        this.parent.matchChildWidths();
      }
      if (!this.silent) {
        this.table.columnManager.rerenderColumns();
      }
    }
  }
  hide(silent, responsiveToggle) {
    if (this.visible) {
      this.visible = false;
      this.element.style.display = "none";
      this.table.columnManager.verticalAlignHeaders();
      if (this.parent.isGroup) {
        this.parent.checkColumnVisibility();
      }
      this.cells.forEach(function(cell) {
        cell.hide();
      });
      this.dispatch("column-hide", this, responsiveToggle);
      if (!silent) {
        this.dispatchExternal("columnVisibilityChanged", this.getComponent(), false);
      }
      if (this.parent.isGroup) {
        this.parent.matchChildWidths();
      }
      if (!this.silent) {
        this.table.columnManager.rerenderColumns();
      }
    }
  }
  matchChildWidths() {
    var childWidth = 0;
    if (this.contentElement && this.columns.length) {
      this.columns.forEach(function(column) {
        if (column.visible) {
          childWidth += column.getWidth();
        }
      });
      this.contentElement.style.maxWidth = childWidth - 1 + "px";
      if (this.parent.isGroup) {
        this.parent.matchChildWidths();
      }
    }
  }
  removeChild(child) {
    var index2 = this.columns.indexOf(child);
    if (index2 > -1) {
      this.columns.splice(index2, 1);
    }
    if (!this.columns.length) {
      this.delete();
    }
  }
  setWidth(width) {
    this.widthFixed = true;
    this.setWidthActual(width);
  }
  setWidthActual(width) {
    if (isNaN(width)) {
      width = Math.floor(this.table.element.clientWidth / 100 * parseInt(width));
    }
    width = Math.max(this.minWidth, width);
    if (this.maxWidth) {
      width = Math.min(this.maxWidth, width);
    }
    this.width = width;
    this.widthStyled = width ? width + "px" : "";
    this.element.style.width = this.widthStyled;
    if (!this.isGroup) {
      this.cells.forEach(function(cell) {
        cell.setWidth();
      });
    }
    if (this.parent.isGroup) {
      this.parent.matchChildWidths();
    }
    this.dispatch("column-width", this);
  }
  checkCellHeights() {
    var rows3 = [];
    this.cells.forEach(function(cell) {
      if (cell.row.heightInitialized) {
        if (cell.row.getElement().offsetParent !== null) {
          rows3.push(cell.row);
          cell.row.clearCellHeight();
        } else {
          cell.row.heightInitialized = false;
        }
      }
    });
    rows3.forEach(function(row2) {
      row2.calcHeight();
    });
    rows3.forEach(function(row2) {
      row2.setCellHeight();
    });
  }
  getWidth() {
    var width = 0;
    if (this.isGroup) {
      this.columns.forEach(function(column) {
        if (column.visible) {
          width += column.getWidth();
        }
      });
    } else {
      width = this.width;
    }
    return width;
  }
  getLeftOffset() {
    var offset2 = this.element.offsetLeft;
    if (this.parent.isGroup) {
      offset2 += this.parent.getLeftOffset();
    }
    return offset2;
  }
  getHeight() {
    return Math.ceil(this.element.getBoundingClientRect().height);
  }
  setMinWidth(minWidth) {
    if (this.maxWidth && minWidth > this.maxWidth) {
      minWidth = this.maxWidth;
      console.warn("the minWidth (" + minWidth + "px) for column '" + this.field + "' cannot be bigger that its maxWidth (" + this.maxWidthStyled + ")");
    }
    this.minWidth = minWidth;
    this.minWidthStyled = minWidth ? minWidth + "px" : "";
    this.element.style.minWidth = this.minWidthStyled;
    this.cells.forEach(function(cell) {
      cell.setMinWidth();
    });
  }
  setMaxWidth(maxWidth) {
    if (this.minWidth && maxWidth < this.minWidth) {
      maxWidth = this.minWidth;
      console.warn("the maxWidth (" + maxWidth + "px) for column '" + this.field + "' cannot be smaller that its minWidth (" + this.minWidthStyled + ")");
    }
    this.maxWidth = maxWidth;
    this.maxWidthStyled = maxWidth ? maxWidth + "px" : "";
    this.element.style.maxWidth = this.maxWidthStyled;
    this.cells.forEach(function(cell) {
      cell.setMaxWidth();
    });
  }
  delete() {
    return new Promise((resolve2, reject) => {
      if (this.isGroup) {
        this.columns.forEach(function(column) {
          column.delete();
        });
      }
      this.dispatch("column-delete", this);
      var cellCount = this.cells.length;
      for (let i2 = 0; i2 < cellCount; i2++) {
        this.cells[0].delete();
      }
      if (this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }
      this.element = false;
      this.contentElement = false;
      this.titleElement = false;
      this.groupElement = false;
      if (this.parent.isGroup) {
        this.parent.removeChild(this);
      }
      this.table.columnManager.deregisterColumn(this);
      this.table.columnManager.rerenderColumns(true);
      resolve2();
    });
  }
  columnRendered() {
    if (this.titleFormatterRendered) {
      this.titleFormatterRendered();
    }
    this.dispatch("column-rendered", this);
  }
  generateCell(row2) {
    var cell = new Cell(this, row2);
    this.cells.push(cell);
    return cell;
  }
  nextColumn() {
    var index2 = this.table.columnManager.findColumnIndex(this);
    return index2 > -1 ? this._nextVisibleColumn(index2 + 1) : false;
  }
  _nextVisibleColumn(index2) {
    var column = this.table.columnManager.getColumnByIndex(index2);
    return !column || column.visible ? column : this._nextVisibleColumn(index2 + 1);
  }
  prevColumn() {
    var index2 = this.table.columnManager.findColumnIndex(this);
    return index2 > -1 ? this._prevVisibleColumn(index2 - 1) : false;
  }
  _prevVisibleColumn(index2) {
    var column = this.table.columnManager.getColumnByIndex(index2);
    return !column || column.visible ? column : this._prevVisibleColumn(index2 - 1);
  }
  reinitializeWidth(force) {
    this.widthFixed = false;
    if (typeof this.definition.width !== "undefined" && !force) {
      this.setWidth(this.definition.width);
    }
    this.dispatch("column-width-fit-before", this);
    this.fitToData(force);
    this.dispatch("column-width-fit-after", this);
  }
  fitToData(force) {
    if (this.isGroup) {
      return;
    }
    if (!this.widthFixed) {
      this.element.style.width = "";
      this.cells.forEach((cell) => {
        cell.clearWidth();
      });
    }
    var maxWidth = this.element.offsetWidth;
    if (!this.width || !this.widthFixed) {
      this.cells.forEach((cell) => {
        var width = cell.getWidth();
        if (width > maxWidth) {
          maxWidth = width;
        }
      });
      if (maxWidth) {
        var setTo = maxWidth + 1;
        if (this.maxInitialWidth && !force) {
          setTo = Math.min(setTo, this.maxInitialWidth);
        }
        this.setWidthActual(setTo);
      }
    }
  }
  updateDefinition(updates) {
    var definition;
    if (!this.isGroup) {
      if (!this.parent.isGroup) {
        definition = Object.assign({}, this.getDefinition());
        definition = Object.assign(definition, updates);
        return this.table.columnManager.addColumn(definition, false, this).then((column) => {
          if (definition.field == this.field) {
            this.field = false;
          }
          return this.delete().then(() => {
            return column.getComponent();
          });
        });
      } else {
        console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns");
        return Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups");
      }
    } else {
      console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns");
      return Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups");
    }
  }
  deleteCell(cell) {
    var index2 = this.cells.indexOf(cell);
    if (index2 > -1) {
      this.cells.splice(index2, 1);
    }
  }
  getComponent() {
    if (!this.component) {
      this.component = new ColumnComponent(this);
    }
    return this.component;
  }
};
Column.defaultOptionList = defaultColumnOptions;
var RowComponent = class {
  constructor(row2) {
    this._row = row2;
    return new Proxy(this, {
      get: function(target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._row.table.componentFunctionBinder.handle("row", target._row, name);
        }
      }
    });
  }
  getData(transform) {
    return this._row.getData(transform);
  }
  getElement() {
    return this._row.getElement();
  }
  getCells() {
    var cells = [];
    this._row.getCells().forEach(function(cell) {
      cells.push(cell.getComponent());
    });
    return cells;
  }
  getCell(column) {
    var cell = this._row.getCell(column);
    return cell ? cell.getComponent() : false;
  }
  getIndex() {
    return this._row.getData("data")[this._row.table.options.index];
  }
  getPosition() {
    return this._row.getPosition();
  }
  watchPosition(callback2) {
    return this._row.watchPosition(callback2);
  }
  delete() {
    return this._row.delete();
  }
  scrollTo() {
    return this._row.table.rowManager.scrollToRow(this._row);
  }
  move(to2, after) {
    this._row.moveToRow(to2, after);
  }
  update(data) {
    return this._row.updateData(data);
  }
  normalizeHeight() {
    this._row.normalizeHeight(true);
  }
  _getSelf() {
    return this._row;
  }
  reformat() {
    return this._row.reinitialize();
  }
  getTable() {
    return this._row.table;
  }
  getNextRow() {
    var row2 = this._row.nextRow();
    return row2 ? row2.getComponent() : row2;
  }
  getPrevRow() {
    var row2 = this._row.prevRow();
    return row2 ? row2.getComponent() : row2;
  }
};
var Row = class extends CoreFeature {
  constructor(data, parent, type = "row") {
    super(parent.table);
    this.parent = parent;
    this.data = {};
    this.type = type;
    this.element = false;
    this.modules = {};
    this.cells = [];
    this.height = 0;
    this.heightStyled = "";
    this.manualHeight = false;
    this.outerHeight = 0;
    this.initialized = false;
    this.heightInitialized = false;
    this.position = 0;
    this.positionWatchers = [];
    this.component = null;
    this.created = false;
    this.setData(data);
  }
  create() {
    if (!this.created) {
      this.created = true;
      this.generateElement();
    }
  }
  createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-row");
    el.setAttribute("role", "row");
    this.element = el;
  }
  getElement() {
    this.create();
    return this.element;
  }
  detachElement() {
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }
  generateElement() {
    this.createElement();
    this.dispatch("row-init", this);
  }
  generateCells() {
    this.cells = this.table.columnManager.generateCells(this);
  }
  initialize(force) {
    this.create();
    if (!this.initialized || force) {
      this.deleteCells();
      while (this.element.firstChild)
        this.element.removeChild(this.element.firstChild);
      this.dispatch("row-layout-before", this);
      this.generateCells();
      this.initialized = true;
      this.table.columnManager.renderer.renderRowCells(this);
      if (force) {
        this.normalizeHeight();
      }
      this.dispatch("row-layout", this);
      if (this.table.options.rowFormatter) {
        this.table.options.rowFormatter(this.getComponent());
      }
      this.dispatch("row-layout-after", this);
    } else {
      this.table.columnManager.renderer.rerenderRowCells(this);
    }
  }
  reinitializeHeight() {
    this.heightInitialized = false;
    if (this.element && this.element.offsetParent !== null) {
      this.normalizeHeight(true);
    }
  }
  deinitialize() {
    this.initialized = false;
  }
  deinitializeHeight() {
    this.heightInitialized = false;
  }
  reinitialize(children) {
    this.initialized = false;
    this.heightInitialized = false;
    if (!this.manualHeight) {
      this.height = 0;
      this.heightStyled = "";
    }
    if (this.element && this.element.offsetParent !== null) {
      this.initialize(true);
    }
    this.dispatch("row-relayout", this);
  }
  calcHeight(force) {
    var maxHeight = 0, minHeight;
    if (this.table.options.rowHeight) {
      this.height = this.table.options.rowHeight;
    } else {
      minHeight = this.table.options.resizableRows ? this.element.clientHeight : 0;
      this.cells.forEach(function(cell) {
        var height = cell.getHeight();
        if (height > maxHeight) {
          maxHeight = height;
        }
      });
      if (force) {
        this.height = Math.max(maxHeight, minHeight);
      } else {
        this.height = this.manualHeight ? this.height : Math.max(maxHeight, minHeight);
      }
    }
    this.heightStyled = this.height ? this.height + "px" : "";
    this.outerHeight = this.element.offsetHeight;
  }
  setCellHeight() {
    this.cells.forEach(function(cell) {
      cell.setHeight();
    });
    this.heightInitialized = true;
  }
  clearCellHeight() {
    this.cells.forEach(function(cell) {
      cell.clearHeight();
    });
  }
  normalizeHeight(force) {
    if (force && !this.table.options.rowHeight) {
      this.clearCellHeight();
    }
    this.calcHeight(force);
    this.setCellHeight();
  }
  setHeight(height, force) {
    if (this.height != height || force) {
      this.manualHeight = true;
      this.height = height;
      this.heightStyled = height ? height + "px" : "";
      this.setCellHeight();
      this.outerHeight = this.element.offsetHeight;
    }
  }
  getHeight() {
    return this.outerHeight;
  }
  getWidth() {
    return this.element.offsetWidth;
  }
  deleteCell(cell) {
    var index2 = this.cells.indexOf(cell);
    if (index2 > -1) {
      this.cells.splice(index2, 1);
    }
  }
  setData(data) {
    this.data = this.chain("row-data-init-before", [this, data], void 0, data);
    this.dispatch("row-data-init-after", this);
  }
  updateData(updatedData) {
    var visible = this.element && Helpers.elVisible(this.element), tempData = {}, newRowData;
    return new Promise((resolve2, reject) => {
      if (typeof updatedData === "string") {
        updatedData = JSON.parse(updatedData);
      }
      this.dispatch("row-data-save-before", this);
      if (this.subscribed("row-data-changing")) {
        tempData = Object.assign(tempData, this.data);
        tempData = Object.assign(tempData, updatedData);
      }
      newRowData = this.chain("row-data-changing", [this, tempData, updatedData], null, updatedData);
      for (let attrname in newRowData) {
        this.data[attrname] = newRowData[attrname];
      }
      this.dispatch("row-data-save-after", this);
      for (let attrname in updatedData) {
        let columns = this.table.columnManager.getColumnsByFieldRoot(attrname);
        columns.forEach((column) => {
          let cell = this.getCell(column.getField());
          if (cell) {
            let value = column.getFieldValue(newRowData);
            if (cell.getValue() !== value) {
              cell.setValueProcessData(value);
              if (visible) {
                cell.cellRendered();
              }
            }
          }
        });
      }
      if (visible) {
        this.normalizeHeight(true);
        if (this.table.options.rowFormatter) {
          this.table.options.rowFormatter(this.getComponent());
        }
      } else {
        this.initialized = false;
        this.height = 0;
        this.heightStyled = "";
      }
      this.dispatch("row-data-changed", this, visible, updatedData);
      this.dispatchExternal("rowUpdated", this.getComponent());
      if (this.subscribedExternal("dataChanged")) {
        this.dispatchExternal("dataChanged", this.table.rowManager.getData());
      }
      resolve2();
    });
  }
  getData(transform) {
    if (transform) {
      return this.chain("row-data-retrieve", [this, transform], null, this.data);
    }
    return this.data;
  }
  getCell(column) {
    var match2 = false;
    column = this.table.columnManager.findColumn(column);
    if (!this.initialized) {
      this.generateCells();
    }
    match2 = this.cells.find(function(cell) {
      return cell.column === column;
    });
    return match2;
  }
  getCellIndex(findCell) {
    return this.cells.findIndex(function(cell) {
      return cell === findCell;
    });
  }
  findCell(subject) {
    return this.cells.find((cell) => {
      return cell.element === subject;
    });
  }
  getCells() {
    if (!this.initialized) {
      this.generateCells();
    }
    return this.cells;
  }
  nextRow() {
    var row2 = this.table.rowManager.nextDisplayRow(this, true);
    return row2 || false;
  }
  prevRow() {
    var row2 = this.table.rowManager.prevDisplayRow(this, true);
    return row2 || false;
  }
  moveToRow(to2, before) {
    var toRow = this.table.rowManager.findRow(to2);
    if (toRow) {
      this.table.rowManager.moveRowActual(this, toRow, !before);
      this.table.rowManager.refreshActiveData("display", false, true);
    } else {
      console.warn("Move Error - No matching row found:", to2);
    }
  }
  delete() {
    this.dispatch("row-delete", this);
    this.deleteActual();
    return Promise.resolve();
  }
  deleteActual(blockRedraw) {
    this.detachModules();
    this.table.rowManager.deleteRow(this, blockRedraw);
    this.deleteCells();
    this.initialized = false;
    this.heightInitialized = false;
    this.element = false;
    this.dispatch("row-deleted", this);
  }
  detachModules() {
    this.dispatch("row-deleting", this);
  }
  deleteCells() {
    var cellCount = this.cells.length;
    for (let i2 = 0; i2 < cellCount; i2++) {
      this.cells[0].delete();
    }
  }
  wipe() {
    this.detachModules();
    this.deleteCells();
    if (this.element) {
      while (this.element.firstChild)
        this.element.removeChild(this.element.firstChild);
      if (this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }
    }
    this.element = false;
    this.modules = {};
  }
  isDisplayed() {
    return this.table.rowManager.getDisplayRows().includes(this);
  }
  getPosition() {
    return this.isDisplayed() ? this.position : false;
  }
  setPosition(position) {
    if (position != this.position) {
      this.position = position;
      this.positionWatchers.forEach((callback2) => {
        callback2(this.position);
      });
    }
  }
  watchPosition(callback2) {
    this.positionWatchers.push(callback2);
    callback2(this.position);
  }
  getGroup() {
    return this.modules.group || false;
  }
  getComponent() {
    if (!this.component) {
      this.component = new RowComponent(this);
    }
    return this.component;
  }
};
var defaultCalculations = {
  "avg": function(values2, data, calcParams) {
    var output = 0, precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : 2;
    if (values2.length) {
      output = values2.reduce(function(sum, value) {
        return Number(sum) + Number(value);
      });
      output = output / values2.length;
      output = precision !== false ? output.toFixed(precision) : output;
    }
    return parseFloat(output).toString();
  },
  "max": function(values2, data, calcParams) {
    var output = null, precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;
    values2.forEach(function(value) {
      value = Number(value);
      if (value > output || output === null) {
        output = value;
      }
    });
    return output !== null ? precision !== false ? output.toFixed(precision) : output : "";
  },
  "min": function(values2, data, calcParams) {
    var output = null, precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;
    values2.forEach(function(value) {
      value = Number(value);
      if (value < output || output === null) {
        output = value;
      }
    });
    return output !== null ? precision !== false ? output.toFixed(precision) : output : "";
  },
  "sum": function(values2, data, calcParams) {
    var output = 0, precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;
    if (values2.length) {
      values2.forEach(function(value) {
        value = Number(value);
        output += !isNaN(value) ? Number(value) : 0;
      });
    }
    return precision !== false ? output.toFixed(precision) : output;
  },
  "concat": function(values2, data, calcParams) {
    var output = 0;
    if (values2.length) {
      output = values2.reduce(function(sum, value) {
        return String(sum) + String(value);
      });
    }
    return output;
  },
  "count": function(values2, data, calcParams) {
    var output = 0;
    if (values2.length) {
      values2.forEach(function(value) {
        if (value) {
          output++;
        }
      });
    }
    return output;
  }
};
var ColumnCalcs = class extends Module {
  constructor(table) {
    super(table);
    this.topCalcs = [];
    this.botCalcs = [];
    this.genColumn = false;
    this.topElement = this.createElement();
    this.botElement = this.createElement();
    this.topRow = false;
    this.botRow = false;
    this.topInitialized = false;
    this.botInitialized = false;
    this.blocked = false;
    this.recalcAfterBlock = false;
    this.registerTableOption("columnCalcs", true);
    this.registerColumnOption("topCalc");
    this.registerColumnOption("topCalcParams");
    this.registerColumnOption("topCalcFormatter");
    this.registerColumnOption("topCalcFormatterParams");
    this.registerColumnOption("bottomCalc");
    this.registerColumnOption("bottomCalcParams");
    this.registerColumnOption("bottomCalcFormatter");
    this.registerColumnOption("bottomCalcFormatterParams");
  }
  createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-calcs-holder");
    return el;
  }
  initialize() {
    this.genColumn = new Column({ field: "value" }, this);
    this.subscribe("cell-value-changed", this.cellValueChanged.bind(this));
    this.subscribe("column-init", this.initializeColumnCheck.bind(this));
    this.subscribe("row-deleted", this.rowsUpdated.bind(this));
    this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this));
    this.subscribe("row-added", this.rowsUpdated.bind(this));
    this.subscribe("column-moved", this.recalcActiveRows.bind(this));
    this.subscribe("column-add", this.recalcActiveRows.bind(this));
    this.subscribe("data-refreshed", this.recalcActiveRowsRefresh.bind(this));
    this.subscribe("table-redraw", this.tableRedraw.bind(this));
    this.subscribe("rows-visible", this.visibleRows.bind(this));
    this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this));
    this.subscribe("redraw-blocked", this.blockRedraw.bind(this));
    this.subscribe("redraw-restored", this.restoreRedraw.bind(this));
    this.registerTableFunction("getCalcResults", this.getResults.bind(this));
    this.registerTableFunction("recalc", this.userRecalc.bind(this));
  }
  tableRedraw(force) {
    this.recalc(this.table.rowManager.activeRows);
    if (force) {
      this.redraw();
    }
  }
  blockRedraw() {
    this.blocked = true;
    this.recalcAfterBlock = false;
  }
  restoreRedraw() {
    this.blocked = false;
    if (this.recalcAfterBlock) {
      this.recalcAfterBlock = false;
      this.recalcActiveRowsRefresh();
    }
  }
  userRecalc() {
    this.recalc(this.table.rowManager.activeRows);
  }
  blockCheck() {
    if (this.blocked) {
      this.recalcAfterBlock = true;
    }
    return this.blocked;
  }
  visibleRows(viewable, rows3) {
    if (this.topRow) {
      rows3.unshift(this.topRow);
    }
    if (this.botRow) {
      rows3.push(this.botRow);
    }
    return rows3;
  }
  rowsUpdated(row2) {
    if (this.table.options.groupBy) {
      this.recalcRowGroup(row2);
    } else {
      this.recalcActiveRows();
    }
  }
  recalcActiveRowsRefresh() {
    if (this.table.options.groupBy && this.table.options.dataTreeStartExpanded && this.table.options.dataTree) {
      this.recalcAll();
    } else {
      this.recalcActiveRows();
    }
  }
  recalcActiveRows() {
    this.recalc(this.table.rowManager.activeRows);
  }
  cellValueChanged(cell) {
    if (cell.column.definition.topCalc || cell.column.definition.bottomCalc) {
      if (this.table.options.groupBy) {
        if (this.table.options.columnCalcs == "table" || this.table.options.columnCalcs == "both") {
          this.recalcActiveRows();
        }
        if (this.table.options.columnCalcs != "table") {
          this.recalcRowGroup(cell.row);
        }
      } else {
        this.recalcActiveRows();
      }
    }
  }
  initializeColumnCheck(column) {
    if (column.definition.topCalc || column.definition.bottomCalc) {
      this.initializeColumn(column);
    }
  }
  initializeColumn(column) {
    var def = column.definition;
    var config = {
      topCalcParams: def.topCalcParams || {},
      botCalcParams: def.bottomCalcParams || {}
    };
    if (def.topCalc) {
      switch (typeof def.topCalc) {
        case "string":
          if (ColumnCalcs.calculations[def.topCalc]) {
            config.topCalc = ColumnCalcs.calculations[def.topCalc];
          } else {
            console.warn("Column Calc Error - No such calculation found, ignoring: ", def.topCalc);
          }
          break;
        case "function":
          config.topCalc = def.topCalc;
          break;
      }
      if (config.topCalc) {
        column.modules.columnCalcs = config;
        this.topCalcs.push(column);
        if (this.table.options.columnCalcs != "group") {
          this.initializeTopRow();
        }
      }
    }
    if (def.bottomCalc) {
      switch (typeof def.bottomCalc) {
        case "string":
          if (ColumnCalcs.calculations[def.bottomCalc]) {
            config.botCalc = ColumnCalcs.calculations[def.bottomCalc];
          } else {
            console.warn("Column Calc Error - No such calculation found, ignoring: ", def.bottomCalc);
          }
          break;
        case "function":
          config.botCalc = def.bottomCalc;
          break;
      }
      if (config.botCalc) {
        column.modules.columnCalcs = config;
        this.botCalcs.push(column);
        if (this.table.options.columnCalcs != "group") {
          this.initializeBottomRow();
        }
      }
    }
  }
  registerColumnField() {
  }
  removeCalcs() {
    var changed = false;
    if (this.topInitialized) {
      this.topInitialized = false;
      this.topElement.parentNode.removeChild(this.topElement);
      changed = true;
    }
    if (this.botInitialized) {
      this.botInitialized = false;
      this.footerRemove(this.botElement);
      changed = true;
    }
    if (changed) {
      this.table.rowManager.adjustTableSize();
    }
  }
  reinitializeCalcs() {
    if (this.topCalcs.length) {
      this.initializeTopRow();
    }
    if (this.botCalcs.length) {
      this.initializeBottomRow();
    }
  }
  initializeTopRow() {
    if (!this.topInitialized) {
      this.table.columnManager.getContentsElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling);
      this.topInitialized = true;
    }
  }
  initializeBottomRow() {
    if (!this.botInitialized) {
      this.footerPrepend(this.botElement);
      this.botInitialized = true;
    }
  }
  scrollHorizontal(left) {
    if (this.botInitialized && this.botRow) {
      this.botElement.scrollLeft = left;
    }
  }
  recalc(rows3) {
    var data, row2;
    if (!this.blockCheck()) {
      if (this.topInitialized || this.botInitialized) {
        data = this.rowsToData(rows3);
        if (this.topInitialized) {
          if (this.topRow) {
            this.topRow.deleteCells();
          }
          row2 = this.generateRow("top", data);
          this.topRow = row2;
          while (this.topElement.firstChild)
            this.topElement.removeChild(this.topElement.firstChild);
          this.topElement.appendChild(row2.getElement());
          row2.initialize(true);
        }
        if (this.botInitialized) {
          if (this.botRow) {
            this.botRow.deleteCells();
          }
          row2 = this.generateRow("bottom", data);
          this.botRow = row2;
          while (this.botElement.firstChild)
            this.botElement.removeChild(this.botElement.firstChild);
          this.botElement.appendChild(row2.getElement());
          row2.initialize(true);
        }
        this.table.rowManager.adjustTableSize();
        if (this.table.modExists("frozenColumns")) {
          this.table.modules.frozenColumns.layout();
        }
      }
    }
  }
  recalcRowGroup(row2) {
    this.recalcGroup(this.table.modules.groupRows.getRowGroup(row2));
  }
  recalcAll() {
    if (this.topCalcs.length || this.botCalcs.length) {
      if (this.table.options.columnCalcs !== "group") {
        this.recalcActiveRows();
      }
      if (this.table.options.groupBy && this.table.options.columnCalcs !== "table") {
        var groups = this.table.modules.groupRows.getChildGroups();
        groups.forEach((group) => {
          this.recalcGroup(group);
        });
      }
    }
  }
  recalcGroup(group) {
    var data, rowData;
    if (!this.blockCheck()) {
      if (group) {
        if (group.calcs) {
          if (group.calcs.bottom) {
            data = this.rowsToData(group.rows);
            rowData = this.generateRowData("bottom", data);
            group.calcs.bottom.updateData(rowData);
            group.calcs.bottom.reinitialize();
          }
          if (group.calcs.top) {
            data = this.rowsToData(group.rows);
            rowData = this.generateRowData("top", data);
            group.calcs.top.updateData(rowData);
            group.calcs.top.reinitialize();
          }
        }
      }
    }
  }
  generateTopRow(rows3) {
    return this.generateRow("top", this.rowsToData(rows3));
  }
  generateBottomRow(rows3) {
    return this.generateRow("bottom", this.rowsToData(rows3));
  }
  rowsToData(rows3) {
    var data = [];
    rows3.forEach((row2) => {
      data.push(row2.getData());
      if (this.table.options.dataTree && this.table.options.dataTreeChildColumnCalcs) {
        if (row2.modules.dataTree && row2.modules.dataTree.open) {
          var children = this.rowsToData(this.table.modules.dataTree.getFilteredTreeChildren(row2));
          data = data.concat(children);
        }
      }
    });
    return data;
  }
  generateRow(pos, data) {
    var rowData = this.generateRowData(pos, data), row2;
    if (this.table.modExists("mutator")) {
      this.table.modules.mutator.disable();
    }
    row2 = new Row(rowData, this, "calc");
    if (this.table.modExists("mutator")) {
      this.table.modules.mutator.enable();
    }
    row2.getElement().classList.add("tabulator-calcs", "tabulator-calcs-" + pos);
    row2.component = false;
    row2.getComponent = () => {
      if (!row2.component) {
        row2.component = new CalcComponent(row2);
      }
      return row2.component;
    };
    row2.generateCells = () => {
      var cells = [];
      this.table.columnManager.columnsByIndex.forEach((column) => {
        this.genColumn.setField(column.getField());
        this.genColumn.hozAlign = column.hozAlign;
        if (column.definition[pos + "CalcFormatter"] && this.table.modExists("format")) {
          this.genColumn.modules.format = {
            formatter: this.table.modules.format.getFormatter(column.definition[pos + "CalcFormatter"]),
            params: column.definition[pos + "CalcFormatterParams"] || {}
          };
        } else {
          this.genColumn.modules.format = {
            formatter: this.table.modules.format.getFormatter("plaintext"),
            params: {}
          };
        }
        this.genColumn.definition.cssClass = column.definition.cssClass;
        var cell = new Cell(this.genColumn, row2);
        cell.getElement();
        cell.column = column;
        cell.setWidth();
        column.cells.push(cell);
        cells.push(cell);
        if (!column.visible) {
          cell.hide();
        }
      });
      row2.cells = cells;
    };
    return row2;
  }
  generateRowData(pos, data) {
    var rowData = {}, calcs = pos == "top" ? this.topCalcs : this.botCalcs, type = pos == "top" ? "topCalc" : "botCalc", params, paramKey;
    calcs.forEach(function(column) {
      var values2 = [];
      if (column.modules.columnCalcs && column.modules.columnCalcs[type]) {
        data.forEach(function(item) {
          values2.push(column.getFieldValue(item));
        });
        paramKey = type + "Params";
        params = typeof column.modules.columnCalcs[paramKey] === "function" ? column.modules.columnCalcs[paramKey](values2, data) : column.modules.columnCalcs[paramKey];
        column.setFieldValue(rowData, column.modules.columnCalcs[type](values2, data, params));
      }
    });
    return rowData;
  }
  hasTopCalcs() {
    return !!this.topCalcs.length;
  }
  hasBottomCalcs() {
    return !!this.botCalcs.length;
  }
  redraw() {
    if (this.topRow) {
      this.topRow.normalizeHeight(true);
    }
    if (this.botRow) {
      this.botRow.normalizeHeight(true);
    }
  }
  getResults() {
    var results = {}, groups;
    if (this.table.options.groupBy && this.table.modExists("groupRows")) {
      groups = this.table.modules.groupRows.getGroups(true);
      groups.forEach((group) => {
        results[group.getKey()] = this.getGroupResults(group);
      });
    } else {
      results = {
        top: this.topRow ? this.topRow.getData() : {},
        bottom: this.botRow ? this.botRow.getData() : {}
      };
    }
    return results;
  }
  getGroupResults(group) {
    var groupObj = group._getSelf(), subGroups = group.getSubGroups(), subGroupResults = {}, results = {};
    subGroups.forEach((subgroup) => {
      subGroupResults[subgroup.getKey()] = this.getGroupResults(subgroup);
    });
    results = {
      top: groupObj.calcs.top ? groupObj.calcs.top.getData() : {},
      bottom: groupObj.calcs.bottom ? groupObj.calcs.bottom.getData() : {},
      groups: subGroupResults
    };
    return results;
  }
  adjustForScrollbar(width) {
    if (this.botRow) {
      if (this.table.rtl) {
        this.botElement.style.paddingLeft = width + "px";
      } else {
        this.botElement.style.paddingRight = width + "px";
      }
    }
  }
};
ColumnCalcs.moduleName = "columnCalcs";
ColumnCalcs.calculations = defaultCalculations;
var DataTree = class extends Module {
  constructor(table) {
    super(table);
    this.indent = 10;
    this.field = "";
    this.collapseEl = null;
    this.expandEl = null;
    this.branchEl = null;
    this.elementField = false;
    this.startOpen = function() {
    };
    this.registerTableOption("dataTree", false);
    this.registerTableOption("dataTreeFilter", true);
    this.registerTableOption("dataTreeSort", true);
    this.registerTableOption("dataTreeElementColumn", false);
    this.registerTableOption("dataTreeBranchElement", true);
    this.registerTableOption("dataTreeChildIndent", 9);
    this.registerTableOption("dataTreeChildField", "_children");
    this.registerTableOption("dataTreeCollapseElement", false);
    this.registerTableOption("dataTreeExpandElement", false);
    this.registerTableOption("dataTreeStartExpanded", false);
    this.registerTableOption("dataTreeChildColumnCalcs", false);
    this.registerTableOption("dataTreeSelectPropagate", false);
    this.registerComponentFunction("row", "treeCollapse", this.collapseRow.bind(this));
    this.registerComponentFunction("row", "treeExpand", this.expandRow.bind(this));
    this.registerComponentFunction("row", "treeToggle", this.toggleRow.bind(this));
    this.registerComponentFunction("row", "getTreeParent", this.getTreeParent.bind(this));
    this.registerComponentFunction("row", "getTreeChildren", this.getRowChildren.bind(this));
    this.registerComponentFunction("row", "addTreeChild", this.addTreeChildRow.bind(this));
    this.registerComponentFunction("row", "isTreeExpanded", this.isRowExpanded.bind(this));
  }
  initialize() {
    if (this.table.options.dataTree) {
      var dummyEl = null, options = this.table.options;
      this.field = options.dataTreeChildField;
      this.indent = options.dataTreeChildIndent;
      if (this.options("movableRows")) {
        console.warn("The movableRows option is not available with dataTree enabled, moving of child rows could result in unpredictable behavior");
      }
      if (options.dataTreeBranchElement) {
        if (options.dataTreeBranchElement === true) {
          this.branchEl = document.createElement("div");
          this.branchEl.classList.add("tabulator-data-tree-branch");
        } else {
          if (typeof options.dataTreeBranchElement === "string") {
            dummyEl = document.createElement("div");
            dummyEl.innerHTML = options.dataTreeBranchElement;
            this.branchEl = dummyEl.firstChild;
          } else {
            this.branchEl = options.dataTreeBranchElement;
          }
        }
      }
      if (options.dataTreeCollapseElement) {
        if (typeof options.dataTreeCollapseElement === "string") {
          dummyEl = document.createElement("div");
          dummyEl.innerHTML = options.dataTreeCollapseElement;
          this.collapseEl = dummyEl.firstChild;
        } else {
          this.collapseEl = options.dataTreeCollapseElement;
        }
      } else {
        this.collapseEl = document.createElement("div");
        this.collapseEl.classList.add("tabulator-data-tree-control");
        this.collapseEl.tabIndex = 0;
        this.collapseEl.innerHTML = "<div class='tabulator-data-tree-control-collapse'></div>";
      }
      if (options.dataTreeExpandElement) {
        if (typeof options.dataTreeExpandElement === "string") {
          dummyEl = document.createElement("div");
          dummyEl.innerHTML = options.dataTreeExpandElement;
          this.expandEl = dummyEl.firstChild;
        } else {
          this.expandEl = options.dataTreeExpandElement;
        }
      } else {
        this.expandEl = document.createElement("div");
        this.expandEl.classList.add("tabulator-data-tree-control");
        this.expandEl.tabIndex = 0;
        this.expandEl.innerHTML = "<div class='tabulator-data-tree-control-expand'></div>";
      }
      switch (typeof options.dataTreeStartExpanded) {
        case "boolean":
          this.startOpen = function(row2, index2) {
            return options.dataTreeStartExpanded;
          };
          break;
        case "function":
          this.startOpen = options.dataTreeStartExpanded;
          break;
        default:
          this.startOpen = function(row2, index2) {
            return options.dataTreeStartExpanded[index2];
          };
          break;
      }
      this.subscribe("row-init", this.initializeRow.bind(this));
      this.subscribe("row-layout-after", this.layoutRow.bind(this));
      this.subscribe("row-deleted", this.rowDelete.bind(this), 0);
      this.subscribe("row-data-changed", this.rowDataChanged.bind(this), 10);
      this.subscribe("cell-value-updated", this.cellValueChanged.bind(this));
      this.subscribe("edit-cancelled", this.cellValueChanged.bind(this));
      this.subscribe("column-moving-rows", this.columnMoving.bind(this));
      this.subscribe("table-built", this.initializeElementField.bind(this));
      this.subscribe("table-redrawing", this.tableRedrawing.bind(this));
      this.registerDisplayHandler(this.getRows.bind(this), 30);
    }
  }
  tableRedrawing(force) {
    var rows3;
    if (force) {
      rows3 = this.table.rowManager.getRows();
      rows3.forEach((row2) => {
        this.reinitializeRowChildren(row2);
      });
    }
  }
  initializeElementField() {
    var firstCol = this.table.columnManager.getFirstVisibleColumn();
    this.elementField = this.table.options.dataTreeElementColumn || (firstCol ? firstCol.field : false);
  }
  getRowChildren(row2) {
    return this.getTreeChildren(row2, true);
  }
  columnMoving() {
    var rows3 = [];
    this.table.rowManager.rows.forEach((row2) => {
      rows3 = rows3.concat(this.getTreeChildren(row2, false, true));
    });
    return rows3;
  }
  rowDataChanged(row2, visible, updatedData) {
    if (this.redrawNeeded(updatedData)) {
      this.initializeRow(row2);
      if (visible) {
        this.layoutRow(row2);
        this.refreshData(true);
      }
    }
  }
  cellValueChanged(cell) {
    var field = cell.column.getField();
    if (field === this.elementField) {
      this.layoutRow(cell.row);
    }
  }
  initializeRow(row2) {
    var childArray = row2.getData()[this.field];
    var isArray2 = Array.isArray(childArray);
    var children = isArray2 || !isArray2 && typeof childArray === "object" && childArray !== null;
    if (!children && row2.modules.dataTree && row2.modules.dataTree.branchEl) {
      row2.modules.dataTree.branchEl.parentNode.removeChild(row2.modules.dataTree.branchEl);
    }
    if (!children && row2.modules.dataTree && row2.modules.dataTree.controlEl) {
      row2.modules.dataTree.controlEl.parentNode.removeChild(row2.modules.dataTree.controlEl);
    }
    row2.modules.dataTree = {
      index: row2.modules.dataTree ? row2.modules.dataTree.index : 0,
      open: children ? row2.modules.dataTree ? row2.modules.dataTree.open : this.startOpen(row2.getComponent(), 0) : false,
      controlEl: row2.modules.dataTree && children ? row2.modules.dataTree.controlEl : false,
      branchEl: row2.modules.dataTree && children ? row2.modules.dataTree.branchEl : false,
      parent: row2.modules.dataTree ? row2.modules.dataTree.parent : false,
      children
    };
  }
  reinitializeRowChildren(row2) {
    var children = this.getTreeChildren(row2, false, true);
    children.forEach(function(child) {
      child.reinitialize(true);
    });
  }
  layoutRow(row2) {
    var cell = this.elementField ? row2.getCell(this.elementField) : row2.getCells()[0], el = cell.getElement(), config = row2.modules.dataTree;
    if (config.branchEl) {
      if (config.branchEl.parentNode) {
        config.branchEl.parentNode.removeChild(config.branchEl);
      }
      config.branchEl = false;
    }
    if (config.controlEl) {
      if (config.controlEl.parentNode) {
        config.controlEl.parentNode.removeChild(config.controlEl);
      }
      config.controlEl = false;
    }
    this.generateControlElement(row2, el);
    row2.getElement().classList.add("tabulator-tree-level-" + config.index);
    if (config.index) {
      if (this.branchEl) {
        config.branchEl = this.branchEl.cloneNode(true);
        el.insertBefore(config.branchEl, el.firstChild);
        if (this.table.rtl) {
          config.branchEl.style.marginRight = (config.branchEl.offsetWidth + config.branchEl.style.marginLeft) * (config.index - 1) + config.index * this.indent + "px";
        } else {
          config.branchEl.style.marginLeft = (config.branchEl.offsetWidth + config.branchEl.style.marginRight) * (config.index - 1) + config.index * this.indent + "px";
        }
      } else {
        if (this.table.rtl) {
          el.style.paddingRight = parseInt(window.getComputedStyle(el, null).getPropertyValue("padding-right")) + config.index * this.indent + "px";
        } else {
          el.style.paddingLeft = parseInt(window.getComputedStyle(el, null).getPropertyValue("padding-left")) + config.index * this.indent + "px";
        }
      }
    }
  }
  generateControlElement(row2, el) {
    var config = row2.modules.dataTree, oldControl = config.controlEl;
    el = el || row2.getCells()[0].getElement();
    if (config.children !== false) {
      if (config.open) {
        config.controlEl = this.collapseEl.cloneNode(true);
        config.controlEl.addEventListener("click", (e) => {
          e.stopPropagation();
          this.collapseRow(row2);
        });
      } else {
        config.controlEl = this.expandEl.cloneNode(true);
        config.controlEl.addEventListener("click", (e) => {
          e.stopPropagation();
          this.expandRow(row2);
        });
      }
      config.controlEl.addEventListener("mousedown", (e) => {
        e.stopPropagation();
      });
      if (oldControl && oldControl.parentNode === el) {
        oldControl.parentNode.replaceChild(config.controlEl, oldControl);
      } else {
        el.insertBefore(config.controlEl, el.firstChild);
      }
    }
  }
  getRows(rows3) {
    var output = [];
    rows3.forEach((row2, i2) => {
      var config, children;
      output.push(row2);
      if (row2 instanceof Row) {
        row2.create();
        config = row2.modules.dataTree.children;
        if (!config.index && config.children !== false) {
          children = this.getChildren(row2);
          children.forEach((child) => {
            child.create();
            output.push(child);
          });
        }
      }
    });
    return output;
  }
  getChildren(row2, allChildren) {
    var config = row2.modules.dataTree, children = [], output = [];
    if (config.children !== false && (config.open || allChildren)) {
      if (!Array.isArray(config.children)) {
        config.children = this.generateChildren(row2);
      }
      if (this.table.modExists("filter") && this.table.options.dataTreeFilter) {
        children = this.table.modules.filter.filter(config.children);
      } else {
        children = config.children;
      }
      if (this.table.modExists("sort") && this.table.options.dataTreeSort) {
        this.table.modules.sort.sort(children);
      }
      children.forEach((child) => {
        output.push(child);
        var subChildren = this.getChildren(child);
        subChildren.forEach((sub) => {
          output.push(sub);
        });
      });
    }
    return output;
  }
  generateChildren(row2) {
    var children = [];
    var childArray = row2.getData()[this.field];
    if (!Array.isArray(childArray)) {
      childArray = [childArray];
    }
    childArray.forEach((childData) => {
      var childRow = new Row(childData || {}, this.table.rowManager);
      childRow.create();
      childRow.modules.dataTree.index = row2.modules.dataTree.index + 1;
      childRow.modules.dataTree.parent = row2;
      if (childRow.modules.dataTree.children) {
        childRow.modules.dataTree.open = this.startOpen(childRow.getComponent(), childRow.modules.dataTree.index);
      }
      children.push(childRow);
    });
    return children;
  }
  expandRow(row2, silent) {
    var config = row2.modules.dataTree;
    if (config.children !== false) {
      config.open = true;
      row2.reinitialize();
      this.refreshData(true);
      this.dispatchExternal("dataTreeRowExpanded", row2.getComponent(), row2.modules.dataTree.index);
    }
  }
  collapseRow(row2) {
    var config = row2.modules.dataTree;
    if (config.children !== false) {
      config.open = false;
      row2.reinitialize();
      this.refreshData(true);
      this.dispatchExternal("dataTreeRowCollapsed", row2.getComponent(), row2.modules.dataTree.index);
    }
  }
  toggleRow(row2) {
    var config = row2.modules.dataTree;
    if (config.children !== false) {
      if (config.open) {
        this.collapseRow(row2);
      } else {
        this.expandRow(row2);
      }
    }
  }
  isRowExpanded(row2) {
    return row2.modules.dataTree.open;
  }
  getTreeParent(row2) {
    return row2.modules.dataTree.parent ? row2.modules.dataTree.parent.getComponent() : false;
  }
  getTreeParentRoot(row2) {
    return row2.modules.dataTree && row2.modules.dataTree.parent ? this.getTreeParentRoot(row2.modules.dataTree.parent) : row2;
  }
  getFilteredTreeChildren(row2) {
    var config = row2.modules.dataTree, output = [], children;
    if (config.children) {
      if (!Array.isArray(config.children)) {
        config.children = this.generateChildren(row2);
      }
      if (this.table.modExists("filter") && this.table.options.dataTreeFilter) {
        children = this.table.modules.filter.filter(config.children);
      } else {
        children = config.children;
      }
      children.forEach((childRow) => {
        if (childRow instanceof Row) {
          output.push(childRow);
        }
      });
    }
    return output;
  }
  rowDelete(row2) {
    var parent = row2.modules.dataTree.parent, childIndex;
    if (parent) {
      childIndex = this.findChildIndex(row2, parent);
      if (childIndex !== false) {
        parent.data[this.field].splice(childIndex, 1);
      }
      if (!parent.data[this.field].length) {
        delete parent.data[this.field];
      }
      this.initializeRow(parent);
      this.layoutRow(parent);
    }
    this.refreshData(true);
  }
  addTreeChildRow(row2, data, top, index2) {
    var childIndex = false;
    if (typeof data === "string") {
      data = JSON.parse(data);
    }
    if (!Array.isArray(row2.data[this.field])) {
      row2.data[this.field] = [];
      row2.modules.dataTree.open = this.startOpen(row2.getComponent(), row2.modules.dataTree.index);
    }
    if (typeof index2 !== "undefined") {
      childIndex = this.findChildIndex(index2, row2);
      if (childIndex !== false) {
        row2.data[this.field].splice(top ? childIndex : childIndex + 1, 0, data);
      }
    }
    if (childIndex === false) {
      if (top) {
        row2.data[this.field].unshift(data);
      } else {
        row2.data[this.field].push(data);
      }
    }
    this.initializeRow(row2);
    this.layoutRow(row2);
    this.refreshData(true);
  }
  findChildIndex(subject, parent) {
    var match2 = false;
    if (typeof subject == "object") {
      if (subject instanceof Row) {
        match2 = subject.data;
      } else if (subject instanceof RowComponent) {
        match2 = subject._getSelf().data;
      } else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
        if (parent.modules.dataTree) {
          match2 = parent.modules.dataTree.children.find((childRow) => {
            return childRow instanceof Row ? childRow.element === subject : false;
          });
          if (match2) {
            match2 = match2.data;
          }
        }
      } else if (subject === null) {
        match2 = false;
      }
    } else if (typeof subject == "undefined") {
      match2 = false;
    } else {
      match2 = parent.data[this.field].find((row2) => {
        return row2.data[this.table.options.index] == subject;
      });
    }
    if (match2) {
      if (Array.isArray(parent.data[this.field])) {
        match2 = parent.data[this.field].indexOf(match2);
      }
      if (match2 == -1) {
        match2 = false;
      }
    }
    return match2;
  }
  getTreeChildren(row2, component, recurse) {
    var config = row2.modules.dataTree, output = [];
    if (config.children) {
      if (!Array.isArray(config.children)) {
        config.children = this.generateChildren(row2);
      }
      config.children.forEach((childRow) => {
        if (childRow instanceof Row) {
          output.push(component ? childRow.getComponent() : childRow);
          if (recurse) {
            output = output.concat(this.getTreeChildren(childRow, component, recurse));
          }
        }
      });
    }
    return output;
  }
  getChildField() {
    return this.field;
  }
  redrawNeeded(data) {
    return (this.field ? typeof data[this.field] !== "undefined" : false) || (this.elementField ? typeof data[this.elementField] !== "undefined" : false);
  }
};
DataTree.moduleName = "dataTree";
function csv2(list2, options = {}, setFileContents) {
  var delimiter = options.delimiter ? options.delimiter : ",", fileContents = [], headers = [];
  list2.forEach((row2) => {
    var item = [];
    switch (row2.type) {
      case "group":
        console.warn("Download Warning - CSV downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - CSV downloader cannot process column calculations");
        break;
      case "header":
        row2.columns.forEach((col, i2) => {
          if (col && col.depth === 1) {
            headers[i2] = typeof col.value == "undefined" || col.value === null ? "" : '"' + String(col.value).split('"').join('""') + '"';
          }
        });
        break;
      case "row":
        row2.columns.forEach((col) => {
          if (col) {
            switch (typeof col.value) {
              case "object":
                col.value = col.value !== null ? JSON.stringify(col.value) : "";
                break;
              case "undefined":
                col.value = "";
                break;
            }
            item.push('"' + String(col.value).split('"').join('""') + '"');
          }
        });
        fileContents.push(item.join(delimiter));
        break;
    }
  });
  if (headers.length) {
    fileContents.unshift(headers.join(delimiter));
  }
  fileContents = fileContents.join("\n");
  if (options.bom) {
    fileContents = "\uFEFF" + fileContents;
  }
  setFileContents(fileContents, "text/csv");
}
function json(list2, options, setFileContents) {
  var fileContents = [];
  list2.forEach((row2) => {
    var item = {};
    switch (row2.type) {
      case "header":
        break;
      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;
      case "row":
        row2.columns.forEach((col) => {
          if (col) {
            item[col.component.getTitleDownload() || col.component.getField()] = col.value;
          }
        });
        fileContents.push(item);
        break;
    }
  });
  fileContents = JSON.stringify(fileContents, null, "	");
  setFileContents(fileContents, "application/json");
}
function pdf(list2, options = {}, setFileContents) {
  var header = [], body = [], autoTableParams = {}, rowGroupStyles = options.rowGroupStyles || {
    fontStyle: "bold",
    fontSize: 12,
    cellPadding: 6,
    fillColor: 220
  }, rowCalcStyles = options.rowCalcStyles || {
    fontStyle: "bold",
    fontSize: 10,
    cellPadding: 4,
    fillColor: 232
  }, jsPDFParams = options.jsPDF || {}, title = options.title ? options.title : "";
  if (!jsPDFParams.orientation) {
    jsPDFParams.orientation = options.orientation || "landscape";
  }
  if (!jsPDFParams.unit) {
    jsPDFParams.unit = "pt";
  }
  list2.forEach((row2) => {
    switch (row2.type) {
      case "header":
        header.push(parseRow(row2));
        break;
      case "group":
        body.push(parseRow(row2, rowGroupStyles));
        break;
      case "calc":
        body.push(parseRow(row2, rowCalcStyles));
        break;
      case "row":
        body.push(parseRow(row2));
        break;
    }
  });
  function parseRow(row2, styles) {
    var rowData = [];
    row2.columns.forEach((col) => {
      var cell;
      if (col) {
        switch (typeof col.value) {
          case "object":
            col.value = col.value !== null ? JSON.stringify(col.value) : "";
            break;
          case "undefined":
            col.value = "";
            break;
        }
        cell = {
          content: col.value,
          colSpan: col.width,
          rowSpan: col.height
        };
        if (styles) {
          cell.styles = styles;
        }
        rowData.push(cell);
      }
    });
    return rowData;
  }
  var doc = new jspdf.jsPDF(jsPDFParams);
  if (options.autoTable) {
    if (typeof options.autoTable === "function") {
      autoTableParams = options.autoTable(doc) || {};
    } else {
      autoTableParams = options.autoTable;
    }
  }
  if (title) {
    autoTableParams.didDrawPage = function(data) {
      doc.text(title, 40, 30);
    };
  }
  autoTableParams.head = header;
  autoTableParams.body = body;
  doc.autoTable(autoTableParams);
  if (options.documentProcessing) {
    options.documentProcessing(doc);
  }
  setFileContents(doc.output("arraybuffer"), "application/pdf");
}
function xlsx(list2, options, setFileContents) {
  var self2 = this, sheetName = options.sheetName || "Sheet1", workbook = XLSX.utils.book_new(), tableFeatures = new CoreFeature(this), compression = "compress" in options ? options.compress : true, output;
  workbook.SheetNames = [];
  workbook.Sheets = {};
  function generateSheet() {
    var rows3 = [], merges = [], worksheet = {}, range2 = { s: { c: 0, r: 0 }, e: { c: list2[0] ? list2[0].columns.reduce((a, b) => a + (b && b.width ? b.width : 1), 0) : 0, r: list2.length } };
    list2.forEach((row2, i2) => {
      var rowData = [];
      row2.columns.forEach(function(col, j) {
        if (col) {
          rowData.push(!(col.value instanceof Date) && typeof col.value === "object" ? JSON.stringify(col.value) : col.value);
          if (col.width > 1 || col.height > -1) {
            if (col.height > 1 || col.width > 1) {
              merges.push({ s: { r: i2, c: j }, e: { r: i2 + col.height - 1, c: j + col.width - 1 } });
            }
          }
        } else {
          rowData.push("");
        }
      });
      rows3.push(rowData);
    });
    XLSX.utils.sheet_add_aoa(worksheet, rows3);
    worksheet["!ref"] = XLSX.utils.encode_range(range2);
    if (merges.length) {
      worksheet["!merges"] = merges;
    }
    return worksheet;
  }
  if (options.sheetOnly) {
    setFileContents(generateSheet());
    return;
  }
  if (options.sheets) {
    for (var sheet in options.sheets) {
      if (options.sheets[sheet] === true) {
        workbook.SheetNames.push(sheet);
        workbook.Sheets[sheet] = generateSheet();
      } else {
        workbook.SheetNames.push(sheet);
        tableFeatures.commsSend(options.sheets[sheet], "download", "intercept", {
          type: "xlsx",
          options: { sheetOnly: true },
          active: self2.active,
          intercept: function(data) {
            workbook.Sheets[sheet] = data;
          }
        });
      }
    }
  } else {
    workbook.SheetNames.push(sheetName);
    workbook.Sheets[sheetName] = generateSheet();
  }
  if (options.documentProcessing) {
    workbook = options.documentProcessing(workbook);
  }
  function s2ab(s2) {
    var buf = new ArrayBuffer(s2.length);
    var view = new Uint8Array(buf);
    for (var i2 = 0; i2 != s2.length; ++i2)
      view[i2] = s2.charCodeAt(i2) & 255;
    return buf;
  }
  output = XLSX.write(workbook, { bookType: "xlsx", bookSST: true, type: "binary", compression });
  setFileContents(s2ab(output), "application/octet-stream");
}
function html(list2, options, setFileContents) {
  if (this.modExists("export", true)) {
    setFileContents(this.modules.export.generateHTMLTable(list2), "text/html");
  }
}
function jsonLines(list2, options, setFileContents) {
  const fileContents = [];
  list2.forEach((row2) => {
    const item = {};
    switch (row2.type) {
      case "header":
        break;
      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;
      case "row":
        row2.columns.forEach((col) => {
          if (col) {
            item[col.component.getTitleDownload() || col.component.getField()] = col.value;
          }
        });
        fileContents.push(JSON.stringify(item));
        break;
    }
  });
  setFileContents(fileContents.join("\n"), "application/x-ndjson");
}
var defaultDownloaders = {
  csv: csv2,
  json,
  jsonLines,
  pdf,
  xlsx,
  html
};
var Download = class extends Module {
  constructor(table) {
    super(table);
    this.registerTableOption("downloadEncoder", function(data, mimeType) {
      return new Blob([data], { type: mimeType });
    });
    this.registerTableOption("downloadReady", void 0);
    this.registerTableOption("downloadConfig", {});
    this.registerTableOption("downloadRowRange", "active");
    this.registerColumnOption("download");
    this.registerColumnOption("titleDownload");
  }
  initialize() {
    this.deprecatedOptionsCheck();
    this.registerTableFunction("download", this.download.bind(this));
    this.registerTableFunction("downloadToTab", this.downloadToTab.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheck("downloadReady", "downloadEncoder");
  }
  downloadToTab(type, filename, options, active) {
    this.download(type, filename, options, active, true);
  }
  download(type, filename, options, range2, interceptCallback) {
    var downloadFunc = false;
    function buildLink(data, mime) {
      if (interceptCallback) {
        if (interceptCallback === true) {
          this.triggerDownload(data, mime, type, filename, true);
        } else {
          interceptCallback(data);
        }
      } else {
        this.triggerDownload(data, mime, type, filename);
      }
    }
    if (typeof type == "function") {
      downloadFunc = type;
    } else {
      if (Download.downloaders[type]) {
        downloadFunc = Download.downloaders[type];
      } else {
        console.warn("Download Error - No such download type found: ", type);
      }
    }
    if (downloadFunc) {
      var list2 = this.generateExportList(range2);
      downloadFunc.call(this.table, list2, options || {}, buildLink.bind(this));
    }
  }
  generateExportList(range2) {
    var list2 = this.table.modules.export.generateExportList(this.table.options.downloadConfig, false, range2 || this.table.options.downloadRowRange, "download");
    var groupHeader = this.table.options.groupHeaderDownload;
    if (groupHeader && !Array.isArray(groupHeader)) {
      groupHeader = [groupHeader];
    }
    list2.forEach((row2) => {
      var group;
      if (row2.type === "group") {
        group = row2.columns[0];
        if (groupHeader && groupHeader[row2.indent]) {
          group.value = groupHeader[row2.indent](group.value, row2.component._group.getRowCount(), row2.component._group.getData(), row2.component);
        }
      }
    });
    return list2;
  }
  triggerDownload(data, mime, type, filename, newTab) {
    var element = document.createElement("a"), blob = this.table.options.downloadEncoder(data, mime);
    if (blob) {
      if (newTab) {
        window.open(window.URL.createObjectURL(blob));
      } else {
        filename = filename || "Tabulator." + (typeof type === "function" ? "txt" : type);
        if (navigator.msSaveOrOpenBlob) {
          navigator.msSaveOrOpenBlob(blob, filename);
        } else {
          element.setAttribute("href", window.URL.createObjectURL(blob));
          element.setAttribute("download", filename);
          element.style.display = "none";
          document.body.appendChild(element);
          element.click();
          document.body.removeChild(element);
        }
      }
      this.dispatchExternal("downloadComplete");
    }
  }
  commsReceived(table, action, data) {
    switch (action) {
      case "intercept":
        this.download(data.type, "", data.options, data.active, data.intercept);
        break;
    }
  }
};
Download.moduleName = "download";
Download.downloaders = defaultDownloaders;
function maskInput(el, options) {
  var mask = options.mask, maskLetter = typeof options.maskLetterChar !== "undefined" ? options.maskLetterChar : "A", maskNumber = typeof options.maskNumberChar !== "undefined" ? options.maskNumberChar : "9", maskWildcard = typeof options.maskWildcardChar !== "undefined" ? options.maskWildcardChar : "*";
  function fillSymbols(index2) {
    var symbol = mask[index2];
    if (typeof symbol !== "undefined" && symbol !== maskWildcard && symbol !== maskLetter && symbol !== maskNumber) {
      el.value = el.value + "" + symbol;
      fillSymbols(index2 + 1);
    }
  }
  el.addEventListener("keydown", (e) => {
    var index2 = el.value.length, char = e.key;
    if (e.keyCode > 46 && !e.ctrlKey && !e.metaKey) {
      if (index2 >= mask.length) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      } else {
        switch (mask[index2]) {
          case maskLetter:
            if (char.toUpperCase() == char.toLowerCase()) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
            break;
          case maskNumber:
            if (isNaN(char)) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
            break;
          case maskWildcard:
            break;
          default:
            if (char !== mask[index2]) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
        }
      }
    }
    return;
  });
  el.addEventListener("keyup", (e) => {
    if (e.keyCode > 46) {
      if (options.maskAutoFill) {
        fillSymbols(el.value.length);
      }
    }
  });
  if (!el.placeholder) {
    el.placeholder = mask;
  }
  if (options.maskAutoFill) {
    fillSymbols(el.value.length);
  }
}
function input(cell, onRendered, success, cancel, editorParams) {
  var cellValue = cell.getValue(), input2 = document.createElement("input");
  input2.setAttribute("type", editorParams.search ? "search" : "text");
  input2.style.padding = "4px";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  input2.value = typeof cellValue !== "undefined" ? cellValue : "";
  onRendered(function() {
    input2.focus({ preventScroll: true });
    input2.style.height = "100%";
    if (editorParams.selectContents) {
      input2.select();
    }
  });
  function onChange(e) {
    if ((cellValue === null || typeof cellValue === "undefined") && input2.value !== "" || input2.value !== cellValue) {
      if (success(input2.value)) {
        cellValue = input2.value;
      }
    } else {
      cancel();
    }
  }
  input2.addEventListener("change", onChange);
  input2.addEventListener("blur", onChange);
  input2.addEventListener("keydown", function(e) {
    switch (e.keyCode) {
      case 13:
        onChange();
        break;
      case 27:
        cancel();
        break;
      case 35:
      case 36:
        e.stopPropagation();
        break;
    }
  });
  if (editorParams.mask) {
    maskInput(input2, editorParams);
  }
  return input2;
}
function textarea(cell, onRendered, success, cancel, editorParams) {
  var cellValue = cell.getValue(), vertNav = editorParams.verticalNavigation || "hybrid", value = String(cellValue !== null && typeof cellValue !== "undefined" ? cellValue : ""), input2 = document.createElement("textarea"), scrollHeight = 0;
  input2.style.display = "block";
  input2.style.padding = "2px";
  input2.style.height = "100%";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  input2.style.whiteSpace = "pre-wrap";
  input2.style.resize = "none";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  input2.value = value;
  onRendered(function() {
    input2.focus({ preventScroll: true });
    input2.style.height = "100%";
    input2.scrollHeight;
    input2.style.height = input2.scrollHeight + "px";
    cell.getRow().normalizeHeight();
    if (editorParams.selectContents) {
      input2.select();
    }
  });
  function onChange(e) {
    if ((cellValue === null || typeof cellValue === "undefined") && input2.value !== "" || input2.value !== cellValue) {
      if (success(input2.value)) {
        cellValue = input2.value;
      }
      setTimeout(function() {
        cell.getRow().normalizeHeight();
      }, 300);
    } else {
      cancel();
    }
  }
  input2.addEventListener("change", onChange);
  input2.addEventListener("blur", onChange);
  input2.addEventListener("keyup", function() {
    input2.style.height = "";
    var heightNow = input2.scrollHeight;
    input2.style.height = heightNow + "px";
    if (heightNow != scrollHeight) {
      scrollHeight = heightNow;
      cell.getRow().normalizeHeight();
    }
  });
  input2.addEventListener("keydown", function(e) {
    switch (e.keyCode) {
      case 13:
        if (e.shiftKey && editorParams.shiftEnterSubmit) {
          onChange();
        }
        break;
      case 27:
        cancel();
        break;
      case 38:
        if (vertNav == "editor" || vertNav == "hybrid" && input2.selectionStart) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
        break;
      case 40:
        if (vertNav == "editor" || vertNav == "hybrid" && input2.selectionStart !== input2.value.length) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
        break;
      case 35:
      case 36:
        e.stopPropagation();
        break;
    }
  });
  if (editorParams.mask) {
    maskInput(input2, editorParams);
  }
  return input2;
}
function number(cell, onRendered, success, cancel, editorParams) {
  var cellValue = cell.getValue(), vertNav = editorParams.verticalNavigation || "editor", input2 = document.createElement("input");
  input2.setAttribute("type", "number");
  if (typeof editorParams.max != "undefined") {
    input2.setAttribute("max", editorParams.max);
  }
  if (typeof editorParams.min != "undefined") {
    input2.setAttribute("min", editorParams.min);
  }
  if (typeof editorParams.step != "undefined") {
    input2.setAttribute("step", editorParams.step);
  }
  input2.style.padding = "4px";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  input2.value = cellValue;
  var blurFunc = function(e) {
    onChange();
  };
  onRendered(function() {
    input2.removeEventListener("blur", blurFunc);
    input2.focus({ preventScroll: true });
    input2.style.height = "100%";
    input2.addEventListener("blur", blurFunc);
    if (editorParams.selectContents) {
      input2.select();
    }
  });
  function onChange() {
    var value = input2.value;
    if (!isNaN(value) && value !== "") {
      value = Number(value);
    }
    if (value !== cellValue) {
      if (success(value)) {
        cellValue = value;
      }
    } else {
      cancel();
    }
  }
  input2.addEventListener("keydown", function(e) {
    switch (e.keyCode) {
      case 13:
        onChange();
        break;
      case 27:
        cancel();
        break;
      case 38:
      case 40:
        if (vertNav == "editor") {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
        break;
      case 35:
      case 36:
        e.stopPropagation();
        break;
    }
  });
  if (editorParams.mask) {
    maskInput(input2, editorParams);
  }
  return input2;
}
function range(cell, onRendered, success, cancel, editorParams) {
  var cellValue = cell.getValue(), input2 = document.createElement("input");
  input2.setAttribute("type", "range");
  if (typeof editorParams.max != "undefined") {
    input2.setAttribute("max", editorParams.max);
  }
  if (typeof editorParams.min != "undefined") {
    input2.setAttribute("min", editorParams.min);
  }
  if (typeof editorParams.step != "undefined") {
    input2.setAttribute("step", editorParams.step);
  }
  input2.style.padding = "4px";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  input2.value = cellValue;
  onRendered(function() {
    input2.focus({ preventScroll: true });
    input2.style.height = "100%";
  });
  function onChange() {
    var value = input2.value;
    if (!isNaN(value) && value !== "") {
      value = Number(value);
    }
    if (value != cellValue) {
      if (success(value)) {
        cellValue = value;
      }
    } else {
      cancel();
    }
  }
  input2.addEventListener("blur", function(e) {
    onChange();
  });
  input2.addEventListener("keydown", function(e) {
    switch (e.keyCode) {
      case 13:
        onChange();
        break;
      case 27:
        cancel();
        break;
    }
  });
  return input2;
}
function date(cell, onRendered, success, cancel, editorParams) {
  var inputFormat = editorParams.format, DT = inputFormat ? window.DateTime || luxon.DateTime : null;
  var cellValue = cell.getValue(), input2 = document.createElement("input");
  function convertDate(value) {
    var newDatetime;
    if (DT.isDateTime(value)) {
      newDatetime = value;
    } else if (inputFormat === "iso") {
      newDatetime = DT.fromISO(String(value));
    } else {
      newDatetime = DT.fromFormat(String(value), inputFormat);
    }
    return newDatetime.toFormat("yyyy-MM-dd");
  }
  input2.type = "date";
  input2.style.padding = "4px";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  if (editorParams.max) {
    input2.setAttribute("max", inputFormat ? convertDate(editorParams.max) : editorParams.max);
  }
  if (editorParams.min) {
    input2.setAttribute("min", inputFormat ? convertDate(editorParams.min) : editorParams.min);
  }
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  cellValue = typeof cellValue !== "undefined" ? cellValue : "";
  if (inputFormat) {
    if (DT) {
      cellValue = convertDate(cellValue);
    } else {
      console.error("Editor Error - 'date' editor 'inputFormat' param is dependant on luxon.js");
    }
  }
  input2.value = cellValue;
  onRendered(function() {
    input2.focus({ preventScroll: true });
    input2.style.height = "100%";
    if (editorParams.selectContents) {
      input2.select();
    }
  });
  function onChange(e) {
    var value = input2.value;
    if ((cellValue === null || typeof cellValue === "undefined") && value !== "" || value !== cellValue) {
      if (value && inputFormat) {
        value = DT.fromFormat(String(value), "yyyy-MM-dd").toFormat(inputFormat);
      }
      if (success(value)) {
        cellValue = input2.value;
      }
    } else {
      cancel();
    }
  }
  input2.addEventListener("change", onChange);
  input2.addEventListener("blur", onChange);
  input2.addEventListener("keydown", function(e) {
    switch (e.keyCode) {
      case 13:
        onChange();
        break;
      case 27:
        cancel();
        break;
      case 35:
      case 36:
        e.stopPropagation();
        break;
    }
  });
  return input2;
}
function time(cell, onRendered, success, cancel, editorParams) {
  var inputFormat = editorParams.format, DT = inputFormat ? window.DateTime || luxon.DateTime : null, newDatetime;
  var cellValue = cell.getValue(), input2 = document.createElement("input");
  input2.type = "time";
  input2.style.padding = "4px";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  cellValue = typeof cellValue !== "undefined" ? cellValue : "";
  if (inputFormat) {
    if (DT) {
      if (DT.isDateTime(cellValue)) {
        newDatetime = cellValue;
      } else if (inputFormat === "iso") {
        newDatetime = DT.fromISO(String(cellValue));
      } else {
        newDatetime = DT.fromFormat(String(cellValue), inputFormat);
      }
      cellValue = newDatetime.toFormat("hh:mm");
    } else {
      console.error("Editor Error - 'date' editor 'inputFormat' param is dependant on luxon.js");
    }
  }
  input2.value = cellValue;
  onRendered(function() {
    input2.focus({ preventScroll: true });
    input2.style.height = "100%";
    if (editorParams.selectContents) {
      input2.select();
    }
  });
  function onChange(e) {
    var value = input2.value;
    if ((cellValue === null || typeof cellValue === "undefined") && value !== "" || value !== cellValue) {
      if (value && inputFormat) {
        value = DT.fromFormat(String(value), "hh:mm").toFormat(inputFormat);
      }
      if (success(value)) {
        cellValue = input2.value;
      }
    } else {
      cancel();
    }
  }
  input2.addEventListener("change", onChange);
  input2.addEventListener("blur", onChange);
  input2.addEventListener("keydown", function(e) {
    switch (e.keyCode) {
      case 13:
        onChange();
        break;
      case 27:
        cancel();
        break;
      case 35:
      case 36:
        e.stopPropagation();
        break;
    }
  });
  return input2;
}
function datetime(cell, onRendered, success, cancel, editorParams) {
  var inputFormat = editorParams.format, DT = inputFormat ? window.DateTime || luxon.DateTime : null, newDatetime;
  var cellValue = cell.getValue(), input2 = document.createElement("input");
  input2.type = "datetime-local";
  input2.style.padding = "4px";
  input2.style.width = "100%";
  input2.style.boxSizing = "border-box";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  cellValue = typeof cellValue !== "undefined" ? cellValue : "";
  if (inputFormat) {
    if (DT) {
      if (DT.isDateTime(cellValue)) {
        newDatetime = cellValue;
      } else if (inputFormat === "iso") {
        newDatetime = DT.fromISO(String(cellValue));
      } else {
        newDatetime = DT.fromFormat(String(cellValue), inputFormat);
      }
      cellValue = newDatetime.toFormat("yyyy-MM-dd") + "T" + newDatetime.toFormat("hh:mm");
    } else {
      console.error("Editor Error - 'date' editor 'inputFormat' param is dependant on luxon.js");
    }
  }
  input2.value = cellValue;
  onRendered(function() {
    input2.focus({ preventScroll: true });
    input2.style.height = "100%";
    if (editorParams.selectContents) {
      input2.select();
    }
  });
  function onChange(e) {
    var value = input2.value;
    if ((cellValue === null || typeof cellValue === "undefined") && value !== "" || value !== cellValue) {
      if (value && inputFormat) {
        value = DT.fromISO(String(value)).toFormat(inputFormat);
      }
      if (success(value)) {
        cellValue = input2.value;
      }
    } else {
      cancel();
    }
  }
  input2.addEventListener("change", onChange);
  input2.addEventListener("blur", onChange);
  input2.addEventListener("keydown", function(e) {
    switch (e.keyCode) {
      case 13:
        onChange();
        break;
      case 27:
        cancel();
        break;
      case 35:
      case 36:
        e.stopPropagation();
        break;
    }
  });
  return input2;
}
var Edit = class {
  constructor(editor, cell, onRendered, success, cancel, editorParams) {
    this.edit = editor;
    this.table = editor.table;
    this.cell = cell;
    this.params = this._initializeParams(editorParams);
    this.data = [];
    this.displayItems = [];
    this.currentItems = [];
    this.focusedItem = null;
    this.input = this._createInputElement();
    this.listEl = this._createListElement();
    this.initialValues = null;
    this.isFilter = !cell._getSelf;
    this.filterTimeout = null;
    this.filtered = false;
    this.typing = false;
    this.values = [];
    this.popup = null;
    this.listIteration = 0;
    this.lastAction = "";
    this.filterTerm = "";
    this.blurable = true;
    this.actions = {
      success,
      cancel
    };
    this._deprecatedOptionsCheck();
    this._initializeValue();
    onRendered(this._onRendered.bind(this));
  }
  _deprecatedOptionsCheck() {
    if (this.params.listItemFormatter) {
      this.cell.getTable().deprecationAdvisor.msg("The listItemFormatter editor param has been deprecated, please see the latest editor documentation for updated options");
    }
    if (this.params.sortValuesList) {
      this.cell.getTable().deprecationAdvisor.msg("The sortValuesList editor param has been deprecated, please see the latest editor documentation for updated options");
    }
    if (this.params.searchFunc) {
      this.cell.getTable().deprecationAdvisor.msg("The searchFunc editor param has been deprecated, please see the latest editor documentation for updated options");
    }
    if (this.params.searchingPlaceholder) {
      this.cell.getTable().deprecationAdvisor.msg("The searchingPlaceholder editor param has been deprecated, please see the latest editor documentation for updated options");
    }
  }
  _initializeValue() {
    var initialValue = this.cell.getValue();
    if (typeof initialValue === "undefined" && typeof this.params.defaultValue !== "undefined") {
      initialValue = this.params.defaultValue;
    }
    this.initialValues = this.params.multiselect ? initialValue : [initialValue];
    if (this.isFilter) {
      this.input.value = this.initialValues ? this.initialValues.join(",") : "";
      this.headerFilterInitialListGen();
    }
  }
  _onRendered() {
    var cellEl = this.cell.getElement();
    function clickStop(e) {
      e.stopPropagation();
    }
    this.input.style.height = "100%";
    this.input.focus({ preventScroll: true });
    cellEl.addEventListener("click", clickStop);
    setTimeout(() => {
      cellEl.removeEventListener("click", clickStop);
    }, 1e3);
    this.input.addEventListener("mousedown", this._preventPopupBlur.bind(this));
  }
  _createListElement() {
    var listEl = document.createElement("div");
    listEl.classList.add("tabulator-edit-list");
    listEl.addEventListener("mousedown", this._preventBlur.bind(this));
    listEl.addEventListener("keydown", this._inputKeyDown.bind(this));
    return listEl;
  }
  _setListWidth() {
    var element = this.isFilter ? this.input : this.cell.getElement();
    this.listEl.style.minWidth = element.offsetWidth + "px";
    if (this.params.maxWidth) {
      if (this.params.maxWidth === true) {
        this.listEl.style.maxWidth = element.offsetWidth + "px";
      } else if (typeof this.params.maxWidth === "number") {
        this.listEl.style.maxWidth = this.params.maxWidth + "px";
      } else {
        this.listEl.style.maxWidth = this.params.maxWidth;
      }
    }
  }
  _createInputElement() {
    var attribs = this.params.elementAttributes;
    var input2 = document.createElement("input");
    input2.setAttribute("type", this.params.clearable ? "search" : "text");
    input2.style.padding = "4px";
    input2.style.width = "100%";
    input2.style.boxSizing = "border-box";
    if (!this.params.autocomplete) {
      input2.style.cursor = "default";
      input2.style.caretColor = "transparent";
    }
    if (attribs && typeof attribs == "object") {
      for (let key in attribs) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          input2.setAttribute(key, input2.getAttribute(key) + attribs["+" + key]);
        } else {
          input2.setAttribute(key, attribs[key]);
        }
      }
    }
    if (this.params.mask) {
      maskInput(input2, this.params);
    }
    this._bindInputEvents(input2);
    return input2;
  }
  _initializeParams(params) {
    var valueKeys = ["values", "valuesURL", "valuesLookup"], valueCheck;
    params = Object.assign({}, params);
    params.verticalNavigation = params.verticalNavigation || "editor";
    params.placeholderLoading = typeof params.placeholderLoading === "undefined" ? "Searching ..." : params.placeholderLoading;
    params.placeholderEmpty = typeof params.placeholderEmpty === "undefined" ? "No Results Found" : params.placeholderEmpty;
    params.filterDelay = typeof params.filterDelay === "undefined" ? 300 : params.filterDelay;
    params.emptyValue = Object.keys(params).includes("emptyValue") ? params.emptyValue : "";
    valueCheck = Object.keys(params).filter((key) => valueKeys.includes(key)).length;
    if (!valueCheck) {
      console.warn("list editor config error - either the values, valuesURL, or valuesLookup option must be set");
    } else if (valueCheck > 1) {
      console.warn("list editor config error - only one of the values, valuesURL, or valuesLookup options can be set on the same editor");
    }
    if (params.autocomplete) {
      if (params.multiselect) {
        params.multiselect = false;
        console.warn("list editor config error - multiselect option is not available when autocomplete is enabled");
      }
    } else {
      if (params.freetext) {
        params.freetext = false;
        console.warn("list editor config error - freetext option is only available when autocomplete is enabled");
      }
      if (params.filterFunc) {
        params.filterFunc = false;
        console.warn("list editor config error - filterFunc option is only available when autocomplete is enabled");
      }
      if (params.filterRemote) {
        params.filterRemote = false;
        console.warn("list editor config error - filterRemote option is only available when autocomplete is enabled");
      }
      if (params.mask) {
        params.mask = false;
        console.warn("list editor config error - mask option is only available when autocomplete is enabled");
      }
      if (params.allowEmpty) {
        params.allowEmpty = false;
        console.warn("list editor config error - allowEmpty option is only available when autocomplete is enabled");
      }
      if (params.listOnEmpty) {
        params.listOnEmpty = false;
        console.warn("list editor config error - listOnEmpty option is only available when autocomplete is enabled");
      }
    }
    if (params.filterRemote && !(typeof params.valuesLookup === "function" || params.valuesURL)) {
      params.filterRemote = false;
      console.warn("list editor config error - filterRemote option should only be used when values list is populated from a remote source");
    }
    return params;
  }
  _bindInputEvents(input2) {
    input2.addEventListener("focus", this._inputFocus.bind(this));
    input2.addEventListener("click", this._inputClick.bind(this));
    input2.addEventListener("blur", this._inputBlur.bind(this));
    input2.addEventListener("keydown", this._inputKeyDown.bind(this));
    input2.addEventListener("search", this._inputSearch.bind(this));
    if (this.params.autocomplete) {
      input2.addEventListener("keyup", this._inputKeyUp.bind(this));
    }
  }
  _inputFocus(e) {
    this.rebuildOptionsList();
  }
  _filter() {
    if (this.params.filterRemote) {
      clearTimeout(this.filterTimeout);
      this.filterTimeout = setTimeout(() => {
        this.rebuildOptionsList();
      }, this.params.filterDelay);
    } else {
      this._filterList();
    }
  }
  _inputClick(e) {
    e.stopPropagation();
  }
  _inputBlur(e) {
    if (this.blurable) {
      if (this.popup) {
        this.popup.hide();
      } else {
        this._resolveValue(true);
      }
    }
  }
  _inputSearch() {
    this._clearChoices();
  }
  _inputKeyDown(e) {
    switch (e.keyCode) {
      case 38:
        this._keyUp(e);
        break;
      case 40:
        this._keyDown(e);
        break;
      case 37:
      case 39:
        this._keySide(e);
        break;
      case 13:
        this._keyEnter();
        break;
      case 27:
        this._keyEsc();
        break;
      case 36:
      case 35:
        this._keyHomeEnd(e);
        break;
      case 9:
        break;
      default:
        this._keySelectLetter(e);
    }
  }
  _inputKeyUp(e) {
    switch (e.keyCode) {
      case 38:
      case 37:
      case 39:
      case 40:
      case 13:
      case 27:
        break;
      default:
        this._keyAutoCompLetter(e);
    }
  }
  _preventPopupBlur() {
    if (this.popup) {
      this.popup.blockHide();
    }
    setTimeout(() => {
      if (this.popup) {
        this.popup.restoreHide();
      }
    }, 10);
  }
  _preventBlur() {
    this.blurable = false;
    setTimeout(() => {
      this.blurable = true;
    }, 10);
  }
  _keyUp(e) {
    var index2 = this.displayItems.indexOf(this.focusedItem);
    if (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && index2) {
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.preventDefault();
      if (index2 > 0) {
        this._focusItem(this.displayItems[index2 - 1]);
      }
    }
  }
  _keyDown(e) {
    var index2 = this.displayItems.indexOf(this.focusedItem);
    if (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && index2 < this.displayItems.length - 1) {
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.preventDefault();
      if (index2 < this.displayItems.length - 1) {
        if (index2 == -1) {
          this._focusItem(this.displayItems[0]);
        } else {
          this._focusItem(this.displayItems[index2 + 1]);
        }
      }
    }
  }
  _keySide(e) {
    e.stopImmediatePropagation();
    e.stopPropagation();
    e.preventDefault();
  }
  _keyEnter(e) {
    if (this.params.autocomplete && this.lastAction === "typing") {
      this._resolveValue(true);
    } else {
      if (this.focusedItem) {
        this._chooseItem(this.focusedItem);
      }
    }
  }
  _keyEsc(e) {
    this._cancel();
  }
  _keyHomeEnd(e) {
    if (this.params.autocomplete) {
      e.stopImmediatePropagation();
    }
  }
  _keySelectLetter(e) {
    if (!this.params.autocomplete) {
      e.preventDefault();
      if (e.keyCode >= 38 && e.keyCode <= 90) {
        this._scrollToValue(e.keyCode);
      }
    }
  }
  _keyAutoCompLetter(e) {
    this._filter();
    this.lastAction = "typing";
    this.typing = true;
  }
  _scrollToValue(char) {
    clearTimeout(this.filterTimeout);
    var character = String.fromCharCode(char).toLowerCase();
    this.filterTerm += character.toLowerCase();
    var match2 = this.displayItems.find((item) => {
      return typeof item.label !== "undefined" && item.label.toLowerCase().startsWith(this.filterTerm);
    });
    if (match2) {
      this._focusItem(match2);
    }
    this.filterTimeout = setTimeout(() => {
      this.filterTerm = "";
    }, 800);
  }
  _focusItem(item) {
    this.lastAction = "focus";
    if (this.focusedItem && this.focusedItem.element) {
      this.focusedItem.element.classList.remove("focused");
    }
    this.focusedItem = item;
    if (item && item.element) {
      item.element.classList.add("focused");
      item.element.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "start" });
    }
  }
  headerFilterInitialListGen() {
    this._generateOptions(true);
  }
  rebuildOptionsList() {
    this._generateOptions().then(this._sortOptions.bind(this)).then(this._buildList.bind(this)).then(this._showList.bind(this)).catch((e) => {
      if (!Number.isInteger(e)) {
        console.error("List generation error", e);
      }
    });
  }
  _filterList() {
    this._buildList(this._filterOptions());
    this._showList();
  }
  _generateOptions(silent) {
    var values2 = [];
    var iteration = ++this.listIteration;
    this.filtered = false;
    if (this.params.values) {
      values2 = this.params.values;
    } else if (this.params.valuesURL) {
      values2 = this._ajaxRequest(this.params.valuesURL, this.input.value);
    } else {
      if (typeof this.params.valuesLookup === "function") {
        values2 = this.params.valuesLookup(this.cell, this.input.value);
      } else if (this.params.valuesLookup) {
        values2 = this._uniqueColumnValues(this.params.valuesLookupField);
      }
    }
    if (values2 instanceof Promise) {
      if (!silent) {
        this._addPlaceholder(this.params.placeholderLoading);
      }
      return values2.then().then((responseValues) => {
        if (this.listIteration === iteration) {
          return this._parseList(responseValues);
        } else {
          return Promise.reject(iteration);
        }
      });
    } else {
      return Promise.resolve(this._parseList(values2));
    }
  }
  _addPlaceholder(contents) {
    var placeholder = document.createElement("div");
    if (typeof contents === "function") {
      contents = contents(this.cell.getComponent(), this.listEl);
    }
    if (contents) {
      this._clearList();
      if (contents instanceof HTMLElement) {
        placeholder = contents;
      } else {
        placeholder.classList.add("tabulator-edit-list-placeholder");
        placeholder.innerHTML = contents;
      }
      this.listEl.appendChild(placeholder);
      this._showList();
    }
  }
  _ajaxRequest(url2, term) {
    var params = this.params.filterRemote ? { term } : {};
    url2 = urlBuilder(url2, {}, params);
    return fetch(url2).then((response) => {
      if (response.ok) {
        return response.json().catch((error) => {
          console.warn("List Ajax Load Error - Invalid JSON returned", error);
          return Promise.reject(error);
        });
      } else {
        console.error("List Ajax Load Error - Connection Error: " + response.status, response.statusText);
        return Promise.reject(response);
      }
    }).catch((error) => {
      console.error("List Ajax Load Error - Connection Error: ", error);
      return Promise.reject(error);
    });
  }
  _uniqueColumnValues(field) {
    var output = {}, data = this.table.getData(this.params.valuesLookup), column;
    if (field) {
      column = this.table.columnManager.getColumnByField(field);
    } else {
      column = this.cell.getColumn()._getSelf();
    }
    if (column) {
      data.forEach((row2) => {
        var val = column.getFieldValue(row2);
        if (val !== null && typeof val !== "undefined" && val !== "") {
          output[val] = true;
        }
      });
    } else {
      console.warn("unable to find matching column to create select lookup list:", field);
      output = [];
    }
    return Object.keys(output);
  }
  _parseList(inputValues) {
    var data = [];
    if (!Array.isArray(inputValues)) {
      inputValues = Object.entries(inputValues).map(([key, value]) => {
        return {
          label: value,
          value: key
        };
      });
    }
    inputValues.forEach((value) => {
      if (typeof value !== "object") {
        value = {
          label: value,
          value
        };
      }
      this._parseListItem(value, data, 0);
    });
    if (!this.currentItems.length && this.params.freetext) {
      this.input.value = this.initialValues;
      this.typing = true;
      this.lastAction = "typing";
    }
    this.data = data;
    return data;
  }
  _parseListItem(option, data, level) {
    var item = {};
    if (option.options) {
      item = this._parseListGroup(option, level + 1);
    } else {
      item = {
        label: option.label,
        value: option.value,
        itemParams: option.itemParams,
        elementAttributes: option.elementAttributes,
        element: false,
        selected: false,
        visible: true,
        level,
        original: option
      };
      if (this.initialValues && this.initialValues.indexOf(option.value) > -1) {
        this._chooseItem(item, true);
      }
    }
    data.push(item);
  }
  _parseListGroup(option, level) {
    var item = {
      label: option.label,
      group: true,
      itemParams: option.itemParams,
      elementAttributes: option.elementAttributes,
      element: false,
      visible: true,
      level,
      options: [],
      original: option
    };
    option.options.forEach((child) => {
      this._parseListItem(child, item.options, level);
    });
    return item;
  }
  _sortOptions(options) {
    var sorter2;
    if (this.params.sort) {
      sorter2 = typeof this.params.sort === "function" ? this.params.sort : this._defaultSortFunction.bind(this);
      this._sortGroup(sorter2, options);
    }
    return options;
  }
  _sortGroup(sorter2, options) {
    options.sort((a, b) => {
      return sorter2(a.label, b.label, a.value, b.value, a.original, b.original);
    });
    options.forEach((option) => {
      if (option.group) {
        this._sortGroup(sorter2, option.options);
      }
    });
  }
  _defaultSortFunction(as, bs) {
    var a, b, a1, b1, i2 = 0, L, rx = /(\d+)|(\D+)/g, rd = /\d/;
    var emptyAlign = 0;
    if (this.params.sort === "desc") {
      [as, bs] = [bs, as];
    }
    if (!as && as !== 0) {
      emptyAlign = !bs && bs !== 0 ? 0 : -1;
    } else if (!bs && bs !== 0) {
      emptyAlign = 1;
    } else {
      if (isFinite(as) && isFinite(bs))
        return as - bs;
      a = String(as).toLowerCase();
      b = String(bs).toLowerCase();
      if (a === b)
        return 0;
      if (!(rd.test(a) && rd.test(b)))
        return a > b ? 1 : -1;
      a = a.match(rx);
      b = b.match(rx);
      L = a.length > b.length ? b.length : a.length;
      while (i2 < L) {
        a1 = a[i2];
        b1 = b[i2++];
        if (a1 !== b1) {
          if (isFinite(a1) && isFinite(b1)) {
            if (a1.charAt(0) === "0")
              a1 = "." + a1;
            if (b1.charAt(0) === "0")
              b1 = "." + b1;
            return a1 - b1;
          } else
            return a1 > b1 ? 1 : -1;
        }
      }
      return a.length > b.length;
    }
    return emptyAlign;
  }
  _filterOptions() {
    var filterFunc = this.params.filterFunc || this._defaultFilterFunc, term = this.input.value;
    if (term) {
      this.filtered = true;
      this.data.forEach((item) => {
        this._filterItem(filterFunc, term, item);
      });
    } else {
      this.filtered = false;
    }
    return this.data;
  }
  _filterItem(func, term, item) {
    var matches = false;
    if (!item.group) {
      item.visible = func(term, item.label, item.value, item.original);
    } else {
      item.options.forEach((option) => {
        if (this._filterItem(func, term, option)) {
          matches = true;
        }
      });
      item.visible = matches;
    }
    return item.visible;
  }
  _defaultFilterFunc(term, label, value, item) {
    term = String(term).toLowerCase();
    if (label !== null && typeof label !== "undefined") {
      if (String(label).toLowerCase().indexOf(term) > -1 || String(value).toLowerCase().indexOf(term) > -1) {
        return true;
      }
    }
    return false;
  }
  _clearList() {
    while (this.listEl.firstChild)
      this.listEl.removeChild(this.listEl.firstChild);
    this.displayItems = [];
  }
  _buildList(data) {
    this._clearList();
    data.forEach((option) => {
      this._buildItem(option);
    });
    if (!this.displayItems.length) {
      this._addPlaceholder(this.params.placeholderEmpty);
    }
  }
  _buildItem(item) {
    var el = item.element, contents;
    if (!this.filtered || item.visible) {
      if (!el) {
        el = document.createElement("div");
        el.tabIndex = 0;
        contents = this.params.itemFormatter ? this.params.itemFormatter(item.label, item.value, item.original, el) : item.label;
        if (contents instanceof HTMLElement) {
          el.appendChild(contents);
        } else {
          el.innerHTML = contents;
        }
        if (item.group) {
          el.classList.add("tabulator-edit-list-group");
        } else {
          el.classList.add("tabulator-edit-list-item");
        }
        el.classList.add("tabulator-edit-list-group-level-" + item.level);
        if (item.elementAttributes && typeof item.elementAttributes == "object") {
          for (let key in item.elementAttributes) {
            if (key.charAt(0) == "+") {
              key = key.slice(1);
              el.setAttribute(key, this.input.getAttribute(key) + item.elementAttributes["+" + key]);
            } else {
              el.setAttribute(key, item.elementAttributes[key]);
            }
          }
        }
        if (item.group) {
          el.addEventListener("click", this._groupClick.bind(this, item));
        } else {
          el.addEventListener("click", this._itemClick.bind(this, item));
        }
        el.addEventListener("mousedown", this._preventBlur.bind(this));
        item.element = el;
      }
      this._styleItem(item);
      this.listEl.appendChild(el);
      if (item.group) {
        item.options.forEach((option) => {
          this._buildItem(option);
        });
      } else {
        this.displayItems.push(item);
      }
    }
  }
  _showList() {
    var startVis = this.popup && this.popup.isVisible();
    if (this.input.parentNode) {
      if (this.params.autocomplete && this.input.value === "" && !this.params.listOnEmpty) {
        if (this.popup) {
          this.popup.hide(true);
        }
        return;
      }
      this._setListWidth();
      if (!this.popup) {
        this.popup = this.edit.popup(this.listEl);
      }
      this.popup.show(this.cell.getElement(), "bottom");
      if (!startVis) {
        setTimeout(() => {
          this.popup.hideOnBlur(this._resolveValue.bind(this, true));
        }, 10);
      }
    }
  }
  _styleItem(item) {
    if (item && item.element) {
      if (item.selected) {
        item.element.classList.add("active");
      } else {
        item.element.classList.remove("active");
      }
    }
  }
  _itemClick(item, e) {
    e.stopPropagation();
    this._chooseItem(item);
  }
  _groupClick(item, e) {
    e.stopPropagation();
  }
  _cancel() {
    this.popup.hide(true);
    this.actions.cancel();
  }
  _clearChoices() {
    this.typing = true;
    this.currentItems.forEach((item) => {
      item.selected = false;
      this._styleItem(item);
    });
    this.currentItems = [];
    this.focusedItem = null;
  }
  _chooseItem(item, silent) {
    var index2;
    this.typing = false;
    if (this.params.multiselect) {
      index2 = this.currentItems.indexOf(item);
      if (index2 > -1) {
        this.currentItems.splice(index2, 1);
        item.selected = false;
      } else {
        this.currentItems.push(item);
        item.selected = true;
      }
      this.input.value = this.currentItems.map((item2) => item2.label).join(",");
      this._styleItem(item);
    } else {
      this.currentItems = [item];
      item.selected = true;
      this.input.value = item.label;
      this._styleItem(item);
      if (!silent) {
        this._resolveValue();
      }
    }
    this._focusItem(item);
  }
  _resolveValue(blur) {
    var output, initialValue;
    if (this.popup) {
      this.popup.hide(true);
    }
    if (this.params.multiselect) {
      output = this.currentItems.map((item) => item.value);
    } else {
      if (blur && this.params.autocomplete && this.typing) {
        if (this.params.freetext || this.params.allowEmpty && this.input.value === "") {
          output = this.input.value;
        } else {
          this.actions.cancel();
          return;
        }
      } else {
        if (this.currentItems[0]) {
          output = this.currentItems[0].value;
        } else {
          initialValue = Array.isArray(this.initialValues) ? this.initialValues[0] : this.initialValues;
          if (initialValue === null || typeof initialValue === "undefined" || initialValue === "") {
            output = initialValue;
          } else {
            output = this.params.emptyValue;
          }
        }
      }
    }
    if (output === "") {
      output = this.params.emptyValue;
    }
    this.actions.success(output);
    if (this.isFilter) {
      this.initialValues = output && !Array.isArray(output) ? [output] : output;
      this.currentItems = [];
    }
  }
};
function select(cell, onRendered, success, cancel, editorParams) {
  this.deprecationMsg("The select editor has been deprecated, please use the new list editor");
  var list2 = new Edit(this, cell, onRendered, success, cancel, editorParams);
  return list2.input;
}
function list(cell, onRendered, success, cancel, editorParams) {
  var list2 = new Edit(this, cell, onRendered, success, cancel, editorParams);
  return list2.input;
}
function autocomplete(cell, onRendered, success, cancel, editorParams) {
  this.deprecationMsg("The autocomplete editor has been deprecated, please use the new list editor with the 'autocomplete' editorParam");
  editorParams.autocomplete = true;
  var list2 = new Edit(this, cell, onRendered, success, cancel, editorParams);
  return list2.input;
}
function star(cell, onRendered, success, cancel, editorParams) {
  var self2 = this, element = cell.getElement(), value = cell.getValue(), maxStars = element.getElementsByTagName("svg").length || 5, size = element.getElementsByTagName("svg")[0] ? element.getElementsByTagName("svg")[0].getAttribute("width") : 14, stars = [], starsHolder = document.createElement("div"), star2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  function starChange(val) {
    stars.forEach(function(star3, i3) {
      if (i3 < val) {
        if (self2.table.browser == "ie") {
          star3.setAttribute("class", "tabulator-star-active");
        } else {
          star3.classList.replace("tabulator-star-inactive", "tabulator-star-active");
        }
        star3.innerHTML = '<polygon fill="#488CE9" stroke="#014AAE" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
      } else {
        if (self2.table.browser == "ie") {
          star3.setAttribute("class", "tabulator-star-inactive");
        } else {
          star3.classList.replace("tabulator-star-active", "tabulator-star-inactive");
        }
        star3.innerHTML = '<polygon fill="#010155" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
      }
    });
  }
  function buildStar(i3) {
    var starHolder = document.createElement("span");
    var nextStar = star2.cloneNode(true);
    stars.push(nextStar);
    starHolder.addEventListener("mouseenter", function(e) {
      e.stopPropagation();
      e.stopImmediatePropagation();
      starChange(i3);
    });
    starHolder.addEventListener("mousemove", function(e) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    });
    starHolder.addEventListener("click", function(e) {
      e.stopPropagation();
      e.stopImmediatePropagation();
      success(i3);
      element.blur();
    });
    starHolder.appendChild(nextStar);
    starsHolder.appendChild(starHolder);
  }
  function changeValue(val) {
    value = val;
    starChange(val);
  }
  element.style.whiteSpace = "nowrap";
  element.style.overflow = "hidden";
  element.style.textOverflow = "ellipsis";
  starsHolder.style.verticalAlign = "middle";
  starsHolder.style.display = "inline-block";
  starsHolder.style.padding = "4px";
  star2.setAttribute("width", size);
  star2.setAttribute("height", size);
  star2.setAttribute("viewBox", "0 0 512 512");
  star2.setAttribute("xml:space", "preserve");
  star2.style.padding = "0 1px";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        starsHolder.setAttribute(key, starsHolder.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        starsHolder.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  for (var i2 = 1; i2 <= maxStars; i2++) {
    buildStar(i2);
  }
  value = Math.min(parseInt(value), maxStars);
  starChange(value);
  starsHolder.addEventListener("mousemove", function(e) {
    starChange(0);
  });
  starsHolder.addEventListener("click", function(e) {
    success(0);
  });
  element.addEventListener("blur", function(e) {
    cancel();
  });
  element.addEventListener("keydown", function(e) {
    switch (e.keyCode) {
      case 39:
        changeValue(value + 1);
        break;
      case 37:
        changeValue(value - 1);
        break;
      case 13:
        success(value);
        break;
      case 27:
        cancel();
        break;
    }
  });
  return starsHolder;
}
function progress(cell, onRendered, success, cancel, editorParams) {
  var element = cell.getElement(), max = typeof editorParams.max === "undefined" ? element.getElementsByTagName("div")[0] && element.getElementsByTagName("div")[0].getAttribute("max") || 100 : editorParams.max, min = typeof editorParams.min === "undefined" ? element.getElementsByTagName("div")[0] && element.getElementsByTagName("div")[0].getAttribute("min") || 0 : editorParams.min, percent = (max - min) / 100, value = cell.getValue() || 0, handle2 = document.createElement("div"), bar = document.createElement("div"), mouseDrag, mouseDragWidth;
  function updateValue() {
    var style = window.getComputedStyle(element, null);
    var calcVal = percent * Math.round(bar.offsetWidth / ((element.clientWidth - parseInt(style.getPropertyValue("padding-left")) - parseInt(style.getPropertyValue("padding-right"))) / 100)) + min;
    success(calcVal);
    element.setAttribute("aria-valuenow", calcVal);
    element.setAttribute("aria-label", value);
  }
  handle2.style.position = "absolute";
  handle2.style.right = "0";
  handle2.style.top = "0";
  handle2.style.bottom = "0";
  handle2.style.width = "5px";
  handle2.classList.add("tabulator-progress-handle");
  bar.style.display = "inline-block";
  bar.style.position = "relative";
  bar.style.height = "100%";
  bar.style.backgroundColor = "#488CE9";
  bar.style.maxWidth = "100%";
  bar.style.minWidth = "0%";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        bar.setAttribute(key, bar.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        bar.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  element.style.padding = "4px 4px";
  value = Math.min(parseFloat(value), max);
  value = Math.max(parseFloat(value), min);
  value = Math.round((value - min) / percent);
  bar.style.width = value + "%";
  element.setAttribute("aria-valuemin", min);
  element.setAttribute("aria-valuemax", max);
  bar.appendChild(handle2);
  handle2.addEventListener("mousedown", function(e) {
    mouseDrag = e.screenX;
    mouseDragWidth = bar.offsetWidth;
  });
  handle2.addEventListener("mouseover", function() {
    handle2.style.cursor = "ew-resize";
  });
  element.addEventListener("mousemove", function(e) {
    if (mouseDrag) {
      bar.style.width = mouseDragWidth + e.screenX - mouseDrag + "px";
    }
  });
  element.addEventListener("mouseup", function(e) {
    if (mouseDrag) {
      e.stopPropagation();
      e.stopImmediatePropagation();
      mouseDrag = false;
      mouseDragWidth = false;
      updateValue();
    }
  });
  element.addEventListener("keydown", function(e) {
    switch (e.keyCode) {
      case 39:
        e.preventDefault();
        bar.style.width = bar.clientWidth + element.clientWidth / 100 + "px";
        break;
      case 37:
        e.preventDefault();
        bar.style.width = bar.clientWidth - element.clientWidth / 100 + "px";
        break;
      case 9:
      case 13:
        updateValue();
        break;
      case 27:
        cancel();
        break;
    }
  });
  element.addEventListener("blur", function() {
    cancel();
  });
  return bar;
}
function tickCross(cell, onRendered, success, cancel, editorParams) {
  var value = cell.getValue(), input2 = document.createElement("input"), tristate = editorParams.tristate, indetermValue = typeof editorParams.indeterminateValue === "undefined" ? null : editorParams.indeterminateValue, indetermState = false, trueValueSet = Object.keys(editorParams).includes("trueValue"), falseValueSet = Object.keys(editorParams).includes("falseValue");
  input2.setAttribute("type", "checkbox");
  input2.style.marginTop = "5px";
  input2.style.boxSizing = "border-box";
  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input2.setAttribute(key, input2.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input2.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }
  input2.value = value;
  if (tristate && (typeof value === "undefined" || value === indetermValue || value === "")) {
    indetermState = true;
    input2.indeterminate = true;
  }
  if (this.table.browser != "firefox") {
    onRendered(function() {
      input2.focus({ preventScroll: true });
    });
  }
  input2.checked = trueValueSet ? value === editorParams.trueValue : value === true || value === "true" || value === "True" || value === 1;
  onRendered(function() {
    input2.focus();
  });
  function setValue(blur) {
    var checkedValue = input2.checked;
    if (trueValueSet && checkedValue) {
      checkedValue = editorParams.trueValue;
    } else if (falseValueSet && !checkedValue) {
      checkedValue = editorParams.falseValue;
    }
    if (tristate) {
      if (!blur) {
        if (input2.checked && !indetermState) {
          input2.checked = false;
          input2.indeterminate = true;
          indetermState = true;
          return indetermValue;
        } else {
          indetermState = false;
          return checkedValue;
        }
      } else {
        if (indetermState) {
          return indetermValue;
        } else {
          return checkedValue;
        }
      }
    } else {
      return checkedValue;
    }
  }
  input2.addEventListener("change", function(e) {
    success(setValue());
  });
  input2.addEventListener("blur", function(e) {
    success(setValue(true));
  });
  input2.addEventListener("keydown", function(e) {
    if (e.keyCode == 13) {
      success(setValue());
    }
    if (e.keyCode == 27) {
      cancel();
    }
  });
  return input2;
}
var defaultEditors = {
  input,
  textarea,
  number,
  range,
  date,
  time,
  datetime,
  select,
  list,
  autocomplete,
  star,
  progress,
  tickCross
};
var Edit$1 = class extends Module {
  constructor(table) {
    super(table);
    this.currentCell = false;
    this.mouseClick = false;
    this.recursionBlock = false;
    this.invalidEdit = false;
    this.editedCells = [];
    this.editors = Edit$1.editors;
    this.registerColumnOption("editable");
    this.registerColumnOption("editor");
    this.registerColumnOption("editorParams");
    this.registerColumnOption("cellEditing");
    this.registerColumnOption("cellEdited");
    this.registerColumnOption("cellEditCancelled");
    this.registerTableFunction("getEditedCells", this.getEditedCells.bind(this));
    this.registerTableFunction("clearCellEdited", this.clearCellEdited.bind(this));
    this.registerTableFunction("navigatePrev", this.navigatePrev.bind(this));
    this.registerTableFunction("navigateNext", this.navigateNext.bind(this));
    this.registerTableFunction("navigateLeft", this.navigateLeft.bind(this));
    this.registerTableFunction("navigateRight", this.navigateRight.bind(this));
    this.registerTableFunction("navigateUp", this.navigateUp.bind(this));
    this.registerTableFunction("navigateDown", this.navigateDown.bind(this));
    this.registerComponentFunction("cell", "isEdited", this.cellIsEdited.bind(this));
    this.registerComponentFunction("cell", "clearEdited", this.clearEdited.bind(this));
    this.registerComponentFunction("cell", "edit", this.editCell.bind(this));
    this.registerComponentFunction("cell", "cancelEdit", this.cellCancelEdit.bind(this));
    this.registerComponentFunction("cell", "navigatePrev", this.navigatePrev.bind(this));
    this.registerComponentFunction("cell", "navigateNext", this.navigateNext.bind(this));
    this.registerComponentFunction("cell", "navigateLeft", this.navigateLeft.bind(this));
    this.registerComponentFunction("cell", "navigateRight", this.navigateRight.bind(this));
    this.registerComponentFunction("cell", "navigateUp", this.navigateUp.bind(this));
    this.registerComponentFunction("cell", "navigateDown", this.navigateDown.bind(this));
  }
  initialize() {
    this.subscribe("cell-init", this.bindEditor.bind(this));
    this.subscribe("cell-delete", this.clearEdited.bind(this));
    this.subscribe("cell-value-changed", this.updateCellClass.bind(this));
    this.subscribe("column-layout", this.initializeColumnCheck.bind(this));
    this.subscribe("column-delete", this.columnDeleteCheck.bind(this));
    this.subscribe("row-deleting", this.rowDeleteCheck.bind(this));
    this.subscribe("row-layout", this.rowEditableCheck.bind(this));
    this.subscribe("data-refreshing", this.cancelEdit.bind(this));
    this.subscribe("keybinding-nav-prev", this.navigatePrev.bind(this, void 0));
    this.subscribe("keybinding-nav-next", this.keybindingNavigateNext.bind(this));
    this.subscribe("keybinding-nav-left", this.navigateLeft.bind(this, void 0));
    this.subscribe("keybinding-nav-right", this.navigateRight.bind(this, void 0));
    this.subscribe("keybinding-nav-up", this.navigateUp.bind(this, void 0));
    this.subscribe("keybinding-nav-down", this.navigateDown.bind(this, void 0));
  }
  keybindingNavigateNext(e) {
    var cell = this.currentCell, newRow = this.options("tabEndNewRow");
    if (cell) {
      if (!this.navigateNext(cell, e)) {
        if (newRow) {
          cell.getElement().firstChild.blur();
          if (newRow === true) {
            newRow = this.table.addRow({});
          } else {
            if (typeof newRow == "function") {
              newRow = this.table.addRow(newRow(cell.row.getComponent()));
            } else {
              newRow = this.table.addRow(Object.assign({}, newRow));
            }
          }
          newRow.then(() => {
            setTimeout(() => {
              cell.getComponent().navigateNext();
            });
          });
        }
      }
    }
  }
  cellIsEdited(cell) {
    return !!cell.modules.edit && cell.modules.edit.edited;
  }
  cellCancelEdit(cell) {
    if (cell === this.currentCell) {
      this.table.modules.edit.cancelEdit();
    } else {
      console.warn("Cancel Editor Error - This cell is not currently being edited ");
    }
  }
  updateCellClass(cell) {
    if (this.allowEdit(cell)) {
      cell.getElement().classList.add("tabulator-editable");
    } else {
      cell.getElement().classList.remove("tabulator-editable");
    }
  }
  clearCellEdited(cells) {
    if (!cells) {
      cells = this.table.modules.edit.getEditedCells();
    }
    if (!Array.isArray(cells)) {
      cells = [cells];
    }
    cells.forEach((cell) => {
      this.table.modules.edit.clearEdited(cell._getSelf());
    });
  }
  navigatePrev(cell = this.currentCell, e) {
    var nextCell, prevRow;
    if (cell) {
      if (e) {
        e.preventDefault();
      }
      nextCell = this.navigateLeft();
      if (nextCell) {
        return true;
      } else {
        prevRow = this.table.rowManager.prevDisplayRow(cell.row, true);
        if (prevRow) {
          nextCell = this.findPrevEditableCell(prevRow, prevRow.cells.length);
          if (nextCell) {
            nextCell.getComponent().edit();
            return true;
          }
        }
      }
    }
    return false;
  }
  navigateNext(cell = this.currentCell, e) {
    var nextCell, nextRow;
    if (cell) {
      if (e) {
        e.preventDefault();
      }
      nextCell = this.navigateRight();
      if (nextCell) {
        return true;
      } else {
        nextRow = this.table.rowManager.nextDisplayRow(cell.row, true);
        if (nextRow) {
          nextCell = this.findNextEditableCell(nextRow, -1);
          if (nextCell) {
            nextCell.getComponent().edit();
            return true;
          }
        }
      }
    }
    return false;
  }
  navigateLeft(cell = this.currentCell, e) {
    var index2, nextCell;
    if (cell) {
      if (e) {
        e.preventDefault();
      }
      index2 = cell.getIndex();
      nextCell = this.findPrevEditableCell(cell.row, index2);
      if (nextCell) {
        nextCell.getComponent().edit();
        return true;
      }
    }
    return false;
  }
  navigateRight(cell = this.currentCell, e) {
    var index2, nextCell;
    if (cell) {
      if (e) {
        e.preventDefault();
      }
      index2 = cell.getIndex();
      nextCell = this.findNextEditableCell(cell.row, index2);
      if (nextCell) {
        nextCell.getComponent().edit();
        return true;
      }
    }
    return false;
  }
  navigateUp(cell = this.currentCell, e) {
    var index2, nextRow;
    if (cell) {
      if (e) {
        e.preventDefault();
      }
      index2 = cell.getIndex();
      nextRow = this.table.rowManager.prevDisplayRow(cell.row, true);
      if (nextRow) {
        nextRow.cells[index2].getComponent().edit();
        return true;
      }
    }
    return false;
  }
  navigateDown(cell = this.currentCell, e) {
    var index2, nextRow;
    if (cell) {
      if (e) {
        e.preventDefault();
      }
      index2 = cell.getIndex();
      nextRow = this.table.rowManager.nextDisplayRow(cell.row, true);
      if (nextRow) {
        nextRow.cells[index2].getComponent().edit();
        return true;
      }
    }
    return false;
  }
  findNextEditableCell(row2, index2) {
    var nextCell = false;
    if (index2 < row2.cells.length - 1) {
      for (var i2 = index2 + 1; i2 < row2.cells.length; i2++) {
        let cell = row2.cells[i2];
        if (cell.column.modules.edit && Helpers.elVisible(cell.getElement())) {
          let allowEdit = this.allowEdit(cell);
          if (allowEdit) {
            nextCell = cell;
            break;
          }
        }
      }
    }
    return nextCell;
  }
  findPrevEditableCell(row2, index2) {
    var prevCell = false;
    if (index2 > 0) {
      for (var i2 = index2 - 1; i2 >= 0; i2--) {
        let cell = row2.cells[i2];
        if (cell.column.modules.edit && Helpers.elVisible(cell.getElement())) {
          let allowEdit = this.allowEdit(cell);
          if (allowEdit) {
            prevCell = cell;
            break;
          }
        }
      }
    }
    return prevCell;
  }
  initializeColumnCheck(column) {
    if (typeof column.definition.editor !== "undefined") {
      this.initializeColumn(column);
    }
  }
  columnDeleteCheck(column) {
    if (this.currentCell && this.currentCell.column === column) {
      this.cancelEdit();
    }
  }
  rowDeleteCheck(row2) {
    if (this.currentCell && this.currentCell.row === row2) {
      this.cancelEdit();
    }
  }
  rowEditableCheck(row2) {
    row2.getCells().forEach((cell) => {
      if (cell.column.modules.edit && typeof cell.column.modules.edit.check === "function") {
        this.updateCellClass(cell);
      }
    });
  }
  initializeColumn(column) {
    var config = {
      editor: false,
      blocked: false,
      check: column.definition.editable,
      params: column.definition.editorParams || {}
    };
    switch (typeof column.definition.editor) {
      case "string":
        if (this.editors[column.definition.editor]) {
          config.editor = this.editors[column.definition.editor];
        } else {
          console.warn("Editor Error - No such editor found: ", column.definition.editor);
        }
        break;
      case "function":
        config.editor = column.definition.editor;
        break;
      case "boolean":
        if (column.definition.editor === true) {
          if (typeof column.definition.formatter !== "function") {
            if (this.editors[column.definition.formatter]) {
              config.editor = this.editors[column.definition.formatter];
            } else {
              config.editor = this.editors["input"];
            }
          } else {
            console.warn("Editor Error - Cannot auto lookup editor for a custom formatter: ", column.definition.formatter);
          }
        }
        break;
    }
    if (config.editor) {
      column.modules.edit = config;
    }
  }
  getCurrentCell() {
    return this.currentCell ? this.currentCell.getComponent() : false;
  }
  clearEditor(cancel) {
    var cell = this.currentCell, cellEl;
    this.invalidEdit = false;
    if (cell) {
      this.currentCell = false;
      cellEl = cell.getElement();
      this.dispatch("edit-editor-clear", cell, cancel);
      cellEl.classList.remove("tabulator-editing");
      while (cellEl.firstChild)
        cellEl.removeChild(cellEl.firstChild);
      cell.row.getElement().classList.remove("tabulator-editing");
      cell.table.element.classList.remove("tabulator-editing");
    }
  }
  cancelEdit() {
    if (this.currentCell) {
      var cell = this.currentCell;
      var component = this.currentCell.getComponent();
      this.clearEditor(true);
      cell.setValueActual(cell.getValue());
      cell.cellRendered();
      if (cell.column.definition.editor == "textarea" || cell.column.definition.variableHeight) {
        cell.row.normalizeHeight(true);
      }
      if (cell.column.definition.cellEditCancelled) {
        cell.column.definition.cellEditCancelled.call(this.table, component);
      }
      this.dispatch("edit-cancelled", cell);
      this.dispatchExternal("cellEditCancelled", component);
    }
  }
  bindEditor(cell) {
    if (cell.column.modules.edit) {
      var self2 = this, element = cell.getElement(true);
      this.updateCellClass(cell);
      element.setAttribute("tabindex", 0);
      element.addEventListener("click", function(e) {
        if (!element.classList.contains("tabulator-editing")) {
          element.focus({ preventScroll: true });
        }
      });
      element.addEventListener("mousedown", function(e) {
        if (e.button === 2) {
          e.preventDefault();
        } else {
          self2.mouseClick = true;
        }
      });
      element.addEventListener("focus", function(e) {
        if (!self2.recursionBlock) {
          self2.edit(cell, e, false);
        }
      });
    }
  }
  focusCellNoEvent(cell, block) {
    this.recursionBlock = true;
    if (!(block && this.table.browser === "ie")) {
      cell.getElement().focus({ preventScroll: true });
    }
    this.recursionBlock = false;
  }
  editCell(cell, forceEdit) {
    this.focusCellNoEvent(cell);
    this.edit(cell, false, forceEdit);
  }
  focusScrollAdjust(cell) {
    if (this.table.rowManager.getRenderMode() == "virtual") {
      var topEdge = this.table.rowManager.element.scrollTop, bottomEdge = this.table.rowManager.element.clientHeight + this.table.rowManager.element.scrollTop, rowEl = cell.row.getElement();
      if (rowEl.offsetTop < topEdge) {
        this.table.rowManager.element.scrollTop -= topEdge - rowEl.offsetTop;
      } else {
        if (rowEl.offsetTop + rowEl.offsetHeight > bottomEdge) {
          this.table.rowManager.element.scrollTop += rowEl.offsetTop + rowEl.offsetHeight - bottomEdge;
        }
      }
      var leftEdge = this.table.rowManager.element.scrollLeft, rightEdge = this.table.rowManager.element.clientWidth + this.table.rowManager.element.scrollLeft, cellEl = cell.getElement();
      if (this.table.modExists("frozenColumns")) {
        leftEdge += parseInt(this.table.modules.frozenColumns.leftMargin);
        rightEdge -= parseInt(this.table.modules.frozenColumns.rightMargin);
      }
      if (this.table.options.renderHorizontal === "virtual") {
        leftEdge -= parseInt(this.table.columnManager.renderer.vDomPadLeft);
        rightEdge -= parseInt(this.table.columnManager.renderer.vDomPadLeft);
      }
      if (cellEl.offsetLeft < leftEdge) {
        this.table.rowManager.element.scrollLeft -= leftEdge - cellEl.offsetLeft;
      } else {
        if (cellEl.offsetLeft + cellEl.offsetWidth > rightEdge) {
          this.table.rowManager.element.scrollLeft += cellEl.offsetLeft + cellEl.offsetWidth - rightEdge;
        }
      }
    }
  }
  allowEdit(cell) {
    var check = cell.column.modules.edit ? true : false;
    if (cell.column.modules.edit) {
      switch (typeof cell.column.modules.edit.check) {
        case "function":
          if (cell.row.initialized) {
            check = cell.column.modules.edit.check(cell.getComponent());
          }
          break;
        case "string":
          check = !!cell.row.data[cell.column.modules.edit.check];
          break;
        case "boolean":
          check = cell.column.modules.edit.check;
          break;
      }
    }
    return check;
  }
  edit(cell, e, forceEdit) {
    var self2 = this, allowEdit = true, rendered = function() {
    }, element = cell.getElement(), cellEditor, component, params;
    if (this.currentCell) {
      if (!this.invalidEdit) {
        this.cancelEdit();
      }
      return;
    }
    function success(value) {
      if (self2.currentCell === cell) {
        var valid = self2.chain("edit-success", [cell, value], true, true);
        if (valid === true || self2.table.options.validationMode === "highlight") {
          self2.clearEditor();
          if (!cell.modules.edit) {
            cell.modules.edit = {};
          }
          cell.modules.edit.edited = true;
          if (self2.editedCells.indexOf(cell) == -1) {
            self2.editedCells.push(cell);
          }
          cell.setValue(value, true);
          return valid === true;
        } else {
          self2.invalidEdit = true;
          self2.focusCellNoEvent(cell, true);
          rendered();
          return false;
        }
      }
    }
    function cancel() {
      if (self2.currentCell === cell) {
        self2.cancelEdit();
      }
    }
    function onRendered(callback2) {
      rendered = callback2;
    }
    if (!cell.column.modules.edit.blocked) {
      if (e) {
        e.stopPropagation();
      }
      allowEdit = this.allowEdit(cell);
      if (allowEdit || forceEdit) {
        self2.cancelEdit();
        self2.currentCell = cell;
        this.focusScrollAdjust(cell);
        component = cell.getComponent();
        if (this.mouseClick) {
          this.mouseClick = false;
          if (cell.column.definition.cellClick) {
            cell.column.definition.cellClick.call(this.table, e, component);
          }
        }
        if (cell.column.definition.cellEditing) {
          cell.column.definition.cellEditing.call(this.table, component);
        }
        this.dispatch("cell-editing", cell);
        this.dispatchExternal("cellEditing", component);
        params = typeof cell.column.modules.edit.params === "function" ? cell.column.modules.edit.params(component) : cell.column.modules.edit.params;
        cellEditor = cell.column.modules.edit.editor.call(self2, component, onRendered, success, cancel, params);
        if (cellEditor !== false) {
          if (cellEditor instanceof Node) {
            element.classList.add("tabulator-editing");
            cell.row.getElement().classList.add("tabulator-editing");
            cell.table.element.classList.add("tabulator-editing");
            while (element.firstChild)
              element.removeChild(element.firstChild);
            element.appendChild(cellEditor);
            rendered();
            var children = element.children;
            for (var i2 = 0; i2 < children.length; i2++) {
              children[i2].addEventListener("click", function(e2) {
                e2.stopPropagation();
              });
            }
          } else {
            console.warn("Edit Error - Editor should return an instance of Node, the editor returned:", cellEditor);
            element.blur();
            return false;
          }
        } else {
          element.blur();
          return false;
        }
        return true;
      } else {
        this.mouseClick = false;
        element.blur();
        return false;
      }
    } else {
      this.mouseClick = false;
      element.blur();
      return false;
    }
  }
  getEditedCells() {
    var output = [];
    this.editedCells.forEach((cell) => {
      output.push(cell.getComponent());
    });
    return output;
  }
  clearEdited(cell) {
    var editIndex;
    if (cell.modules.edit && cell.modules.edit.edited) {
      cell.modules.edit.edited = false;
      this.dispatch("edit-edited-clear", cell);
    }
    editIndex = this.editedCells.indexOf(cell);
    if (editIndex > -1) {
      this.editedCells.splice(editIndex, 1);
    }
  }
};
Edit$1.moduleName = "edit";
Edit$1.editors = defaultEditors;
var ExportRow = class {
  constructor(type, columns, component, indent) {
    this.type = type;
    this.columns = columns;
    this.component = component || false;
    this.indent = indent || 0;
  }
};
var ExportColumn = class {
  constructor(value, component, width, height, depth) {
    this.value = value;
    this.component = component || false;
    this.width = width;
    this.height = height;
    this.depth = depth;
  }
};
var Export = class extends Module {
  constructor(table) {
    super(table);
    this.config = {};
    this.cloneTableStyle = true;
    this.colVisProp = "";
    this.registerTableOption("htmlOutputConfig", false);
    this.registerColumnOption("htmlOutput");
    this.registerColumnOption("titleHtmlOutput");
  }
  initialize() {
    this.registerTableFunction("getHtml", this.getHtml.bind(this));
  }
  generateExportList(config, style, range2, colVisProp) {
    this.cloneTableStyle = style;
    this.config = config || {};
    this.colVisProp = colVisProp;
    var headers = this.config.columnHeaders !== false ? this.headersToExportRows(this.generateColumnGroupHeaders()) : [];
    var body = this.bodyToExportRows(this.rowLookup(range2));
    return headers.concat(body);
  }
  generateTable(config, style, range2, colVisProp) {
    var list2 = this.generateExportList(config, style, range2, colVisProp);
    return this.generateTableElement(list2);
  }
  rowLookup(range2) {
    var rows3 = [];
    if (typeof range2 == "function") {
      range2.call(this.table).forEach((row2) => {
        row2 = this.table.rowManager.findRow(row2);
        if (row2) {
          rows3.push(row2);
        }
      });
    } else {
      switch (range2) {
        case true:
        case "visible":
          rows3 = this.table.rowManager.getVisibleRows(false, true);
          break;
        case "all":
          rows3 = this.table.rowManager.rows;
          break;
        case "selected":
          rows3 = this.table.modules.selectRow.selectedRows;
          break;
        case "active":
        default:
          if (this.table.options.pagination) {
            rows3 = this.table.rowManager.getDisplayRows(this.table.rowManager.displayRows.length - 2);
          } else {
            rows3 = this.table.rowManager.getDisplayRows();
          }
      }
    }
    return Object.assign([], rows3);
  }
  generateColumnGroupHeaders() {
    var output = [];
    var columns = this.config.columnGroups !== false ? this.table.columnManager.columns : this.table.columnManager.columnsByIndex;
    columns.forEach((column) => {
      var colData = this.processColumnGroup(column);
      if (colData) {
        output.push(colData);
      }
    });
    return output;
  }
  processColumnGroup(column) {
    var subGroups = column.columns, maxDepth = 0, title = column.definition["title" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))] || column.definition.title;
    var groupData = {
      title,
      column,
      depth: 1
    };
    if (subGroups.length) {
      groupData.subGroups = [];
      groupData.width = 0;
      subGroups.forEach((subGroup) => {
        var subGroupData = this.processColumnGroup(subGroup);
        if (subGroupData) {
          groupData.width += subGroupData.width;
          groupData.subGroups.push(subGroupData);
          if (subGroupData.depth > maxDepth) {
            maxDepth = subGroupData.depth;
          }
        }
      });
      groupData.depth += maxDepth;
      if (!groupData.width) {
        return false;
      }
    } else {
      if (this.columnVisCheck(column)) {
        groupData.width = 1;
      } else {
        return false;
      }
    }
    return groupData;
  }
  columnVisCheck(column) {
    var visProp = column.definition[this.colVisProp];
    if (typeof visProp === "function") {
      visProp = visProp.call(this.table, column.getComponent());
    }
    return visProp !== false && (column.visible || !column.visible && visProp);
  }
  headersToExportRows(columns) {
    var headers = [], headerDepth = 0, exportRows = [];
    function parseColumnGroup(column, level) {
      var depth = headerDepth - level;
      if (typeof headers[level] === "undefined") {
        headers[level] = [];
      }
      column.height = column.subGroups ? 1 : depth - column.depth + 1;
      headers[level].push(column);
      if (column.height > 1) {
        for (let i2 = 1; i2 < column.height; i2++) {
          if (typeof headers[level + i2] === "undefined") {
            headers[level + i2] = [];
          }
          headers[level + i2].push(false);
        }
      }
      if (column.width > 1) {
        for (let i2 = 1; i2 < column.width; i2++) {
          headers[level].push(false);
        }
      }
      if (column.subGroups) {
        column.subGroups.forEach(function(subGroup) {
          parseColumnGroup(subGroup, level + 1);
        });
      }
    }
    columns.forEach(function(column) {
      if (column.depth > headerDepth) {
        headerDepth = column.depth;
      }
    });
    columns.forEach(function(column) {
      parseColumnGroup(column, 0);
    });
    headers.forEach((header) => {
      var columns2 = [];
      header.forEach((col) => {
        if (col) {
          let title = typeof col.title === "undefined" ? "" : col.title;
          columns2.push(new ExportColumn(title, col.column.getComponent(), col.width, col.height, col.depth));
        } else {
          columns2.push(null);
        }
      });
      exportRows.push(new ExportRow("header", columns2));
    });
    return exportRows;
  }
  bodyToExportRows(rows3) {
    var columns = [];
    var exportRows = [];
    this.table.columnManager.columnsByIndex.forEach((column) => {
      if (this.columnVisCheck(column)) {
        columns.push(column.getComponent());
      }
    });
    if (this.config.columnCalcs !== false && this.table.modExists("columnCalcs")) {
      if (this.table.modules.columnCalcs.topInitialized) {
        rows3.unshift(this.table.modules.columnCalcs.topRow);
      }
      if (this.table.modules.columnCalcs.botInitialized) {
        rows3.push(this.table.modules.columnCalcs.botRow);
      }
    }
    rows3 = rows3.filter((row2) => {
      switch (row2.type) {
        case "group":
          return this.config.rowGroups !== false;
        case "calc":
          return this.config.columnCalcs !== false;
        case "row":
          return !(this.table.options.dataTree && this.config.dataTree === false && row2.modules.dataTree.parent);
      }
      return true;
    });
    rows3.forEach((row2, i2) => {
      var rowData = row2.getData(this.colVisProp);
      var exportCols = [];
      var indent = 0;
      switch (row2.type) {
        case "group":
          indent = row2.level;
          exportCols.push(new ExportColumn(row2.key, row2.getComponent(), columns.length, 1));
          break;
        case "calc":
        case "row":
          columns.forEach((col) => {
            exportCols.push(new ExportColumn(col._column.getFieldValue(rowData), col, 1, 1));
          });
          if (this.table.options.dataTree && this.config.dataTree !== false) {
            indent = row2.modules.dataTree.index;
          }
          break;
      }
      exportRows.push(new ExportRow(row2.type, exportCols, row2.getComponent(), indent));
    });
    return exportRows;
  }
  generateTableElement(list2) {
    var table = document.createElement("table"), headerEl = document.createElement("thead"), bodyEl = document.createElement("tbody"), styles = this.lookupTableStyles(), rowFormatter = this.table.options["rowFormatter" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))], setup = {};
    setup.rowFormatter = rowFormatter !== null ? rowFormatter : this.table.options.rowFormatter;
    if (this.table.options.dataTree && this.config.dataTree !== false && this.table.modExists("columnCalcs")) {
      setup.treeElementField = this.table.modules.dataTree.elementField;
    }
    setup.groupHeader = this.table.options["groupHeader" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))];
    if (setup.groupHeader && !Array.isArray(setup.groupHeader)) {
      setup.groupHeader = [setup.groupHeader];
    }
    table.classList.add("tabulator-print-table");
    this.mapElementStyles(this.table.columnManager.getHeadersElement(), headerEl, ["border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]);
    if (list2.length > 1e3) {
      console.warn("It may take a long time to render an HTML table with more than 1000 rows");
    }
    list2.forEach((row2, i2) => {
      let rowEl;
      switch (row2.type) {
        case "header":
          headerEl.appendChild(this.generateHeaderElement(row2, setup, styles));
          break;
        case "group":
          bodyEl.appendChild(this.generateGroupElement(row2, setup, styles));
          break;
        case "calc":
          bodyEl.appendChild(this.generateCalcElement(row2, setup, styles));
          break;
        case "row":
          rowEl = this.generateRowElement(row2, setup, styles);
          this.mapElementStyles(i2 % 2 && styles.evenRow ? styles.evenRow : styles.oddRow, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
          bodyEl.appendChild(rowEl);
          break;
      }
    });
    if (headerEl.innerHTML) {
      table.appendChild(headerEl);
    }
    table.appendChild(bodyEl);
    this.mapElementStyles(this.table.element, table, ["border-top", "border-left", "border-right", "border-bottom"]);
    return table;
  }
  lookupTableStyles() {
    var styles = {};
    if (this.cloneTableStyle && window.getComputedStyle) {
      styles.oddRow = this.table.element.querySelector(".tabulator-row-odd:not(.tabulator-group):not(.tabulator-calcs)");
      styles.evenRow = this.table.element.querySelector(".tabulator-row-even:not(.tabulator-group):not(.tabulator-calcs)");
      styles.calcRow = this.table.element.querySelector(".tabulator-row.tabulator-calcs");
      styles.firstRow = this.table.element.querySelector(".tabulator-row:not(.tabulator-group):not(.tabulator-calcs)");
      styles.firstGroup = this.table.element.getElementsByClassName("tabulator-group")[0];
      if (styles.firstRow) {
        styles.styleCells = styles.firstRow.getElementsByClassName("tabulator-cell");
        styles.firstCell = styles.styleCells[0];
        styles.lastCell = styles.styleCells[styles.styleCells.length - 1];
      }
    }
    return styles;
  }
  generateHeaderElement(row2, setup, styles) {
    var rowEl = document.createElement("tr");
    row2.columns.forEach((column) => {
      if (column) {
        var cellEl = document.createElement("th");
        var classNames = column.component._column.definition.cssClass ? column.component._column.definition.cssClass.split(" ") : [];
        cellEl.colSpan = column.width;
        cellEl.rowSpan = column.height;
        cellEl.innerHTML = column.value;
        if (this.cloneTableStyle) {
          cellEl.style.boxSizing = "border-box";
        }
        classNames.forEach(function(className) {
          cellEl.classList.add(className);
        });
        this.mapElementStyles(column.component.getElement(), cellEl, ["text-align", "border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]);
        this.mapElementStyles(column.component._column.contentElement, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom"]);
        if (column.component._column.visible) {
          this.mapElementStyles(column.component.getElement(), cellEl, ["width"]);
        } else {
          if (column.component._column.definition.width) {
            cellEl.style.width = column.component._column.definition.width + "px";
          }
        }
        if (column.component._column.parent) {
          this.mapElementStyles(column.component._column.parent.groupElement, cellEl, ["border-top"]);
        }
        rowEl.appendChild(cellEl);
      }
    });
    return rowEl;
  }
  generateGroupElement(row2, setup, styles) {
    var rowEl = document.createElement("tr"), cellEl = document.createElement("td"), group = row2.columns[0];
    rowEl.classList.add("tabulator-print-table-row");
    if (setup.groupHeader && setup.groupHeader[row2.indent]) {
      group.value = setup.groupHeader[row2.indent](group.value, row2.component._group.getRowCount(), row2.component._group.getData(), row2.component);
    } else {
      if (setup.groupHeader !== false) {
        group.value = row2.component._group.generator(group.value, row2.component._group.getRowCount(), row2.component._group.getData(), row2.component);
      }
    }
    cellEl.colSpan = group.width;
    cellEl.innerHTML = group.value;
    rowEl.classList.add("tabulator-print-table-group");
    rowEl.classList.add("tabulator-group-level-" + row2.indent);
    if (group.component.isVisible()) {
      rowEl.classList.add("tabulator-group-visible");
    }
    this.mapElementStyles(styles.firstGroup, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
    this.mapElementStyles(styles.firstGroup, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom"]);
    rowEl.appendChild(cellEl);
    return rowEl;
  }
  generateCalcElement(row2, setup, styles) {
    var rowEl = this.generateRowElement(row2, setup, styles);
    rowEl.classList.add("tabulator-print-table-calcs");
    this.mapElementStyles(styles.calcRow, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
    return rowEl;
  }
  generateRowElement(row2, setup, styles) {
    var rowEl = document.createElement("tr");
    rowEl.classList.add("tabulator-print-table-row");
    row2.columns.forEach((col, i2) => {
      if (col) {
        var cellEl = document.createElement("td"), column = col.component._column, index2 = this.table.columnManager.findColumnIndex(column), value = col.value, cellStyle;
        var cellWrapper = {
          modules: {},
          getValue: function() {
            return value;
          },
          getField: function() {
            return column.definition.field;
          },
          getElement: function() {
            return cellEl;
          },
          getColumn: function() {
            return column.getComponent();
          },
          getData: function() {
            return row2.component.getData();
          },
          getRow: function() {
            return row2.component;
          },
          getComponent: function() {
            return cellWrapper;
          },
          column
        };
        var classNames = column.definition.cssClass ? column.definition.cssClass.split(" ") : [];
        classNames.forEach(function(className) {
          cellEl.classList.add(className);
        });
        if (this.table.modExists("format") && this.config.formatCells !== false) {
          value = this.table.modules.format.formatExportValue(cellWrapper, this.colVisProp);
        } else {
          switch (typeof value) {
            case "object":
              value = value !== null ? JSON.stringify(value) : "";
              break;
            case "undefined":
              value = "";
              break;
          }
        }
        if (value instanceof Node) {
          cellEl.appendChild(value);
        } else {
          cellEl.innerHTML = value;
        }
        cellStyle = styles.styleCells && styles.styleCells[index2] ? styles.styleCells[index2] : styles.firstCell;
        if (cellStyle) {
          this.mapElementStyles(cellStyle, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom", "border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "text-align"]);
          if (column.definition.align) {
            cellEl.style.textAlign = column.definition.align;
          }
        }
        if (this.table.options.dataTree && this.config.dataTree !== false) {
          if (setup.treeElementField && setup.treeElementField == column.field || !setup.treeElementField && i2 == 0) {
            if (row2.component._row.modules.dataTree.controlEl) {
              cellEl.insertBefore(row2.component._row.modules.dataTree.controlEl.cloneNode(true), cellEl.firstChild);
            }
            if (row2.component._row.modules.dataTree.branchEl) {
              cellEl.insertBefore(row2.component._row.modules.dataTree.branchEl.cloneNode(true), cellEl.firstChild);
            }
          }
        }
        rowEl.appendChild(cellEl);
        if (cellWrapper.modules.format && cellWrapper.modules.format.renderedCallback) {
          cellWrapper.modules.format.renderedCallback();
        }
      }
    });
    if (setup.rowFormatter && row2.type === "row" && this.config.formatCells !== false) {
      let formatComponent = Object.assign(row2.component);
      formatComponent.getElement = function() {
        return rowEl;
      };
      setup.rowFormatter(row2.component);
    }
    return rowEl;
  }
  generateHTMLTable(list2) {
    var holder = document.createElement("div");
    holder.appendChild(this.generateTableElement(list2));
    return holder.innerHTML;
  }
  getHtml(visible, style, config, colVisProp) {
    var list2 = this.generateExportList(config || this.table.options.htmlOutputConfig, style, visible, colVisProp || "htmlOutput");
    return this.generateHTMLTable(list2);
  }
  mapElementStyles(from2, to2, props) {
    if (this.cloneTableStyle && from2 && to2) {
      var lookup2 = {
        "background-color": "backgroundColor",
        "color": "fontColor",
        "width": "width",
        "font-weight": "fontWeight",
        "font-family": "fontFamily",
        "font-size": "fontSize",
        "text-align": "textAlign",
        "border-top": "borderTop",
        "border-left": "borderLeft",
        "border-right": "borderRight",
        "border-bottom": "borderBottom",
        "padding-top": "paddingTop",
        "padding-left": "paddingLeft",
        "padding-right": "paddingRight",
        "padding-bottom": "paddingBottom"
      };
      if (window.getComputedStyle) {
        var fromStyle = window.getComputedStyle(from2);
        props.forEach(function(prop) {
          if (!to2.style[lookup2[prop]]) {
            to2.style[lookup2[prop]] = fromStyle.getPropertyValue(prop);
          }
        });
      }
    }
  }
};
Export.moduleName = "export";
var defaultFilters = {
  "=": function(filterVal, rowVal, rowData, filterParams) {
    return rowVal == filterVal ? true : false;
  },
  "<": function(filterVal, rowVal, rowData, filterParams) {
    return rowVal < filterVal ? true : false;
  },
  "<=": function(filterVal, rowVal, rowData, filterParams) {
    return rowVal <= filterVal ? true : false;
  },
  ">": function(filterVal, rowVal, rowData, filterParams) {
    return rowVal > filterVal ? true : false;
  },
  ">=": function(filterVal, rowVal, rowData, filterParams) {
    return rowVal >= filterVal ? true : false;
  },
  "!=": function(filterVal, rowVal, rowData, filterParams) {
    return rowVal != filterVal ? true : false;
  },
  "regex": function(filterVal, rowVal, rowData, filterParams) {
    if (typeof filterVal == "string") {
      filterVal = new RegExp(filterVal);
    }
    return filterVal.test(rowVal);
  },
  "like": function(filterVal, rowVal, rowData, filterParams) {
    if (filterVal === null || typeof filterVal === "undefined") {
      return rowVal === filterVal ? true : false;
    } else {
      if (typeof rowVal !== "undefined" && rowVal !== null) {
        return String(rowVal).toLowerCase().indexOf(filterVal.toLowerCase()) > -1;
      } else {
        return false;
      }
    }
  },
  "keywords": function(filterVal, rowVal, rowData, filterParams) {
    var keywords = filterVal.toLowerCase().split(typeof filterParams.separator === "undefined" ? " " : filterParams.separator), value = String(rowVal === null || typeof rowVal === "undefined" ? "" : rowVal).toLowerCase(), matches = [];
    keywords.forEach((keyword) => {
      if (value.includes(keyword)) {
        matches.push(true);
      }
    });
    return filterParams.matchAll ? matches.length === keywords.length : !!matches.length;
  },
  "starts": function(filterVal, rowVal, rowData, filterParams) {
    if (filterVal === null || typeof filterVal === "undefined") {
      return rowVal === filterVal ? true : false;
    } else {
      if (typeof rowVal !== "undefined" && rowVal !== null) {
        return String(rowVal).toLowerCase().startsWith(filterVal.toLowerCase());
      } else {
        return false;
      }
    }
  },
  "ends": function(filterVal, rowVal, rowData, filterParams) {
    if (filterVal === null || typeof filterVal === "undefined") {
      return rowVal === filterVal ? true : false;
    } else {
      if (typeof rowVal !== "undefined" && rowVal !== null) {
        return String(rowVal).toLowerCase().endsWith(filterVal.toLowerCase());
      } else {
        return false;
      }
    }
  },
  "in": function(filterVal, rowVal, rowData, filterParams) {
    if (Array.isArray(filterVal)) {
      return filterVal.length ? filterVal.indexOf(rowVal) > -1 : true;
    } else {
      console.warn("Filter Error - filter value is not an array:", filterVal);
      return false;
    }
  }
};
var Filter = class extends Module {
  constructor(table) {
    super(table);
    this.filterList = [];
    this.headerFilters = {};
    this.headerFilterColumns = [];
    this.prevHeaderFilterChangeCheck = "";
    this.prevHeaderFilterChangeCheck = "{}";
    this.changed = false;
    this.tableInitialized = false;
    this.registerTableOption("filterMode", "local");
    this.registerTableOption("initialFilter", false);
    this.registerTableOption("initialHeaderFilter", false);
    this.registerTableOption("headerFilterLiveFilterDelay", 300);
    this.registerColumnOption("headerFilter");
    this.registerColumnOption("headerFilterPlaceholder");
    this.registerColumnOption("headerFilterParams");
    this.registerColumnOption("headerFilterEmptyCheck");
    this.registerColumnOption("headerFilterFunc");
    this.registerColumnOption("headerFilterFuncParams");
    this.registerColumnOption("headerFilterLiveFilter");
    this.registerTableFunction("searchRows", this.searchRows.bind(this));
    this.registerTableFunction("searchData", this.searchData.bind(this));
    this.registerTableFunction("setFilter", this.userSetFilter.bind(this));
    this.registerTableFunction("refreshFilter", this.userRefreshFilter.bind(this));
    this.registerTableFunction("addFilter", this.userAddFilter.bind(this));
    this.registerTableFunction("getFilters", this.getFilters.bind(this));
    this.registerTableFunction("setHeaderFilterFocus", this.userSetHeaderFilterFocus.bind(this));
    this.registerTableFunction("getHeaderFilterValue", this.userGetHeaderFilterValue.bind(this));
    this.registerTableFunction("setHeaderFilterValue", this.userSetHeaderFilterValue.bind(this));
    this.registerTableFunction("getHeaderFilters", this.getHeaderFilters.bind(this));
    this.registerTableFunction("removeFilter", this.userRemoveFilter.bind(this));
    this.registerTableFunction("clearFilter", this.userClearFilter.bind(this));
    this.registerTableFunction("clearHeaderFilter", this.userClearHeaderFilter.bind(this));
    this.registerComponentFunction("column", "headerFilterFocus", this.setHeaderFilterFocus.bind(this));
    this.registerComponentFunction("column", "reloadHeaderFilter", this.reloadHeaderFilter.bind(this));
    this.registerComponentFunction("column", "getHeaderFilterValue", this.getHeaderFilterValue.bind(this));
    this.registerComponentFunction("column", "setHeaderFilterValue", this.setHeaderFilterValue.bind(this));
  }
  initialize() {
    this.subscribe("column-init", this.initializeColumnHeaderFilter.bind(this));
    this.subscribe("column-width-fit-before", this.hideHeaderFilterElements.bind(this));
    this.subscribe("column-width-fit-after", this.showHeaderFilterElements.bind(this));
    this.subscribe("table-built", this.tableBuilt.bind(this));
    if (this.table.options.filterMode === "remote") {
      this.subscribe("data-params", this.remoteFilterParams.bind(this));
    }
    this.registerDataHandler(this.filter.bind(this), 10);
  }
  tableBuilt() {
    if (this.table.options.initialFilter) {
      this.setFilter(this.table.options.initialFilter);
    }
    if (this.table.options.initialHeaderFilter) {
      this.table.options.initialHeaderFilter.forEach((item) => {
        var column = this.table.columnManager.findColumn(item.field);
        if (column) {
          this.setHeaderFilterValue(column, item.value);
        } else {
          console.warn("Column Filter Error - No matching column found:", item.field);
          return false;
        }
      });
    }
    this.tableInitialized = true;
  }
  remoteFilterParams(data, config, silent, params) {
    params.filter = this.getFilters(true, true);
    return params;
  }
  userSetFilter(field, type, value, params) {
    this.setFilter(field, type, value, params);
    this.refreshFilter();
  }
  userRefreshFilter() {
    this.refreshFilter();
  }
  userAddFilter(field, type, value, params) {
    this.addFilter(field, type, value, params);
    this.refreshFilter();
  }
  userSetHeaderFilterFocus(field) {
    var column = this.table.columnManager.findColumn(field);
    if (column) {
      this.setHeaderFilterFocus(column);
    } else {
      console.warn("Column Filter Focus Error - No matching column found:", field);
      return false;
    }
  }
  userGetHeaderFilterValue(field) {
    var column = this.table.columnManager.findColumn(field);
    if (column) {
      return this.getHeaderFilterValue(column);
    } else {
      console.warn("Column Filter Error - No matching column found:", field);
    }
  }
  userSetHeaderFilterValue(field, value) {
    var column = this.table.columnManager.findColumn(field);
    if (column) {
      this.setHeaderFilterValue(column, value);
    } else {
      console.warn("Column Filter Error - No matching column found:", field);
      return false;
    }
  }
  userRemoveFilter(field, type, value) {
    this.removeFilter(field, type, value);
    this.refreshFilter();
  }
  userClearFilter(all) {
    this.clearFilter(all);
    this.refreshFilter();
  }
  userClearHeaderFilter() {
    this.clearHeaderFilter();
    this.refreshFilter();
  }
  searchRows(field, type, value) {
    return this.search("rows", field, type, value);
  }
  searchData(field, type, value) {
    return this.search("data", field, type, value);
  }
  initializeColumnHeaderFilter(column) {
    var def = column.definition;
    if (def.headerFilter) {
      this.initializeColumn(column);
    }
  }
  initializeColumn(column, value) {
    var self2 = this, field = column.getField();
    function success(value2) {
      var filterType = column.modules.filter.tagType == "input" && column.modules.filter.attrType == "text" || column.modules.filter.tagType == "textarea" ? "partial" : "match", type = "", filterChangeCheck = "", filterFunc;
      if (typeof column.modules.filter.prevSuccess === "undefined" || column.modules.filter.prevSuccess !== value2) {
        column.modules.filter.prevSuccess = value2;
        if (!column.modules.filter.emptyFunc(value2)) {
          column.modules.filter.value = value2;
          switch (typeof column.definition.headerFilterFunc) {
            case "string":
              if (Filter.filters[column.definition.headerFilterFunc]) {
                type = column.definition.headerFilterFunc;
                filterFunc = function(data) {
                  var params = column.definition.headerFilterFuncParams || {};
                  var fieldVal = column.getFieldValue(data);
                  params = typeof params === "function" ? params(value2, fieldVal, data) : params;
                  return Filter.filters[column.definition.headerFilterFunc](value2, fieldVal, data, params);
                };
              } else {
                console.warn("Header Filter Error - Matching filter function not found: ", column.definition.headerFilterFunc);
              }
              break;
            case "function":
              filterFunc = function(data) {
                var params = column.definition.headerFilterFuncParams || {};
                var fieldVal = column.getFieldValue(data);
                params = typeof params === "function" ? params(value2, fieldVal, data) : params;
                return column.definition.headerFilterFunc(value2, fieldVal, data, params);
              };
              type = filterFunc;
              break;
          }
          if (!filterFunc) {
            switch (filterType) {
              case "partial":
                filterFunc = function(data) {
                  var colVal = column.getFieldValue(data);
                  if (typeof colVal !== "undefined" && colVal !== null) {
                    return String(colVal).toLowerCase().indexOf(String(value2).toLowerCase()) > -1;
                  } else {
                    return false;
                  }
                };
                type = "like";
                break;
              default:
                filterFunc = function(data) {
                  return column.getFieldValue(data) == value2;
                };
                type = "=";
            }
          }
          self2.headerFilters[field] = { value: value2, func: filterFunc, type };
        } else {
          delete self2.headerFilters[field];
        }
        column.modules.filter.value = value2;
        filterChangeCheck = JSON.stringify(self2.headerFilters);
        if (self2.prevHeaderFilterChangeCheck !== filterChangeCheck) {
          self2.prevHeaderFilterChangeCheck = filterChangeCheck;
          self2.trackChanges();
          self2.refreshFilter();
        }
      }
      return true;
    }
    column.modules.filter = {
      success,
      attrType: false,
      tagType: false,
      emptyFunc: false
    };
    this.generateHeaderFilterElement(column);
  }
  generateHeaderFilterElement(column, initialValue, reinitialize) {
    var self2 = this, success = column.modules.filter.success, field = column.getField(), filterElement, editor, editorElement, cellWrapper, typingTimer, searchTrigger, params, onRenderedCallback;
    column.modules.filter.value = initialValue;
    function cancel() {
    }
    function onRendered(callback2) {
      onRenderedCallback = callback2;
    }
    if (column.modules.filter.headerElement && column.modules.filter.headerElement.parentNode) {
      column.contentElement.removeChild(column.modules.filter.headerElement.parentNode);
    }
    if (field) {
      column.modules.filter.emptyFunc = column.definition.headerFilterEmptyCheck || function(value) {
        return !value && value !== 0;
      };
      filterElement = document.createElement("div");
      filterElement.classList.add("tabulator-header-filter");
      switch (typeof column.definition.headerFilter) {
        case "string":
          if (self2.table.modules.edit.editors[column.definition.headerFilter]) {
            editor = self2.table.modules.edit.editors[column.definition.headerFilter];
            if ((column.definition.headerFilter === "tick" || column.definition.headerFilter === "tickCross") && !column.definition.headerFilterEmptyCheck) {
              column.modules.filter.emptyFunc = function(value) {
                return value !== true && value !== false;
              };
            }
          } else {
            console.warn("Filter Error - Cannot build header filter, No such editor found: ", column.definition.editor);
          }
          break;
        case "function":
          editor = column.definition.headerFilter;
          break;
        case "boolean":
          if (column.modules.edit && column.modules.edit.editor) {
            editor = column.modules.edit.editor;
          } else {
            if (column.definition.formatter && self2.table.modules.edit.editors[column.definition.formatter]) {
              editor = self2.table.modules.edit.editors[column.definition.formatter];
              if ((column.definition.formatter === "tick" || column.definition.formatter === "tickCross") && !column.definition.headerFilterEmptyCheck) {
                column.modules.filter.emptyFunc = function(value) {
                  return value !== true && value !== false;
                };
              }
            } else {
              editor = self2.table.modules.edit.editors["input"];
            }
          }
          break;
      }
      if (editor) {
        cellWrapper = {
          getValue: function() {
            return typeof initialValue !== "undefined" ? initialValue : "";
          },
          getField: function() {
            return column.definition.field;
          },
          getElement: function() {
            return filterElement;
          },
          getColumn: function() {
            return column.getComponent();
          },
          getTable: () => {
            return this.table;
          },
          getRow: function() {
            return {
              normalizeHeight: function() {
              }
            };
          }
        };
        params = column.definition.headerFilterParams || {};
        params = typeof params === "function" ? params.call(self2.table, cellWrapper) : params;
        editorElement = editor.call(this.table.modules.edit, cellWrapper, onRendered, success, cancel, params);
        if (!editorElement) {
          console.warn("Filter Error - Cannot add filter to " + field + " column, editor returned a value of false");
          return;
        }
        if (!(editorElement instanceof Node)) {
          console.warn("Filter Error - Cannot add filter to " + field + " column, editor should return an instance of Node, the editor returned:", editorElement);
          return;
        }
        self2.langBind("headerFilters|columns|" + column.definition.field, function(value) {
          editorElement.setAttribute("placeholder", typeof value !== "undefined" && value ? value : column.definition.headerFilterPlaceholder || self2.langText("headerFilters|default"));
        });
        editorElement.addEventListener("click", function(e) {
          e.stopPropagation();
          editorElement.focus();
        });
        editorElement.addEventListener("focus", (e) => {
          var left = this.table.columnManager.contentsElement.scrollLeft;
          var headerPos = this.table.rowManager.element.scrollLeft;
          if (left !== headerPos) {
            this.table.rowManager.scrollHorizontal(left);
            this.table.columnManager.scrollHorizontal(left);
          }
        });
        typingTimer = false;
        searchTrigger = function(e) {
          if (typingTimer) {
            clearTimeout(typingTimer);
          }
          typingTimer = setTimeout(function() {
            success(editorElement.value);
          }, self2.table.options.headerFilterLiveFilterDelay);
        };
        column.modules.filter.headerElement = editorElement;
        column.modules.filter.attrType = editorElement.hasAttribute("type") ? editorElement.getAttribute("type").toLowerCase() : "";
        column.modules.filter.tagType = editorElement.tagName.toLowerCase();
        if (column.definition.headerFilterLiveFilter !== false) {
          if (!(column.definition.headerFilter === "autocomplete" || column.definition.headerFilter === "tickCross" || (column.definition.editor === "autocomplete" || column.definition.editor === "tickCross") && column.definition.headerFilter === true)) {
            editorElement.addEventListener("keyup", searchTrigger);
            editorElement.addEventListener("search", searchTrigger);
            if (column.modules.filter.attrType == "number") {
              editorElement.addEventListener("change", function(e) {
                success(editorElement.value);
              });
            }
            if (column.modules.filter.attrType == "text" && this.table.browser !== "ie") {
              editorElement.setAttribute("type", "search");
            }
          }
          if (column.modules.filter.tagType == "input" || column.modules.filter.tagType == "select" || column.modules.filter.tagType == "textarea") {
            editorElement.addEventListener("mousedown", function(e) {
              e.stopPropagation();
            });
          }
        }
        filterElement.appendChild(editorElement);
        column.contentElement.appendChild(filterElement);
        if (!reinitialize) {
          self2.headerFilterColumns.push(column);
        }
        if (onRenderedCallback) {
          onRenderedCallback();
        }
      }
    } else {
      console.warn("Filter Error - Cannot add header filter, column has no field set:", column.definition.title);
    }
  }
  hideHeaderFilterElements() {
    this.headerFilterColumns.forEach(function(column) {
      if (column.modules.filter && column.modules.filter.headerElement) {
        column.modules.filter.headerElement.style.display = "none";
      }
    });
  }
  showHeaderFilterElements() {
    this.headerFilterColumns.forEach(function(column) {
      if (column.modules.filter && column.modules.filter.headerElement) {
        column.modules.filter.headerElement.style.display = "";
      }
    });
  }
  setHeaderFilterFocus(column) {
    if (column.modules.filter && column.modules.filter.headerElement) {
      column.modules.filter.headerElement.focus();
    } else {
      console.warn("Column Filter Focus Error - No header filter set on column:", column.getField());
    }
  }
  getHeaderFilterValue(column) {
    if (column.modules.filter && column.modules.filter.headerElement) {
      return column.modules.filter.value;
    } else {
      console.warn("Column Filter Error - No header filter set on column:", column.getField());
    }
  }
  setHeaderFilterValue(column, value) {
    if (column) {
      if (column.modules.filter && column.modules.filter.headerElement) {
        this.generateHeaderFilterElement(column, value, true);
        column.modules.filter.success(value);
      } else {
        console.warn("Column Filter Error - No header filter set on column:", column.getField());
      }
    }
  }
  reloadHeaderFilter(column) {
    if (column) {
      if (column.modules.filter && column.modules.filter.headerElement) {
        this.generateHeaderFilterElement(column, column.modules.filter.value, true);
      } else {
        console.warn("Column Filter Error - No header filter set on column:", column.getField());
      }
    }
  }
  refreshFilter() {
    if (this.tableInitialized) {
      if (this.table.options.filterMode === "remote") {
        this.reloadData(null, false, false);
      } else {
        this.refreshData(true);
      }
    }
  }
  trackChanges() {
    this.changed = true;
    this.dispatch("filter-changed");
  }
  hasChanged() {
    var changed = this.changed;
    this.changed = false;
    return changed;
  }
  setFilter(field, type, value, params) {
    this.filterList = [];
    if (!Array.isArray(field)) {
      field = [{ field, type, value, params }];
    }
    this.addFilter(field);
  }
  addFilter(field, type, value, params) {
    var changed = false;
    if (!Array.isArray(field)) {
      field = [{ field, type, value, params }];
    }
    field.forEach((filter) => {
      filter = this.findFilter(filter);
      if (filter) {
        this.filterList.push(filter);
        changed = true;
      }
    });
    if (changed) {
      this.trackChanges();
    }
  }
  findFilter(filter) {
    var column;
    if (Array.isArray(filter)) {
      return this.findSubFilters(filter);
    }
    var filterFunc = false;
    if (typeof filter.field == "function") {
      filterFunc = function(data) {
        return filter.field(data, filter.type || {});
      };
    } else {
      if (Filter.filters[filter.type]) {
        column = this.table.columnManager.getColumnByField(filter.field);
        if (column) {
          filterFunc = function(data) {
            return Filter.filters[filter.type](filter.value, column.getFieldValue(data), data, filter.params || {});
          };
        } else {
          filterFunc = function(data) {
            return Filter.filters[filter.type](filter.value, data[filter.field], data, filter.params || {});
          };
        }
      } else {
        console.warn("Filter Error - No such filter type found, ignoring: ", filter.type);
      }
    }
    filter.func = filterFunc;
    return filter.func ? filter : false;
  }
  findSubFilters(filters) {
    var output = [];
    filters.forEach((filter) => {
      filter = this.findFilter(filter);
      if (filter) {
        output.push(filter);
      }
    });
    return output.length ? output : false;
  }
  getFilters(all, ajax) {
    var output = [];
    if (all) {
      output = this.getHeaderFilters();
    }
    if (ajax) {
      output.forEach(function(item) {
        if (typeof item.type == "function") {
          item.type = "function";
        }
      });
    }
    output = output.concat(this.filtersToArray(this.filterList, ajax));
    return output;
  }
  filtersToArray(filterList, ajax) {
    var output = [];
    filterList.forEach((filter) => {
      var item;
      if (Array.isArray(filter)) {
        output.push(this.filtersToArray(filter, ajax));
      } else {
        item = { field: filter.field, type: filter.type, value: filter.value };
        if (ajax) {
          if (typeof item.type == "function") {
            item.type = "function";
          }
        }
        output.push(item);
      }
    });
    return output;
  }
  getHeaderFilters() {
    var output = [];
    for (var key in this.headerFilters) {
      output.push({ field: key, type: this.headerFilters[key].type, value: this.headerFilters[key].value });
    }
    return output;
  }
  removeFilter(field, type, value) {
    if (!Array.isArray(field)) {
      field = [{ field, type, value }];
    }
    field.forEach((filter) => {
      var index2 = -1;
      if (typeof filter.field == "object") {
        index2 = this.filterList.findIndex((element) => {
          return filter === element;
        });
      } else {
        index2 = this.filterList.findIndex((element) => {
          return filter.field === element.field && filter.type === element.type && filter.value === element.value;
        });
      }
      if (index2 > -1) {
        this.filterList.splice(index2, 1);
      } else {
        console.warn("Filter Error - No matching filter type found, ignoring: ", filter.type);
      }
    });
    this.trackChanges();
  }
  clearFilter(all) {
    this.filterList = [];
    if (all) {
      this.clearHeaderFilter();
    }
    this.trackChanges();
  }
  clearHeaderFilter() {
    this.headerFilters = {};
    this.prevHeaderFilterChangeCheck = "{}";
    this.headerFilterColumns.forEach((column) => {
      if (typeof column.modules.filter.value !== "undefined") {
        delete column.modules.filter.value;
      }
      column.modules.filter.prevSuccess = void 0;
      this.reloadHeaderFilter(column);
    });
    this.trackChanges();
  }
  search(searchType, field, type, value) {
    var activeRows = [], filterList = [];
    if (!Array.isArray(field)) {
      field = [{ field, type, value }];
    }
    field.forEach((filter) => {
      filter = this.findFilter(filter);
      if (filter) {
        filterList.push(filter);
      }
    });
    this.table.rowManager.rows.forEach((row2) => {
      var match2 = true;
      filterList.forEach((filter) => {
        if (!this.filterRecurse(filter, row2.getData())) {
          match2 = false;
        }
      });
      if (match2) {
        activeRows.push(searchType === "data" ? row2.getData("data") : row2.getComponent());
      }
    });
    return activeRows;
  }
  filter(rowList, filters) {
    var activeRows = [], activeRowComponents = [];
    if (this.subscribedExternal("dataFiltering")) {
      this.dispatchExternal("dataFiltering", this.getFilters(true));
    }
    if (this.table.options.filterMode !== "remote" && (this.filterList.length || Object.keys(this.headerFilters).length)) {
      rowList.forEach((row2) => {
        if (this.filterRow(row2)) {
          activeRows.push(row2);
        }
      });
    } else {
      activeRows = rowList.slice(0);
    }
    if (this.subscribedExternal("dataFiltered")) {
      activeRows.forEach((row2) => {
        activeRowComponents.push(row2.getComponent());
      });
      this.dispatchExternal("dataFiltered", this.getFilters(true), activeRowComponents);
    }
    return activeRows;
  }
  filterRow(row2, filters) {
    var match2 = true, data = row2.getData();
    this.filterList.forEach((filter) => {
      if (!this.filterRecurse(filter, data)) {
        match2 = false;
      }
    });
    for (var field in this.headerFilters) {
      if (!this.headerFilters[field].func(data)) {
        match2 = false;
      }
    }
    return match2;
  }
  filterRecurse(filter, data) {
    var match2 = false;
    if (Array.isArray(filter)) {
      filter.forEach((subFilter) => {
        if (this.filterRecurse(subFilter, data)) {
          match2 = true;
        }
      });
    } else {
      match2 = filter.func(data);
    }
    return match2;
  }
};
Filter.moduleName = "filter";
Filter.filters = defaultFilters;
function plaintext(cell, formatterParams, onRendered) {
  return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
}
function html$1(cell, formatterParams, onRendered) {
  return cell.getValue();
}
function textarea$1(cell, formatterParams, onRendered) {
  cell.getElement().style.whiteSpace = "pre-wrap";
  return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
}
function money(cell, formatterParams, onRendered) {
  var floatVal = parseFloat(cell.getValue()), sign2 = "", number2, integer, decimal, rgx;
  var decimalSym = formatterParams.decimal || ".";
  var thousandSym = formatterParams.thousand || ",";
  var negativeSign = formatterParams.negativeSign || "-";
  var symbol = formatterParams.symbol || "";
  var after = !!formatterParams.symbolAfter;
  var precision = typeof formatterParams.precision !== "undefined" ? formatterParams.precision : 2;
  if (isNaN(floatVal)) {
    return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
  }
  if (floatVal < 0) {
    floatVal = Math.abs(floatVal);
    sign2 = negativeSign;
  }
  number2 = precision !== false ? floatVal.toFixed(precision) : floatVal;
  number2 = String(number2).split(".");
  integer = number2[0];
  decimal = number2.length > 1 ? decimalSym + number2[1] : "";
  if (formatterParams.thousand !== false) {
    rgx = /(\d+)(\d{3})/;
    while (rgx.test(integer)) {
      integer = integer.replace(rgx, "$1" + thousandSym + "$2");
    }
  }
  return after ? sign2 + integer + decimal + symbol : sign2 + symbol + integer + decimal;
}
function link(cell, formatterParams, onRendered) {
  var value = cell.getValue(), urlPrefix = formatterParams.urlPrefix || "", download = formatterParams.download, label = value, el = document.createElement("a"), data;
  function labelTraverse(path, data2) {
    var item = path.shift(), value2 = data2[item];
    if (path.length && typeof value2 === "object") {
      return labelTraverse(path, value2);
    }
    return value2;
  }
  if (formatterParams.labelField) {
    data = cell.getData();
    label = labelTraverse(formatterParams.labelField.split(this.table.options.nestedFieldSeparator), data);
  }
  if (formatterParams.label) {
    switch (typeof formatterParams.label) {
      case "string":
        label = formatterParams.label;
        break;
      case "function":
        label = formatterParams.label(cell);
        break;
    }
  }
  if (label) {
    if (formatterParams.urlField) {
      data = cell.getData();
      value = data[formatterParams.urlField];
    }
    if (formatterParams.url) {
      switch (typeof formatterParams.url) {
        case "string":
          value = formatterParams.url;
          break;
        case "function":
          value = formatterParams.url(cell);
          break;
      }
    }
    el.setAttribute("href", urlPrefix + value);
    if (formatterParams.target) {
      el.setAttribute("target", formatterParams.target);
    }
    if (formatterParams.download) {
      if (typeof download == "function") {
        download = download(cell);
      } else {
        download = download === true ? "" : download;
      }
      el.setAttribute("download", download);
    }
    el.innerHTML = this.emptyToSpace(this.sanitizeHTML(label));
    return el;
  } else {
    return "&nbsp;";
  }
}
function image(cell, formatterParams, onRendered) {
  var el = document.createElement("img"), src = cell.getValue();
  if (formatterParams.urlPrefix) {
    src = formatterParams.urlPrefix + cell.getValue();
  }
  if (formatterParams.urlSuffix) {
    src = src + formatterParams.urlSuffix;
  }
  el.setAttribute("src", src);
  switch (typeof formatterParams.height) {
    case "number":
      el.style.height = formatterParams.height + "px";
      break;
    case "string":
      el.style.height = formatterParams.height;
      break;
  }
  switch (typeof formatterParams.width) {
    case "number":
      el.style.width = formatterParams.width + "px";
      break;
    case "string":
      el.style.width = formatterParams.width;
      break;
  }
  el.addEventListener("load", function() {
    cell.getRow().normalizeHeight();
  });
  return el;
}
function tickCross$1(cell, formatterParams, onRendered) {
  var value = cell.getValue(), element = cell.getElement(), empty = formatterParams.allowEmpty, truthy = formatterParams.allowTruthy, trueValueSet = Object.keys(formatterParams).includes("trueValue"), tick = typeof formatterParams.tickElement !== "undefined" ? formatterParams.tickElement : '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>', cross = typeof formatterParams.crossElement !== "undefined" ? formatterParams.crossElement : '<svg enable-background="new 0 0 24 24" height="14" width="14"  viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
  if (trueValueSet && value === formatterParams.trueValue || !trueValueSet && (truthy && value || (value === true || value === "true" || value === "True" || value === 1 || value === "1"))) {
    element.setAttribute("aria-checked", true);
    return tick || "";
  } else {
    if (empty && (value === "null" || value === "" || value === null || typeof value === "undefined")) {
      element.setAttribute("aria-checked", "mixed");
      return "";
    } else {
      element.setAttribute("aria-checked", false);
      return cross || "";
    }
  }
}
function datetime$1(cell, formatterParams, onRendered) {
  var DT = window.DateTime || luxon.DateTime;
  var inputFormat = formatterParams.inputFormat || "yyyy-MM-dd HH:mm:ss";
  var outputFormat = formatterParams.outputFormat || "dd/MM/yyyy HH:mm:ss";
  var invalid = typeof formatterParams.invalidPlaceholder !== "undefined" ? formatterParams.invalidPlaceholder : "";
  var value = cell.getValue();
  if (typeof DT != "undefined") {
    var newDatetime;
    if (DT.isDateTime(value)) {
      newDatetime = value;
    } else if (inputFormat === "iso") {
      newDatetime = DT.fromISO(String(value));
    } else {
      newDatetime = DT.fromFormat(String(value), inputFormat);
    }
    if (newDatetime.isValid) {
      if (formatterParams.timezone) {
        newDatetime = newDatetime.setZone(formatterParams.timezone);
      }
      return newDatetime.toFormat(outputFormat);
    } else {
      if (invalid === true || !value) {
        return value;
      } else if (typeof invalid === "function") {
        return invalid(value);
      } else {
        return invalid;
      }
    }
  } else {
    console.error("Format Error - 'datetime' formatter is dependant on luxon.js");
  }
}
function datetimediff(cell, formatterParams, onRendered) {
  var DT = window.DateTime || luxon.DateTime;
  var inputFormat = formatterParams.inputFormat || "yyyy-MM-dd HH:mm:ss";
  var invalid = typeof formatterParams.invalidPlaceholder !== "undefined" ? formatterParams.invalidPlaceholder : "";
  var suffix = typeof formatterParams.suffix !== "undefined" ? formatterParams.suffix : false;
  var unit = typeof formatterParams.unit !== "undefined" ? formatterParams.unit : "days";
  var humanize = typeof formatterParams.humanize !== "undefined" ? formatterParams.humanize : false;
  var date2 = typeof formatterParams.date !== "undefined" ? formatterParams.date : DT.now();
  var value = cell.getValue();
  if (typeof DT != "undefined") {
    var newDatetime;
    if (DT.isDateTime(value)) {
      newDatetime = value;
    } else if (inputFormat === "iso") {
      newDatetime = DT.fromISO(String(value));
    } else {
      newDatetime = DT.fromFormat(String(value), inputFormat);
    }
    if (newDatetime.isValid) {
      if (humanize) {
        return newDatetime.diff(date2, unit).toHuman() + (suffix ? " " + suffix : "");
      } else {
        return parseInt(newDatetime.diff(date2, unit)[unit]) + (suffix ? " " + suffix : "");
      }
    } else {
      if (invalid === true) {
        return value;
      } else if (typeof invalid === "function") {
        return invalid(value);
      } else {
        return invalid;
      }
    }
  } else {
    console.error("Format Error - 'datetimediff' formatter is dependant on luxon.js");
  }
}
function lookup(cell, formatterParams, onRendered) {
  var value = cell.getValue();
  if (typeof formatterParams[value] === "undefined") {
    console.warn("Missing display value for " + value);
    return value;
  }
  return formatterParams[value];
}
function star$1(cell, formatterParams, onRendered) {
  var value = cell.getValue(), element = cell.getElement(), maxStars = formatterParams && formatterParams.stars ? formatterParams.stars : 5, stars = document.createElement("span"), star2 = document.createElementNS("http://www.w3.org/2000/svg", "svg"), starActive = '<polygon fill="#FFEA00" stroke="#C1AB60" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>', starInactive = '<polygon fill="#D2D2D2" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
  stars.style.verticalAlign = "middle";
  star2.setAttribute("width", "14");
  star2.setAttribute("height", "14");
  star2.setAttribute("viewBox", "0 0 512 512");
  star2.setAttribute("xml:space", "preserve");
  star2.style.padding = "0 1px";
  value = value && !isNaN(value) ? parseInt(value) : 0;
  value = Math.max(0, Math.min(value, maxStars));
  for (var i2 = 1; i2 <= maxStars; i2++) {
    var nextStar = star2.cloneNode(true);
    nextStar.innerHTML = i2 <= value ? starActive : starInactive;
    stars.appendChild(nextStar);
  }
  element.style.whiteSpace = "nowrap";
  element.style.overflow = "hidden";
  element.style.textOverflow = "ellipsis";
  element.setAttribute("aria-label", value);
  return stars;
}
function traffic(cell, formatterParams, onRendered) {
  var value = this.sanitizeHTML(cell.getValue()) || 0, el = document.createElement("span"), max = formatterParams && formatterParams.max ? formatterParams.max : 100, min = formatterParams && formatterParams.min ? formatterParams.min : 0, colors3 = formatterParams && typeof formatterParams.color !== "undefined" ? formatterParams.color : ["red", "orange", "green"], color3 = "#666666", percent, percentValue;
  if (isNaN(value) || typeof cell.getValue() === "undefined") {
    return;
  }
  el.classList.add("tabulator-traffic-light");
  percentValue = parseFloat(value) <= max ? parseFloat(value) : max;
  percentValue = parseFloat(percentValue) >= min ? parseFloat(percentValue) : min;
  percent = (max - min) / 100;
  percentValue = Math.round((percentValue - min) / percent);
  switch (typeof colors3) {
    case "string":
      color3 = colors3;
      break;
    case "function":
      color3 = colors3(value);
      break;
    case "object":
      if (Array.isArray(colors3)) {
        var unit = 100 / colors3.length;
        var index2 = Math.floor(percentValue / unit);
        index2 = Math.min(index2, colors3.length - 1);
        index2 = Math.max(index2, 0);
        color3 = colors3[index2];
        break;
      }
  }
  el.style.backgroundColor = color3;
  return el;
}
function progress$1(cell, formatterParams = {}, onRendered) {
  var value = this.sanitizeHTML(cell.getValue()) || 0, element = cell.getElement(), max = formatterParams.max ? formatterParams.max : 100, min = formatterParams.min ? formatterParams.min : 0, legendAlign = formatterParams.legendAlign ? formatterParams.legendAlign : "center", percent, percentValue, color3, legend, legendColor;
  percentValue = parseFloat(value) <= max ? parseFloat(value) : max;
  percentValue = parseFloat(percentValue) >= min ? parseFloat(percentValue) : min;
  percent = (max - min) / 100;
  percentValue = Math.round((percentValue - min) / percent);
  switch (typeof formatterParams.color) {
    case "string":
      color3 = formatterParams.color;
      break;
    case "function":
      color3 = formatterParams.color(value);
      break;
    case "object":
      if (Array.isArray(formatterParams.color)) {
        let unit = 100 / formatterParams.color.length;
        let index2 = Math.floor(percentValue / unit);
        index2 = Math.min(index2, formatterParams.color.length - 1);
        index2 = Math.max(index2, 0);
        color3 = formatterParams.color[index2];
        break;
      }
    default:
      color3 = "#2DC214";
  }
  switch (typeof formatterParams.legend) {
    case "string":
      legend = formatterParams.legend;
      break;
    case "function":
      legend = formatterParams.legend(value);
      break;
    case "boolean":
      legend = value;
      break;
    default:
      legend = false;
  }
  switch (typeof formatterParams.legendColor) {
    case "string":
      legendColor = formatterParams.legendColor;
      break;
    case "function":
      legendColor = formatterParams.legendColor(value);
      break;
    case "object":
      if (Array.isArray(formatterParams.legendColor)) {
        let unit = 100 / formatterParams.legendColor.length;
        let index2 = Math.floor(percentValue / unit);
        index2 = Math.min(index2, formatterParams.legendColor.length - 1);
        index2 = Math.max(index2, 0);
        legendColor = formatterParams.legendColor[index2];
      }
      break;
    default:
      legendColor = "#000";
  }
  element.style.minWidth = "30px";
  element.style.position = "relative";
  element.setAttribute("aria-label", percentValue);
  var barEl = document.createElement("div");
  barEl.style.display = "inline-block";
  barEl.style.width = percentValue + "%";
  barEl.style.backgroundColor = color3;
  barEl.style.height = "100%";
  barEl.setAttribute("data-max", max);
  barEl.setAttribute("data-min", min);
  var barContainer = document.createElement("div");
  barContainer.style.position = "relative";
  barContainer.style.width = "100%";
  barContainer.style.height = "100%";
  if (legend) {
    var legendEl = document.createElement("div");
    legendEl.style.position = "absolute";
    legendEl.style.top = 0;
    legendEl.style.left = 0;
    legendEl.style.textAlign = legendAlign;
    legendEl.style.width = "100%";
    legendEl.style.color = legendColor;
    legendEl.innerHTML = legend;
  }
  onRendered(function() {
    if (!(cell instanceof CellComponent)) {
      var holderEl = document.createElement("div");
      holderEl.style.position = "absolute";
      holderEl.style.top = "4px";
      holderEl.style.bottom = "4px";
      holderEl.style.left = "4px";
      holderEl.style.right = "4px";
      element.appendChild(holderEl);
      element = holderEl;
    }
    element.appendChild(barContainer);
    barContainer.appendChild(barEl);
    if (legend) {
      barContainer.appendChild(legendEl);
    }
  });
  return "";
}
function color2(cell, formatterParams, onRendered) {
  cell.getElement().style.backgroundColor = this.sanitizeHTML(cell.getValue());
  return "";
}
function buttonTick(cell, formatterParams, onRendered) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>';
}
function buttonCross(cell, formatterParams, onRendered) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
}
function rownum(cell, formatterParams, onRendered) {
  var content = document.createElement("span");
  var row2 = cell.getRow();
  row2.watchPosition((position) => {
    content.innerText = position;
  });
  return content;
}
function handle(cell, formatterParams, onRendered) {
  cell.getElement().classList.add("tabulator-row-handle");
  return "<div class='tabulator-row-handle-box'><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div></div>";
}
function responsiveCollapse(cell, formatterParams, onRendered) {
  var el = document.createElement("div"), config = cell.getRow()._row.modules.responsiveLayout;
  el.classList.add("tabulator-responsive-collapse-toggle");
  el.innerHTML = `<svg class='tabulator-responsive-collapse-toggle-open' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12" fill="none" stroke-width="3" stroke-linecap="round" />
  <line y1="7" x1="12" y2="17" x2="12" fill="none" stroke-width="3" stroke-linecap="round" />
</svg>

<svg class='tabulator-responsive-collapse-toggle-close' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12"  fill="none" stroke-width="3" stroke-linecap="round" />
</svg>`;
  cell.getElement().classList.add("tabulator-row-handle");
  function toggleList(isOpen) {
    var collapseEl = config.element;
    config.open = isOpen;
    if (collapseEl) {
      if (config.open) {
        el.classList.add("open");
        collapseEl.style.display = "";
      } else {
        el.classList.remove("open");
        collapseEl.style.display = "none";
      }
    }
  }
  el.addEventListener("click", function(e) {
    e.stopImmediatePropagation();
    toggleList(!config.open);
    cell.getTable().rowManager.adjustTableSize();
  });
  toggleList(config.open);
  return el;
}
function rowSelection(cell, formatterParams, onRendered) {
  var checkbox = document.createElement("input");
  var blocked = false;
  checkbox.type = "checkbox";
  checkbox.setAttribute("aria-label", "Select Row");
  if (this.table.modExists("selectRow", true)) {
    checkbox.addEventListener("click", (e) => {
      e.stopPropagation();
    });
    if (typeof cell.getRow == "function") {
      var row2 = cell.getRow();
      if (row2 instanceof RowComponent) {
        checkbox.addEventListener("change", (e) => {
          if (this.table.options.selectableRangeMode === "click") {
            if (!blocked) {
              row2.toggleSelect();
            } else {
              blocked = false;
            }
          } else {
            row2.toggleSelect();
          }
        });
        if (this.table.options.selectableRangeMode === "click") {
          checkbox.addEventListener("click", (e) => {
            blocked = true;
            this.table.modules.selectRow.handleComplexRowClick(row2._row, e);
          });
        }
        checkbox.checked = row2.isSelected && row2.isSelected();
        this.table.modules.selectRow.registerRowSelectCheckbox(row2, checkbox);
      } else {
        checkbox = "";
      }
    } else {
      checkbox.addEventListener("change", (e) => {
        if (this.table.modules.selectRow.selectedRows.length) {
          this.table.deselectRow();
        } else {
          this.table.selectRow(formatterParams.rowRange);
        }
      });
      this.table.modules.selectRow.registerHeaderSelectCheckbox(checkbox);
    }
  }
  return checkbox;
}
var defaultFormatters = {
  plaintext,
  html: html$1,
  textarea: textarea$1,
  money,
  link,
  image,
  tickCross: tickCross$1,
  datetime: datetime$1,
  datetimediff,
  lookup,
  star: star$1,
  traffic,
  progress: progress$1,
  color: color2,
  buttonTick,
  buttonCross,
  rownum,
  handle,
  responsiveCollapse,
  rowSelection
};
var Format = class extends Module {
  constructor(table) {
    super(table);
    this.registerColumnOption("formatter");
    this.registerColumnOption("formatterParams");
    this.registerColumnOption("formatterPrint");
    this.registerColumnOption("formatterPrintParams");
    this.registerColumnOption("formatterClipboard");
    this.registerColumnOption("formatterClipboardParams");
    this.registerColumnOption("formatterHtmlOutput");
    this.registerColumnOption("formatterHtmlOutputParams");
    this.registerColumnOption("titleFormatter");
    this.registerColumnOption("titleFormatterParams");
  }
  initialize() {
    this.subscribe("cell-format", this.formatValue.bind(this));
    this.subscribe("cell-rendered", this.cellRendered.bind(this));
    this.subscribe("column-layout", this.initializeColumn.bind(this));
    this.subscribe("column-format", this.formatHeader.bind(this));
  }
  initializeColumn(column) {
    column.modules.format = this.lookupFormatter(column, "");
    if (typeof column.definition.formatterPrint !== "undefined") {
      column.modules.format.print = this.lookupFormatter(column, "Print");
    }
    if (typeof column.definition.formatterClipboard !== "undefined") {
      column.modules.format.clipboard = this.lookupFormatter(column, "Clipboard");
    }
    if (typeof column.definition.formatterHtmlOutput !== "undefined") {
      column.modules.format.htmlOutput = this.lookupFormatter(column, "HtmlOutput");
    }
  }
  lookupFormatter(column, type) {
    var config = { params: column.definition["formatter" + type + "Params"] || {} }, formatter = column.definition["formatter" + type];
    switch (typeof formatter) {
      case "string":
        if (Format.formatters[formatter]) {
          config.formatter = Format.formatters[formatter];
        } else {
          console.warn("Formatter Error - No such formatter found: ", formatter);
          config.formatter = Format.formatters.plaintext;
        }
        break;
      case "function":
        config.formatter = formatter;
        break;
      default:
        config.formatter = Format.formatters.plaintext;
        break;
    }
    return config;
  }
  cellRendered(cell) {
    if (cell.modules.format && cell.modules.format.renderedCallback && !cell.modules.format.rendered) {
      cell.modules.format.renderedCallback();
      cell.modules.format.rendered = true;
    }
  }
  formatHeader(column, title, el) {
    var formatter, params, onRendered, mockCell;
    if (column.definition.titleFormatter) {
      formatter = this.getFormatter(column.definition.titleFormatter);
      onRendered = (callback2) => {
        column.titleFormatterRendered = callback2;
      };
      mockCell = {
        getValue: function() {
          return title;
        },
        getElement: function() {
          return el;
        },
        getColumn: function() {
          return column.getComponent();
        },
        getTable: () => {
          return this.table;
        }
      };
      params = column.definition.titleFormatterParams || {};
      params = typeof params === "function" ? params() : params;
      return formatter.call(this, mockCell, params, onRendered);
    } else {
      return title;
    }
  }
  formatValue(cell) {
    var component = cell.getComponent(), params = typeof cell.column.modules.format.params === "function" ? cell.column.modules.format.params(component) : cell.column.modules.format.params;
    function onRendered(callback2) {
      if (!cell.modules.format) {
        cell.modules.format = {};
      }
      cell.modules.format.renderedCallback = callback2;
      cell.modules.format.rendered = false;
    }
    return cell.column.modules.format.formatter.call(this, component, params, onRendered);
  }
  formatExportValue(cell, type) {
    var formatter = cell.column.modules.format[type], params;
    if (formatter) {
      let onRendered = function(callback2) {
        if (!cell.modules.format) {
          cell.modules.format = {};
        }
        cell.modules.format.renderedCallback = callback2;
        cell.modules.format.rendered = false;
      };
      params = typeof formatter.params === "function" ? formatter.params(cell.getComponent()) : formatter.params;
      return formatter.formatter.call(this, cell.getComponent(), params, onRendered);
    } else {
      return this.formatValue(cell);
    }
  }
  sanitizeHTML(value) {
    if (value) {
      var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      return String(value).replace(/[&<>"'`=/]/g, function(s2) {
        return entityMap[s2];
      });
    } else {
      return value;
    }
  }
  emptyToSpace(value) {
    return value === null || typeof value === "undefined" || value === "" ? "&nbsp;" : value;
  }
  getFormatter(formatter) {
    switch (typeof formatter) {
      case "string":
        if (Format.formatters[formatter]) {
          formatter = Format.formatters[formatter];
        } else {
          console.warn("Formatter Error - No such formatter found: ", formatter);
          formatter = Format.formatters.plaintext;
        }
        break;
      case "function":
        break;
      default:
        formatter = Format.formatters.plaintext;
        break;
    }
    return formatter;
  }
};
Format.moduleName = "format";
Format.formatters = defaultFormatters;
var FrozenColumns = class extends Module {
  constructor(table) {
    super(table);
    this.leftColumns = [];
    this.rightColumns = [];
    this.initializationMode = "left";
    this.active = false;
    this.blocked = true;
    this.registerColumnOption("frozen");
  }
  reset() {
    this.initializationMode = "left";
    this.leftColumns = [];
    this.rightColumns = [];
    this.active = false;
  }
  initialize() {
    this.subscribe("cell-layout", this.layoutCell.bind(this));
    this.subscribe("column-init", this.initializeColumn.bind(this));
    this.subscribe("column-width", this.layout.bind(this));
    this.subscribe("row-layout-after", this.layoutRow.bind(this));
    this.subscribe("table-layout", this.layout.bind(this));
    this.subscribe("columns-loading", this.reset.bind(this));
    this.subscribe("column-add", this.reinitializeColumns.bind(this));
    this.subscribe("column-delete", this.reinitializeColumns.bind(this));
    this.subscribe("table-redraw", this.layout.bind(this));
    this.subscribe("layout-refreshing", this.blockLayout.bind(this));
    this.subscribe("layout-refreshed", this.unblockLayout.bind(this));
    this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this));
  }
  blockLayout() {
    this.blocked = true;
  }
  unblockLayout() {
    this.blocked = false;
  }
  layoutCell(cell) {
    this.layoutElement(cell.element, cell.column);
  }
  reinitializeColumns() {
    this.reset();
    this.table.columnManager.columnsByIndex.forEach((column) => {
      this.initializeColumn(column);
    });
  }
  initializeColumn(column) {
    var config = { margin: 0, edge: false };
    if (!column.isGroup) {
      if (this.frozenCheck(column)) {
        config.position = this.initializationMode;
        if (this.initializationMode == "left") {
          this.leftColumns.push(column);
        } else {
          this.rightColumns.unshift(column);
        }
        this.active = true;
        column.modules.frozen = config;
      } else {
        this.initializationMode = "right";
      }
    }
  }
  frozenCheck(column) {
    if (column.parent.isGroup && column.definition.frozen) {
      console.warn("Frozen Column Error - Parent column group must be frozen, not individual columns or sub column groups");
    }
    if (column.parent.isGroup) {
      return this.frozenCheck(column.parent);
    } else {
      return column.definition.frozen;
    }
  }
  layoutCalcRows() {
    if (this.table.modExists("columnCalcs")) {
      if (this.table.modules.columnCalcs.topInitialized && this.table.modules.columnCalcs.topRow) {
        this.layoutRow(this.table.modules.columnCalcs.topRow);
      }
      if (this.table.modules.columnCalcs.botInitialized && this.table.modules.columnCalcs.botRow) {
        this.layoutRow(this.table.modules.columnCalcs.botRow);
      }
      if (this.table.modExists("groupRows")) {
        this.layoutGroupCalcs(this.table.modules.groupRows.getGroups());
      }
    }
  }
  layoutGroupCalcs(groups) {
    groups.forEach((group) => {
      if (group.calcs.top) {
        this.layoutRow(group.calcs.top);
      }
      if (group.calcs.bottom) {
        this.layoutRow(group.calcs.bottom);
      }
      if (group.groupList && group.groupList.length) {
        this.layoutGroupCalcs(group.groupList);
      }
    });
  }
  layoutColumnPosition(allCells) {
    var leftParents = [];
    var leftMargin = 0;
    var rightMargin = 0;
    this.leftColumns.forEach((column, i2) => {
      column.modules.frozen.marginValue = leftMargin;
      column.modules.frozen.margin = column.modules.frozen.marginValue + "px";
      if (column.visible) {
        leftMargin += column.getWidth();
      }
      if (i2 == this.leftColumns.length - 1) {
        column.modules.frozen.edge = true;
      } else {
        column.modules.frozen.edge = false;
      }
      if (column.parent.isGroup) {
        var parentEl = this.getColGroupParentElement(column);
        if (!leftParents.includes(parentEl)) {
          this.layoutElement(parentEl, column);
          leftParents.push(parentEl);
        }
        if (column.modules.frozen.edge) {
          parentEl.classList.add("tabulator-frozen-" + column.modules.frozen.position);
        }
      } else {
        this.layoutElement(column.getElement(), column);
      }
      if (allCells) {
        column.cells.forEach((cell) => {
          this.layoutElement(cell.getElement(true), column);
        });
      }
    });
    this.rightColumns.forEach((column, i2) => {
      column.modules.frozen.marginValue = rightMargin;
      column.modules.frozen.margin = column.modules.frozen.marginValue + "px";
      if (column.visible) {
        rightMargin += column.getWidth();
      }
      if (i2 == this.rightColumns.length - 1) {
        column.modules.frozen.edge = true;
      } else {
        column.modules.frozen.edge = false;
      }
      if (column.parent.isGroup) {
        this.layoutElement(this.getColGroupParentElement(column), column);
      } else {
        this.layoutElement(column.getElement(), column);
      }
      if (allCells) {
        column.cells.forEach((cell) => {
          this.layoutElement(cell.getElement(true), column);
        });
      }
    });
  }
  getColGroupParentElement(column) {
    return column.parent.isGroup ? this.getColGroupParentElement(column.parent) : column.getElement();
  }
  layout() {
    if (this.active && !this.blocked) {
      this.layoutColumnPosition();
      this.reinitializeRows();
      this.layoutCalcRows();
    }
  }
  reinitializeRows() {
    var visibleRows = this.table.rowManager.getVisibleRows(true);
    var otherRows = this.table.rowManager.getRows().filter((row2) => !visibleRows.includes(row2));
    otherRows.forEach((row2) => {
      row2.deinitialize();
    });
    visibleRows.forEach((row2) => {
      if (row2.type === "row") {
        this.layoutRow(row2);
      }
    });
  }
  layoutRow(row2) {
    if (this.table.options.layout === "fitDataFill" && this.rightColumns.length) {
      this.table.rowManager.getTableElement().style.minWidth = "calc(100% - " + this.rightMargin + ")";
    }
    this.leftColumns.forEach((column) => {
      var cell = row2.getCell(column);
      if (cell) {
        this.layoutElement(cell.getElement(true), column);
      }
    });
    this.rightColumns.forEach((column) => {
      var cell = row2.getCell(column);
      if (cell) {
        this.layoutElement(cell.getElement(true), column);
      }
    });
  }
  layoutElement(element, column) {
    var position;
    if (column.modules.frozen) {
      element.style.position = "sticky";
      if (this.table.rtl) {
        position = column.modules.frozen.position === "left" ? "right" : "left";
      } else {
        position = column.modules.frozen.position;
      }
      element.style[position] = column.modules.frozen.margin;
      element.classList.add("tabulator-frozen");
      if (column.modules.frozen.edge) {
        element.classList.add("tabulator-frozen-" + column.modules.frozen.position);
      }
    }
  }
  adjustForScrollbar(width) {
    if (this.rightColumns.length) {
      this.table.columnManager.getContentsElement().style.width = "calc(100% - " + width + "px)";
    }
  }
  _calcSpace(columns, index2) {
    var width = 0;
    for (let i2 = 0; i2 < index2; i2++) {
      if (columns[i2].visible) {
        width += columns[i2].getWidth();
      }
    }
    return width;
  }
};
FrozenColumns.moduleName = "frozenColumns";
var FrozenRows = class extends Module {
  constructor(table) {
    super(table);
    this.topElement = document.createElement("div");
    this.rows = [];
    this.registerComponentFunction("row", "freeze", this.freezeRow.bind(this));
    this.registerComponentFunction("row", "unfreeze", this.unfreezeRow.bind(this));
    this.registerComponentFunction("row", "isFrozen", this.isRowFrozen.bind(this));
    this.registerTableOption("frozenRowsField", "id");
    this.registerTableOption("frozenRows", false);
  }
  initialize() {
    this.rows = [];
    this.topElement.classList.add("tabulator-frozen-rows-holder");
    this.table.columnManager.getContentsElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling);
    this.subscribe("row-deleting", this.detachRow.bind(this));
    this.subscribe("rows-visible", this.visibleRows.bind(this));
    this.registerDisplayHandler(this.getRows.bind(this), 10);
    if (this.table.options.frozenRows) {
      this.subscribe("data-processed", this.initializeRows.bind(this));
      this.subscribe("row-added", this.initializeRow.bind(this));
    }
  }
  initializeRows() {
    this.table.rowManager.getRows().forEach((row2) => {
      this.initializeRow(row2);
    });
  }
  initializeRow(row2) {
    var frozenRows = this.table.options.frozenRows, rowType = typeof frozenRows;
    if (rowType === "number") {
      if (row2.getPosition() && row2.getPosition() + this.rows.length <= frozenRows) {
        this.freezeRow(row2);
      }
    } else if (rowType === "function") {
      if (frozenRows.call(this.table, row2.getComponent())) {
        this.freezeRow(row2);
      }
    } else if (Array.isArray(frozenRows)) {
      if (frozenRows.includes(row2.data[this.options("frozenRowsField")])) {
        this.freezeRow(row2);
      }
    }
  }
  isRowFrozen(row2) {
    var index2 = this.rows.indexOf(row2);
    return index2 > -1;
  }
  isFrozen() {
    return !!this.rows.length;
  }
  visibleRows(viewable, rows3) {
    this.rows.forEach((row2) => {
      rows3.push(row2);
    });
    return rows3;
  }
  getRows(rows3) {
    var output = rows3.slice(0);
    this.rows.forEach(function(row2) {
      var index2 = output.indexOf(row2);
      if (index2 > -1) {
        output.splice(index2, 1);
      }
    });
    return output;
  }
  freezeRow(row2) {
    if (!row2.modules.frozen) {
      row2.modules.frozen = true;
      this.topElement.appendChild(row2.getElement());
      row2.initialize();
      row2.normalizeHeight();
      this.rows.push(row2);
      this.refreshData(false, "display");
      this.table.rowManager.adjustTableSize();
      this.styleRows();
    } else {
      console.warn("Freeze Error - Row is already frozen");
    }
  }
  unfreezeRow(row2) {
    if (row2.modules.frozen) {
      row2.modules.frozen = false;
      this.detachRow(row2);
      this.table.rowManager.adjustTableSize();
      this.refreshData(false, "display");
      if (this.rows.length) {
        this.styleRows();
      }
    } else {
      console.warn("Freeze Error - Row is already unfrozen");
    }
  }
  detachRow(row2) {
    var index2 = this.rows.indexOf(row2);
    if (index2 > -1) {
      var rowEl = row2.getElement();
      if (rowEl.parentNode) {
        rowEl.parentNode.removeChild(rowEl);
      }
      this.rows.splice(index2, 1);
    }
  }
  styleRows(row2) {
    this.rows.forEach((row3, i2) => {
      this.table.rowManager.styleRow(row3, i2);
    });
  }
};
FrozenRows.moduleName = "frozenRows";
var GroupComponent = class {
  constructor(group) {
    this._group = group;
    this.type = "GroupComponent";
    return new Proxy(this, {
      get: function(target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._group.groupManager.table.componentFunctionBinder.handle("row", target._group, name);
        }
      }
    });
  }
  getKey() {
    return this._group.key;
  }
  getField() {
    return this._group.field;
  }
  getElement() {
    return this._group.element;
  }
  getRows() {
    return this._group.getRows(true);
  }
  getSubGroups() {
    return this._group.getSubGroups(true);
  }
  getParentGroup() {
    return this._group.parent ? this._group.parent.getComponent() : false;
  }
  isVisible() {
    return this._group.visible;
  }
  show() {
    this._group.show();
  }
  hide() {
    this._group.hide();
  }
  toggle() {
    this._group.toggleVisibility();
  }
  _getSelf() {
    return this._group;
  }
  getTable() {
    return this._group.groupManager.table;
  }
};
var Group = class {
  constructor(groupManager, parent, level, key, field, generator, oldGroup) {
    this.groupManager = groupManager;
    this.parent = parent;
    this.key = key;
    this.level = level;
    this.field = field;
    this.hasSubGroups = level < groupManager.groupIDLookups.length - 1;
    this.addRow = this.hasSubGroups ? this._addRowToGroup : this._addRow;
    this.type = "group";
    this.old = oldGroup;
    this.rows = [];
    this.groups = [];
    this.groupList = [];
    this.generator = generator;
    this.element = false;
    this.elementContents = false;
    this.height = 0;
    this.outerHeight = 0;
    this.initialized = false;
    this.calcs = {};
    this.initialized = false;
    this.modules = {};
    this.arrowElement = false;
    this.visible = oldGroup ? oldGroup.visible : typeof groupManager.startOpen[level] !== "undefined" ? groupManager.startOpen[level] : groupManager.startOpen[0];
    this.component = null;
    this.createElements();
    this.addBindings();
    this.createValueGroups();
  }
  wipe(elementsOnly) {
    if (!elementsOnly) {
      if (this.groupList.length) {
        this.groupList.forEach(function(group) {
          group.wipe();
        });
      } else {
        this.rows.forEach((row2) => {
          if (row2.modules) {
            delete row2.modules.group;
          }
        });
      }
    }
    this.element = false;
    this.arrowElement = false;
    this.elementContents = false;
  }
  createElements() {
    var arrow = document.createElement("div");
    arrow.classList.add("tabulator-arrow");
    this.element = document.createElement("div");
    this.element.classList.add("tabulator-row");
    this.element.classList.add("tabulator-group");
    this.element.classList.add("tabulator-group-level-" + this.level);
    this.element.setAttribute("role", "rowgroup");
    this.arrowElement = document.createElement("div");
    this.arrowElement.classList.add("tabulator-group-toggle");
    this.arrowElement.appendChild(arrow);
    if (this.groupManager.table.options.movableRows !== false && this.groupManager.table.modExists("moveRow")) {
      this.groupManager.table.modules.moveRow.initializeGroupHeader(this);
    }
  }
  createValueGroups() {
    var level = this.level + 1;
    if (this.groupManager.allowedValues && this.groupManager.allowedValues[level]) {
      this.groupManager.allowedValues[level].forEach((value) => {
        this._createGroup(value, level);
      });
    }
  }
  addBindings() {
    var toggleElement;
    if (this.groupManager.table.options.groupToggleElement) {
      toggleElement = this.groupManager.table.options.groupToggleElement == "arrow" ? this.arrowElement : this.element;
      toggleElement.addEventListener("click", (e) => {
        e.stopPropagation();
        e.stopImmediatePropagation();
        this.toggleVisibility();
      });
    }
  }
  _createGroup(groupID, level) {
    var groupKey = level + "_" + groupID;
    var group = new Group(this.groupManager, this, level, groupID, this.groupManager.groupIDLookups[level].field, this.groupManager.headerGenerator[level] || this.groupManager.headerGenerator[0], this.old ? this.old.groups[groupKey] : false);
    this.groups[groupKey] = group;
    this.groupList.push(group);
  }
  _addRowToGroup(row2) {
    var level = this.level + 1;
    if (this.hasSubGroups) {
      var groupID = this.groupManager.groupIDLookups[level].func(row2.getData()), groupKey = level + "_" + groupID;
      if (this.groupManager.allowedValues && this.groupManager.allowedValues[level]) {
        if (this.groups[groupKey]) {
          this.groups[groupKey].addRow(row2);
        }
      } else {
        if (!this.groups[groupKey]) {
          this._createGroup(groupID, level);
        }
        this.groups[groupKey].addRow(row2);
      }
    }
  }
  _addRow(row2) {
    this.rows.push(row2);
    row2.modules.group = this;
  }
  insertRow(row2, to2, after) {
    var data = this.conformRowData({});
    row2.updateData(data);
    var toIndex = this.rows.indexOf(to2);
    if (toIndex > -1) {
      if (after) {
        this.rows.splice(toIndex + 1, 0, row2);
      } else {
        this.rows.splice(toIndex, 0, row2);
      }
    } else {
      if (after) {
        this.rows.push(row2);
      } else {
        this.rows.unshift(row2);
      }
    }
    row2.modules.group = this;
    this.generateGroupHeaderContents();
    if (this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table") {
      this.groupManager.table.modules.columnCalcs.recalcGroup(this);
    }
    this.groupManager.updateGroupRows(true);
  }
  scrollHeader(left) {
    if (this.arrowElement) {
      this.arrowElement.style.marginLeft = left;
      this.groupList.forEach(function(child) {
        child.scrollHeader(left);
      });
    }
  }
  getRowIndex(row2) {
  }
  conformRowData(data) {
    if (this.field) {
      data[this.field] = this.key;
    } else {
      console.warn("Data Conforming Error - Cannot conform row data to match new group as groupBy is a function");
    }
    if (this.parent) {
      data = this.parent.conformRowData(data);
    }
    return data;
  }
  removeRow(row2) {
    var index2 = this.rows.indexOf(row2);
    var el = row2.getElement();
    if (index2 > -1) {
      this.rows.splice(index2, 1);
    }
    if (!this.groupManager.table.options.groupValues && !this.rows.length) {
      if (this.parent) {
        this.parent.removeGroup(this);
      } else {
        this.groupManager.removeGroup(this);
      }
      this.groupManager.updateGroupRows(true);
    } else {
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
      if (!this.groupManager.blockRedraw) {
        this.generateGroupHeaderContents();
        if (this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table") {
          this.groupManager.table.modules.columnCalcs.recalcGroup(this);
        }
      }
    }
  }
  removeGroup(group) {
    var groupKey = group.level + "_" + group.key, index2;
    if (this.groups[groupKey]) {
      delete this.groups[groupKey];
      index2 = this.groupList.indexOf(group);
      if (index2 > -1) {
        this.groupList.splice(index2, 1);
      }
      if (!this.groupList.length) {
        if (this.parent) {
          this.parent.removeGroup(this);
        } else {
          this.groupManager.removeGroup(this);
        }
      }
    }
  }
  getHeadersAndRows() {
    var output = [];
    output.push(this);
    this._visSet();
    if (this.calcs.top) {
      this.calcs.top.detachElement();
      this.calcs.top.deleteCells();
    }
    if (this.calcs.bottom) {
      this.calcs.bottom.detachElement();
      this.calcs.bottom.deleteCells();
    }
    if (this.visible) {
      if (this.groupList.length) {
        this.groupList.forEach(function(group) {
          output = output.concat(group.getHeadersAndRows());
        });
      } else {
        if (this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasTopCalcs()) {
          this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows);
          output.push(this.calcs.top);
        }
        output = output.concat(this.rows);
        if (this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasBottomCalcs()) {
          this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows);
          output.push(this.calcs.bottom);
        }
      }
    } else {
      if (!this.groupList.length && this.groupManager.table.options.columnCalcs != "table") {
        if (this.groupManager.table.modExists("columnCalcs")) {
          if (this.groupManager.table.modules.columnCalcs.hasTopCalcs()) {
            if (this.groupManager.table.options.groupClosedShowCalcs) {
              this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows);
              output.push(this.calcs.top);
            }
          }
          if (this.groupManager.table.modules.columnCalcs.hasBottomCalcs()) {
            if (this.groupManager.table.options.groupClosedShowCalcs) {
              this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows);
              output.push(this.calcs.bottom);
            }
          }
        }
      }
    }
    return output;
  }
  getData(visible, transform) {
    var output = [];
    this._visSet();
    if (!visible || visible && this.visible) {
      this.rows.forEach((row2) => {
        output.push(row2.getData(transform || "data"));
      });
    }
    return output;
  }
  getRowCount() {
    var count = 0;
    if (this.groupList.length) {
      this.groupList.forEach((group) => {
        count += group.getRowCount();
      });
    } else {
      count = this.rows.length;
    }
    return count;
  }
  toggleVisibility() {
    if (this.visible) {
      this.hide();
    } else {
      this.show();
    }
  }
  hide() {
    this.visible = false;
    if (this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination) {
      this.element.classList.remove("tabulator-group-visible");
      if (this.groupList.length) {
        this.groupList.forEach((group) => {
          var rows3 = group.getHeadersAndRows();
          rows3.forEach((row2) => {
            row2.detachElement();
          });
        });
      } else {
        this.rows.forEach((row2) => {
          var rowEl = row2.getElement();
          rowEl.parentNode.removeChild(rowEl);
        });
      }
      this.groupManager.updateGroupRows(true);
    } else {
      this.groupManager.updateGroupRows(true);
    }
    this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), false);
  }
  show() {
    this.visible = true;
    if (this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination) {
      this.element.classList.add("tabulator-group-visible");
      var prev = this.generateElement();
      if (this.groupList.length) {
        this.groupList.forEach((group) => {
          var rows3 = group.getHeadersAndRows();
          rows3.forEach((row2) => {
            var rowEl = row2.getElement();
            prev.parentNode.insertBefore(rowEl, prev.nextSibling);
            row2.initialize();
            prev = rowEl;
          });
        });
      } else {
        this.rows.forEach((row2) => {
          var rowEl = row2.getElement();
          prev.parentNode.insertBefore(rowEl, prev.nextSibling);
          row2.initialize();
          prev = rowEl;
        });
      }
      this.groupManager.updateGroupRows(true);
    } else {
      this.groupManager.updateGroupRows(true);
    }
    this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), true);
  }
  _visSet() {
    var data = [];
    if (typeof this.visible == "function") {
      this.rows.forEach(function(row2) {
        data.push(row2.getData());
      });
      this.visible = this.visible(this.key, this.getRowCount(), data, this.getComponent());
    }
  }
  getRowGroup(row2) {
    var match2 = false;
    if (this.groupList.length) {
      this.groupList.forEach(function(group) {
        var result = group.getRowGroup(row2);
        if (result) {
          match2 = result;
        }
      });
    } else {
      if (this.rows.find(function(item) {
        return item === row2;
      })) {
        match2 = this;
      }
    }
    return match2;
  }
  getSubGroups(component) {
    var output = [];
    this.groupList.forEach(function(child) {
      output.push(component ? child.getComponent() : child);
    });
    return output;
  }
  getRows(component) {
    var output = [];
    this.rows.forEach(function(row2) {
      output.push(component ? row2.getComponent() : row2);
    });
    return output;
  }
  generateGroupHeaderContents() {
    var data = [];
    this.rows.forEach(function(row2) {
      data.push(row2.getData());
    });
    this.elementContents = this.generator(this.key, this.getRowCount(), data, this.getComponent());
    while (this.element.firstChild)
      this.element.removeChild(this.element.firstChild);
    if (typeof this.elementContents === "string") {
      this.element.innerHTML = this.elementContents;
    } else {
      this.element.appendChild(this.elementContents);
    }
    this.element.insertBefore(this.arrowElement, this.element.firstChild);
  }
  getPath(path = []) {
    path.unshift(this.key);
    if (this.parent) {
      this.parent.getPath(path);
    }
    return path;
  }
  getElement() {
    return this.elementContents ? this.element : this.generateElement();
  }
  generateElement() {
    this.addBindings = false;
    this._visSet();
    if (this.visible) {
      this.element.classList.add("tabulator-group-visible");
    } else {
      this.element.classList.remove("tabulator-group-visible");
    }
    for (var i2 = 0; i2 < this.element.childNodes.length; ++i2) {
      this.element.childNodes[i2].parentNode.removeChild(this.element.childNodes[i2]);
    }
    this.generateGroupHeaderContents();
    return this.element;
  }
  detachElement() {
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }
  normalizeHeight() {
    this.setHeight(this.element.clientHeight);
  }
  initialize(force) {
    if (!this.initialized || force) {
      this.normalizeHeight();
      this.initialized = true;
    }
  }
  reinitialize() {
    this.initialized = false;
    this.height = 0;
    if (Helpers.elVisible(this.element)) {
      this.initialize(true);
    }
  }
  setHeight(height) {
    if (this.height != height) {
      this.height = height;
      this.outerHeight = this.element.offsetHeight;
    }
  }
  getHeight() {
    return this.outerHeight;
  }
  getGroup() {
    return this;
  }
  reinitializeHeight() {
  }
  calcHeight() {
  }
  setCellHeight() {
  }
  clearCellHeight() {
  }
  deinitializeHeight() {
  }
  getComponent() {
    if (!this.component) {
      this.component = new GroupComponent(this);
    }
    return this.component;
  }
};
var GroupRows = class extends Module {
  constructor(table) {
    super(table);
    this.groupIDLookups = false;
    this.startOpen = [function() {
      return false;
    }];
    this.headerGenerator = [function() {
      return "";
    }];
    this.groupList = [];
    this.allowedValues = false;
    this.groups = {};
    this.displayHandler = this.getRows.bind(this);
    this.blockRedraw = false;
    this.registerTableOption("groupBy", false);
    this.registerTableOption("groupStartOpen", true);
    this.registerTableOption("groupValues", false);
    this.registerTableOption("groupUpdateOnCellEdit", false);
    this.registerTableOption("groupHeader", false);
    this.registerTableOption("groupHeaderPrint", null);
    this.registerTableOption("groupHeaderClipboard", null);
    this.registerTableOption("groupHeaderHtmlOutput", null);
    this.registerTableOption("groupHeaderDownload", null);
    this.registerTableOption("groupToggleElement", "arrow");
    this.registerTableOption("groupClosedShowCalcs", false);
    this.registerTableFunction("setGroupBy", this.setGroupBy.bind(this));
    this.registerTableFunction("setGroupValues", this.setGroupValues.bind(this));
    this.registerTableFunction("setGroupStartOpen", this.setGroupStartOpen.bind(this));
    this.registerTableFunction("setGroupHeader", this.setGroupHeader.bind(this));
    this.registerTableFunction("getGroups", this.userGetGroups.bind(this));
    this.registerTableFunction("getGroupedData", this.userGetGroupedData.bind(this));
    this.registerComponentFunction("row", "getGroup", this.rowGetGroup.bind(this));
  }
  initialize() {
    this.subscribe("table-destroy", this._blockRedrawing.bind(this));
    this.subscribe("rows-wipe", this._blockRedrawing.bind(this));
    this.subscribe("rows-wiped", this._restore_redrawing.bind(this));
    if (this.table.options.groupBy) {
      if (this.table.options.groupUpdateOnCellEdit) {
        this.subscribe("cell-value-updated", this.cellUpdated.bind(this));
        this.subscribe("row-data-changed", this.reassignRowToGroup.bind(this), 0);
      }
      this.subscribe("table-built", this.configureGroupSetup.bind(this));
      this.subscribe("row-deleting", this.rowDeleting.bind(this));
      this.subscribe("row-deleted", this.rowsUpdated.bind(this));
      this.subscribe("scroll-horizontal", this.scrollHeaders.bind(this));
      this.subscribe("rows-wipe", this.wipe.bind(this));
      this.subscribe("rows-added", this.rowsUpdated.bind(this));
      this.subscribe("row-moving", this.rowMoving.bind(this));
      this.subscribe("row-adding-index", this.rowAddingIndex.bind(this));
      this.subscribe("rows-sample", this.rowSample.bind(this));
      this.subscribe("render-virtual-fill", this.virtualRenderFill.bind(this));
      this.registerDisplayHandler(this.displayHandler, 20);
      this.initialized = true;
    }
  }
  _blockRedrawing() {
    this.blockRedraw = true;
  }
  _restore_redrawing() {
    this.blockRedraw = false;
  }
  configureGroupSetup() {
    if (this.table.options.groupBy) {
      var groupBy = this.table.options.groupBy, startOpen = this.table.options.groupStartOpen, groupHeader = this.table.options.groupHeader;
      this.allowedValues = this.table.options.groupValues;
      if (Array.isArray(groupBy) && Array.isArray(groupHeader) && groupBy.length > groupHeader.length) {
        console.warn("Error creating group headers, groupHeader array is shorter than groupBy array");
      }
      this.headerGenerator = [function() {
        return "";
      }];
      this.startOpen = [function() {
        return false;
      }];
      this.langBind("groups|item", (langValue, lang) => {
        this.headerGenerator[0] = (value, count, data) => {
          return (typeof value === "undefined" ? "" : value) + "<span>(" + count + " " + (count === 1 ? langValue : lang.groups.items) + ")</span>";
        };
      });
      this.groupIDLookups = [];
      if (groupBy) {
        if (this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "table" && this.table.options.columnCalcs != "both") {
          this.table.modules.columnCalcs.removeCalcs();
        }
      } else {
        if (this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "group") {
          var cols = this.table.columnManager.getRealColumns();
          cols.forEach((col) => {
            if (col.definition.topCalc) {
              this.table.modules.columnCalcs.initializeTopRow();
            }
            if (col.definition.bottomCalc) {
              this.table.modules.columnCalcs.initializeBottomRow();
            }
          });
        }
      }
      if (!Array.isArray(groupBy)) {
        groupBy = [groupBy];
      }
      groupBy.forEach((group, i2) => {
        var lookupFunc, column;
        if (typeof group == "function") {
          lookupFunc = group;
        } else {
          column = this.table.columnManager.getColumnByField(group);
          if (column) {
            lookupFunc = function(data) {
              return column.getFieldValue(data);
            };
          } else {
            lookupFunc = function(data) {
              return data[group];
            };
          }
        }
        this.groupIDLookups.push({
          field: typeof group === "function" ? false : group,
          func: lookupFunc,
          values: this.allowedValues ? this.allowedValues[i2] : false
        });
      });
      if (startOpen) {
        if (!Array.isArray(startOpen)) {
          startOpen = [startOpen];
        }
        startOpen.forEach((level) => {
        });
        this.startOpen = startOpen;
      }
      if (groupHeader) {
        this.headerGenerator = Array.isArray(groupHeader) ? groupHeader : [groupHeader];
      }
    } else {
      this.groupList = [];
      this.groups = {};
    }
  }
  rowSample(rows3, prevValue) {
    if (this.table.options.groupBy) {
      var group = this.getGroups(false)[0];
      prevValue.push(group.getRows(false)[0]);
    }
    return prevValue;
  }
  virtualRenderFill() {
    var el = this.table.rowManager.tableElement;
    var rows3 = this.table.rowManager.getVisibleRows();
    if (this.table.options.groupBy) {
      rows3 = rows3.filter((row2) => {
        return row2.type !== "group";
      });
      el.style.minWidth = !rows3.length ? this.table.columnManager.getWidth() + "px" : "";
    } else {
      return rows3;
    }
  }
  rowAddingIndex(row2, index2, top) {
    if (this.table.options.groupBy) {
      this.assignRowToGroup(row2);
      var groupRows = row2.modules.group.rows;
      if (groupRows.length > 1) {
        if (!index2 || index2 && groupRows.indexOf(index2) == -1) {
          if (top) {
            if (groupRows[0] !== row2) {
              index2 = groupRows[0];
              this.table.rowManager.moveRowInArray(row2.modules.group.rows, row2, index2, !top);
            }
          } else {
            if (groupRows[groupRows.length - 1] !== row2) {
              index2 = groupRows[groupRows.length - 1];
              this.table.rowManager.moveRowInArray(row2.modules.group.rows, row2, index2, !top);
            }
          }
        } else {
          this.table.rowManager.moveRowInArray(row2.modules.group.rows, row2, index2, !top);
        }
      }
      return index2;
    }
  }
  trackChanges() {
    this.dispatch("group-changed");
  }
  setGroupBy(groups) {
    this.table.options.groupBy = groups;
    if (!this.initialized) {
      this.initialize();
    }
    this.configureGroupSetup();
    if (!groups && this.table.modExists("columnCalcs") && this.table.options.columnCalcs === true) {
      this.table.modules.columnCalcs.reinitializeCalcs();
    }
    this.refreshData();
    this.trackChanges();
  }
  setGroupValues(groupValues) {
    this.table.options.groupValues = groupValues;
    this.configureGroupSetup();
    this.refreshData();
    this.trackChanges();
  }
  setGroupStartOpen(values2) {
    this.table.options.groupStartOpen = values2;
    this.configureGroupSetup();
    if (this.table.options.groupBy) {
      this.refreshData();
      this.trackChanges();
    } else {
      console.warn("Grouping Update - cant refresh view, no groups have been set");
    }
  }
  setGroupHeader(values2) {
    this.table.options.groupHeader = values2;
    this.configureGroupSetup();
    if (this.table.options.groupBy) {
      this.refreshData();
      this.trackChanges();
    } else {
      console.warn("Grouping Update - cant refresh view, no groups have been set");
    }
  }
  userGetGroups(values2) {
    return this.getGroups(true);
  }
  userGetGroupedData() {
    return this.table.options.groupBy ? this.getGroupedData() : this.getData();
  }
  rowGetGroup(row2) {
    return row2.modules.group ? row2.modules.group.getComponent() : false;
  }
  rowMoving(from2, to2, after) {
    if (this.table.options.groupBy) {
      if (!after && to2 instanceof Group) {
        to2 = this.table.rowManager.prevDisplayRow(from2) || to2;
      }
      var toGroup = to2 instanceof Group ? to2 : to2.modules.group;
      var fromGroup = from2 instanceof Group ? from2 : from2.modules.group;
      if (toGroup === fromGroup) {
        this.table.rowManager.moveRowInArray(toGroup.rows, from2, to2, after);
      } else {
        if (fromGroup) {
          fromGroup.removeRow(from2);
        }
        toGroup.insertRow(from2, to2, after);
      }
    }
  }
  rowDeleting(row2) {
    if (this.table.options.groupBy && row2.modules.group) {
      row2.modules.group.removeRow(row2);
    }
  }
  rowsUpdated(row2) {
    if (this.table.options.groupBy) {
      this.updateGroupRows(true);
    }
  }
  cellUpdated(cell) {
    if (this.table.options.groupBy) {
      this.reassignRowToGroup(cell.row);
    }
  }
  getRows(rows3) {
    if (this.table.options.groupBy && this.groupIDLookups.length) {
      this.dispatchExternal("dataGrouping");
      this.generateGroups(rows3);
      if (this.subscribedExternal("dataGrouped")) {
        this.dispatchExternal("dataGrouped", this.getGroups(true));
      }
      return this.updateGroupRows();
    } else {
      return rows3.slice(0);
    }
  }
  getGroups(component) {
    var groupComponents = [];
    this.groupList.forEach(function(group) {
      groupComponents.push(component ? group.getComponent() : group);
    });
    return groupComponents;
  }
  getChildGroups(group) {
    var groupComponents = [];
    if (!group) {
      group = this;
    }
    group.groupList.forEach((child) => {
      if (child.groupList.length) {
        groupComponents = groupComponents.concat(this.getChildGroups(child));
      } else {
        groupComponents.push(child);
      }
    });
    return groupComponents;
  }
  wipe() {
    if (this.table.options.groupBy) {
      this.groupList.forEach(function(group) {
        group.wipe();
      });
      this.groupList = [];
      this.groups = {};
    }
  }
  pullGroupListData(groupList) {
    var groupListData = [];
    groupList.forEach((group) => {
      var groupHeader = {};
      groupHeader.level = 0;
      groupHeader.rowCount = 0;
      groupHeader.headerContent = "";
      var childData = [];
      if (group.hasSubGroups) {
        childData = this.pullGroupListData(group.groupList);
        groupHeader.level = group.level;
        groupHeader.rowCount = childData.length - group.groupList.length;
        groupHeader.headerContent = group.generator(group.key, groupHeader.rowCount, group.rows, group);
        groupListData.push(groupHeader);
        groupListData = groupListData.concat(childData);
      } else {
        groupHeader.level = group.level;
        groupHeader.headerContent = group.generator(group.key, group.rows.length, group.rows, group);
        groupHeader.rowCount = group.getRows().length;
        groupListData.push(groupHeader);
        group.getRows().forEach((row2) => {
          groupListData.push(row2.getData("data"));
        });
      }
    });
    return groupListData;
  }
  getGroupedData() {
    return this.pullGroupListData(this.groupList);
  }
  getRowGroup(row2) {
    var match2 = false;
    if (this.options("dataTree")) {
      row2 = this.table.modules.dataTree.getTreeParentRoot(row2);
    }
    this.groupList.forEach((group) => {
      var result = group.getRowGroup(row2);
      if (result) {
        match2 = result;
      }
    });
    return match2;
  }
  countGroups() {
    return this.groupList.length;
  }
  generateGroups(rows3) {
    var oldGroups = this.groups;
    this.groups = {};
    this.groupList = [];
    if (this.allowedValues && this.allowedValues[0]) {
      this.allowedValues[0].forEach((value) => {
        this.createGroup(value, 0, oldGroups);
      });
      rows3.forEach((row2) => {
        this.assignRowToExistingGroup(row2, oldGroups);
      });
    } else {
      rows3.forEach((row2) => {
        this.assignRowToGroup(row2, oldGroups);
      });
    }
    Object.values(oldGroups).forEach((group) => {
      group.wipe(true);
    });
  }
  createGroup(groupID, level, oldGroups) {
    var groupKey = level + "_" + groupID, group;
    oldGroups = oldGroups || [];
    group = new Group(this, false, level, groupID, this.groupIDLookups[0].field, this.headerGenerator[0], oldGroups[groupKey]);
    this.groups[groupKey] = group;
    this.groupList.push(group);
  }
  assignRowToExistingGroup(row2, oldGroups) {
    var groupID = this.groupIDLookups[0].func(row2.getData()), groupKey = "0_" + groupID;
    if (this.groups[groupKey]) {
      this.groups[groupKey].addRow(row2);
    }
  }
  assignRowToGroup(row2, oldGroups) {
    var groupID = this.groupIDLookups[0].func(row2.getData()), newGroupNeeded = !this.groups["0_" + groupID];
    if (newGroupNeeded) {
      this.createGroup(groupID, 0, oldGroups);
    }
    this.groups["0_" + groupID].addRow(row2);
    return !newGroupNeeded;
  }
  reassignRowToGroup(row2) {
    if (row2.type === "row") {
      var oldRowGroup = row2.modules.group, oldGroupPath = oldRowGroup.getPath(), newGroupPath = this.getExpectedPath(row2), samePath;
      samePath = oldGroupPath.length == newGroupPath.length && oldGroupPath.every((element, index2) => {
        return element === newGroupPath[index2];
      });
      if (!samePath) {
        oldRowGroup.removeRow(row2);
        this.assignRowToGroup(row2, this.groups);
        this.refreshData(true);
      }
    }
  }
  getExpectedPath(row2) {
    var groupPath = [], rowData = row2.getData();
    this.groupIDLookups.forEach((groupId) => {
      groupPath.push(groupId.func(rowData));
    });
    return groupPath;
  }
  updateGroupRows(force) {
    var output = [];
    if (!this.blockRedraw) {
      this.groupList.forEach((group) => {
        output = output.concat(group.getHeadersAndRows());
      });
      if (force) {
        this.refreshData(true);
      }
    }
    return output;
  }
  scrollHeaders(left) {
    if (this.table.options.groupBy) {
      if (this.table.options.renderHorizontal === "virtual") {
        left -= this.table.columnManager.renderer.vDomPadLeft;
      }
      left = left + "px";
      this.groupList.forEach((group) => {
        group.scrollHeader(left);
      });
    }
  }
  removeGroup(group) {
    var groupKey = group.level + "_" + group.key, index2;
    if (this.groups[groupKey]) {
      delete this.groups[groupKey];
      index2 = this.groupList.indexOf(group);
      if (index2 > -1) {
        this.groupList.splice(index2, 1);
      }
    }
  }
  checkBasicModeGroupHeaderWidth() {
    var element = this.table.rowManager.tableElement, onlyGroupHeaders = true;
    this.table.rowManager.getDisplayRows().forEach((row2, index2) => {
      this.table.rowManager.styleRow(row2, index2);
      element.appendChild(row2.getElement());
      row2.initialize(true);
      if (row2.type !== "group") {
        onlyGroupHeaders = false;
      }
    });
    if (onlyGroupHeaders) {
      element.style.minWidth = this.table.columnManager.getWidth() + "px";
    } else {
      element.style.minWidth = "";
    }
  }
};
GroupRows.moduleName = "groupRows";
var defaultUndoers = {
  cellEdit: function(action) {
    action.component.setValueProcessData(action.data.oldValue);
    action.component.cellRendered();
  },
  rowAdd: function(action) {
    action.component.deleteActual();
  },
  rowDelete: function(action) {
    var newRow = this.table.rowManager.addRowActual(action.data.data, action.data.pos, action.data.index);
    if (this.table.options.groupBy && this.table.modExists("groupRows")) {
      this.table.modules.groupRows.updateGroupRows(true);
    }
    this._rebindRow(action.component, newRow);
  },
  rowMove: function(action) {
    this.table.rowManager.moveRowActual(action.component, this.table.rowManager.rows[action.data.posFrom], !action.data.after);
    this.table.rowManager.redraw();
  }
};
var defaultRedoers = {
  cellEdit: function(action) {
    action.component.setValueProcessData(action.data.newValue);
    action.component.cellRendered();
  },
  rowAdd: function(action) {
    var newRow = this.table.rowManager.addRowActual(action.data.data, action.data.pos, action.data.index);
    if (this.table.options.groupBy && this.table.modExists("groupRows")) {
      this.table.modules.groupRows.updateGroupRows(true);
    }
    this._rebindRow(action.component, newRow);
  },
  rowDelete: function(action) {
    action.component.deleteActual();
  },
  rowMove: function(action) {
    this.table.rowManager.moveRowActual(action.component, this.table.rowManager.rows[action.data.posTo], action.data.after);
    this.table.rowManager.redraw();
  }
};
var History = class extends Module {
  constructor(table) {
    super(table);
    this.history = [];
    this.index = -1;
    this.registerTableOption("history", false);
  }
  initialize() {
    if (this.table.options.history) {
      this.subscribe("cell-value-updated", this.cellUpdated.bind(this));
      this.subscribe("cell-delete", this.clearComponentHistory.bind(this));
      this.subscribe("row-delete", this.rowDeleted.bind(this));
      this.subscribe("rows-wipe", this.clear.bind(this));
      this.subscribe("row-added", this.rowAdded.bind(this));
      this.subscribe("row-move", this.rowMoved.bind(this));
    }
    this.registerTableFunction("undo", this.undo.bind(this));
    this.registerTableFunction("redo", this.redo.bind(this));
    this.registerTableFunction("getHistoryUndoSize", this.getHistoryUndoSize.bind(this));
    this.registerTableFunction("getHistoryRedoSize", this.getHistoryRedoSize.bind(this));
    this.registerTableFunction("clearHistory", this.clear.bind(this));
  }
  rowMoved(from2, to2, after) {
    this.action("rowMove", from2, { posFrom: from2.getPosition(), posTo: to2.getPosition(), to: to2, after });
  }
  rowAdded(row2, data, pos, index2) {
    this.action("rowAdd", row2, { data, pos, index: index2 });
  }
  rowDeleted(row2) {
    var index2, rows3;
    if (this.table.options.groupBy) {
      rows3 = row2.getComponent().getGroup()._getSelf().rows;
      index2 = rows3.indexOf(row2);
      if (index2) {
        index2 = rows3[index2 - 1];
      }
    } else {
      index2 = row2.table.rowManager.getRowIndex(row2);
      if (index2) {
        index2 = row2.table.rowManager.rows[index2 - 1];
      }
    }
    this.action("rowDelete", row2, { data: row2.getData(), pos: !index2, index: index2 });
  }
  cellUpdated(cell) {
    this.action("cellEdit", cell, { oldValue: cell.oldValue, newValue: cell.value });
  }
  clear() {
    this.history = [];
    this.index = -1;
  }
  action(type, component, data) {
    this.history = this.history.slice(0, this.index + 1);
    this.history.push({
      type,
      component,
      data
    });
    this.index++;
  }
  getHistoryUndoSize() {
    return this.index + 1;
  }
  getHistoryRedoSize() {
    return this.history.length - (this.index + 1);
  }
  clearComponentHistory(component) {
    var index2 = this.history.findIndex(function(item) {
      return item.component === component;
    });
    if (index2 > -1) {
      this.history.splice(index2, 1);
      if (index2 <= this.index) {
        this.index--;
      }
      this.clearComponentHistory(component);
    }
  }
  undo() {
    if (this.index > -1) {
      let action = this.history[this.index];
      History.undoers[action.type].call(this, action);
      this.index--;
      this.dispatchExternal("historyUndo", action.type, action.component.getComponent(), action.data);
      return true;
    } else {
      console.warn("History Undo Error - No more history to undo");
      return false;
    }
  }
  redo() {
    if (this.history.length - 1 > this.index) {
      this.index++;
      let action = this.history[this.index];
      History.redoers[action.type].call(this, action);
      this.dispatchExternal("historyRedo", action.type, action.component.getComponent(), action.data);
      return true;
    } else {
      console.warn("History Redo Error - No more history to redo");
      return false;
    }
  }
  _rebindRow(oldRow, newRow) {
    this.history.forEach(function(action) {
      if (action.component instanceof Row) {
        if (action.component === oldRow) {
          action.component = newRow;
        }
      } else if (action.component instanceof Cell) {
        if (action.component.row === oldRow) {
          var field = action.component.column.getField();
          if (field) {
            action.component = newRow.getCell(field);
          }
        }
      }
    });
  }
};
History.moduleName = "history";
History.undoers = defaultUndoers;
History.redoers = defaultRedoers;
var HtmlTableImport = class extends Module {
  constructor(table) {
    super(table);
    this.fieldIndex = [];
    this.hasIndex = false;
  }
  initialize() {
    this.tableElementCheck();
  }
  tableElementCheck() {
    if (this.table.originalElement && this.table.originalElement.tagName === "TABLE") {
      if (this.table.originalElement.childNodes.length) {
        this.parseTable();
      } else {
        console.warn("Unable to parse data from empty table tag, Tabulator should be initialized on a div tag unless importing data from a table element.");
      }
    }
  }
  parseTable() {
    var element = this.table.originalElement, options = this.table.options, headers = element.getElementsByTagName("th"), rows3 = element.getElementsByTagName("tbody")[0], data = [];
    this.hasIndex = false;
    this.dispatchExternal("htmlImporting");
    rows3 = rows3 ? rows3.getElementsByTagName("tr") : [];
    this._extractOptions(element, options);
    if (headers.length) {
      this._extractHeaders(headers, rows3);
    } else {
      this._generateBlankHeaders(headers, rows3);
    }
    for (var index2 = 0; index2 < rows3.length; index2++) {
      var row2 = rows3[index2], cells = row2.getElementsByTagName("td"), item = {};
      if (!this.hasIndex) {
        item[options.index] = index2;
      }
      for (var i2 = 0; i2 < cells.length; i2++) {
        var cell = cells[i2];
        if (typeof this.fieldIndex[i2] !== "undefined") {
          item[this.fieldIndex[i2]] = cell.innerHTML;
        }
      }
      data.push(item);
    }
    options.data = data;
    this.dispatchExternal("htmlImported");
  }
  _extractOptions(element, options, defaultOptions2) {
    var attributes = element.attributes;
    var optionsArr = defaultOptions2 ? Object.keys(defaultOptions2) : Object.keys(options);
    var optionsList = {};
    optionsArr.forEach((item) => {
      optionsList[item.toLowerCase()] = item;
    });
    for (var index2 in attributes) {
      var attrib = attributes[index2];
      var name;
      if (attrib && typeof attrib == "object" && attrib.name && attrib.name.indexOf("tabulator-") === 0) {
        name = attrib.name.replace("tabulator-", "");
        if (typeof optionsList[name] !== "undefined") {
          options[optionsList[name]] = this._attribValue(attrib.value);
        }
      }
    }
  }
  _attribValue(value) {
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return value;
  }
  _findCol(title) {
    var match2 = this.table.options.columns.find((column) => {
      return column.title === title;
    });
    return match2 || false;
  }
  _extractHeaders(headers, rows3) {
    for (var index2 = 0; index2 < headers.length; index2++) {
      var header = headers[index2], exists2 = false, col = this._findCol(header.textContent), width;
      if (col) {
        exists2 = true;
      } else {
        col = { title: header.textContent.trim() };
      }
      if (!col.field) {
        col.field = header.textContent.trim().toLowerCase().replace(" ", "_");
      }
      width = header.getAttribute("width");
      if (width && !col.width) {
        col.width = width;
      }
      this._extractOptions(header, col, this.table.columnManager.optionsList.registeredDefaults);
      this.fieldIndex[index2] = col.field;
      if (col.field == this.table.options.index) {
        this.hasIndex = true;
      }
      if (!exists2) {
        this.table.options.columns.push(col);
      }
    }
  }
  _generateBlankHeaders(headers, rows3) {
    for (var index2 = 0; index2 < headers.length; index2++) {
      var header = headers[index2], col = { title: "", field: "col" + index2 };
      this.fieldIndex[index2] = col.field;
      var width = header.getAttribute("width");
      if (width) {
        col.width = width;
      }
      this.table.options.columns.push(col);
    }
  }
};
HtmlTableImport.moduleName = "htmlTableImport";
function csvImporter(input2) {
  var data = [], row2 = 0, col = 0, inQuote = false;
  for (let index2 = 0; index2 < input2.length; index2++) {
    let char = input2[index2], nextChar = input2[index2 + 1];
    if (!data[row2]) {
      data[row2] = [];
    }
    if (!data[row2][col]) {
      data[row2][col] = "";
    }
    if (char == '"' && inQuote && nextChar == '"') {
      data[row2][col] += char;
      index2++;
      continue;
    }
    if (char == '"') {
      inQuote = !inQuote;
      continue;
    }
    if (char == "," && !inQuote) {
      col++;
      continue;
    }
    if (char == "\r" && nextChar == "\n" && !inQuote) {
      col = 0;
      row2++;
      index2++;
      continue;
    }
    if ((char == "\r" || char == "\n") && !inQuote) {
      col = 0;
      row2++;
      continue;
    }
    data[row2][col] += char;
  }
  return data;
}
function json$1(input2) {
  try {
    return JSON.parse(input2);
  } catch (e) {
    console.warn("JSON Import Error - File contents is invalid JSON", e);
    return Promise.reject();
  }
}
function arrayImporter(input2) {
  return input2;
}
var defaultImporters = {
  csv: csvImporter,
  json: json$1,
  array: arrayImporter
};
var Import = class extends Module {
  constructor(table) {
    super(table);
    this.registerTableOption("importFormat");
    this.registerTableOption("importReader", "text");
  }
  initialize() {
    this.registerTableFunction("import", this.importFromFile.bind(this));
    if (this.table.options.importFormat) {
      this.subscribe("data-loading", this.loadDataCheck.bind(this), 10);
      this.subscribe("data-load", this.loadData.bind(this), 10);
    }
  }
  loadDataCheck(data) {
    return this.table.options.importFormat && (typeof data === "string" || Array.isArray(data) && data.length && Array.isArray(data));
  }
  loadData(data, params, config, silent, previousData) {
    return this.importData(this.lookupImporter(), data).then(this.structureData.bind(this)).catch((err) => {
      console.error("Import Error:", err || "Unable to import data");
      return Promise.reject(err);
    });
  }
  lookupImporter(importFormat) {
    var importer;
    if (!importFormat) {
      importFormat = this.table.options.importFormat;
    }
    if (typeof importFormat === "string") {
      importer = Import.importers[importFormat];
    } else {
      importer = importFormat;
    }
    if (!importer) {
      console.error("Import Error - Importer not found:", importFormat);
    }
    return importer;
  }
  importFromFile(importFormat, extension) {
    var importer = this.lookupImporter(importFormat);
    if (importer) {
      return this.pickFile(extension).then(this.importData.bind(this, importer)).then(this.structureData.bind(this)).then(this.setData.bind(this)).catch((err) => {
        console.error("Import Error:", err || "Unable to import file");
        return Promise.reject(err);
      });
    }
  }
  pickFile(extensions) {
    return new Promise((resolve2, reject) => {
      var input2 = document.createElement("input");
      input2.type = "file";
      input2.accept = extensions;
      input2.addEventListener("change", (e) => {
        var file = input2.files[0], reader = new FileReader();
        switch (this.table.options.importReader) {
          case "buffer":
            reader.readAsArrayBuffer(file);
            break;
          case "binary":
            reader.readAsBinaryString(file);
            break;
          case "url":
            reader.readAsDataURL(file);
            break;
          case "text":
          default:
            reader.readAsText(file);
        }
        reader.onload = (e2) => {
          resolve2(reader.result);
        };
        reader.onerror = (e2) => {
          console.warn("File Load Error - Unable to read file");
          reject();
        };
      });
      input2.click();
    });
  }
  importData(importer, fileContents) {
    var data = importer.call(this.table, fileContents);
    if (data instanceof Promise) {
      return data;
    } else {
      return data ? Promise.resolve(data) : Promise.reject();
    }
  }
  structureData(parsedData) {
    var data = [];
    if (Array.isArray(parsedData) && parsedData.length && Array.isArray(parsedData[0])) {
      if (this.table.options.autoColumns) {
        data = this.structureArrayToObject(parsedData);
      } else {
        data = this.structureArrayToColumns(parsedData);
      }
      return data;
    } else {
      return parsedData;
    }
  }
  structureArrayToObject(parsedData) {
    var columns = parsedData.shift();
    var data = parsedData.map((values2) => {
      var row2 = {};
      columns.forEach((key, i2) => {
        row2[key] = values2[i2];
      });
      return row2;
    });
    return data;
  }
  structureArrayToColumns(parsedData) {
    var data = [], columns = this.table.getColumns();
    if (columns[0] && parsedData[0][0]) {
      if (columns[0].getDefinition().title === parsedData[0][0]) {
        parsedData.shift();
      }
    }
    parsedData.forEach((rowData) => {
      var row2 = {};
      rowData.forEach((value, index2) => {
        var column = columns[index2];
        if (column) {
          row2[column.getField()] = value;
        }
      });
      data.push(row2);
    });
    return data;
  }
  setData(data) {
    return this.table.setData(data);
  }
};
Import.moduleName = "import";
Import.importers = defaultImporters;
var Interaction2 = class extends Module {
  constructor(table) {
    super(table);
    this.eventMap = {
      rowClick: "row-click",
      rowDblClick: "row-dblclick",
      rowContext: "row-contextmenu",
      rowMouseEnter: "row-mouseenter",
      rowMouseLeave: "row-mouseleave",
      rowMouseOver: "row-mouseover",
      rowMouseOut: "row-mouseout",
      rowMouseMove: "row-mousemove",
      rowMouseDown: "row-mousedown",
      rowMouseUp: "row-mouseup",
      rowTap: "row",
      rowDblTap: "row",
      rowTapHold: "row",
      cellClick: "cell-click",
      cellDblClick: "cell-dblclick",
      cellContext: "cell-contextmenu",
      cellMouseEnter: "cell-mouseenter",
      cellMouseLeave: "cell-mouseleave",
      cellMouseOver: "cell-mouseover",
      cellMouseOut: "cell-mouseout",
      cellMouseMove: "cell-mousemove",
      cellMouseDown: "cell-mousedown",
      cellMouseUp: "cell-mouseup",
      cellTap: "cell",
      cellDblTap: "cell",
      cellTapHold: "cell",
      headerClick: "column-click",
      headerDblClick: "column-dblclick",
      headerContext: "column-contextmenu",
      headerMouseEnter: "column-mouseenter",
      headerMouseLeave: "column-mouseleave",
      headerMouseOver: "column-mouseover",
      headerMouseOut: "column-mouseout",
      headerMouseMove: "column-mousemove",
      headerMouseDown: "column-mousedown",
      headerMouseUp: "column-mouseup",
      headerTap: "column",
      headerDblTap: "column",
      headerTapHold: "column",
      groupClick: "group-click",
      groupDblClick: "group-dblclick",
      groupContext: "group-contextmenu",
      groupMouseEnter: "group-mouseenter",
      groupMouseLeave: "group-mouseleave",
      groupMouseOver: "group-mouseover",
      groupMouseOut: "group-mouseout",
      groupMouseMove: "group-mousemove",
      groupMouseDown: "group-mousedown",
      groupMouseUp: "group-mouseup",
      groupTap: "group",
      groupDblTap: "group",
      groupTapHold: "group"
    };
    this.subscribers = {};
    this.touchSubscribers = {};
    this.columnSubscribers = {};
    this.touchWatchers = {
      row: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      cell: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      column: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      group: {
        tap: null,
        tapDbl: null,
        tapHold: null
      }
    };
    this.registerColumnOption("headerClick");
    this.registerColumnOption("headerDblClick");
    this.registerColumnOption("headerContext");
    this.registerColumnOption("headerMouseEnter");
    this.registerColumnOption("headerMouseLeave");
    this.registerColumnOption("headerMouseOver");
    this.registerColumnOption("headerMouseOut");
    this.registerColumnOption("headerMouseMove");
    this.registerColumnOption("headerMouseDown");
    this.registerColumnOption("headerMouseUp");
    this.registerColumnOption("headerTap");
    this.registerColumnOption("headerDblTap");
    this.registerColumnOption("headerTapHold");
    this.registerColumnOption("cellClick");
    this.registerColumnOption("cellDblClick");
    this.registerColumnOption("cellContext");
    this.registerColumnOption("cellMouseEnter");
    this.registerColumnOption("cellMouseLeave");
    this.registerColumnOption("cellMouseOver");
    this.registerColumnOption("cellMouseOut");
    this.registerColumnOption("cellMouseMove");
    this.registerColumnOption("cellMouseDown");
    this.registerColumnOption("cellMouseUp");
    this.registerColumnOption("cellTap");
    this.registerColumnOption("cellDblTap");
    this.registerColumnOption("cellTapHold");
  }
  initialize() {
    this.initializeExternalEvents();
    this.subscribe("column-init", this.initializeColumn.bind(this));
    this.subscribe("cell-dblclick", this.cellContentsSelectionFixer.bind(this));
  }
  cellContentsSelectionFixer(e, cell) {
    var range2;
    if (this.table.modExists("edit")) {
      if (this.table.modules.edit.currentCell === cell) {
        return;
      }
    }
    e.preventDefault();
    try {
      if (document.selection) {
        range2 = document.body.createTextRange();
        range2.moveToElementText(cell.getElement());
        range2.select();
      } else if (window.getSelection) {
        range2 = document.createRange();
        range2.selectNode(cell.getElement());
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range2);
      }
    } catch (e2) {
    }
  }
  initializeExternalEvents() {
    for (let key in this.eventMap) {
      this.subscriptionChangeExternal(key, this.subscriptionChanged.bind(this, key));
    }
  }
  subscriptionChanged(key, added) {
    if (added) {
      if (!this.subscribers[key]) {
        if (this.eventMap[key].includes("-")) {
          this.subscribers[key] = this.handle.bind(this, key);
          this.subscribe(this.eventMap[key], this.subscribers[key]);
        } else {
          this.subscribeTouchEvents(key);
        }
      }
    } else {
      if (this.eventMap[key].includes("-")) {
        if (this.subscribers[key] && !this.columnSubscribers[key] && !this.subscribedExternal(key)) {
          this.unsubscribe(this.eventMap[key], this.subscribers[key]);
          delete this.subscribers[key];
        }
      } else {
        this.unsubscribeTouchEvents(key);
      }
    }
  }
  subscribeTouchEvents(key) {
    var type = this.eventMap[key];
    if (!this.touchSubscribers[type + "-touchstart"]) {
      this.touchSubscribers[type + "-touchstart"] = this.handleTouch.bind(this, type, "start");
      this.touchSubscribers[type + "-touchend"] = this.handleTouch.bind(this, type, "end");
      this.subscribe(type + "-touchstart", this.touchSubscribers[type + "-touchstart"]);
      this.subscribe(type + "-touchend", this.touchSubscribers[type + "-touchend"]);
    }
    this.subscribers[key] = true;
  }
  unsubscribeTouchEvents(key) {
    var noTouch = true, type = this.eventMap[key];
    if (this.subscribers[key] && !this.subscribedExternal(key)) {
      delete this.subscribers[key];
      for (let i2 in this.eventMap) {
        if (this.eventMap[i2] === type) {
          if (this.subscribers[i2]) {
            noTouch = false;
          }
        }
      }
      if (noTouch) {
        this.unsubscribe(type + "-touchstart", this.touchSubscribers[type + "-touchstart"]);
        this.unsubscribe(type + "-touchend", this.touchSubscribers[type + "-touchend"]);
        delete this.touchSubscribers[type + "-touchstart"];
        delete this.touchSubscribers[type + "-touchend"];
      }
    }
  }
  initializeColumn(column) {
    var def = column.definition;
    for (let key in this.eventMap) {
      if (def[key]) {
        this.subscriptionChanged(key, true);
        if (!this.columnSubscribers[key]) {
          this.columnSubscribers[key] = [];
        }
        this.columnSubscribers[key].push(column);
      }
    }
  }
  handle(action, e, component) {
    this.dispatchEvent(action, e, component);
  }
  handleTouch(type, action, e, component) {
    var watchers = this.touchWatchers[type];
    if (type === "column") {
      type = "header";
    }
    switch (action) {
      case "start":
        watchers.tap = true;
        clearTimeout(watchers.tapHold);
        watchers.tapHold = setTimeout(() => {
          clearTimeout(watchers.tapHold);
          watchers.tapHold = null;
          watchers.tap = null;
          clearTimeout(watchers.tapDbl);
          watchers.tapDbl = null;
          this.dispatchEvent(type + "TapHold", e, component);
        }, 1e3);
        break;
      case "end":
        if (watchers.tap) {
          watchers.tap = null;
          this.dispatchEvent(type + "Tap", e, component);
        }
        if (watchers.tapDbl) {
          clearTimeout(watchers.tapDbl);
          watchers.tapDbl = null;
          this.dispatchEvent(type + "DblTap", e, component);
        } else {
          watchers.tapDbl = setTimeout(() => {
            clearTimeout(watchers.tapDbl);
            watchers.tapDbl = null;
          }, 300);
        }
        clearTimeout(watchers.tapHold);
        watchers.tapHold = null;
        break;
    }
  }
  dispatchEvent(action, e, component) {
    var componentObj = component.getComponent(), callback2;
    if (this.columnSubscribers[action]) {
      if (component instanceof Cell) {
        callback2 = component.column.definition[action];
      } else if (component instanceof Column) {
        callback2 = component.definition[action];
      }
      if (callback2) {
        callback2(e, componentObj);
      }
    }
    this.dispatchExternal(action, e, componentObj);
  }
};
Interaction2.moduleName = "interaction";
var defaultBindings = {
  navPrev: "shift + 9",
  navNext: 9,
  navUp: 38,
  navDown: 40,
  scrollPageUp: 33,
  scrollPageDown: 34,
  scrollToStart: 36,
  scrollToEnd: 35,
  undo: ["ctrl + 90", "meta + 90"],
  redo: ["ctrl + 89", "meta + 89"],
  copyToClipboard: ["ctrl + 67", "meta + 89"]
};
var defaultActions = {
  keyBlock: function(e) {
    e.stopPropagation();
    e.preventDefault();
  },
  scrollPageUp: function(e) {
    var rowManager = this.table.rowManager, newPos = rowManager.scrollTop - rowManager.element.clientHeight;
    e.preventDefault();
    if (rowManager.displayRowsCount) {
      if (newPos >= 0) {
        rowManager.element.scrollTop = newPos;
      } else {
        rowManager.scrollToRow(rowManager.getDisplayRows()[0]);
      }
    }
    this.table.element.focus();
  },
  scrollPageDown: function(e) {
    var rowManager = this.table.rowManager, newPos = rowManager.scrollTop + rowManager.element.clientHeight, scrollMax = rowManager.element.scrollHeight;
    e.preventDefault();
    if (rowManager.displayRowsCount) {
      if (newPos <= scrollMax) {
        rowManager.element.scrollTop = newPos;
      } else {
        rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount - 1]);
      }
    }
    this.table.element.focus();
  },
  scrollToStart: function(e) {
    var rowManager = this.table.rowManager;
    e.preventDefault();
    if (rowManager.displayRowsCount) {
      rowManager.scrollToRow(rowManager.getDisplayRows()[0]);
    }
    this.table.element.focus();
  },
  scrollToEnd: function(e) {
    var rowManager = this.table.rowManager;
    e.preventDefault();
    if (rowManager.displayRowsCount) {
      rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount - 1]);
    }
    this.table.element.focus();
  },
  navPrev: function(e) {
    this.dispatch("keybinding-nav-prev", e);
  },
  navNext: function(e) {
    this.dispatch("keybinding-nav-next", e);
  },
  navLeft: function(e) {
    this.dispatch("keybinding-nav-left", e);
  },
  navRight: function(e) {
    this.dispatch("keybinding-nav-right", e);
  },
  navUp: function(e) {
    this.dispatch("keybinding-nav-up", e);
  },
  navDown: function(e) {
    this.dispatch("keybinding-nav-down", e);
  },
  undo: function(e) {
    var cell = false;
    if (this.table.options.history && this.table.modExists("history") && this.table.modExists("edit")) {
      cell = this.table.modules.edit.currentCell;
      if (!cell) {
        e.preventDefault();
        this.table.modules.history.undo();
      }
    }
  },
  redo: function(e) {
    var cell = false;
    if (this.table.options.history && this.table.modExists("history") && this.table.modExists("edit")) {
      cell = this.table.modules.edit.currentCell;
      if (!cell) {
        e.preventDefault();
        this.table.modules.history.redo();
      }
    }
  },
  copyToClipboard: function(e) {
    if (!this.table.modules.edit.currentCell) {
      if (this.table.modExists("clipboard", true)) {
        this.table.modules.clipboard.copy(false, true);
      }
    }
  }
};
var Keybindings = class extends Module {
  constructor(table) {
    super(table);
    this.watchKeys = null;
    this.pressedKeys = null;
    this.keyupBinding = false;
    this.keydownBinding = false;
    this.registerTableOption("keybindings", {});
    this.registerTableOption("tabEndNewRow", false);
  }
  initialize() {
    var bindings = this.table.options.keybindings, mergedBindings = {};
    this.watchKeys = {};
    this.pressedKeys = [];
    if (bindings !== false) {
      Object.assign(mergedBindings, Keybindings.bindings);
      Object.assign(mergedBindings, bindings);
      this.mapBindings(mergedBindings);
      this.bindEvents();
    }
    this.subscribe("table-destroy", this.clearBindings.bind(this));
  }
  mapBindings(bindings) {
    for (let key in bindings) {
      if (Keybindings.actions[key]) {
        if (bindings[key]) {
          if (typeof bindings[key] !== "object") {
            bindings[key] = [bindings[key]];
          }
          bindings[key].forEach((binding) => {
            var bindingList = Array.isArray(binding) ? binding : [binding];
            bindingList.forEach((item) => {
              this.mapBinding(key, item);
            });
          });
        }
      } else {
        console.warn("Key Binding Error - no such action:", key);
      }
    }
  }
  mapBinding(action, symbolsList) {
    var binding = {
      action: Keybindings.actions[action],
      keys: [],
      ctrl: false,
      shift: false,
      meta: false
    };
    var symbols = symbolsList.toString().toLowerCase().split(" ").join("").split("+");
    symbols.forEach((symbol) => {
      switch (symbol) {
        case "ctrl":
          binding.ctrl = true;
          break;
        case "shift":
          binding.shift = true;
          break;
        case "meta":
          binding.meta = true;
          break;
        default:
          symbol = isNaN(symbol) ? symbol.toUpperCase().charCodeAt(0) : parseInt(symbol);
          binding.keys.push(symbol);
          if (!this.watchKeys[symbol]) {
            this.watchKeys[symbol] = [];
          }
          this.watchKeys[symbol].push(binding);
      }
    });
  }
  bindEvents() {
    var self2 = this;
    this.keyupBinding = function(e) {
      var code = e.keyCode;
      var bindings = self2.watchKeys[code];
      if (bindings) {
        self2.pressedKeys.push(code);
        bindings.forEach(function(binding) {
          self2.checkBinding(e, binding);
        });
      }
    };
    this.keydownBinding = function(e) {
      var code = e.keyCode;
      var bindings = self2.watchKeys[code];
      if (bindings) {
        var index2 = self2.pressedKeys.indexOf(code);
        if (index2 > -1) {
          self2.pressedKeys.splice(index2, 1);
        }
      }
    };
    this.table.element.addEventListener("keydown", this.keyupBinding);
    this.table.element.addEventListener("keyup", this.keydownBinding);
  }
  clearBindings() {
    if (this.keyupBinding) {
      this.table.element.removeEventListener("keydown", this.keyupBinding);
    }
    if (this.keydownBinding) {
      this.table.element.removeEventListener("keyup", this.keydownBinding);
    }
  }
  checkBinding(e, binding) {
    var match2 = true;
    if (e.ctrlKey == binding.ctrl && e.shiftKey == binding.shift && e.metaKey == binding.meta) {
      binding.keys.forEach((key) => {
        var index2 = this.pressedKeys.indexOf(key);
        if (index2 == -1) {
          match2 = false;
        }
      });
      if (match2) {
        binding.action.call(this, e);
      }
      return true;
    }
    return false;
  }
};
Keybindings.moduleName = "keybindings";
Keybindings.bindings = defaultBindings;
Keybindings.actions = defaultActions;
var Menu = class extends Module {
  constructor(table) {
    super(table);
    this.menuContainer = null;
    this.nestedMenuBlock = false;
    this.currentComponent = null;
    this.rootPopup = null;
    this.columnSubscribers = {};
    this.registerTableOption("menuContainer", void 0);
    this.registerTableOption("rowContextMenu", false);
    this.registerTableOption("rowClickMenu", false);
    this.registerTableOption("rowDblClickMenu", false);
    this.registerTableOption("groupContextMenu", false);
    this.registerTableOption("groupClickMenu", false);
    this.registerTableOption("groupDblClickMenu", false);
    this.registerColumnOption("headerContextMenu");
    this.registerColumnOption("headerClickMenu");
    this.registerColumnOption("headerDblClickMenu");
    this.registerColumnOption("headerMenu");
    this.registerColumnOption("headerMenuIcon");
    this.registerColumnOption("contextMenu");
    this.registerColumnOption("clickMenu");
    this.registerColumnOption("dblClickMenu");
  }
  initialize() {
    this.deprecatedOptionsCheck();
    this.initializeRowWatchers();
    this.initializeGroupWatchers();
    this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  deprecatedOptionsCheck() {
    if (!this.deprecationCheck("menuContainer", "popupContainer")) {
      this.table.options.popupContainer = this.table.options.menuContainer;
    }
  }
  initializeRowWatchers() {
    if (this.table.options.rowContextMenu) {
      this.subscribe("row-contextmenu", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu));
      this.table.on("rowTapHold", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu));
    }
    if (this.table.options.rowClickMenu) {
      this.subscribe("row-click", this.loadMenuEvent.bind(this, this.table.options.rowClickMenu));
    }
    if (this.table.options.rowDblClickMenu) {
      this.subscribe("row-dblclick", this.loadMenuEvent.bind(this, this.table.options.rowDblClickMenu));
    }
  }
  initializeGroupWatchers() {
    if (this.table.options.groupContextMenu) {
      this.subscribe("group-contextmenu", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu));
      this.table.on("groupTapHold", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu));
    }
    if (this.table.options.groupClickMenu) {
      this.subscribe("group-click", this.loadMenuEvent.bind(this, this.table.options.groupClickMenu));
    }
    if (this.table.options.groupDblClickMenu) {
      this.subscribe("group-dblclick", this.loadMenuEvent.bind(this, this.table.options.groupDblClickMenu));
    }
  }
  initializeColumn(column) {
    var def = column.definition;
    if (def.headerContextMenu && !this.columnSubscribers.headerContextMenu) {
      this.columnSubscribers.headerContextMenu = this.loadMenuTableColumnEvent.bind(this, "headerContextMenu");
      this.subscribe("column-contextmenu", this.columnSubscribers.headerContextMenu);
      this.table.on("headerTapHold", this.loadMenuTableColumnEvent.bind(this, "headerContextMenu"));
    }
    if (def.headerClickMenu && !this.columnSubscribers.headerClickMenu) {
      this.columnSubscribers.headerClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerClickMenu");
      this.subscribe("column-click", this.columnSubscribers.headerClickMenu);
    }
    if (def.headerDblClickMenu && !this.columnSubscribers.headerDblClickMenu) {
      this.columnSubscribers.headerDblClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerDblClickMenu");
      this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickMenu);
    }
    if (def.headerMenu) {
      this.initializeColumnHeaderMenu(column);
    }
    if (def.contextMenu && !this.columnSubscribers.contextMenu) {
      this.columnSubscribers.contextMenu = this.loadMenuTableCellEvent.bind(this, "contextMenu");
      this.subscribe("cell-contextmenu", this.columnSubscribers.contextMenu);
      this.table.on("cellTapHold", this.loadMenuTableCellEvent.bind(this, "contextMenu"));
    }
    if (def.clickMenu && !this.columnSubscribers.clickMenu) {
      this.columnSubscribers.clickMenu = this.loadMenuTableCellEvent.bind(this, "clickMenu");
      this.subscribe("cell-click", this.columnSubscribers.clickMenu);
    }
    if (def.dblClickMenu && !this.columnSubscribers.dblClickMenu) {
      this.columnSubscribers.dblClickMenu = this.loadMenuTableCellEvent.bind(this, "dblClickMenu");
      this.subscribe("cell-dblclick", this.columnSubscribers.dblClickMenu);
    }
  }
  initializeColumnHeaderMenu(column) {
    var icon = column.definition.headerMenuIcon, headerMenuEl;
    headerMenuEl = document.createElement("span");
    headerMenuEl.classList.add("tabulator-header-popup-button");
    if (icon) {
      if (typeof icon === "function") {
        icon = icon(column.getComponent());
      }
      if (icon instanceof HTMLElement) {
        headerMenuEl.appendChild(icon);
      } else {
        headerMenuEl.innerHTML = icon;
      }
    } else {
      headerMenuEl.innerHTML = "&vellip;";
    }
    headerMenuEl.addEventListener("click", (e) => {
      e.stopPropagation();
      e.preventDefault();
      this.loadMenuEvent(column.definition.headerMenu, e, column);
    });
    column.titleElement.insertBefore(headerMenuEl, column.titleElement.firstChild);
  }
  loadMenuTableCellEvent(option, e, cell) {
    if (cell._cell) {
      cell = cell._cell;
    }
    if (cell.column.definition[option]) {
      this.loadMenuEvent(cell.column.definition[option], e, cell);
    }
  }
  loadMenuTableColumnEvent(option, e, column) {
    if (column._column) {
      column = column._column;
    }
    if (column.definition[option]) {
      this.loadMenuEvent(column.definition[option], e, column);
    }
  }
  loadMenuEvent(menu, e, component) {
    if (component._group) {
      component = component._group;
    } else if (component._row) {
      component = component._row;
    }
    menu = typeof menu == "function" ? menu.call(this.table, e, component.getComponent()) : menu;
    this.loadMenu(e, component, menu);
  }
  loadMenu(e, component, menu, parentEl, parentPopup) {
    var touch = !(e instanceof MouseEvent), menuEl = document.createElement("div"), popup;
    menuEl.classList.add("tabulator-menu");
    if (!touch) {
      e.preventDefault();
    }
    if (!menu || !menu.length) {
      return;
    }
    if (!parentEl) {
      if (this.nestedMenuBlock) {
        if (this.rootPopup) {
          return;
        }
      } else {
        this.nestedMenuBlock = setTimeout(() => {
          this.nestedMenuBlock = false;
        }, 100);
      }
      if (this.rootPopup) {
        this.rootPopup.hide();
      }
      this.rootPopup = popup = this.popup(menuEl);
    } else {
      popup = parentPopup.child(menuEl);
    }
    menu.forEach((item) => {
      var itemEl = document.createElement("div"), label = item.label, disabled = item.disabled;
      if (item.separator) {
        itemEl.classList.add("tabulator-menu-separator");
      } else {
        itemEl.classList.add("tabulator-menu-item");
        if (typeof label == "function") {
          label = label.call(this.table, component.getComponent());
        }
        if (label instanceof Node) {
          itemEl.appendChild(label);
        } else {
          itemEl.innerHTML = label;
        }
        if (typeof disabled == "function") {
          disabled = disabled.call(this.table, component.getComponent());
        }
        if (disabled) {
          itemEl.classList.add("tabulator-menu-item-disabled");
          itemEl.addEventListener("click", (e2) => {
            e2.stopPropagation();
          });
        } else {
          if (item.menu && item.menu.length) {
            itemEl.addEventListener("click", (e2) => {
              e2.stopPropagation();
              this.loadMenu(e2, component, item.menu, itemEl, popup);
            });
          } else {
            if (item.action) {
              itemEl.addEventListener("click", (e2) => {
                item.action(e2, component.getComponent());
              });
            }
          }
        }
        if (item.menu && item.menu.length) {
          itemEl.classList.add("tabulator-menu-item-submenu");
        }
      }
      menuEl.appendChild(itemEl);
    });
    menuEl.addEventListener("click", (e2) => {
      if (this.rootPopup) {
        this.rootPopup.hide();
      }
    });
    popup.show(parentEl || e);
    if (popup === this.rootPopup) {
      this.rootPopup.hideOnBlur(() => {
        this.rootPopup = null;
        if (this.currentComponent) {
          this.dispatchExternal("menuClosed", this.currentComponent.getComponent());
          this.currentComponent = null;
        }
      });
      this.currentComponent = component;
      this.dispatchExternal("menuOpened", component.getComponent());
    }
  }
};
Menu.moduleName = "menu";
var MoveColumns = class extends Module {
  constructor(table) {
    super(table);
    this.placeholderElement = this.createPlaceholderElement();
    this.hoverElement = false;
    this.checkTimeout = false;
    this.checkPeriod = 250;
    this.moving = false;
    this.toCol = false;
    this.toColAfter = false;
    this.startX = 0;
    this.autoScrollMargin = 40;
    this.autoScrollStep = 5;
    this.autoScrollTimeout = false;
    this.touchMove = false;
    this.moveHover = this.moveHover.bind(this);
    this.endMove = this.endMove.bind(this);
    this.registerTableOption("movableColumns", false);
  }
  createPlaceholderElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-col");
    el.classList.add("tabulator-col-placeholder");
    return el;
  }
  initialize() {
    if (this.table.options.movableColumns) {
      this.subscribe("column-init", this.initializeColumn.bind(this));
    }
  }
  initializeColumn(column) {
    var self2 = this, config = {}, colEl;
    if (!column.modules.frozen && !column.isGroup) {
      colEl = column.getElement();
      config.mousemove = function(e) {
        if (column.parent === self2.moving.parent) {
          if ((self2.touchMove ? e.touches[0].pageX : e.pageX) - Helpers.elOffset(colEl).left + self2.table.columnManager.contentsElement.scrollLeft > column.getWidth() / 2) {
            if (self2.toCol !== column || !self2.toColAfter) {
              colEl.parentNode.insertBefore(self2.placeholderElement, colEl.nextSibling);
              self2.moveColumn(column, true);
            }
          } else {
            if (self2.toCol !== column || self2.toColAfter) {
              colEl.parentNode.insertBefore(self2.placeholderElement, colEl);
              self2.moveColumn(column, false);
            }
          }
        }
      }.bind(self2);
      colEl.addEventListener("mousedown", function(e) {
        self2.touchMove = false;
        if (e.which === 1) {
          self2.checkTimeout = setTimeout(function() {
            self2.startMove(e, column);
          }, self2.checkPeriod);
        }
      });
      colEl.addEventListener("mouseup", function(e) {
        if (e.which === 1) {
          if (self2.checkTimeout) {
            clearTimeout(self2.checkTimeout);
          }
        }
      });
      self2.bindTouchEvents(column);
    }
    column.modules.moveColumn = config;
  }
  bindTouchEvents(column) {
    var colEl = column.getElement(), startXMove = false, nextCol, prevCol, nextColWidth, prevColWidth, nextColWidthLast, prevColWidthLast;
    colEl.addEventListener("touchstart", (e) => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = true;
        nextCol = column.nextColumn();
        nextColWidth = nextCol ? nextCol.getWidth() / 2 : 0;
        prevCol = column.prevColumn();
        prevColWidth = prevCol ? prevCol.getWidth() / 2 : 0;
        nextColWidthLast = 0;
        prevColWidthLast = 0;
        startXMove = false;
        this.startMove(e, column);
      }, this.checkPeriod);
    }, { passive: true });
    colEl.addEventListener("touchmove", (e) => {
      var diff, moveToCol;
      if (this.moving) {
        this.moveHover(e);
        if (!startXMove) {
          startXMove = e.touches[0].pageX;
        }
        diff = e.touches[0].pageX - startXMove;
        if (diff > 0) {
          if (nextCol && diff - nextColWidthLast > nextColWidth) {
            moveToCol = nextCol;
            if (moveToCol !== column) {
              startXMove = e.touches[0].pageX;
              moveToCol.getElement().parentNode.insertBefore(this.placeholderElement, moveToCol.getElement().nextSibling);
              this.moveColumn(moveToCol, true);
            }
          }
        } else {
          if (prevCol && -diff - prevColWidthLast > prevColWidth) {
            moveToCol = prevCol;
            if (moveToCol !== column) {
              startXMove = e.touches[0].pageX;
              moveToCol.getElement().parentNode.insertBefore(this.placeholderElement, moveToCol.getElement());
              this.moveColumn(moveToCol, false);
            }
          }
        }
        if (moveToCol) {
          nextCol = moveToCol.nextColumn();
          nextColWidthLast = nextColWidth;
          nextColWidth = nextCol ? nextCol.getWidth() / 2 : 0;
          prevCol = moveToCol.prevColumn();
          prevColWidthLast = prevColWidth;
          prevColWidth = prevCol ? prevCol.getWidth() / 2 : 0;
        }
      }
    }, { passive: true });
    colEl.addEventListener("touchend", (e) => {
      if (this.checkTimeout) {
        clearTimeout(this.checkTimeout);
      }
      if (this.moving) {
        this.endMove(e);
      }
    });
  }
  startMove(e, column) {
    var element = column.getElement(), headerElement = this.table.columnManager.getContentsElement(), headersElement = this.table.columnManager.getHeadersElement();
    this.moving = column;
    this.startX = (this.touchMove ? e.touches[0].pageX : e.pageX) - Helpers.elOffset(element).left;
    this.table.element.classList.add("tabulator-block-select");
    this.placeholderElement.style.width = column.getWidth() + "px";
    this.placeholderElement.style.height = column.getHeight() + "px";
    element.parentNode.insertBefore(this.placeholderElement, element);
    element.parentNode.removeChild(element);
    this.hoverElement = element.cloneNode(true);
    this.hoverElement.classList.add("tabulator-moving");
    headerElement.appendChild(this.hoverElement);
    this.hoverElement.style.left = "0";
    this.hoverElement.style.bottom = headerElement.clientHeight - headersElement.offsetHeight + "px";
    if (!this.touchMove) {
      this._bindMouseMove();
      document.body.addEventListener("mousemove", this.moveHover);
      document.body.addEventListener("mouseup", this.endMove);
    }
    this.moveHover(e);
  }
  _bindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function(column) {
      if (column.modules.moveColumn.mousemove) {
        column.getElement().addEventListener("mousemove", column.modules.moveColumn.mousemove);
      }
    });
  }
  _unbindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function(column) {
      if (column.modules.moveColumn.mousemove) {
        column.getElement().removeEventListener("mousemove", column.modules.moveColumn.mousemove);
      }
    });
  }
  moveColumn(column, after) {
    var movingCells = this.moving.getCells();
    this.toCol = column;
    this.toColAfter = after;
    if (after) {
      column.getCells().forEach(function(cell, i2) {
        var cellEl = cell.getElement(true);
        if (cellEl.parentNode && movingCells[i2]) {
          cellEl.parentNode.insertBefore(movingCells[i2].getElement(), cellEl.nextSibling);
        }
      });
    } else {
      column.getCells().forEach(function(cell, i2) {
        var cellEl = cell.getElement(true);
        if (cellEl.parentNode && movingCells[i2]) {
          cellEl.parentNode.insertBefore(movingCells[i2].getElement(), cellEl);
        }
      });
    }
  }
  endMove(e) {
    if (e.which === 1 || this.touchMove) {
      this._unbindMouseMove();
      this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling);
      this.placeholderElement.parentNode.removeChild(this.placeholderElement);
      this.hoverElement.parentNode.removeChild(this.hoverElement);
      this.table.element.classList.remove("tabulator-block-select");
      if (this.toCol) {
        this.table.columnManager.moveColumnActual(this.moving, this.toCol, this.toColAfter);
      }
      this.moving = false;
      this.toCol = false;
      this.toColAfter = false;
      if (!this.touchMove) {
        document.body.removeEventListener("mousemove", this.moveHover);
        document.body.removeEventListener("mouseup", this.endMove);
      }
    }
  }
  moveHover(e) {
    var columnHolder = this.table.columnManager.getContentsElement(), scrollLeft = columnHolder.scrollLeft, xPos = (this.touchMove ? e.touches[0].pageX : e.pageX) - Helpers.elOffset(columnHolder).left + scrollLeft, scrollPos;
    this.hoverElement.style.left = xPos - this.startX + "px";
    if (xPos - scrollLeft < this.autoScrollMargin) {
      if (!this.autoScrollTimeout) {
        this.autoScrollTimeout = setTimeout(() => {
          scrollPos = Math.max(0, scrollLeft - 5);
          this.table.rowManager.getElement().scrollLeft = scrollPos;
          this.autoScrollTimeout = false;
        }, 1);
      }
    }
    if (scrollLeft + columnHolder.clientWidth - xPos < this.autoScrollMargin) {
      if (!this.autoScrollTimeout) {
        this.autoScrollTimeout = setTimeout(() => {
          scrollPos = Math.min(columnHolder.clientWidth, scrollLeft + 5);
          this.table.rowManager.getElement().scrollLeft = scrollPos;
          this.autoScrollTimeout = false;
        }, 1);
      }
    }
  }
};
MoveColumns.moduleName = "moveColumn";
var MoveRows = class extends Module {
  constructor(table) {
    super(table);
    this.placeholderElement = this.createPlaceholderElement();
    this.hoverElement = false;
    this.checkTimeout = false;
    this.checkPeriod = 150;
    this.moving = false;
    this.toRow = false;
    this.toRowAfter = false;
    this.hasHandle = false;
    this.startY = 0;
    this.startX = 0;
    this.moveHover = this.moveHover.bind(this);
    this.endMove = this.endMove.bind(this);
    this.tableRowDropEvent = false;
    this.touchMove = false;
    this.connection = false;
    this.connectionSelectorsTables = false;
    this.connectionSelectorsElements = false;
    this.connectionElements = [];
    this.connections = [];
    this.connectedTable = false;
    this.connectedRow = false;
    this.registerTableOption("movableRows", false);
    this.registerTableOption("movableRowsConnectedTables", false);
    this.registerTableOption("movableRowsConnectedElements", false);
    this.registerTableOption("movableRowsSender", false);
    this.registerTableOption("movableRowsReceiver", "insert");
    this.registerColumnOption("rowHandle");
  }
  createPlaceholderElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-row");
    el.classList.add("tabulator-row-placeholder");
    return el;
  }
  initialize() {
    if (this.table.options.movableRows) {
      this.connectionSelectorsTables = this.table.options.movableRowsConnectedTables;
      this.connectionSelectorsElements = this.table.options.movableRowsConnectedElements;
      this.connection = this.connectionSelectorsTables || this.connectionSelectorsElements;
      this.subscribe("cell-init", this.initializeCell.bind(this));
      this.subscribe("column-init", this.initializeColumn.bind(this));
      this.subscribe("row-init", this.initializeRow.bind(this));
    }
  }
  initializeGroupHeader(group) {
    var self2 = this, config = {};
    config.mouseup = function(e) {
      self2.tableRowDrop(e, group);
    }.bind(self2);
    config.mousemove = function(e) {
      var rowEl;
      if (e.pageY - Helpers.elOffset(group.element).top + self2.table.rowManager.element.scrollTop > group.getHeight() / 2) {
        if (self2.toRow !== group || !self2.toRowAfter) {
          rowEl = group.getElement();
          rowEl.parentNode.insertBefore(self2.placeholderElement, rowEl.nextSibling);
          self2.moveRow(group, true);
        }
      } else {
        if (self2.toRow !== group || self2.toRowAfter) {
          rowEl = group.getElement();
          if (rowEl.previousSibling) {
            rowEl.parentNode.insertBefore(self2.placeholderElement, rowEl);
            self2.moveRow(group, false);
          }
        }
      }
    }.bind(self2);
    group.modules.moveRow = config;
  }
  initializeRow(row2) {
    var self2 = this, config = {}, rowEl;
    config.mouseup = function(e) {
      self2.tableRowDrop(e, row2);
    }.bind(self2);
    config.mousemove = function(e) {
      var rowEl2 = row2.getElement();
      if (e.pageY - Helpers.elOffset(rowEl2).top + self2.table.rowManager.element.scrollTop > row2.getHeight() / 2) {
        if (self2.toRow !== row2 || !self2.toRowAfter) {
          rowEl2.parentNode.insertBefore(self2.placeholderElement, rowEl2.nextSibling);
          self2.moveRow(row2, true);
        }
      } else {
        if (self2.toRow !== row2 || self2.toRowAfter) {
          rowEl2.parentNode.insertBefore(self2.placeholderElement, rowEl2);
          self2.moveRow(row2, false);
        }
      }
    }.bind(self2);
    if (!this.hasHandle) {
      rowEl = row2.getElement();
      rowEl.addEventListener("mousedown", function(e) {
        if (e.which === 1) {
          self2.checkTimeout = setTimeout(function() {
            self2.startMove(e, row2);
          }, self2.checkPeriod);
        }
      });
      rowEl.addEventListener("mouseup", function(e) {
        if (e.which === 1) {
          if (self2.checkTimeout) {
            clearTimeout(self2.checkTimeout);
          }
        }
      });
      this.bindTouchEvents(row2, row2.getElement());
    }
    row2.modules.moveRow = config;
  }
  initializeColumn(column) {
    if (column.definition.rowHandle && this.table.options.movableRows !== false) {
      this.hasHandle = true;
    }
  }
  initializeCell(cell) {
    if (cell.column.definition.rowHandle && this.table.options.movableRows !== false) {
      var self2 = this, cellEl = cell.getElement(true);
      cellEl.addEventListener("mousedown", function(e) {
        if (e.which === 1) {
          self2.checkTimeout = setTimeout(function() {
            self2.startMove(e, cell.row);
          }, self2.checkPeriod);
        }
      });
      cellEl.addEventListener("mouseup", function(e) {
        if (e.which === 1) {
          if (self2.checkTimeout) {
            clearTimeout(self2.checkTimeout);
          }
        }
      });
      this.bindTouchEvents(cell.row, cellEl);
    }
  }
  bindTouchEvents(row2, element) {
    var startYMove = false, nextRow, prevRow, nextRowHeight, prevRowHeight, nextRowHeightLast, prevRowHeightLast;
    element.addEventListener("touchstart", (e) => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = true;
        nextRow = row2.nextRow();
        nextRowHeight = nextRow ? nextRow.getHeight() / 2 : 0;
        prevRow = row2.prevRow();
        prevRowHeight = prevRow ? prevRow.getHeight() / 2 : 0;
        nextRowHeightLast = 0;
        prevRowHeightLast = 0;
        startYMove = false;
        this.startMove(e, row2);
      }, this.checkPeriod);
    }, { passive: true });
    this.moving, this.toRow, this.toRowAfter;
    element.addEventListener("touchmove", (e) => {
      var diff, moveToRow;
      if (this.moving) {
        e.preventDefault();
        this.moveHover(e);
        if (!startYMove) {
          startYMove = e.touches[0].pageY;
        }
        diff = e.touches[0].pageY - startYMove;
        if (diff > 0) {
          if (nextRow && diff - nextRowHeightLast > nextRowHeight) {
            moveToRow = nextRow;
            if (moveToRow !== row2) {
              startYMove = e.touches[0].pageY;
              moveToRow.getElement().parentNode.insertBefore(this.placeholderElement, moveToRow.getElement().nextSibling);
              this.moveRow(moveToRow, true);
            }
          }
        } else {
          if (prevRow && -diff - prevRowHeightLast > prevRowHeight) {
            moveToRow = prevRow;
            if (moveToRow !== row2) {
              startYMove = e.touches[0].pageY;
              moveToRow.getElement().parentNode.insertBefore(this.placeholderElement, moveToRow.getElement());
              this.moveRow(moveToRow, false);
            }
          }
        }
        if (moveToRow) {
          nextRow = moveToRow.nextRow();
          nextRowHeightLast = nextRowHeight;
          nextRowHeight = nextRow ? nextRow.getHeight() / 2 : 0;
          prevRow = moveToRow.prevRow();
          prevRowHeightLast = prevRowHeight;
          prevRowHeight = prevRow ? prevRow.getHeight() / 2 : 0;
        }
      }
    });
    element.addEventListener("touchend", (e) => {
      if (this.checkTimeout) {
        clearTimeout(this.checkTimeout);
      }
      if (this.moving) {
        this.endMove(e);
        this.touchMove = false;
      }
    });
  }
  _bindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach((row2) => {
      if ((row2.type === "row" || row2.type === "group") && row2.modules.moveRow && row2.modules.moveRow.mousemove) {
        row2.getElement().addEventListener("mousemove", row2.modules.moveRow.mousemove);
      }
    });
  }
  _unbindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach((row2) => {
      if ((row2.type === "row" || row2.type === "group") && row2.modules.moveRow && row2.modules.moveRow.mousemove) {
        row2.getElement().removeEventListener("mousemove", row2.modules.moveRow.mousemove);
      }
    });
  }
  startMove(e, row2) {
    var element = row2.getElement();
    this.setStartPosition(e, row2);
    this.moving = row2;
    this.table.element.classList.add("tabulator-block-select");
    this.placeholderElement.style.width = row2.getWidth() + "px";
    this.placeholderElement.style.height = row2.getHeight() + "px";
    if (!this.connection) {
      element.parentNode.insertBefore(this.placeholderElement, element);
      element.parentNode.removeChild(element);
    } else {
      this.table.element.classList.add("tabulator-movingrow-sending");
      this.connectToTables(row2);
    }
    this.hoverElement = element.cloneNode(true);
    this.hoverElement.classList.add("tabulator-moving");
    if (this.connection) {
      document.body.appendChild(this.hoverElement);
      this.hoverElement.style.left = "0";
      this.hoverElement.style.top = "0";
      this.hoverElement.style.width = this.table.element.clientWidth + "px";
      this.hoverElement.style.whiteSpace = "nowrap";
      this.hoverElement.style.overflow = "hidden";
      this.hoverElement.style.pointerEvents = "none";
    } else {
      this.table.rowManager.getTableElement().appendChild(this.hoverElement);
      this.hoverElement.style.left = "0";
      this.hoverElement.style.top = "0";
      this._bindMouseMove();
    }
    document.body.addEventListener("mousemove", this.moveHover);
    document.body.addEventListener("mouseup", this.endMove);
    this.dispatchExternal("rowMoving", row2.getComponent());
    this.moveHover(e);
  }
  setStartPosition(e, row2) {
    var pageX = this.touchMove ? e.touches[0].pageX : e.pageX, pageY = this.touchMove ? e.touches[0].pageY : e.pageY, element, position;
    element = row2.getElement();
    if (this.connection) {
      position = element.getBoundingClientRect();
      this.startX = position.left - pageX + window.pageXOffset;
      this.startY = position.top - pageY + window.pageYOffset;
    } else {
      this.startY = pageY - element.getBoundingClientRect().top;
    }
  }
  endMove(e) {
    if (!e || e.which === 1 || this.touchMove) {
      this._unbindMouseMove();
      if (!this.connection) {
        this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling);
        this.placeholderElement.parentNode.removeChild(this.placeholderElement);
      }
      this.hoverElement.parentNode.removeChild(this.hoverElement);
      this.table.element.classList.remove("tabulator-block-select");
      if (this.toRow) {
        this.table.rowManager.moveRow(this.moving, this.toRow, this.toRowAfter);
      } else {
        this.dispatchExternal("rowMoveCancelled", this.moving.getComponent());
      }
      this.moving = false;
      this.toRow = false;
      this.toRowAfter = false;
      document.body.removeEventListener("mousemove", this.moveHover);
      document.body.removeEventListener("mouseup", this.endMove);
      if (this.connection) {
        this.table.element.classList.remove("tabulator-movingrow-sending");
        this.disconnectFromTables();
      }
    }
  }
  moveRow(row2, after) {
    this.toRow = row2;
    this.toRowAfter = after;
  }
  moveHover(e) {
    if (this.connection) {
      this.moveHoverConnections.call(this, e);
    } else {
      this.moveHoverTable.call(this, e);
    }
  }
  moveHoverTable(e) {
    var rowHolder = this.table.rowManager.getElement(), scrollTop = rowHolder.scrollTop, yPos = (this.touchMove ? e.touches[0].pageY : e.pageY) - rowHolder.getBoundingClientRect().top + scrollTop;
    this.hoverElement.style.top = Math.min(yPos - this.startY, this.table.rowManager.element.scrollHeight - this.hoverElement.offsetHeight) + "px";
  }
  moveHoverConnections(e) {
    this.hoverElement.style.left = this.startX + (this.touchMove ? e.touches[0].pageX : e.pageX) + "px";
    this.hoverElement.style.top = this.startY + (this.touchMove ? e.touches[0].pageY : e.pageY) + "px";
  }
  elementRowDrop(e, element, row2) {
    this.dispatchExternal("movableRowsElementDrop", e, element, row2 ? row2.getComponent() : false);
  }
  connectToTables(row2) {
    var connectionTables;
    if (this.connectionSelectorsTables) {
      connectionTables = this.commsConnections(this.connectionSelectorsTables);
      this.dispatchExternal("movableRowsSendingStart", connectionTables);
      this.commsSend(this.connectionSelectorsTables, "moveRow", "connect", {
        row: row2
      });
    }
    if (this.connectionSelectorsElements) {
      this.connectionElements = [];
      if (!Array.isArray(this.connectionSelectorsElements)) {
        this.connectionSelectorsElements = [this.connectionSelectorsElements];
      }
      this.connectionSelectorsElements.forEach((query) => {
        if (typeof query === "string") {
          this.connectionElements = this.connectionElements.concat(Array.prototype.slice.call(document.querySelectorAll(query)));
        } else {
          this.connectionElements.push(query);
        }
      });
      this.connectionElements.forEach((element) => {
        var dropEvent = (e) => {
          this.elementRowDrop(e, element, this.moving);
        };
        element.addEventListener("mouseup", dropEvent);
        element.tabulatorElementDropEvent = dropEvent;
        element.classList.add("tabulator-movingrow-receiving");
      });
    }
  }
  disconnectFromTables() {
    var connectionTables;
    if (this.connectionSelectorsTables) {
      connectionTables = this.commsConnections(this.connectionSelectorsTables);
      this.dispatchExternal("movableRowsSendingStop", connectionTables);
      this.commsSend(this.connectionSelectorsTables, "moveRow", "disconnect");
    }
    this.connectionElements.forEach((element) => {
      element.classList.remove("tabulator-movingrow-receiving");
      element.removeEventListener("mouseup", element.tabulatorElementDropEvent);
      delete element.tabulatorElementDropEvent;
    });
  }
  connect(table, row2) {
    if (!this.connectedTable) {
      this.connectedTable = table;
      this.connectedRow = row2;
      this.table.element.classList.add("tabulator-movingrow-receiving");
      this.table.rowManager.getDisplayRows().forEach((row3) => {
        if (row3.type === "row" && row3.modules.moveRow && row3.modules.moveRow.mouseup) {
          row3.getElement().addEventListener("mouseup", row3.modules.moveRow.mouseup);
        }
      });
      this.tableRowDropEvent = this.tableRowDrop.bind(this);
      this.table.element.addEventListener("mouseup", this.tableRowDropEvent);
      this.dispatchExternal("movableRowsReceivingStart", row2, table);
      return true;
    } else {
      console.warn("Move Row Error - Table cannot accept connection, already connected to table:", this.connectedTable);
      return false;
    }
  }
  disconnect(table) {
    if (table === this.connectedTable) {
      this.connectedTable = false;
      this.connectedRow = false;
      this.table.element.classList.remove("tabulator-movingrow-receiving");
      this.table.rowManager.getDisplayRows().forEach((row2) => {
        if (row2.type === "row" && row2.modules.moveRow && row2.modules.moveRow.mouseup) {
          row2.getElement().removeEventListener("mouseup", row2.modules.moveRow.mouseup);
        }
      });
      this.table.element.removeEventListener("mouseup", this.tableRowDropEvent);
      this.dispatchExternal("movableRowsReceivingStop", table);
    } else {
      console.warn("Move Row Error - trying to disconnect from non connected table");
    }
  }
  dropComplete(table, row2, success) {
    var sender = false;
    if (success) {
      switch (typeof this.table.options.movableRowsSender) {
        case "string":
          sender = this.senders[this.table.options.movableRowsSender];
          break;
        case "function":
          sender = this.table.options.movableRowsSender;
          break;
      }
      if (sender) {
        sender.call(this, this.moving ? this.moving.getComponent() : void 0, row2 ? row2.getComponent() : void 0, table);
      } else {
        if (this.table.options.movableRowsSender) {
          console.warn("Mover Row Error - no matching sender found:", this.table.options.movableRowsSender);
        }
      }
      this.dispatchExternal("movableRowsSent", this.moving.getComponent(), row2 ? row2.getComponent() : void 0, table);
    } else {
      this.dispatchExternal("movableRowsSentFailed", this.moving.getComponent(), row2 ? row2.getComponent() : void 0, table);
    }
    this.endMove();
  }
  tableRowDrop(e, row2) {
    var receiver = false, success = false;
    e.stopImmediatePropagation();
    switch (typeof this.table.options.movableRowsReceiver) {
      case "string":
        receiver = this.receivers[this.table.options.movableRowsReceiver];
        break;
      case "function":
        receiver = this.table.options.movableRowsReceiver;
        break;
    }
    if (receiver) {
      success = receiver.call(this, this.connectedRow.getComponent(), row2 ? row2.getComponent() : void 0, this.connectedTable);
    } else {
      console.warn("Mover Row Error - no matching receiver found:", this.table.options.movableRowsReceiver);
    }
    if (success) {
      this.dispatchExternal("movableRowsReceived", this.connectedRow.getComponent(), row2 ? row2.getComponent() : void 0, this.connectedTable);
    } else {
      this.dispatchExternal("movableRowsReceivedFailed", this.connectedRow.getComponent(), row2 ? row2.getComponent() : void 0, this.connectedTable);
    }
    this.commsSend(this.connectedTable, "moveRow", "dropcomplete", {
      row: row2,
      success
    });
  }
  commsReceived(table, action, data) {
    switch (action) {
      case "connect":
        return this.connect(table, data.row);
      case "disconnect":
        return this.disconnect(table);
      case "dropcomplete":
        return this.dropComplete(table, data.row, data.success);
    }
  }
};
MoveRows.prototype.receivers = {
  insert: function(fromRow, toRow, fromTable) {
    this.table.addRow(fromRow.getData(), void 0, toRow);
    return true;
  },
  add: function(fromRow, toRow, fromTable) {
    this.table.addRow(fromRow.getData());
    return true;
  },
  update: function(fromRow, toRow, fromTable) {
    if (toRow) {
      toRow.update(fromRow.getData());
      return true;
    }
    return false;
  },
  replace: function(fromRow, toRow, fromTable) {
    if (toRow) {
      this.table.addRow(fromRow.getData(), void 0, toRow);
      toRow.delete();
      return true;
    }
    return false;
  }
};
MoveRows.prototype.senders = {
  delete: function(fromRow, toRow, toTable) {
    fromRow.delete();
  }
};
MoveRows.moduleName = "moveRow";
var defaultMutators = {};
var Mutator = class extends Module {
  constructor(table) {
    super(table);
    this.allowedTypes = ["", "data", "edit", "clipboard"];
    this.enabled = true;
    this.registerColumnOption("mutator");
    this.registerColumnOption("mutatorParams");
    this.registerColumnOption("mutatorData");
    this.registerColumnOption("mutatorDataParams");
    this.registerColumnOption("mutatorEdit");
    this.registerColumnOption("mutatorEditParams");
    this.registerColumnOption("mutatorClipboard");
    this.registerColumnOption("mutatorClipboardParams");
    this.registerColumnOption("mutateLink");
  }
  initialize() {
    this.subscribe("cell-value-changing", this.transformCell.bind(this));
    this.subscribe("cell-value-changed", this.mutateLink.bind(this));
    this.subscribe("column-layout", this.initializeColumn.bind(this));
    this.subscribe("row-data-init-before", this.rowDataChanged.bind(this));
    this.subscribe("row-data-changing", this.rowDataChanged.bind(this));
  }
  rowDataChanged(row2, tempData, updatedData) {
    return this.transformRow(tempData, "data", updatedData);
  }
  initializeColumn(column) {
    var match2 = false, config = {};
    this.allowedTypes.forEach((type) => {
      var key = "mutator" + (type.charAt(0).toUpperCase() + type.slice(1)), mutator;
      if (column.definition[key]) {
        mutator = this.lookupMutator(column.definition[key]);
        if (mutator) {
          match2 = true;
          config[key] = {
            mutator,
            params: column.definition[key + "Params"] || {}
          };
        }
      }
    });
    if (match2) {
      column.modules.mutate = config;
    }
  }
  lookupMutator(value) {
    var mutator = false;
    switch (typeof value) {
      case "string":
        if (Mutator.mutators[value]) {
          mutator = Mutator.mutators[value];
        } else {
          console.warn("Mutator Error - No such mutator found, ignoring: ", value);
        }
        break;
      case "function":
        mutator = value;
        break;
    }
    return mutator;
  }
  transformRow(data, type, updatedData) {
    var key = "mutator" + (type.charAt(0).toUpperCase() + type.slice(1)), value;
    if (this.enabled) {
      this.table.columnManager.traverse((column) => {
        var mutator, params, component;
        if (column.modules.mutate) {
          mutator = column.modules.mutate[key] || column.modules.mutate.mutator || false;
          if (mutator) {
            value = column.getFieldValue(typeof updatedData !== "undefined" ? updatedData : data);
            if (type == "data" || typeof value !== "undefined") {
              component = column.getComponent();
              params = typeof mutator.params === "function" ? mutator.params(value, data, type, component) : mutator.params;
              column.setFieldValue(data, mutator.mutator(value, data, type, params, component));
            }
          }
        }
      });
    }
    return data;
  }
  transformCell(cell, value) {
    if (cell.column.modules.mutate) {
      var mutator = cell.column.modules.mutate.mutatorEdit || cell.column.modules.mutate.mutator || false, tempData = {};
      if (mutator) {
        tempData = Object.assign(tempData, cell.row.getData());
        cell.column.setFieldValue(tempData, value);
        return mutator.mutator(value, tempData, "edit", mutator.params, cell.getComponent());
      }
    }
    return value;
  }
  mutateLink(cell) {
    var links = cell.column.definition.mutateLink;
    if (links) {
      if (!Array.isArray(links)) {
        links = [links];
      }
      links.forEach((link2) => {
        var linkCell = cell.row.getCell(link2);
        if (linkCell) {
          linkCell.setValue(linkCell.getValue(), true, true);
        }
      });
    }
  }
  enable() {
    this.enabled = true;
  }
  disable() {
    this.enabled = false;
  }
};
Mutator.moduleName = "mutator";
Mutator.mutators = defaultMutators;
function rows2(pageSize, currentRow, currentPage, totalRows, totalPages) {
  var el = document.createElement("span"), showingEl = document.createElement("span"), valueEl = document.createElement("span"), ofEl = document.createElement("span"), totalEl = document.createElement("span"), rowsEl = document.createElement("span");
  this.table.modules.localize.langBind("pagination|counter|showing", (value) => {
    showingEl.innerHTML = value;
  });
  this.table.modules.localize.langBind("pagination|counter|of", (value) => {
    ofEl.innerHTML = value;
  });
  this.table.modules.localize.langBind("pagination|counter|rows", (value) => {
    rowsEl.innerHTML = value;
  });
  if (totalRows) {
    valueEl.innerHTML = " " + currentRow + "-" + Math.min(currentRow + pageSize - 1, totalRows) + " ";
    totalEl.innerHTML = " " + totalRows + " ";
    el.appendChild(showingEl);
    el.appendChild(valueEl);
    el.appendChild(ofEl);
    el.appendChild(totalEl);
    el.appendChild(rowsEl);
  } else {
    valueEl.innerHTML = " 0 ";
    el.appendChild(showingEl);
    el.appendChild(valueEl);
    el.appendChild(rowsEl);
  }
  return el;
}
function pages(pageSize, currentRow, currentPage, totalRows, totalPages) {
  var el = document.createElement("span"), showingEl = document.createElement("span"), valueEl = document.createElement("span"), ofEl = document.createElement("span"), totalEl = document.createElement("span"), rowsEl = document.createElement("span");
  this.table.modules.localize.langBind("pagination|counter|showing", (value) => {
    showingEl.innerHTML = value;
  });
  valueEl.innerHTML = " " + currentPage + " ";
  this.table.modules.localize.langBind("pagination|counter|of", (value) => {
    ofEl.innerHTML = value;
  });
  totalEl.innerHTML = " " + totalPages + " ";
  this.table.modules.localize.langBind("pagination|counter|pages", (value) => {
    rowsEl.innerHTML = value;
  });
  el.appendChild(showingEl);
  el.appendChild(valueEl);
  el.appendChild(ofEl);
  el.appendChild(totalEl);
  el.appendChild(rowsEl);
  return el;
}
var defaultPageCounters = {
  rows: rows2,
  pages
};
var Page = class extends Module {
  constructor(table) {
    super(table);
    this.mode = "local";
    this.progressiveLoad = false;
    this.element = null;
    this.pageCounterElement = null;
    this.pageCounter = null;
    this.size = 0;
    this.page = 1;
    this.count = 5;
    this.max = 1;
    this.remoteRowCountEstimate = null;
    this.initialLoad = true;
    this.dataChanging = false;
    this.pageSizes = [];
    this.registerTableOption("pagination", false);
    this.registerTableOption("paginationMode", "local");
    this.registerTableOption("paginationSize", false);
    this.registerTableOption("paginationInitialPage", 1);
    this.registerTableOption("paginationCounter", false);
    this.registerTableOption("paginationCounterElement", false);
    this.registerTableOption("paginationButtonCount", 5);
    this.registerTableOption("paginationSizeSelector", false);
    this.registerTableOption("paginationElement", false);
    this.registerTableOption("paginationAddRow", "page");
    this.registerTableOption("progressiveLoad", false);
    this.registerTableOption("progressiveLoadDelay", 0);
    this.registerTableOption("progressiveLoadScrollMargin", 0);
    this.registerTableFunction("setMaxPage", this.setMaxPage.bind(this));
    this.registerTableFunction("setPage", this.setPage.bind(this));
    this.registerTableFunction("setPageToRow", this.userSetPageToRow.bind(this));
    this.registerTableFunction("setPageSize", this.userSetPageSize.bind(this));
    this.registerTableFunction("getPageSize", this.getPageSize.bind(this));
    this.registerTableFunction("previousPage", this.previousPage.bind(this));
    this.registerTableFunction("nextPage", this.nextPage.bind(this));
    this.registerTableFunction("getPage", this.getPage.bind(this));
    this.registerTableFunction("getPageMax", this.getPageMax.bind(this));
    this.registerComponentFunction("row", "pageTo", this.setPageToRow.bind(this));
  }
  initialize() {
    if (this.table.options.pagination) {
      this.subscribe("row-deleted", this.rowsUpdated.bind(this));
      this.subscribe("row-added", this.rowsUpdated.bind(this));
      this.subscribe("data-processed", this.initialLoadComplete.bind(this));
      this.subscribe("table-built", this.calculatePageSizes.bind(this));
      this.subscribe("footer-redraw", this.footerRedraw.bind(this));
      if (this.table.options.paginationAddRow == "page") {
        this.subscribe("row-adding-position", this.rowAddingPosition.bind(this));
      }
      if (this.table.options.paginationMode === "remote") {
        this.subscribe("data-params", this.remotePageParams.bind(this));
        this.subscribe("data-loaded", this._parseRemoteData.bind(this));
      }
      if (this.table.options.progressiveLoad) {
        console.error("Progressive Load Error - Pagination and progressive load cannot be used at the same time");
      }
      this.registerDisplayHandler(this.restOnRenderBefore.bind(this), 40);
      this.registerDisplayHandler(this.getRows.bind(this), 50);
      this.createElements();
      this.initializePageCounter();
      this.initializePaginator();
    } else if (this.table.options.progressiveLoad) {
      this.subscribe("data-params", this.remotePageParams.bind(this));
      this.subscribe("data-loaded", this._parseRemoteData.bind(this));
      this.subscribe("table-built", this.calculatePageSizes.bind(this));
      this.subscribe("data-processed", this.initialLoadComplete.bind(this));
      this.initializeProgressive(this.table.options.progressiveLoad);
      if (this.table.options.progressiveLoad === "scroll") {
        this.subscribe("scroll-vertical", this.scrollVertical.bind(this));
      }
    }
  }
  rowAddingPosition(row2, top) {
    var rowManager = this.table.rowManager, displayRows = rowManager.getDisplayRows(), index2;
    if (top) {
      if (displayRows.length) {
        index2 = displayRows[0];
      } else {
        if (rowManager.activeRows.length) {
          index2 = rowManager.activeRows[rowManager.activeRows.length - 1];
          top = false;
        }
      }
    } else {
      if (displayRows.length) {
        index2 = displayRows[displayRows.length - 1];
        top = displayRows.length < this.size ? false : true;
      }
    }
    return { index: index2, top };
  }
  calculatePageSizes() {
    var testElRow, testElCell;
    if (this.table.options.paginationSize) {
      this.size = this.table.options.paginationSize;
    } else {
      testElRow = document.createElement("div");
      testElRow.classList.add("tabulator-row");
      testElRow.style.visibility = "hidden";
      testElCell = document.createElement("div");
      testElCell.classList.add("tabulator-cell");
      testElCell.innerHTML = "Page Row Test";
      testElRow.appendChild(testElCell);
      this.table.rowManager.getTableElement().appendChild(testElRow);
      this.size = Math.floor(this.table.rowManager.getElement().clientHeight / testElRow.offsetHeight);
      this.table.rowManager.getTableElement().removeChild(testElRow);
    }
    this.dispatchExternal("pageSizeChanged", this.size);
    this.generatePageSizeSelectList();
  }
  initialLoadComplete() {
    this.initialLoad = false;
  }
  remotePageParams(data, config, silent, params) {
    if (!this.initialLoad) {
      if (this.progressiveLoad && !silent || !this.progressiveLoad && !this.dataChanging) {
        this.reset(true);
      }
    }
    params.page = this.page;
    if (this.size) {
      params.size = this.size;
    }
    return params;
  }
  userSetPageToRow(row2) {
    if (this.table.options.pagination) {
      row2 = this.rowManager.findRow(row2);
      if (row2) {
        return this.setPageToRow(row2);
      }
    }
    return Promise.reject();
  }
  userSetPageSize(size) {
    if (this.table.options.pagination) {
      this.setPageSize(size);
      return this.setPage(1);
    } else {
      return false;
    }
  }
  scrollVertical(top, dir) {
    var element, diff, margin;
    if (!dir && !this.table.dataLoader.loading) {
      element = this.table.rowManager.getElement();
      diff = element.scrollHeight - element.clientHeight - top;
      margin = this.table.options.progressiveLoadScrollMargin || element.clientHeight * 2;
      if (diff < margin) {
        this.nextPage().catch(() => {
        });
      }
    }
  }
  restOnRenderBefore(rows3, renderInPosition) {
    if (!renderInPosition) {
      if (this.mode === "local") {
        this.reset();
      }
    }
    return rows3;
  }
  rowsUpdated() {
    this.refreshData(true, "all");
  }
  createElements() {
    var button;
    this.element = document.createElement("span");
    this.element.classList.add("tabulator-paginator");
    this.pagesElement = document.createElement("span");
    this.pagesElement.classList.add("tabulator-pages");
    button = document.createElement("button");
    button.classList.add("tabulator-page");
    button.setAttribute("type", "button");
    button.setAttribute("role", "button");
    button.setAttribute("aria-label", "");
    button.setAttribute("title", "");
    this.firstBut = button.cloneNode(true);
    this.firstBut.setAttribute("data-page", "first");
    this.prevBut = button.cloneNode(true);
    this.prevBut.setAttribute("data-page", "prev");
    this.nextBut = button.cloneNode(true);
    this.nextBut.setAttribute("data-page", "next");
    this.lastBut = button.cloneNode(true);
    this.lastBut.setAttribute("data-page", "last");
    if (this.table.options.paginationSizeSelector) {
      this.pageSizeSelect = document.createElement("select");
      this.pageSizeSelect.classList.add("tabulator-page-size");
    }
  }
  generatePageSizeSelectList() {
    var pageSizes = [];
    if (this.pageSizeSelect) {
      if (Array.isArray(this.table.options.paginationSizeSelector)) {
        pageSizes = this.table.options.paginationSizeSelector;
        this.pageSizes = pageSizes;
        if (this.pageSizes.indexOf(this.size) == -1) {
          pageSizes.unshift(this.size);
        }
      } else {
        if (this.pageSizes.indexOf(this.size) == -1) {
          pageSizes = [];
          for (let i2 = 1; i2 < 5; i2++) {
            pageSizes.push(this.size * i2);
          }
          this.pageSizes = pageSizes;
        } else {
          pageSizes = this.pageSizes;
        }
      }
      while (this.pageSizeSelect.firstChild)
        this.pageSizeSelect.removeChild(this.pageSizeSelect.firstChild);
      pageSizes.forEach((item) => {
        var itemEl = document.createElement("option");
        itemEl.value = item;
        if (item === true) {
          this.langBind("pagination|all", function(value) {
            itemEl.innerHTML = value;
          });
        } else {
          itemEl.innerHTML = item;
        }
        this.pageSizeSelect.appendChild(itemEl);
      });
      this.pageSizeSelect.value = this.size;
    }
  }
  initializePageCounter() {
    var counter = this.table.options.paginationCounter, pageCounter = null;
    if (counter) {
      if (typeof counter === "function") {
        pageCounter = counter;
      } else {
        pageCounter = Page.pageCounters[counter];
      }
      if (pageCounter) {
        this.pageCounter = pageCounter;
        this.pageCounterElement = document.createElement("span");
        this.pageCounterElement.classList.add("tabulator-page-counter");
      } else {
        console.warn("Pagination Error - No such page counter found: ", counter);
      }
    }
  }
  initializePaginator(hidden) {
    var pageSelectLabel, paginationCounterHolder;
    if (!hidden) {
      this.langBind("pagination|first", (value) => {
        this.firstBut.innerHTML = value;
      });
      this.langBind("pagination|first_title", (value) => {
        this.firstBut.setAttribute("aria-label", value);
        this.firstBut.setAttribute("title", value);
      });
      this.langBind("pagination|prev", (value) => {
        this.prevBut.innerHTML = value;
      });
      this.langBind("pagination|prev_title", (value) => {
        this.prevBut.setAttribute("aria-label", value);
        this.prevBut.setAttribute("title", value);
      });
      this.langBind("pagination|next", (value) => {
        this.nextBut.innerHTML = value;
      });
      this.langBind("pagination|next_title", (value) => {
        this.nextBut.setAttribute("aria-label", value);
        this.nextBut.setAttribute("title", value);
      });
      this.langBind("pagination|last", (value) => {
        this.lastBut.innerHTML = value;
      });
      this.langBind("pagination|last_title", (value) => {
        this.lastBut.setAttribute("aria-label", value);
        this.lastBut.setAttribute("title", value);
      });
      this.firstBut.addEventListener("click", () => {
        this.setPage(1);
      });
      this.prevBut.addEventListener("click", () => {
        this.previousPage();
      });
      this.nextBut.addEventListener("click", () => {
        this.nextPage();
      });
      this.lastBut.addEventListener("click", () => {
        this.setPage(this.max);
      });
      if (this.table.options.paginationElement) {
        this.element = this.table.options.paginationElement;
      }
      if (this.pageSizeSelect) {
        pageSelectLabel = document.createElement("label");
        this.langBind("pagination|page_size", (value) => {
          this.pageSizeSelect.setAttribute("aria-label", value);
          this.pageSizeSelect.setAttribute("title", value);
          pageSelectLabel.innerHTML = value;
        });
        this.element.appendChild(pageSelectLabel);
        this.element.appendChild(this.pageSizeSelect);
        this.pageSizeSelect.addEventListener("change", (e) => {
          this.setPageSize(this.pageSizeSelect.value == "true" ? true : this.pageSizeSelect.value);
          this.setPage(1);
        });
      }
      this.element.appendChild(this.firstBut);
      this.element.appendChild(this.prevBut);
      this.element.appendChild(this.pagesElement);
      this.element.appendChild(this.nextBut);
      this.element.appendChild(this.lastBut);
      if (!this.table.options.paginationElement) {
        if (this.table.options.paginationCounter) {
          if (this.table.options.paginationCounterElement) {
            if (this.table.options.paginationCounterElement instanceof HTMLElement) {
              this.table.options.paginationCounterElement.appendChild(this.pageCounterElement);
            } else if (typeof this.table.options.paginationCounterElement === "string") {
              paginationCounterHolder = document.querySelector(this.table.options.paginationCounterElement);
              if (paginationCounterHolder) {
                paginationCounterHolder.appendChild(this.pageCounterElement);
              } else {
                console.warn("Pagination Error - Unable to find element matching paginationCounterElement selector:", this.table.options.paginationCounterElement);
              }
            }
          } else {
            this.footerAppend(this.pageCounterElement);
          }
        }
        this.footerAppend(this.element);
      }
      this.page = this.table.options.paginationInitialPage;
      this.count = this.table.options.paginationButtonCount;
    }
    this.mode = this.table.options.paginationMode;
  }
  initializeProgressive(mode) {
    this.initializePaginator(true);
    this.mode = "progressive_" + mode;
    this.progressiveLoad = true;
  }
  trackChanges() {
    this.dispatch("page-changed");
  }
  setMaxRows(rowCount) {
    if (!rowCount) {
      this.max = 1;
    } else {
      this.max = this.size === true ? 1 : Math.ceil(rowCount / this.size);
    }
    if (this.page > this.max) {
      this.page = this.max;
    }
  }
  reset(force) {
    if (!this.initialLoad) {
      if (this.mode == "local" || force) {
        this.page = 1;
        this.trackChanges();
      }
    }
  }
  setMaxPage(max) {
    max = parseInt(max);
    this.max = max || 1;
    if (this.page > this.max) {
      this.page = this.max;
      this.trigger();
    }
  }
  setPage(page) {
    switch (page) {
      case "first":
        return this.setPage(1);
      case "prev":
        return this.previousPage();
      case "next":
        return this.nextPage();
      case "last":
        return this.setPage(this.max);
    }
    page = parseInt(page);
    if (page > 0 && page <= this.max || this.mode !== "local") {
      this.page = page;
      this.trackChanges();
      return this.trigger();
    } else {
      console.warn("Pagination Error - Requested page is out of range of 1 - " + this.max + ":", page);
      return Promise.reject();
    }
  }
  setPageToRow(row2) {
    var rows3 = this.displayRows(-1);
    var index2 = rows3.indexOf(row2);
    if (index2 > -1) {
      var page = this.size === true ? 1 : Math.ceil((index2 + 1) / this.size);
      return this.setPage(page);
    } else {
      console.warn("Pagination Error - Requested row is not visible");
      return Promise.reject();
    }
  }
  setPageSize(size) {
    if (size !== true) {
      size = parseInt(size);
    }
    if (size > 0) {
      this.size = size;
      this.dispatchExternal("pageSizeChanged", size);
    }
    if (this.pageSizeSelect) {
      this.generatePageSizeSelectList();
    }
    this.trackChanges();
  }
  _setPageCounter(totalRows, size, currentRow) {
    var content;
    if (this.pageCounter) {
      if (this.mode === "remote") {
        size = this.size;
        currentRow = (this.page - 1) * this.size + 1;
        totalRows = this.remoteRowCountEstimate;
      }
      content = this.pageCounter.call(this, size, currentRow, this.page, totalRows, this.max);
      switch (typeof content) {
        case "object":
          if (content instanceof Node) {
            while (this.pageCounterElement.firstChild)
              this.pageCounterElement.removeChild(this.pageCounterElement.firstChild);
            this.pageCounterElement.appendChild(content);
          } else {
            this.pageCounterElement.innerHTML = "";
            if (content != null) {
              console.warn("Page Counter Error - Page Counter has returned a type of object, the only valid page counter object return is an instance of Node, the page counter returned:", content);
            }
          }
          break;
        case "undefined":
          this.pageCounterElement.innerHTML = "";
          break;
        default:
          this.pageCounterElement.innerHTML = content;
      }
    }
  }
  _setPageButtons() {
    let leftSize = Math.floor((this.count - 1) / 2);
    let rightSize = Math.ceil((this.count - 1) / 2);
    let min = this.max - this.page + leftSize + 1 < this.count ? this.max - this.count + 1 : Math.max(this.page - leftSize, 1);
    let max = this.page <= rightSize ? Math.min(this.count, this.max) : Math.min(this.page + rightSize, this.max);
    while (this.pagesElement.firstChild)
      this.pagesElement.removeChild(this.pagesElement.firstChild);
    if (this.page == 1) {
      this.firstBut.disabled = true;
      this.prevBut.disabled = true;
    } else {
      this.firstBut.disabled = false;
      this.prevBut.disabled = false;
    }
    if (this.page == this.max) {
      this.lastBut.disabled = true;
      this.nextBut.disabled = true;
    } else {
      this.lastBut.disabled = false;
      this.nextBut.disabled = false;
    }
    for (let i2 = min; i2 <= max; i2++) {
      if (i2 > 0 && i2 <= this.max) {
        this.pagesElement.appendChild(this._generatePageButton(i2));
      }
    }
    this.footerRedraw();
  }
  _generatePageButton(page) {
    var button = document.createElement("button");
    button.classList.add("tabulator-page");
    if (page == this.page) {
      button.classList.add("active");
    }
    button.setAttribute("type", "button");
    button.setAttribute("role", "button");
    this.langBind("pagination|page_title", (value) => {
      button.setAttribute("aria-label", value + " " + page);
      button.setAttribute("title", value + " " + page);
    });
    button.setAttribute("data-page", page);
    button.textContent = page;
    button.addEventListener("click", (e) => {
      this.setPage(page);
    });
    return button;
  }
  previousPage() {
    if (this.page > 1) {
      this.page--;
      this.trackChanges();
      return this.trigger();
    } else {
      console.warn("Pagination Error - Previous page would be less than page 1:", 0);
      return Promise.reject();
    }
  }
  nextPage() {
    if (this.page < this.max) {
      this.page++;
      this.trackChanges();
      return this.trigger();
    } else {
      if (!this.progressiveLoad) {
        console.warn("Pagination Error - Next page would be greater than maximum page of " + this.max + ":", this.max + 1);
      }
      return Promise.reject();
    }
  }
  getPage() {
    return this.page;
  }
  getPageMax() {
    return this.max;
  }
  getPageSize(size) {
    return this.size;
  }
  getMode() {
    return this.mode;
  }
  getRows(data) {
    var actualRowPageSize = 0, output, start, end, actualStartRow;
    var actualRows = data.filter((row2) => {
      return row2.type === "row";
    });
    if (this.mode == "local") {
      output = [];
      this.setMaxRows(data.length);
      if (this.size === true) {
        start = 0;
        end = data.length;
      } else {
        start = this.size * (this.page - 1);
        end = start + parseInt(this.size);
      }
      this._setPageButtons();
      for (let i2 = start; i2 < end; i2++) {
        let row2 = data[i2];
        if (row2) {
          output.push(row2);
          if (row2.type === "row") {
            if (!actualStartRow) {
              actualStartRow = row2;
            }
            actualRowPageSize++;
          }
        }
      }
      this._setPageCounter(actualRows.length, actualRowPageSize, actualStartRow ? actualRows.indexOf(actualStartRow) + 1 : 0);
      return output;
    } else {
      this._setPageButtons();
      this._setPageCounter(actualRows.length);
      return data.slice(0);
    }
  }
  trigger() {
    var left;
    switch (this.mode) {
      case "local":
        left = this.table.rowManager.scrollLeft;
        this.refreshData();
        this.table.rowManager.scrollHorizontal(left);
        this.dispatchExternal("pageLoaded", this.getPage());
        return Promise.resolve();
      case "remote":
        this.dataChanging = true;
        return this.reloadData(null).finally(() => {
          this.dataChanging = false;
        });
      case "progressive_load":
      case "progressive_scroll":
        return this.reloadData(null, true);
      default:
        console.warn("Pagination Error - no such pagination mode:", this.mode);
        return Promise.reject();
    }
  }
  _parseRemoteData(data) {
    var margin;
    if (typeof data.last_page === "undefined") {
      console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").last_page || "last_page") + "' property");
    }
    if (data.data) {
      this.max = parseInt(data.last_page) || 1;
      this.remoteRowCountEstimate = typeof data.last_row !== "undefined" ? data.last_row : data.last_page * this.size - (this.page == data.last_page ? this.size - data.data.length : 0);
      if (this.progressiveLoad) {
        switch (this.mode) {
          case "progressive_load":
            if (this.page == 1) {
              this.table.rowManager.setData(data.data, false, this.page == 1);
            } else {
              this.table.rowManager.addRows(data.data);
            }
            if (this.page < this.max) {
              setTimeout(() => {
                this.nextPage();
              }, this.table.options.progressiveLoadDelay);
            }
            break;
          case "progressive_scroll":
            data = this.page === 1 ? data.data : this.table.rowManager.getData().concat(data.data);
            this.table.rowManager.setData(data, this.page !== 1, this.page == 1);
            margin = this.table.options.progressiveLoadScrollMargin || this.table.rowManager.element.clientHeight * 2;
            if (this.table.rowManager.element.scrollHeight <= this.table.rowManager.element.clientHeight + margin) {
              if (this.page < this.max) {
                setTimeout(() => {
                  this.nextPage();
                });
              }
            }
            break;
        }
        return false;
      } else {
        this.dispatchExternal("pageLoaded", this.getPage());
      }
    } else {
      console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").data || "data") + "' property");
    }
    return data.data;
  }
  footerRedraw() {
    var footer = this.table.footerManager.containerElement;
    if (Math.ceil(footer.clientWidth) - footer.scrollWidth < 0) {
      this.pagesElement.style.display = "none";
    } else {
      this.pagesElement.style.display = "";
      if (Math.ceil(footer.clientWidth) - footer.scrollWidth < 0) {
        this.pagesElement.style.display = "none";
      }
    }
  }
};
Page.moduleName = "page";
Page.pageCounters = defaultPageCounters;
var defaultReaders = {
  local: function(id, type) {
    var data = localStorage.getItem(id + "-" + type);
    return data ? JSON.parse(data) : false;
  },
  cookie: function(id, type) {
    var cookie = document.cookie, key = id + "-" + type, cookiePos = cookie.indexOf(key + "="), end, data;
    if (cookiePos > -1) {
      cookie = cookie.slice(cookiePos);
      end = cookie.indexOf(";");
      if (end > -1) {
        cookie = cookie.slice(0, end);
      }
      data = cookie.replace(key + "=", "");
    }
    return data ? JSON.parse(data) : false;
  }
};
var defaultWriters = {
  local: function(id, type, data) {
    localStorage.setItem(id + "-" + type, JSON.stringify(data));
  },
  cookie: function(id, type, data) {
    var expireDate = new Date();
    expireDate.setDate(expireDate.getDate() + 1e4);
    document.cookie = id + "-" + type + "=" + JSON.stringify(data) + "; expires=" + expireDate.toUTCString();
  }
};
var Persistence = class extends Module {
  constructor(table) {
    super(table);
    this.mode = "";
    this.id = "";
    this.defWatcherBlock = false;
    this.config = {};
    this.readFunc = false;
    this.writeFunc = false;
    this.registerTableOption("persistence", false);
    this.registerTableOption("persistenceID", "");
    this.registerTableOption("persistenceMode", true);
    this.registerTableOption("persistenceReaderFunc", false);
    this.registerTableOption("persistenceWriterFunc", false);
  }
  localStorageTest() {
    var testKey = "_tabulator_test";
    try {
      window.localStorage.setItem(testKey, testKey);
      window.localStorage.removeItem(testKey);
      return true;
    } catch (e) {
      return false;
    }
  }
  initialize() {
    if (this.table.options.persistence) {
      var mode = this.table.options.persistenceMode, id = this.table.options.persistenceID, retrievedData;
      this.mode = mode !== true ? mode : this.localStorageTest() ? "local" : "cookie";
      if (this.table.options.persistenceReaderFunc) {
        if (typeof this.table.options.persistenceReaderFunc === "function") {
          this.readFunc = this.table.options.persistenceReaderFunc;
        } else {
          if (Persistence.readers[this.table.options.persistenceReaderFunc]) {
            this.readFunc = Persistence.readers[this.table.options.persistenceReaderFunc];
          } else {
            console.warn("Persistence Read Error - invalid reader set", this.table.options.persistenceReaderFunc);
          }
        }
      } else {
        if (Persistence.readers[this.mode]) {
          this.readFunc = Persistence.readers[this.mode];
        } else {
          console.warn("Persistence Read Error - invalid reader set", this.mode);
        }
      }
      if (this.table.options.persistenceWriterFunc) {
        if (typeof this.table.options.persistenceWriterFunc === "function") {
          this.writeFunc = this.table.options.persistenceWriterFunc;
        } else {
          if (Persistence.writers[this.table.options.persistenceWriterFunc]) {
            this.writeFunc = Persistence.writers[this.table.options.persistenceWriterFunc];
          } else {
            console.warn("Persistence Write Error - invalid reader set", this.table.options.persistenceWriterFunc);
          }
        }
      } else {
        if (Persistence.writers[this.mode]) {
          this.writeFunc = Persistence.writers[this.mode];
        } else {
          console.warn("Persistence Write Error - invalid writer set", this.mode);
        }
      }
      this.id = "tabulator-" + (id || (this.table.element.getAttribute("id") || ""));
      this.config = {
        sort: this.table.options.persistence === true || this.table.options.persistence.sort,
        filter: this.table.options.persistence === true || this.table.options.persistence.filter,
        group: this.table.options.persistence === true || this.table.options.persistence.group,
        page: this.table.options.persistence === true || this.table.options.persistence.page,
        columns: this.table.options.persistence === true ? ["title", "width", "visible"] : this.table.options.persistence.columns
      };
      if (this.config.page) {
        retrievedData = this.retrieveData("page");
        if (retrievedData) {
          if (typeof retrievedData.paginationSize !== "undefined" && (this.config.page === true || this.config.page.size)) {
            this.table.options.paginationSize = retrievedData.paginationSize;
          }
          if (typeof retrievedData.paginationInitialPage !== "undefined" && (this.config.page === true || this.config.page.page)) {
            this.table.options.paginationInitialPage = retrievedData.paginationInitialPage;
          }
        }
      }
      if (this.config.group) {
        retrievedData = this.retrieveData("group");
        if (retrievedData) {
          if (typeof retrievedData.groupBy !== "undefined" && (this.config.group === true || this.config.group.groupBy)) {
            this.table.options.groupBy = retrievedData.groupBy;
          }
          if (typeof retrievedData.groupStartOpen !== "undefined" && (this.config.group === true || this.config.group.groupStartOpen)) {
            this.table.options.groupStartOpen = retrievedData.groupStartOpen;
          }
          if (typeof retrievedData.groupHeader !== "undefined" && (this.config.group === true || this.config.group.groupHeader)) {
            this.table.options.groupHeader = retrievedData.groupHeader;
          }
        }
      }
      if (this.config.columns) {
        this.table.options.columns = this.load("columns", this.table.options.columns);
        this.subscribe("column-init", this.initializeColumn.bind(this));
        this.subscribe("column-show", this.save.bind(this, "columns"));
        this.subscribe("column-hide", this.save.bind(this, "columns"));
        this.subscribe("column-moved", this.save.bind(this, "columns"));
      }
      this.subscribe("table-built", this.tableBuilt.bind(this), 0);
      this.subscribe("table-redraw", this.tableRedraw.bind(this));
      this.subscribe("filter-changed", this.eventSave.bind(this, "filter"));
      this.subscribe("sort-changed", this.eventSave.bind(this, "sort"));
      this.subscribe("group-changed", this.eventSave.bind(this, "group"));
      this.subscribe("page-changed", this.eventSave.bind(this, "page"));
      this.subscribe("column-resized", this.eventSave.bind(this, "columns"));
      this.subscribe("column-width", this.eventSave.bind(this, "columns"));
      this.subscribe("layout-refreshed", this.eventSave.bind(this, "columns"));
    }
    this.registerTableFunction("getColumnLayout", this.getColumnLayout.bind(this));
    this.registerTableFunction("setColumnLayout", this.setColumnLayout.bind(this));
  }
  eventSave(type) {
    if (this.config[type]) {
      this.save(type);
    }
  }
  tableBuilt() {
    var sorters, filters;
    if (this.config.sort) {
      sorters = this.load("sort");
      if (!sorters === false) {
        this.table.options.initialSort = sorters;
      }
    }
    if (this.config.filter) {
      filters = this.load("filter");
      if (!filters === false) {
        this.table.options.initialFilter = filters;
      }
    }
  }
  tableRedraw(force) {
    if (force && this.config.columns) {
      this.save("columns");
    }
  }
  getColumnLayout() {
    return this.parseColumns(this.table.columnManager.getColumns());
  }
  setColumnLayout(layout) {
    this.table.columnManager.setColumns(this.mergeDefinition(this.table.options.columns, layout));
    return true;
  }
  initializeColumn(column) {
    var def, keys;
    if (this.config.columns) {
      this.defWatcherBlock = true;
      def = column.getDefinition();
      keys = this.config.columns === true ? Object.keys(def) : this.config.columns;
      keys.forEach((key) => {
        var props = Object.getOwnPropertyDescriptor(def, key);
        var value = def[key];
        if (props) {
          Object.defineProperty(def, key, {
            set: (newValue) => {
              value = newValue;
              if (!this.defWatcherBlock) {
                this.save("columns");
              }
              if (props.set) {
                props.set(newValue);
              }
            },
            get: () => {
              if (props.get) {
                props.get();
              }
              return value;
            }
          });
        }
      });
      this.defWatcherBlock = false;
    }
  }
  load(type, current) {
    var data = this.retrieveData(type);
    if (current) {
      data = data ? this.mergeDefinition(current, data) : current;
    }
    return data;
  }
  retrieveData(type) {
    return this.readFunc ? this.readFunc(this.id, type) : false;
  }
  mergeDefinition(oldCols, newCols) {
    var output = [];
    newCols = newCols || [];
    newCols.forEach((column, to2) => {
      var from2 = this._findColumn(oldCols, column), keys;
      if (from2) {
        if (this.config.columns === true || this.config.columns == void 0) {
          keys = Object.keys(from2);
          keys.push("width");
        } else {
          keys = this.config.columns;
        }
        keys.forEach((key) => {
          if (key !== "columns" && typeof column[key] !== "undefined") {
            from2[key] = column[key];
          }
        });
        if (from2.columns) {
          from2.columns = this.mergeDefinition(from2.columns, column.columns);
        }
        output.push(from2);
      }
    });
    oldCols.forEach((column, i2) => {
      var from2 = this._findColumn(newCols, column);
      if (!from2) {
        if (output.length > i2) {
          output.splice(i2, 0, column);
        } else {
          output.push(column);
        }
      }
    });
    return output;
  }
  _findColumn(columns, subject) {
    var type = subject.columns ? "group" : subject.field ? "field" : "object";
    return columns.find(function(col) {
      switch (type) {
        case "group":
          return col.title === subject.title && col.columns.length === subject.columns.length;
        case "field":
          return col.field === subject.field;
        case "object":
          return col === subject;
      }
    });
  }
  save(type) {
    var data = {};
    switch (type) {
      case "columns":
        data = this.parseColumns(this.table.columnManager.getColumns());
        break;
      case "filter":
        data = this.table.modules.filter.getFilters();
        break;
      case "sort":
        data = this.validateSorters(this.table.modules.sort.getSort());
        break;
      case "group":
        data = this.getGroupConfig();
        break;
      case "page":
        data = this.getPageConfig();
        break;
    }
    if (this.writeFunc) {
      this.writeFunc(this.id, type, data);
    }
  }
  validateSorters(data) {
    data.forEach(function(item) {
      item.column = item.field;
      delete item.field;
    });
    return data;
  }
  getGroupConfig() {
    var data = {};
    if (this.config.group) {
      if (this.config.group === true || this.config.group.groupBy) {
        data.groupBy = this.table.options.groupBy;
      }
      if (this.config.group === true || this.config.group.groupStartOpen) {
        data.groupStartOpen = this.table.options.groupStartOpen;
      }
      if (this.config.group === true || this.config.group.groupHeader) {
        data.groupHeader = this.table.options.groupHeader;
      }
    }
    return data;
  }
  getPageConfig() {
    var data = {};
    if (this.config.page) {
      if (this.config.page === true || this.config.page.size) {
        data.paginationSize = this.table.modules.page.getPageSize();
      }
      if (this.config.page === true || this.config.page.page) {
        data.paginationInitialPage = this.table.modules.page.getPage();
      }
    }
    return data;
  }
  parseColumns(columns) {
    var definitions = [], excludedKeys = ["headerContextMenu", "headerMenu", "contextMenu", "clickMenu"];
    columns.forEach((column) => {
      var defStore = {}, colDef = column.getDefinition(), keys;
      if (column.isGroup) {
        defStore.title = colDef.title;
        defStore.columns = this.parseColumns(column.getColumns());
      } else {
        defStore.field = column.getField();
        if (this.config.columns === true || this.config.columns == void 0) {
          keys = Object.keys(colDef);
          keys.push("width");
          keys.push("visible");
        } else {
          keys = this.config.columns;
        }
        keys.forEach((key) => {
          switch (key) {
            case "width":
              defStore.width = column.getWidth();
              break;
            case "visible":
              defStore.visible = column.visible;
              break;
            default:
              if (typeof colDef[key] !== "function" && excludedKeys.indexOf(key) === -1) {
                defStore[key] = colDef[key];
              }
          }
        });
      }
      definitions.push(defStore);
    });
    return definitions;
  }
};
Persistence.moduleName = "persistence";
Persistence.moduleInitOrder = -10;
Persistence.readers = defaultReaders;
Persistence.writers = defaultWriters;
var Popup$1 = class extends Module {
  constructor(table) {
    super(table);
    this.columnSubscribers = {};
    this.registerTableOption("rowContextPopup", false);
    this.registerTableOption("rowClickPopup", false);
    this.registerTableOption("rowDblClickPopup", false);
    this.registerTableOption("groupContextPopup", false);
    this.registerTableOption("groupClickPopup", false);
    this.registerTableOption("groupDblClickPopup", false);
    this.registerColumnOption("headerContextPopup");
    this.registerColumnOption("headerClickPopup");
    this.registerColumnOption("headerDblClickPopup");
    this.registerColumnOption("headerPopup");
    this.registerColumnOption("headerPopupIcon");
    this.registerColumnOption("contextPopup");
    this.registerColumnOption("clickPopup");
    this.registerColumnOption("dblClickPopup");
    this.registerComponentFunction("cell", "popup", this._componentPopupCall.bind(this));
    this.registerComponentFunction("column", "popup", this._componentPopupCall.bind(this));
    this.registerComponentFunction("row", "popup", this._componentPopupCall.bind(this));
    this.registerComponentFunction("group", "popup", this._componentPopupCall.bind(this));
  }
  initialize() {
    this.initializeRowWatchers();
    this.initializeGroupWatchers();
    this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  _componentPopupCall(component, contents, position) {
    this.loadPopupEvent(contents, null, component, position);
  }
  initializeRowWatchers() {
    if (this.table.options.rowContextPopup) {
      this.subscribe("row-contextmenu", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup));
      this.table.on("rowTapHold", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup));
    }
    if (this.table.options.rowClickPopup) {
      this.subscribe("row-click", this.loadPopupEvent.bind(this, this.table.options.rowClickPopup));
    }
    if (this.table.options.rowDblClickPopup) {
      this.subscribe("row-dblclick", this.loadPopupEvent.bind(this, this.table.options.rowDblClickPopup));
    }
  }
  initializeGroupWatchers() {
    if (this.table.options.groupContextPopup) {
      this.subscribe("group-contextmenu", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup));
      this.table.on("groupTapHold", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup));
    }
    if (this.table.options.groupClickPopup) {
      this.subscribe("group-click", this.loadPopupEvent.bind(this, this.table.options.groupClickPopup));
    }
    if (this.table.options.groupDblClickPopup) {
      this.subscribe("group-dblclick", this.loadPopupEvent.bind(this, this.table.options.groupDblClickPopup));
    }
  }
  initializeColumn(column) {
    var def = column.definition;
    if (def.headerContextPopup && !this.columnSubscribers.headerContextPopup) {
      this.columnSubscribers.headerContextPopup = this.loadPopupTableColumnEvent.bind(this, "headerContextPopup");
      this.subscribe("column-contextmenu", this.columnSubscribers.headerContextPopup);
      this.table.on("headerTapHold", this.loadPopupTableColumnEvent.bind(this, "headerContextPopup"));
    }
    if (def.headerClickPopup && !this.columnSubscribers.headerClickPopup) {
      this.columnSubscribers.headerClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerClickPopup");
      this.subscribe("column-click", this.columnSubscribers.headerClickPopup);
    }
    if (def.headerDblClickPopup && !this.columnSubscribers.headerDblClickPopup) {
      this.columnSubscribers.headerDblClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerDblClickPopup");
      this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickPopup);
    }
    if (def.headerPopup) {
      this.initializeColumnHeaderPopup(column);
    }
    if (def.contextPopup && !this.columnSubscribers.contextPopup) {
      this.columnSubscribers.contextPopup = this.loadPopupTableCellEvent.bind(this, "contextPopup");
      this.subscribe("cell-contextmenu", this.columnSubscribers.contextPopup);
      this.table.on("cellTapHold", this.loadPopupTableCellEvent.bind(this, "contextPopup"));
    }
    if (def.clickPopup && !this.columnSubscribers.clickPopup) {
      this.columnSubscribers.clickPopup = this.loadPopupTableCellEvent.bind(this, "clickPopup");
      this.subscribe("cell-click", this.columnSubscribers.clickPopup);
    }
    if (def.dblClickPopup && !this.columnSubscribers.dblClickPopup) {
      this.columnSubscribers.dblClickPopup = this.loadPopupTableCellEvent.bind(this, "dblClickPopup");
      this.subscribe("cell-click", this.columnSubscribers.dblClickPopup);
    }
  }
  initializeColumnHeaderPopup(column) {
    var icon = column.definition.headerPopupIcon, headerPopupEl;
    headerPopupEl = document.createElement("span");
    headerPopupEl.classList.add("tabulator-header-popup-button");
    if (icon) {
      if (typeof icon === "function") {
        icon = icon(column.getComponent());
      }
      if (icon instanceof HTMLElement) {
        headerPopupEl.appendChild(icon);
      } else {
        headerPopupEl.innerHTML = icon;
      }
    } else {
      headerPopupEl.innerHTML = "&vellip;";
    }
    headerPopupEl.addEventListener("click", (e) => {
      e.stopPropagation();
      e.preventDefault();
      this.loadPopupEvent(column.definition.headerPopup, e, column);
    });
    column.titleElement.insertBefore(headerPopupEl, column.titleElement.firstChild);
  }
  loadPopupTableCellEvent(option, e, cell) {
    if (cell._cell) {
      cell = cell._cell;
    }
    if (cell.column.definition[option]) {
      this.loadPopupEvent(cell.column.definition[option], e, cell);
    }
  }
  loadPopupTableColumnEvent(option, e, column) {
    if (column._column) {
      column = column._column;
    }
    if (column.definition[option]) {
      this.loadPopupEvent(column.definition[option], e, column);
    }
  }
  loadPopupEvent(contents, e, component, position) {
    var renderedCallback;
    function onRendered(callback2) {
      renderedCallback = callback2;
    }
    if (component._group) {
      component = component._group;
    } else if (component._row) {
      component = component._row;
    }
    contents = typeof contents == "function" ? contents.call(this.table, e, component.getComponent(), onRendered) : contents;
    this.loadPopup(e, component, contents, renderedCallback, position);
  }
  loadPopup(e, component, contents, renderedCallback, position) {
    var touch = !(e instanceof MouseEvent), contentsEl, popup;
    if (contents instanceof HTMLElement) {
      contentsEl = contents;
    } else {
      contentsEl = document.createElement("div");
      contentsEl.innerHTML = contents;
    }
    contentsEl.classList.add("tabulator-popup");
    contentsEl.addEventListener("click", (e2) => {
      e2.stopPropagation();
    });
    if (!touch) {
      e.preventDefault();
    }
    popup = this.popup(contentsEl);
    if (typeof renderedCallback === "function") {
      popup.renderCallback(renderedCallback);
    }
    if (e) {
      popup.show(e);
    } else {
      popup.show(component.getElement(), position || "center");
    }
    popup.hideOnBlur(() => {
      this.dispatchExternal("popupClosed", component.getComponent());
    });
    this.dispatchExternal("popupOpened", component.getComponent());
  }
};
Popup$1.moduleName = "popup";
var Print = class extends Module {
  constructor(table) {
    super(table);
    this.element = false;
    this.manualBlock = false;
    this.beforeprintEventHandler = null;
    this.afterprintEventHandler = null;
    this.registerTableOption("printAsHtml", false);
    this.registerTableOption("printFormatter", false);
    this.registerTableOption("printHeader", false);
    this.registerTableOption("printFooter", false);
    this.registerTableOption("printStyled", true);
    this.registerTableOption("printRowRange", "visible");
    this.registerTableOption("printConfig", {});
    this.registerColumnOption("print");
    this.registerColumnOption("titlePrint");
  }
  initialize() {
    if (this.table.options.printAsHtml) {
      this.beforeprintEventHandler = this.replaceTable.bind(this);
      this.afterprintEventHandler = this.cleanup.bind(this);
      window.addEventListener("beforeprint", this.beforeprintEventHandler);
      window.addEventListener("afterprint", this.afterprintEventHandler);
      this.subscribe("table-destroy", this.destroy.bind(this));
    }
    this.registerTableFunction("print", this.printFullscreen.bind(this));
  }
  destroy() {
    if (this.table.options.printAsHtml) {
      window.removeEventListener("beforeprint", this.beforeprintEventHandler);
      window.removeEventListener("afterprint", this.afterprintEventHandler);
    }
  }
  replaceTable() {
    if (!this.manualBlock) {
      this.element = document.createElement("div");
      this.element.classList.add("tabulator-print-table");
      this.element.appendChild(this.table.modules.export.generateTable(this.table.options.printConfig, this.table.options.printStyled, this.table.options.printRowRange, "print"));
      this.table.element.style.display = "none";
      this.table.element.parentNode.insertBefore(this.element, this.table.element);
    }
  }
  cleanup() {
    document.body.classList.remove("tabulator-print-fullscreen-hide");
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
      this.table.element.style.display = "";
    }
  }
  printFullscreen(visible, style, config) {
    var scrollX = window.scrollX, scrollY = window.scrollY, headerEl = document.createElement("div"), footerEl = document.createElement("div"), tableEl = this.table.modules.export.generateTable(typeof config != "undefined" ? config : this.table.options.printConfig, typeof style != "undefined" ? style : this.table.options.printStyled, visible || this.table.options.printRowRange, "print"), headerContent, footerContent;
    this.manualBlock = true;
    this.element = document.createElement("div");
    this.element.classList.add("tabulator-print-fullscreen");
    if (this.table.options.printHeader) {
      headerEl.classList.add("tabulator-print-header");
      headerContent = typeof this.table.options.printHeader == "function" ? this.table.options.printHeader.call(this.table) : this.table.options.printHeader;
      if (typeof headerContent == "string") {
        headerEl.innerHTML = headerContent;
      } else {
        headerEl.appendChild(headerContent);
      }
      this.element.appendChild(headerEl);
    }
    this.element.appendChild(tableEl);
    if (this.table.options.printFooter) {
      footerEl.classList.add("tabulator-print-footer");
      footerContent = typeof this.table.options.printFooter == "function" ? this.table.options.printFooter.call(this.table) : this.table.options.printFooter;
      if (typeof footerContent == "string") {
        footerEl.innerHTML = footerContent;
      } else {
        footerEl.appendChild(footerContent);
      }
      this.element.appendChild(footerEl);
    }
    document.body.classList.add("tabulator-print-fullscreen-hide");
    document.body.appendChild(this.element);
    if (this.table.options.printFormatter) {
      this.table.options.printFormatter(this.element, tableEl);
    }
    window.print();
    this.cleanup();
    window.scrollTo(scrollX, scrollY);
    this.manualBlock = false;
  }
};
Print.moduleName = "print";
var ReactiveData = class extends Module {
  constructor(table) {
    super(table);
    this.data = false;
    this.blocked = false;
    this.origFuncs = {};
    this.currentVersion = 0;
    this.registerTableOption("reactiveData", false);
  }
  initialize() {
    if (this.table.options.reactiveData) {
      this.subscribe("cell-value-save-before", this.block.bind(this, "cellsave"));
      this.subscribe("cell-value-save-after", this.unblock.bind(this, "cellsave"));
      this.subscribe("row-data-save-before", this.block.bind(this, "rowsave"));
      this.subscribe("row-data-save-after", this.unblock.bind(this, "rowsave"));
      this.subscribe("row-data-init-after", this.watchRow.bind(this));
      this.subscribe("data-processing", this.watchData.bind(this));
      this.subscribe("table-destroy", this.unwatchData.bind(this));
    }
  }
  watchData(data) {
    var self2 = this, version3;
    this.currentVersion++;
    version3 = this.currentVersion;
    this.unwatchData();
    this.data = data;
    this.origFuncs.push = data.push;
    Object.defineProperty(this.data, "push", {
      enumerable: false,
      configurable: true,
      value: function() {
        var args = Array.from(arguments), result;
        if (!self2.blocked && version3 === self2.currentVersion) {
          self2.block("data-push");
          args.forEach((arg) => {
            self2.table.rowManager.addRowActual(arg, false);
          });
          result = self2.origFuncs.push.apply(data, arguments);
          self2.unblock("data-push");
        }
        return result;
      }
    });
    this.origFuncs.unshift = data.unshift;
    Object.defineProperty(this.data, "unshift", {
      enumerable: false,
      configurable: true,
      value: function() {
        var args = Array.from(arguments), result;
        if (!self2.blocked && version3 === self2.currentVersion) {
          self2.block("data-unshift");
          args.forEach((arg) => {
            self2.table.rowManager.addRowActual(arg, true);
          });
          result = self2.origFuncs.unshift.apply(data, arguments);
          self2.unblock("data-unshift");
        }
        return result;
      }
    });
    this.origFuncs.shift = data.shift;
    Object.defineProperty(this.data, "shift", {
      enumerable: false,
      configurable: true,
      value: function() {
        var row2, result;
        if (!self2.blocked && version3 === self2.currentVersion) {
          self2.block("data-shift");
          if (self2.data.length) {
            row2 = self2.table.rowManager.getRowFromDataObject(self2.data[0]);
            if (row2) {
              row2.deleteActual();
            }
          }
          result = self2.origFuncs.shift.call(data);
          self2.unblock("data-shift");
        }
        return result;
      }
    });
    this.origFuncs.pop = data.pop;
    Object.defineProperty(this.data, "pop", {
      enumerable: false,
      configurable: true,
      value: function() {
        var row2, result;
        if (!self2.blocked && version3 === self2.currentVersion) {
          self2.block("data-pop");
          if (self2.data.length) {
            row2 = self2.table.rowManager.getRowFromDataObject(self2.data[self2.data.length - 1]);
            if (row2) {
              row2.deleteActual();
            }
          }
          result = self2.origFuncs.pop.call(data);
          self2.unblock("data-pop");
        }
        return result;
      }
    });
    this.origFuncs.splice = data.splice;
    Object.defineProperty(this.data, "splice", {
      enumerable: false,
      configurable: true,
      value: function() {
        var args = Array.from(arguments), start = args[0] < 0 ? data.length + args[0] : args[0], end = args[1], newRows = args[2] ? args.slice(2) : false, startRow, result;
        if (!self2.blocked && version3 === self2.currentVersion) {
          self2.block("data-splice");
          if (newRows) {
            startRow = data[start] ? self2.table.rowManager.getRowFromDataObject(data[start]) : false;
            if (startRow) {
              newRows.forEach((rowData) => {
                self2.table.rowManager.addRowActual(rowData, true, startRow, true);
              });
            } else {
              newRows = newRows.slice().reverse();
              newRows.forEach((rowData) => {
                self2.table.rowManager.addRowActual(rowData, true, false, true);
              });
            }
          }
          if (end !== 0) {
            var oldRows = data.slice(start, typeof args[1] === "undefined" ? args[1] : start + end);
            oldRows.forEach((rowData, i2) => {
              var row2 = self2.table.rowManager.getRowFromDataObject(rowData);
              if (row2) {
                row2.deleteActual(i2 !== oldRows.length - 1);
              }
            });
          }
          if (newRows || end !== 0) {
            self2.table.rowManager.reRenderInPosition();
          }
          result = self2.origFuncs.splice.apply(data, arguments);
          self2.unblock("data-splice");
        }
        return result;
      }
    });
  }
  unwatchData() {
    if (this.data !== false) {
      for (var key in this.origFuncs) {
        Object.defineProperty(this.data, key, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: this.origFuncs.key
        });
      }
    }
  }
  watchRow(row2) {
    var data = row2.getData();
    for (var key in data) {
      this.watchKey(row2, data, key);
    }
    if (this.table.options.dataTree) {
      this.watchTreeChildren(row2);
    }
  }
  watchTreeChildren(row2) {
    var self2 = this, childField = row2.getData()[this.table.options.dataTreeChildField], origFuncs = {};
    if (childField) {
      origFuncs.push = childField.push;
      Object.defineProperty(childField, "push", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self2.blocked) {
            self2.block("tree-push");
            var result = origFuncs.push.apply(childField, arguments);
            this.rebuildTree(row2);
            self2.unblock("tree-push");
          }
          return result;
        }
      });
      origFuncs.unshift = childField.unshift;
      Object.defineProperty(childField, "unshift", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self2.blocked) {
            self2.block("tree-unshift");
            var result = origFuncs.unshift.apply(childField, arguments);
            this.rebuildTree(row2);
            self2.unblock("tree-unshift");
          }
          return result;
        }
      });
      origFuncs.shift = childField.shift;
      Object.defineProperty(childField, "shift", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self2.blocked) {
            self2.block("tree-shift");
            var result = origFuncs.shift.call(childField);
            this.rebuildTree(row2);
            self2.unblock("tree-shift");
          }
          return result;
        }
      });
      origFuncs.pop = childField.pop;
      Object.defineProperty(childField, "pop", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self2.blocked) {
            self2.block("tree-pop");
            var result = origFuncs.pop.call(childField);
            this.rebuildTree(row2);
            self2.unblock("tree-pop");
          }
          return result;
        }
      });
      origFuncs.splice = childField.splice;
      Object.defineProperty(childField, "splice", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self2.blocked) {
            self2.block("tree-splice");
            var result = origFuncs.splice.apply(childField, arguments);
            this.rebuildTree(row2);
            self2.unblock("tree-splice");
          }
          return result;
        }
      });
    }
  }
  rebuildTree(row2) {
    this.table.modules.dataTree.initializeRow(row2);
    this.table.modules.dataTree.layoutRow(row2);
    this.table.rowManager.refreshActiveData("tree", false, true);
  }
  watchKey(row2, data, key) {
    var self2 = this, props = Object.getOwnPropertyDescriptor(data, key), value = data[key], version3 = this.currentVersion;
    Object.defineProperty(data, key, {
      set: (newValue) => {
        value = newValue;
        if (!self2.blocked && version3 === self2.currentVersion) {
          self2.block("key");
          var update = {};
          update[key] = newValue;
          row2.updateData(update);
          self2.unblock("key");
        }
        if (props.set) {
          props.set(newValue);
        }
      },
      get: () => {
        if (props.get) {
          props.get();
        }
        return value;
      }
    });
  }
  unwatchRow(row2) {
    var data = row2.getData();
    for (var key in data) {
      Object.defineProperty(data, key, {
        value: data[key]
      });
    }
  }
  block(key) {
    if (!this.blocked) {
      this.blocked = key;
    }
  }
  unblock(key) {
    if (this.blocked === key) {
      this.blocked = false;
    }
  }
};
ReactiveData.moduleName = "reactiveData";
var ResizeColumns = class extends Module {
  constructor(table) {
    super(table);
    this.startColumn = false;
    this.startX = false;
    this.startWidth = false;
    this.latestX = false;
    this.handle = null;
    this.initialNextColumn = null;
    this.nextColumn = null;
    this.initialized = false;
    this.registerColumnOption("resizable", true);
    this.registerTableOption("resizableColumnFit", false);
  }
  initialize() {
    this.subscribe("column-rendered", this.layoutColumnHeader.bind(this));
  }
  initializeEventWatchers() {
    if (!this.initialized) {
      this.subscribe("cell-rendered", this.layoutCellHandles.bind(this));
      this.subscribe("cell-delete", this.deInitializeComponent.bind(this));
      this.subscribe("cell-height", this.resizeHandle.bind(this));
      this.subscribe("column-moved", this.columnLayoutUpdated.bind(this));
      this.subscribe("column-hide", this.deInitializeColumn.bind(this));
      this.subscribe("column-show", this.columnLayoutUpdated.bind(this));
      this.subscribe("column-width", this.columnWidthUpdated.bind(this));
      this.subscribe("column-delete", this.deInitializeComponent.bind(this));
      this.subscribe("column-height", this.resizeHandle.bind(this));
      this.initialized = true;
    }
  }
  layoutCellHandles(cell) {
    if (cell.row.type === "row") {
      this.deInitializeComponent(cell);
      this.initializeColumn("cell", cell, cell.column, cell.element);
    }
  }
  layoutColumnHeader(column) {
    if (column.definition.resizable) {
      this.initializeEventWatchers();
      this.deInitializeComponent(column);
      this.initializeColumn("header", column, column, column.element);
    }
  }
  columnLayoutUpdated(column) {
    var prev = column.prevColumn();
    this.reinitializeColumn(column);
    if (prev) {
      this.reinitializeColumn(prev);
    }
  }
  columnWidthUpdated(column) {
    if (column.modules.frozen) {
      if (this.table.modules.frozenColumns.leftColumns.includes(column)) {
        this.table.modules.frozenColumns.leftColumns.forEach((col) => {
          this.reinitializeColumn(col);
        });
      } else if (this.table.modules.frozenColumns.rightColumns.includes(column)) {
        this.table.modules.frozenColumns.rightColumns.forEach((col) => {
          this.reinitializeColumn(col);
        });
      }
    }
  }
  frozenColumnOffset(column) {
    var offset2 = false;
    if (column.modules.frozen) {
      offset2 = column.modules.frozen.marginValue;
      if (column.modules.frozen.position === "left") {
        offset2 += column.getWidth() - 3;
      } else {
        if (offset2) {
          offset2 -= 3;
        }
      }
    }
    return offset2 !== false ? offset2 + "px" : false;
  }
  reinitializeColumn(column) {
    var frozenOffset = this.frozenColumnOffset(column);
    column.cells.forEach((cell) => {
      if (cell.modules.resize && cell.modules.resize.handleEl) {
        if (frozenOffset) {
          cell.modules.resize.handleEl.style[column.modules.frozen.position] = frozenOffset;
        }
        cell.element.after(cell.modules.resize.handleEl);
      }
    });
    if (column.modules.resize && column.modules.resize.handleEl) {
      if (frozenOffset) {
        column.modules.resize.handleEl.style[column.modules.frozen.position] = frozenOffset;
      }
      column.element.after(column.modules.resize.handleEl);
    }
  }
  initializeColumn(type, component, column, element) {
    var self2 = this, variableHeight = false, mode = column.definition.resizable, config = {}, nearestColumn = column.getLastColumn();
    if (type === "header") {
      variableHeight = column.definition.formatter == "textarea" || column.definition.variableHeight;
      config = { variableHeight };
    }
    if ((mode === true || mode == type) && this._checkResizability(nearestColumn)) {
      var handle2 = document.createElement("span");
      handle2.className = "tabulator-col-resize-handle";
      handle2.addEventListener("click", function(e) {
        e.stopPropagation();
      });
      var handleDown = function(e) {
        self2.startColumn = column;
        self2.initialNextColumn = self2.nextColumn = nearestColumn.nextColumn();
        self2._mouseDown(e, nearestColumn, handle2);
      };
      handle2.addEventListener("mousedown", handleDown);
      handle2.addEventListener("touchstart", handleDown, { passive: true });
      handle2.addEventListener("dblclick", (e) => {
        var oldWidth = nearestColumn.getWidth();
        e.stopPropagation();
        nearestColumn.reinitializeWidth(true);
        if (oldWidth !== nearestColumn.getWidth()) {
          self2.dispatch("column-resized", nearestColumn);
          self2.table.externalEvents.dispatch("columnResized", nearestColumn.getComponent());
        }
      });
      if (column.modules.frozen) {
        handle2.style.position = "sticky";
        handle2.style[column.modules.frozen.position] = this.frozenColumnOffset(column);
      }
      config.handleEl = handle2;
      if (element.parentNode && column.visible) {
        element.after(handle2);
      }
    }
    component.modules.resize = config;
  }
  deInitializeColumn(column) {
    this.deInitializeComponent(column);
    column.cells.forEach((cell) => {
      this.deInitializeComponent(cell);
    });
  }
  deInitializeComponent(component) {
    var handleEl;
    if (component.modules.resize) {
      handleEl = component.modules.resize.handleEl;
      if (handleEl && handleEl.parentElement) {
        handleEl.parentElement.removeChild(handleEl);
      }
    }
  }
  resizeHandle(component, height) {
    if (component.modules.resize && component.modules.resize.handleEl) {
      component.modules.resize.handleEl.style.height = height;
    }
  }
  _checkResizability(column) {
    return column.definition.resizable;
  }
  _mouseDown(e, column, handle2) {
    var self2 = this;
    self2.table.element.classList.add("tabulator-block-select");
    function mouseMove2(e2) {
      var x = typeof e2.screenX === "undefined" ? e2.touches[0].screenX : e2.screenX, startDiff = x - self2.startX, moveDiff = x - self2.latestX, blockedBefore, blockedAfter;
      self2.latestX = x;
      if (self2.table.rtl) {
        startDiff = -startDiff;
        moveDiff = -moveDiff;
      }
      blockedBefore = column.width == column.minWidth || column.width == column.maxWidth;
      column.setWidth(self2.startWidth + startDiff);
      blockedAfter = column.width == column.minWidth || column.width == column.maxWidth;
      if (moveDiff < 0) {
        self2.nextColumn = self2.initialNextColumn;
      }
      if (self2.table.options.resizableColumnFit && self2.nextColumn && !(blockedBefore && blockedAfter)) {
        let colWidth = self2.nextColumn.getWidth();
        if (moveDiff > 0) {
          if (colWidth <= self2.nextColumn.minWidth) {
            self2.nextColumn = self2.nextColumn.nextColumn();
          }
        }
        if (self2.nextColumn) {
          self2.nextColumn.setWidth(self2.nextColumn.getWidth() - moveDiff);
        }
      }
      self2.table.columnManager.rerenderColumns(true);
      if (!self2.table.browserSlow && column.modules.resize && column.modules.resize.variableHeight) {
        column.checkCellHeights();
      }
    }
    function mouseUp2(e2) {
      if (self2.startColumn.modules.edit) {
        self2.startColumn.modules.edit.blocked = false;
      }
      if (self2.table.browserSlow && column.modules.resize && column.modules.resize.variableHeight) {
        column.checkCellHeights();
      }
      document.body.removeEventListener("mouseup", mouseUp2);
      document.body.removeEventListener("mousemove", mouseMove2);
      handle2.removeEventListener("touchmove", mouseMove2);
      handle2.removeEventListener("touchend", mouseUp2);
      self2.table.element.classList.remove("tabulator-block-select");
      if (self2.startWidth !== column.getWidth()) {
        self2.table.columnManager.verticalAlignHeaders();
        self2.dispatch("column-resized", column);
        self2.table.externalEvents.dispatch("columnResized", column.getComponent());
      }
    }
    e.stopPropagation();
    if (self2.startColumn.modules.edit) {
      self2.startColumn.modules.edit.blocked = true;
    }
    self2.startX = typeof e.screenX === "undefined" ? e.touches[0].screenX : e.screenX;
    self2.latestX = self2.startX;
    self2.startWidth = column.getWidth();
    document.body.addEventListener("mousemove", mouseMove2);
    document.body.addEventListener("mouseup", mouseUp2);
    handle2.addEventListener("touchmove", mouseMove2, { passive: true });
    handle2.addEventListener("touchend", mouseUp2);
  }
};
ResizeColumns.moduleName = "resizeColumns";
var ResizeRows = class extends Module {
  constructor(table) {
    super(table);
    this.startColumn = false;
    this.startY = false;
    this.startHeight = false;
    this.handle = null;
    this.prevHandle = null;
    this.registerTableOption("resizableRows", false);
  }
  initialize() {
    if (this.table.options.resizableRows) {
      this.subscribe("row-layout-after", this.initializeRow.bind(this));
    }
  }
  initializeRow(row2) {
    var self2 = this, rowEl = row2.getElement();
    var handle2 = document.createElement("div");
    handle2.className = "tabulator-row-resize-handle";
    var prevHandle = document.createElement("div");
    prevHandle.className = "tabulator-row-resize-handle prev";
    handle2.addEventListener("click", function(e) {
      e.stopPropagation();
    });
    var handleDown = function(e) {
      self2.startRow = row2;
      self2._mouseDown(e, row2, handle2);
    };
    handle2.addEventListener("mousedown", handleDown);
    handle2.addEventListener("touchstart", handleDown, { passive: true });
    prevHandle.addEventListener("click", function(e) {
      e.stopPropagation();
    });
    var prevHandleDown = function(e) {
      var prevRow = self2.table.rowManager.prevDisplayRow(row2);
      if (prevRow) {
        self2.startRow = prevRow;
        self2._mouseDown(e, prevRow, prevHandle);
      }
    };
    prevHandle.addEventListener("mousedown", prevHandleDown);
    prevHandle.addEventListener("touchstart", prevHandleDown, { passive: true });
    rowEl.appendChild(handle2);
    rowEl.appendChild(prevHandle);
  }
  _mouseDown(e, row2, handle2) {
    var self2 = this;
    self2.table.element.classList.add("tabulator-block-select");
    function mouseMove2(e2) {
      row2.setHeight(self2.startHeight + ((typeof e2.screenY === "undefined" ? e2.touches[0].screenY : e2.screenY) - self2.startY));
    }
    function mouseUp2(e2) {
      document.body.removeEventListener("mouseup", mouseMove2);
      document.body.removeEventListener("mousemove", mouseMove2);
      handle2.removeEventListener("touchmove", mouseMove2);
      handle2.removeEventListener("touchend", mouseUp2);
      self2.table.element.classList.remove("tabulator-block-select");
      self2.dispatchExternal("rowResized", row2.getComponent());
    }
    e.stopPropagation();
    self2.startY = typeof e.screenY === "undefined" ? e.touches[0].screenY : e.screenY;
    self2.startHeight = row2.getHeight();
    document.body.addEventListener("mousemove", mouseMove2);
    document.body.addEventListener("mouseup", mouseUp2);
    handle2.addEventListener("touchmove", mouseMove2, { passive: true });
    handle2.addEventListener("touchend", mouseUp2);
  }
};
ResizeRows.moduleName = "resizeRows";
var ResizeTable = class extends Module {
  constructor(table) {
    super(table);
    this.binding = false;
    this.visibilityObserver = false;
    this.resizeObserver = false;
    this.containerObserver = false;
    this.tableHeight = 0;
    this.tableWidth = 0;
    this.containerHeight = 0;
    this.containerWidth = 0;
    this.autoResize = false;
    this.visible = false;
    this.initialized = false;
    this.initialRedraw = false;
    this.registerTableOption("autoResize", true);
  }
  initialize() {
    if (this.table.options.autoResize) {
      var table = this.table, tableStyle;
      this.tableHeight = table.element.clientHeight;
      this.tableWidth = table.element.clientWidth;
      if (table.element.parentNode) {
        this.containerHeight = table.element.parentNode.clientHeight;
        this.containerWidth = table.element.parentNode.clientWidth;
      }
      if (typeof IntersectionObserver !== "undefined" && typeof ResizeObserver !== "undefined" && table.rowManager.getRenderMode() === "virtual") {
        this.initializeVisibilityObserver();
        this.autoResize = true;
        this.resizeObserver = new ResizeObserver((entry) => {
          if (!table.browserMobile || table.browserMobile && !table.modules.edit.currentCell) {
            var nodeHeight = Math.floor(entry[0].contentRect.height);
            var nodeWidth = Math.floor(entry[0].contentRect.width);
            if (this.tableHeight != nodeHeight || this.tableWidth != nodeWidth) {
              this.tableHeight = nodeHeight;
              this.tableWidth = nodeWidth;
              if (table.element.parentNode) {
                this.containerHeight = table.element.parentNode.clientHeight;
                this.containerWidth = table.element.parentNode.clientWidth;
              }
              this.redrawTable();
            }
          }
        });
        this.resizeObserver.observe(table.element);
        tableStyle = window.getComputedStyle(table.element);
        if (this.table.element.parentNode && !this.table.rowManager.fixedHeight && (tableStyle.getPropertyValue("max-height") || tableStyle.getPropertyValue("min-height"))) {
          this.containerObserver = new ResizeObserver((entry) => {
            if (!table.browserMobile || table.browserMobile && !table.modules.edit.currentCell) {
              var nodeHeight = Math.floor(entry[0].contentRect.height);
              var nodeWidth = Math.floor(entry[0].contentRect.width);
              if (this.containerHeight != nodeHeight || this.containerWidth != nodeWidth) {
                this.containerHeight = nodeHeight;
                this.containerWidth = nodeWidth;
                this.tableHeight = table.element.clientHeight;
                this.tableWidth = table.element.clientWidth;
              }
              this.redrawTable();
            }
          });
          this.containerObserver.observe(this.table.element.parentNode);
        }
        this.subscribe("table-resize", this.tableResized.bind(this));
      } else {
        this.binding = function() {
          if (!table.browserMobile || table.browserMobile && !table.modules.edit.currentCell) {
            table.columnManager.rerenderColumns(true);
            table.redraw();
          }
        };
        window.addEventListener("resize", this.binding);
      }
      this.subscribe("table-destroy", this.clearBindings.bind(this));
    }
  }
  initializeVisibilityObserver() {
    this.visibilityObserver = new IntersectionObserver((entries) => {
      this.visible = entries[0].isIntersecting;
      if (!this.initialized) {
        this.initialized = true;
        this.initialRedraw = !this.visible;
      } else {
        if (this.visible) {
          this.redrawTable(this.initialRedraw);
          this.initialRedraw = false;
        }
      }
    });
    this.visibilityObserver.observe(this.table.element);
  }
  redrawTable(force) {
    if (this.initialized && this.visible) {
      this.table.columnManager.rerenderColumns(true);
      this.table.redraw(force);
    }
  }
  tableResized() {
    this.table.rowManager.redraw();
  }
  clearBindings() {
    if (this.binding) {
      window.removeEventListener("resize", this.binding);
    }
    if (this.resizeObserver) {
      this.resizeObserver.unobserve(this.table.element);
    }
    if (this.visibilityObserver) {
      this.visibilityObserver.unobserve(this.table.element);
    }
    if (this.containerObserver) {
      this.containerObserver.unobserve(this.table.element.parentNode);
    }
  }
};
ResizeTable.moduleName = "resizeTable";
var ResponsiveLayout = class extends Module {
  constructor(table) {
    super(table);
    this.columns = [];
    this.hiddenColumns = [];
    this.mode = "";
    this.index = 0;
    this.collapseFormatter = [];
    this.collapseStartOpen = true;
    this.collapseHandleColumn = false;
    this.registerTableOption("responsiveLayout", false);
    this.registerTableOption("responsiveLayoutCollapseStartOpen", true);
    this.registerTableOption("responsiveLayoutCollapseUseFormatters", true);
    this.registerTableOption("responsiveLayoutCollapseFormatter", false);
    this.registerColumnOption("responsive");
  }
  initialize() {
    if (this.table.options.responsiveLayout) {
      this.subscribe("column-layout", this.initializeColumn.bind(this));
      this.subscribe("column-show", this.updateColumnVisibility.bind(this));
      this.subscribe("column-hide", this.updateColumnVisibility.bind(this));
      this.subscribe("columns-loaded", this.initializeResponsivity.bind(this));
      this.subscribe("column-moved", this.initializeResponsivity.bind(this));
      this.subscribe("column-add", this.initializeResponsivity.bind(this));
      this.subscribe("column-delete", this.initializeResponsivity.bind(this));
      this.subscribe("table-redrawing", this.tableRedraw.bind(this));
      if (this.table.options.responsiveLayout === "collapse") {
        this.subscribe("row-data-changed", this.generateCollapsedRowContent.bind(this));
        this.subscribe("row-init", this.initializeRow.bind(this));
        this.subscribe("row-layout", this.layoutRow.bind(this));
      }
    }
  }
  tableRedraw(force) {
    if (["fitColumns", "fitDataStretch"].indexOf(this.layoutMode()) === -1) {
      if (!force) {
        this.update();
      }
    }
  }
  initializeResponsivity() {
    var columns = [];
    this.mode = this.table.options.responsiveLayout;
    this.collapseFormatter = this.table.options.responsiveLayoutCollapseFormatter || this.formatCollapsedData;
    this.collapseStartOpen = this.table.options.responsiveLayoutCollapseStartOpen;
    this.hiddenColumns = [];
    this.table.columnManager.columnsByIndex.forEach((column, i2) => {
      if (column.modules.responsive) {
        if (column.modules.responsive.order && column.modules.responsive.visible) {
          column.modules.responsive.index = i2;
          columns.push(column);
          if (!column.visible && this.mode === "collapse") {
            this.hiddenColumns.push(column);
          }
        }
      }
    });
    columns = columns.reverse();
    columns = columns.sort((a, b) => {
      var diff = b.modules.responsive.order - a.modules.responsive.order;
      return diff || b.modules.responsive.index - a.modules.responsive.index;
    });
    this.columns = columns;
    if (this.mode === "collapse") {
      this.generateCollapsedContent();
    }
    for (let col of this.table.columnManager.columnsByIndex) {
      if (col.definition.formatter == "responsiveCollapse") {
        this.collapseHandleColumn = col;
        break;
      }
    }
    if (this.collapseHandleColumn) {
      if (this.hiddenColumns.length) {
        this.collapseHandleColumn.show();
      } else {
        this.collapseHandleColumn.hide();
      }
    }
  }
  initializeColumn(column) {
    var def = column.getDefinition();
    column.modules.responsive = { order: typeof def.responsive === "undefined" ? 1 : def.responsive, visible: def.visible === false ? false : true };
  }
  initializeRow(row2) {
    var el;
    if (row2.type !== "calc") {
      el = document.createElement("div");
      el.classList.add("tabulator-responsive-collapse");
      row2.modules.responsiveLayout = {
        element: el,
        open: this.collapseStartOpen
      };
      if (!this.collapseStartOpen) {
        el.style.display = "none";
      }
    }
  }
  layoutRow(row2) {
    var rowEl = row2.getElement();
    if (row2.modules.responsiveLayout) {
      rowEl.appendChild(row2.modules.responsiveLayout.element);
      this.generateCollapsedRowContent(row2);
    }
  }
  updateColumnVisibility(column, responsiveToggle) {
    if (!responsiveToggle && column.modules.responsive) {
      column.modules.responsive.visible = column.visible;
      this.initializeResponsivity();
    }
  }
  hideColumn(column) {
    var colCount = this.hiddenColumns.length;
    column.hide(false, true);
    if (this.mode === "collapse") {
      this.hiddenColumns.unshift(column);
      this.generateCollapsedContent();
      if (this.collapseHandleColumn && !colCount) {
        this.collapseHandleColumn.show();
      }
    }
  }
  showColumn(column) {
    var index2;
    column.show(false, true);
    column.setWidth(column.getWidth());
    if (this.mode === "collapse") {
      index2 = this.hiddenColumns.indexOf(column);
      if (index2 > -1) {
        this.hiddenColumns.splice(index2, 1);
      }
      this.generateCollapsedContent();
      if (this.collapseHandleColumn && !this.hiddenColumns.length) {
        this.collapseHandleColumn.hide();
      }
    }
  }
  update() {
    var working = true;
    while (working) {
      let width = this.table.modules.layout.getMode() == "fitColumns" ? this.table.columnManager.getFlexBaseWidth() : this.table.columnManager.getWidth();
      let diff = (this.table.options.headerVisible ? this.table.columnManager.element.clientWidth : this.table.element.clientWidth) - width;
      if (diff < 0) {
        let column = this.columns[this.index];
        if (column) {
          this.hideColumn(column);
          this.index++;
        } else {
          working = false;
        }
      } else {
        let column = this.columns[this.index - 1];
        if (column) {
          if (diff > 0) {
            if (diff >= column.getWidth()) {
              this.showColumn(column);
              this.index--;
            } else {
              working = false;
            }
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      }
      if (!this.table.rowManager.activeRowsCount) {
        this.table.rowManager.renderEmptyScroll();
      }
    }
  }
  generateCollapsedContent() {
    var rows3 = this.table.rowManager.getDisplayRows();
    rows3.forEach((row2) => {
      this.generateCollapsedRowContent(row2);
    });
  }
  generateCollapsedRowContent(row2) {
    var el, contents;
    if (row2.modules.responsiveLayout) {
      el = row2.modules.responsiveLayout.element;
      while (el.firstChild)
        el.removeChild(el.firstChild);
      contents = this.collapseFormatter(this.generateCollapsedRowData(row2));
      if (contents) {
        el.appendChild(contents);
      }
    }
  }
  generateCollapsedRowData(row2) {
    var data = row2.getData(), output = [], mockCellComponent;
    this.hiddenColumns.forEach((column) => {
      var value = column.getFieldValue(data);
      if (column.definition.title && column.field) {
        if (column.modules.format && this.table.options.responsiveLayoutCollapseUseFormatters) {
          let onRendered = function(callback2) {
            callback2();
          };
          mockCellComponent = {
            value: false,
            data: {},
            getValue: function() {
              return value;
            },
            getData: function() {
              return data;
            },
            getElement: function() {
              return document.createElement("div");
            },
            getRow: function() {
              return row2.getComponent();
            },
            getColumn: function() {
              return column.getComponent();
            },
            getTable: () => {
              return this.table;
            }
          };
          output.push({
            field: column.field,
            title: column.definition.title,
            value: column.modules.format.formatter.call(this.table.modules.format, mockCellComponent, column.modules.format.params, onRendered)
          });
        } else {
          output.push({
            field: column.field,
            title: column.definition.title,
            value
          });
        }
      }
    });
    return output;
  }
  formatCollapsedData(data) {
    var list2 = document.createElement("table");
    data.forEach(function(item) {
      var row2 = document.createElement("tr");
      var titleData = document.createElement("td");
      var valueData = document.createElement("td");
      var node_content;
      var titleHighlight = document.createElement("strong");
      titleData.appendChild(titleHighlight);
      this.langBind("columns|" + item.field, function(text) {
        titleHighlight.innerHTML = text || item.title;
      });
      if (item.value instanceof Node) {
        node_content = document.createElement("div");
        node_content.appendChild(item.value);
        valueData.appendChild(node_content);
      } else {
        valueData.innerHTML = item.value;
      }
      row2.appendChild(titleData);
      row2.appendChild(valueData);
      list2.appendChild(row2);
    }, this);
    return Object.keys(data).length ? list2 : "";
  }
};
ResponsiveLayout.moduleName = "responsiveLayout";
var SelectRow = class extends Module {
  constructor(table) {
    super(table);
    this.selecting = false;
    this.lastClickedRow = false;
    this.selectPrev = [];
    this.selectedRows = [];
    this.headerCheckboxElement = null;
    this.registerTableOption("selectable", "highlight");
    this.registerTableOption("selectableRangeMode", "drag");
    this.registerTableOption("selectableRollingSelection", true);
    this.registerTableOption("selectablePersistence", true);
    this.registerTableOption("selectableCheck", function(data, row2) {
      return true;
    });
    this.registerTableFunction("selectRow", this.selectRows.bind(this));
    this.registerTableFunction("deselectRow", this.deselectRows.bind(this));
    this.registerTableFunction("toggleSelectRow", this.toggleRow.bind(this));
    this.registerTableFunction("getSelectedRows", this.getSelectedRows.bind(this));
    this.registerTableFunction("getSelectedData", this.getSelectedData.bind(this));
    this.registerComponentFunction("row", "select", this.selectRows.bind(this));
    this.registerComponentFunction("row", "deselect", this.deselectRows.bind(this));
    this.registerComponentFunction("row", "toggleSelect", this.toggleRow.bind(this));
    this.registerComponentFunction("row", "isSelected", this.isRowSelected.bind(this));
  }
  initialize() {
    if (this.table.options.selectable !== false) {
      this.subscribe("row-init", this.initializeRow.bind(this));
      this.subscribe("row-deleting", this.rowDeleted.bind(this));
      this.subscribe("rows-wipe", this.clearSelectionData.bind(this));
      this.subscribe("rows-retrieve", this.rowRetrieve.bind(this));
      if (this.table.options.selectable && !this.table.options.selectablePersistence) {
        this.subscribe("data-refreshing", this.deselectRows.bind(this));
      }
    }
  }
  rowRetrieve(type, prevValue) {
    return type === "selected" ? this.selectedRows : prevValue;
  }
  rowDeleted(row2) {
    this._deselectRow(row2, true);
  }
  clearSelectionData(silent) {
    this.selecting = false;
    this.lastClickedRow = false;
    this.selectPrev = [];
    this.selectedRows = [];
    if (silent !== true) {
      this._rowSelectionChanged();
    }
  }
  initializeRow(row2) {
    var self2 = this, element = row2.getElement();
    var endSelect = function() {
      setTimeout(function() {
        self2.selecting = false;
      }, 50);
      document.body.removeEventListener("mouseup", endSelect);
    };
    row2.modules.select = { selected: false };
    if (self2.checkRowSelectability(row2)) {
      element.classList.add("tabulator-selectable");
      element.classList.remove("tabulator-unselectable");
      if (self2.table.options.selectable && self2.table.options.selectable != "highlight") {
        if (self2.table.options.selectableRangeMode === "click") {
          element.addEventListener("click", this.handleComplexRowClick.bind(this, row2));
        } else {
          element.addEventListener("click", function(e) {
            if (!self2.table.modExists("edit") || !self2.table.modules.edit.getCurrentCell()) {
              self2.table._clearSelection();
            }
            if (!self2.selecting) {
              self2.toggleRow(row2);
            }
          });
          element.addEventListener("mousedown", function(e) {
            if (e.shiftKey) {
              self2.table._clearSelection();
              self2.selecting = true;
              self2.selectPrev = [];
              document.body.addEventListener("mouseup", endSelect);
              document.body.addEventListener("keyup", endSelect);
              self2.toggleRow(row2);
              return false;
            }
          });
          element.addEventListener("mouseenter", function(e) {
            if (self2.selecting) {
              self2.table._clearSelection();
              self2.toggleRow(row2);
              if (self2.selectPrev[1] == row2) {
                self2.toggleRow(self2.selectPrev[0]);
              }
            }
          });
          element.addEventListener("mouseout", function(e) {
            if (self2.selecting) {
              self2.table._clearSelection();
              self2.selectPrev.unshift(row2);
            }
          });
        }
      }
    } else {
      element.classList.add("tabulator-unselectable");
      element.classList.remove("tabulator-selectable");
    }
  }
  handleComplexRowClick(row2, e) {
    if (e.shiftKey) {
      this.table._clearSelection();
      this.lastClickedRow = this.lastClickedRow || row2;
      var lastClickedRowIdx = this.table.rowManager.getDisplayRowIndex(this.lastClickedRow);
      var rowIdx = this.table.rowManager.getDisplayRowIndex(row2);
      var fromRowIdx = lastClickedRowIdx <= rowIdx ? lastClickedRowIdx : rowIdx;
      var toRowIdx = lastClickedRowIdx >= rowIdx ? lastClickedRowIdx : rowIdx;
      var rows3 = this.table.rowManager.getDisplayRows().slice(0);
      var toggledRows = rows3.splice(fromRowIdx, toRowIdx - fromRowIdx + 1);
      if (e.ctrlKey || e.metaKey) {
        toggledRows.forEach((toggledRow) => {
          if (toggledRow !== this.lastClickedRow) {
            if (this.table.options.selectable !== true && !this.isRowSelected(row2)) {
              if (this.selectedRows.length < this.table.options.selectable) {
                this.toggleRow(toggledRow);
              }
            } else {
              this.toggleRow(toggledRow);
            }
          }
        });
        this.lastClickedRow = row2;
      } else {
        this.deselectRows(void 0, true);
        if (this.table.options.selectable !== true) {
          if (toggledRows.length > this.table.options.selectable) {
            toggledRows = toggledRows.slice(0, this.table.options.selectable);
          }
        }
        this.selectRows(toggledRows);
      }
      this.table._clearSelection();
    } else if (e.ctrlKey || e.metaKey) {
      this.toggleRow(row2);
      this.lastClickedRow = row2;
    } else {
      this.deselectRows(void 0, true);
      this.selectRows(row2);
      this.lastClickedRow = row2;
    }
  }
  checkRowSelectability(row2) {
    if (row2.type === "row") {
      return this.table.options.selectableCheck.call(this.table, row2.getComponent());
    }
    return false;
  }
  toggleRow(row2) {
    if (this.checkRowSelectability(row2)) {
      if (row2.modules.select && row2.modules.select.selected) {
        this._deselectRow(row2);
      } else {
        this._selectRow(row2);
      }
    }
  }
  selectRows(rows3) {
    var rowMatch;
    switch (typeof rows3) {
      case "undefined":
        this.table.rowManager.rows.forEach((row2) => {
          this._selectRow(row2, true, true);
        });
        this._rowSelectionChanged();
        break;
      case "string":
        rowMatch = this.table.rowManager.findRow(rows3);
        if (rowMatch) {
          this._selectRow(rowMatch, true, true);
          this._rowSelectionChanged();
        } else {
          rowMatch = this.table.rowManager.getRows(rows3);
          rowMatch.forEach((row2) => {
            this._selectRow(row2, true, true);
          });
          if (rowMatch.length) {
            this._rowSelectionChanged();
          }
        }
        break;
      default:
        if (Array.isArray(rows3)) {
          rows3.forEach((row2) => {
            this._selectRow(row2, true, true);
          });
          this._rowSelectionChanged();
        } else {
          this._selectRow(rows3, false, true);
        }
        break;
    }
  }
  _selectRow(rowInfo, silent, force) {
    if (!isNaN(this.table.options.selectable) && this.table.options.selectable !== true && !force) {
      if (this.selectedRows.length >= this.table.options.selectable) {
        if (this.table.options.selectableRollingSelection) {
          this._deselectRow(this.selectedRows[0]);
        } else {
          return false;
        }
      }
    }
    var row2 = this.table.rowManager.findRow(rowInfo);
    if (row2) {
      if (this.selectedRows.indexOf(row2) == -1) {
        row2.getElement().classList.add("tabulator-selected");
        if (!row2.modules.select) {
          row2.modules.select = {};
        }
        row2.modules.select.selected = true;
        if (row2.modules.select.checkboxEl) {
          row2.modules.select.checkboxEl.checked = true;
        }
        this.selectedRows.push(row2);
        if (this.table.options.dataTreeSelectPropagate) {
          this.childRowSelection(row2, true);
        }
        this.dispatchExternal("rowSelected", row2.getComponent());
        this._rowSelectionChanged(silent);
      }
    } else {
      if (!silent) {
        console.warn("Selection Error - No such row found, ignoring selection:" + rowInfo);
      }
    }
  }
  isRowSelected(row2) {
    return this.selectedRows.indexOf(row2) !== -1;
  }
  deselectRows(rows3, silent) {
    var self2 = this, rowCount;
    if (typeof rows3 == "undefined") {
      rowCount = self2.selectedRows.length;
      for (let i2 = 0; i2 < rowCount; i2++) {
        self2._deselectRow(self2.selectedRows[0], true);
      }
      if (rowCount) {
        self2._rowSelectionChanged(silent);
      }
    } else {
      if (Array.isArray(rows3)) {
        rows3.forEach(function(row2) {
          self2._deselectRow(row2, true);
        });
        self2._rowSelectionChanged(silent);
      } else {
        self2._deselectRow(rows3, silent);
      }
    }
  }
  _deselectRow(rowInfo, silent) {
    var self2 = this, row2 = self2.table.rowManager.findRow(rowInfo), index2;
    if (row2) {
      index2 = self2.selectedRows.findIndex(function(selectedRow) {
        return selectedRow == row2;
      });
      if (index2 > -1) {
        row2.getElement().classList.remove("tabulator-selected");
        if (!row2.modules.select) {
          row2.modules.select = {};
        }
        row2.modules.select.selected = false;
        if (row2.modules.select.checkboxEl) {
          row2.modules.select.checkboxEl.checked = false;
        }
        self2.selectedRows.splice(index2, 1);
        if (this.table.options.dataTreeSelectPropagate) {
          this.childRowSelection(row2, false);
        }
        this.dispatchExternal("rowDeselected", row2.getComponent());
        self2._rowSelectionChanged(silent);
      }
    } else {
      if (!silent) {
        console.warn("Deselection Error - No such row found, ignoring selection:" + rowInfo);
      }
    }
  }
  getSelectedData() {
    var data = [];
    this.selectedRows.forEach(function(row2) {
      data.push(row2.getData());
    });
    return data;
  }
  getSelectedRows() {
    var rows3 = [];
    this.selectedRows.forEach(function(row2) {
      rows3.push(row2.getComponent());
    });
    return rows3;
  }
  _rowSelectionChanged(silent) {
    if (this.headerCheckboxElement) {
      if (this.selectedRows.length === 0) {
        this.headerCheckboxElement.checked = false;
        this.headerCheckboxElement.indeterminate = false;
      } else if (this.table.rowManager.rows.length === this.selectedRows.length) {
        this.headerCheckboxElement.checked = true;
        this.headerCheckboxElement.indeterminate = false;
      } else {
        this.headerCheckboxElement.indeterminate = true;
        this.headerCheckboxElement.checked = false;
      }
    }
    if (!silent) {
      this.dispatchExternal("rowSelectionChanged", this.getSelectedData(), this.getSelectedRows());
    }
  }
  registerRowSelectCheckbox(row2, element) {
    if (!row2._row.modules.select) {
      row2._row.modules.select = {};
    }
    row2._row.modules.select.checkboxEl = element;
  }
  registerHeaderSelectCheckbox(element) {
    this.headerCheckboxElement = element;
  }
  childRowSelection(row2, select2) {
    var children = this.table.modules.dataTree.getChildren(row2, true);
    if (select2) {
      for (let child of children) {
        this._selectRow(child, true);
      }
    } else {
      for (let child of children) {
        this._deselectRow(child, true);
      }
    }
  }
};
SelectRow.moduleName = "selectRow";
function number$1(a, b, aRow, bRow, column, dir, params) {
  var alignEmptyValues = params.alignEmptyValues;
  var decimal = params.decimalSeparator;
  var thousand = params.thousandSeparator;
  var emptyAlign = 0;
  a = String(a);
  b = String(b);
  if (thousand) {
    a = a.split(thousand).join("");
    b = b.split(thousand).join("");
  }
  if (decimal) {
    a = a.split(decimal).join(".");
    b = b.split(decimal).join(".");
  }
  a = parseFloat(a);
  b = parseFloat(b);
  if (isNaN(a)) {
    emptyAlign = isNaN(b) ? 0 : -1;
  } else if (isNaN(b)) {
    emptyAlign = 1;
  } else {
    return a - b;
  }
  if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    emptyAlign *= -1;
  }
  return emptyAlign;
}
function string(a, b, aRow, bRow, column, dir, params) {
  var alignEmptyValues = params.alignEmptyValues;
  var emptyAlign = 0;
  var locale;
  if (!a) {
    emptyAlign = !b ? 0 : -1;
  } else if (!b) {
    emptyAlign = 1;
  } else {
    switch (typeof params.locale) {
      case "boolean":
        if (params.locale) {
          locale = this.langLocale();
        }
        break;
      case "string":
        locale = params.locale;
        break;
    }
    return String(a).toLowerCase().localeCompare(String(b).toLowerCase(), locale);
  }
  if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    emptyAlign *= -1;
  }
  return emptyAlign;
}
function datetime$2(a, b, aRow, bRow, column, dir, params) {
  var DT = window.DateTime || luxon.DateTime;
  var format = params.format || "dd/MM/yyyy HH:mm:ss", alignEmptyValues = params.alignEmptyValues, emptyAlign = 0;
  if (typeof DT != "undefined") {
    if (!DT.isDateTime(a)) {
      if (format === "iso") {
        a = DT.fromISO(String(a));
      } else {
        a = DT.fromFormat(String(a), format);
      }
    }
    if (!DT.isDateTime(b)) {
      if (format === "iso") {
        b = DT.fromISO(String(b));
      } else {
        b = DT.fromFormat(String(b), format);
      }
    }
    if (!a.isValid) {
      emptyAlign = !b.isValid ? 0 : -1;
    } else if (!b.isValid) {
      emptyAlign = 1;
    } else {
      return a - b;
    }
    if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
      emptyAlign *= -1;
    }
    return emptyAlign;
  } else {
    console.error("Sort Error - 'datetime' sorter is dependant on luxon.js");
  }
}
function date$1(a, b, aRow, bRow, column, dir, params) {
  if (!params.format) {
    params.format = "dd/MM/yyyy";
  }
  return datetime$2.call(this, a, b, aRow, bRow, column, dir, params);
}
function time$1(a, b, aRow, bRow, column, dir, params) {
  if (!params.format) {
    params.format = "HH:mm";
  }
  return datetime$2.call(this, a, b, aRow, bRow, column, dir, params);
}
function boolean(a, b, aRow, bRow, column, dir, params) {
  var el1 = a === true || a === "true" || a === "True" || a === 1 ? 1 : 0;
  var el2 = b === true || b === "true" || b === "True" || b === 1 ? 1 : 0;
  return el1 - el2;
}
function array(a, b, aRow, bRow, column, dir, params) {
  var type = params.type || "length", alignEmptyValues = params.alignEmptyValues, emptyAlign = 0;
  function calc(value) {
    var result;
    switch (type) {
      case "length":
        result = value.length;
        break;
      case "sum":
        result = value.reduce(function(c, d) {
          return c + d;
        });
        break;
      case "max":
        result = Math.max.apply(null, value);
        break;
      case "min":
        result = Math.min.apply(null, value);
        break;
      case "avg":
        result = value.reduce(function(c, d) {
          return c + d;
        }) / value.length;
        break;
    }
    return result;
  }
  if (!Array.isArray(a)) {
    emptyAlign = !Array.isArray(b) ? 0 : -1;
  } else if (!Array.isArray(b)) {
    emptyAlign = 1;
  } else {
    return calc(b) - calc(a);
  }
  if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    emptyAlign *= -1;
  }
  return emptyAlign;
}
function exists(a, b, aRow, bRow, column, dir, params) {
  var el1 = typeof a == "undefined" ? 0 : 1;
  var el2 = typeof b == "undefined" ? 0 : 1;
  return el1 - el2;
}
function alphanum(as, bs, aRow, bRow, column, dir, params) {
  var a, b, a1, b1, i2 = 0, L, rx = /(\d+)|(\D+)/g, rd = /\d/;
  var alignEmptyValues = params.alignEmptyValues;
  var emptyAlign = 0;
  if (!as && as !== 0) {
    emptyAlign = !bs && bs !== 0 ? 0 : -1;
  } else if (!bs && bs !== 0) {
    emptyAlign = 1;
  } else {
    if (isFinite(as) && isFinite(bs))
      return as - bs;
    a = String(as).toLowerCase();
    b = String(bs).toLowerCase();
    if (a === b)
      return 0;
    if (!(rd.test(a) && rd.test(b)))
      return a > b ? 1 : -1;
    a = a.match(rx);
    b = b.match(rx);
    L = a.length > b.length ? b.length : a.length;
    while (i2 < L) {
      a1 = a[i2];
      b1 = b[i2++];
      if (a1 !== b1) {
        if (isFinite(a1) && isFinite(b1)) {
          if (a1.charAt(0) === "0")
            a1 = "." + a1;
          if (b1.charAt(0) === "0")
            b1 = "." + b1;
          return a1 - b1;
        } else
          return a1 > b1 ? 1 : -1;
      }
    }
    return a.length > b.length;
  }
  if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    emptyAlign *= -1;
  }
  return emptyAlign;
}
var defaultSorters = {
  number: number$1,
  string,
  date: date$1,
  time: time$1,
  datetime: datetime$2,
  boolean,
  array,
  exists,
  alphanum
};
var Sort = class extends Module {
  constructor(table) {
    super(table);
    this.sortList = [];
    this.changed = false;
    this.registerTableOption("sortMode", "local");
    this.registerTableOption("initialSort", false);
    this.registerTableOption("columnHeaderSortMulti", true);
    this.registerTableOption("sortOrderReverse", false);
    this.registerTableOption("headerSortElement", "<div class='tabulator-arrow'></div>");
    this.registerTableOption("headerSortClickElement", "header");
    this.registerColumnOption("sorter");
    this.registerColumnOption("sorterParams");
    this.registerColumnOption("headerSort", true);
    this.registerColumnOption("headerSortStartingDir");
    this.registerColumnOption("headerSortTristate");
  }
  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this));
    this.subscribe("table-built", this.tableBuilt.bind(this));
    this.registerDataHandler(this.sort.bind(this), 20);
    this.registerTableFunction("setSort", this.userSetSort.bind(this));
    this.registerTableFunction("getSorters", this.getSort.bind(this));
    this.registerTableFunction("clearSort", this.clearSort.bind(this));
    if (this.table.options.sortMode === "remote") {
      this.subscribe("data-params", this.remoteSortParams.bind(this));
    }
  }
  tableBuilt() {
    if (this.table.options.initialSort) {
      this.setSort(this.table.options.initialSort);
    }
  }
  remoteSortParams(data, config, silent, params) {
    var sorters = this.getSort();
    sorters.forEach((item) => {
      delete item.column;
    });
    params.sort = sorters;
    return params;
  }
  userSetSort(sortList, dir) {
    this.setSort(sortList, dir);
    this.refreshSort();
  }
  clearSort() {
    this.clear();
    this.refreshSort();
  }
  initializeColumn(column) {
    var sorter2 = false, colEl, arrowEl;
    switch (typeof column.definition.sorter) {
      case "string":
        if (Sort.sorters[column.definition.sorter]) {
          sorter2 = Sort.sorters[column.definition.sorter];
        } else {
          console.warn("Sort Error - No such sorter found: ", column.definition.sorter);
        }
        break;
      case "function":
        sorter2 = column.definition.sorter;
        break;
    }
    column.modules.sort = {
      sorter: sorter2,
      dir: "none",
      params: column.definition.sorterParams || {},
      startingDir: column.definition.headerSortStartingDir || "asc",
      tristate: column.definition.headerSortTristate
    };
    if (column.definition.headerSort !== false) {
      colEl = column.getElement();
      colEl.classList.add("tabulator-sortable");
      arrowEl = document.createElement("div");
      arrowEl.classList.add("tabulator-col-sorter");
      switch (this.table.options.headerSortClickElement) {
        case "icon":
          arrowEl.classList.add("tabulator-col-sorter-element");
          break;
        case "header":
          colEl.classList.add("tabulator-col-sorter-element");
          break;
        default:
          colEl.classList.add("tabulator-col-sorter-element");
          break;
      }
      switch (this.table.options.headerSortElement) {
        case "function":
          break;
        case "object":
          arrowEl.appendChild(this.table.options.headerSortElement);
          break;
        default:
          arrowEl.innerHTML = this.table.options.headerSortElement;
      }
      column.titleHolderElement.appendChild(arrowEl);
      column.modules.sort.element = arrowEl;
      this.setColumnHeaderSortIcon(column, "none");
      (this.table.options.headerSortClickElement === "icon" ? arrowEl : colEl).addEventListener("click", (e) => {
        var dir = "", sorters = [], match2 = false;
        if (column.modules.sort) {
          if (column.modules.sort.tristate) {
            if (column.modules.sort.dir == "none") {
              dir = column.modules.sort.startingDir;
            } else {
              if (column.modules.sort.dir == column.modules.sort.startingDir) {
                dir = column.modules.sort.dir == "asc" ? "desc" : "asc";
              } else {
                dir = "none";
              }
            }
          } else {
            switch (column.modules.sort.dir) {
              case "asc":
                dir = "desc";
                break;
              case "desc":
                dir = "asc";
                break;
              default:
                dir = column.modules.sort.startingDir;
            }
          }
          if (this.table.options.columnHeaderSortMulti && (e.shiftKey || e.ctrlKey)) {
            sorters = this.getSort();
            match2 = sorters.findIndex((sorter3) => {
              return sorter3.field === column.getField();
            });
            if (match2 > -1) {
              sorters[match2].dir = dir;
              match2 = sorters.splice(match2, 1)[0];
              if (dir != "none") {
                sorters.push(match2);
              }
            } else {
              if (dir != "none") {
                sorters.push({ column, dir });
              }
            }
            this.setSort(sorters);
          } else {
            if (dir == "none") {
              this.clear();
            } else {
              this.setSort(column, dir);
            }
          }
          this.refreshSort();
        }
      });
    }
  }
  refreshSort() {
    if (this.table.options.sortMode === "remote") {
      this.reloadData(null, false, false);
    } else {
      this.refreshData(true);
    }
  }
  hasChanged() {
    var changed = this.changed;
    this.changed = false;
    return changed;
  }
  getSort() {
    var self2 = this, sorters = [];
    self2.sortList.forEach(function(item) {
      if (item.column) {
        sorters.push({ column: item.column.getComponent(), field: item.column.getField(), dir: item.dir });
      }
    });
    return sorters;
  }
  setSort(sortList, dir) {
    var self2 = this, newSortList = [];
    if (!Array.isArray(sortList)) {
      sortList = [{ column: sortList, dir }];
    }
    sortList.forEach(function(item) {
      var column;
      column = self2.table.columnManager.findColumn(item.column);
      if (column) {
        item.column = column;
        newSortList.push(item);
        self2.changed = true;
      } else {
        console.warn("Sort Warning - Sort field does not exist and is being ignored: ", item.column);
      }
    });
    self2.sortList = newSortList;
    this.dispatch("sort-changed");
  }
  clear() {
    this.setSort([]);
  }
  findSorter(column) {
    var row2 = this.table.rowManager.activeRows[0], sorter2 = "string", field, value;
    if (row2) {
      row2 = row2.getData();
      field = column.getField();
      if (field) {
        value = column.getFieldValue(row2);
        switch (typeof value) {
          case "undefined":
            sorter2 = "string";
            break;
          case "boolean":
            sorter2 = "boolean";
            break;
          default:
            if (!isNaN(value) && value !== "") {
              sorter2 = "number";
            } else {
              if (value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)) {
                sorter2 = "alphanum";
              }
            }
            break;
        }
      }
    }
    return Sort.sorters[sorter2];
  }
  sort(data) {
    var self2 = this, sortList = this.table.options.sortOrderReverse ? self2.sortList.slice().reverse() : self2.sortList, sortListActual = [], rowComponents = [];
    if (this.subscribedExternal("dataSorting")) {
      this.dispatchExternal("dataSorting", self2.getSort());
    }
    self2.clearColumnHeaders();
    if (this.table.options.sortMode !== "remote") {
      sortList.forEach(function(item, i2) {
        var sortObj;
        if (item.column) {
          sortObj = item.column.modules.sort;
          if (sortObj) {
            if (!sortObj.sorter) {
              sortObj.sorter = self2.findSorter(item.column);
            }
            item.params = typeof sortObj.params === "function" ? sortObj.params(item.column.getComponent(), item.dir) : sortObj.params;
            sortListActual.push(item);
          }
          self2.setColumnHeader(item.column, item.dir);
        }
      });
      if (sortListActual.length) {
        self2._sortItems(data, sortListActual);
      }
    } else {
      sortList.forEach(function(item, i2) {
        self2.setColumnHeader(item.column, item.dir);
      });
    }
    if (this.subscribedExternal("dataSorted")) {
      data.forEach((row2) => {
        rowComponents.push(row2.getComponent());
      });
      this.dispatchExternal("dataSorted", self2.getSort(), rowComponents);
    }
    return data;
  }
  clearColumnHeaders() {
    this.table.columnManager.getRealColumns().forEach((column) => {
      if (column.modules.sort) {
        column.modules.sort.dir = "none";
        column.getElement().setAttribute("aria-sort", "none");
        this.setColumnHeaderSortIcon(column, "none");
      }
    });
  }
  setColumnHeader(column, dir) {
    column.modules.sort.dir = dir;
    column.getElement().setAttribute("aria-sort", dir === "asc" ? "ascending" : "descending");
    this.setColumnHeaderSortIcon(column, dir);
  }
  setColumnHeaderSortIcon(column, dir) {
    var sortEl = column.modules.sort.element, arrowEl;
    if (column.definition.headerSort && typeof this.table.options.headerSortElement === "function") {
      while (sortEl.firstChild)
        sortEl.removeChild(sortEl.firstChild);
      arrowEl = this.table.options.headerSortElement.call(this.table, column.getComponent(), dir);
      if (typeof arrowEl === "object") {
        sortEl.appendChild(arrowEl);
      } else {
        sortEl.innerHTML = arrowEl;
      }
    }
  }
  _sortItems(data, sortList) {
    var sorterCount = sortList.length - 1;
    data.sort((a, b) => {
      var result;
      for (var i2 = sorterCount; i2 >= 0; i2--) {
        let sortItem = sortList[i2];
        result = this._sortRow(a, b, sortItem.column, sortItem.dir, sortItem.params);
        if (result !== 0) {
          break;
        }
      }
      return result;
    });
  }
  _sortRow(a, b, column, dir, params) {
    var el1Comp, el2Comp;
    var el1 = dir == "asc" ? a : b;
    var el2 = dir == "asc" ? b : a;
    a = column.getFieldValue(el1.getData());
    b = column.getFieldValue(el2.getData());
    a = typeof a !== "undefined" ? a : "";
    b = typeof b !== "undefined" ? b : "";
    el1Comp = el1.getComponent();
    el2Comp = el2.getComponent();
    return column.modules.sort.sorter.call(this, a, b, el1Comp, el2Comp, column.getComponent(), dir, params);
  }
};
Sort.moduleName = "sort";
Sort.sorters = defaultSorters;
var Tooltip2 = class extends Module {
  constructor(table) {
    super(table);
    this.tooltipSubscriber = null, this.headerSubscriber = null, this.timeout = null;
    this.popupInstance = null;
    this.registerTableOption("tooltipGenerationMode", void 0);
    this.registerTableOption("tooltipDelay", 300);
    this.registerColumnOption("tooltip");
    this.registerColumnOption("headerTooltip");
  }
  initialize() {
    this.deprecatedOptionsCheck();
    this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheckMsg("tooltipGenerationMode", "This option is no longer needed as tooltips are always generated on hover now");
  }
  initializeColumn(column) {
    if (column.definition.headerTooltip && !this.headerSubscriber) {
      this.headerSubscriber = true;
      this.subscribe("column-mousemove", this.mousemoveCheck.bind(this, "headerTooltip"));
      this.subscribe("column-mouseout", this.mouseoutCheck.bind(this, "headerTooltip"));
    }
    if (column.definition.tooltip && !this.tooltipSubscriber) {
      this.tooltipSubscriber = true;
      this.subscribe("cell-mousemove", this.mousemoveCheck.bind(this, "tooltip"));
      this.subscribe("cell-mouseout", this.mouseoutCheck.bind(this, "tooltip"));
    }
  }
  mousemoveCheck(action, e, component) {
    var tooltip = action === "tooltip" ? component.column.definition.tooltip : component.definition.headerTooltip;
    if (tooltip) {
      this.clearPopup();
      this.timeout = setTimeout(this.loadTooltip.bind(this, e, component, tooltip), this.table.options.tooltipDelay);
    }
  }
  mouseoutCheck(action, e, component) {
    if (!this.popupInstance) {
      this.clearPopup();
    }
  }
  clearPopup(action, e, component) {
    clearTimeout(this.timeout);
    this.timeout = null;
    if (this.popupInstance) {
      this.popupInstance.hide();
    }
  }
  loadTooltip(e, component, tooltip) {
    var contentsEl, renderedCallback, coords;
    function onRendered(callback2) {
      renderedCallback = callback2;
    }
    if (typeof tooltip === "function") {
      tooltip = tooltip(e, component.getComponent(), onRendered);
    }
    if (tooltip instanceof HTMLElement) {
      contentsEl = tooltip;
    } else {
      contentsEl = document.createElement("div");
      if (tooltip === true) {
        if (component instanceof Cell) {
          tooltip = component.value;
        } else {
          if (component.definition.field) {
            this.langBind("columns|" + component.definition.field, (value) => {
              contentsEl.innerHTML = tooltip = value || component.definition.title;
            });
          } else {
            tooltip = component.definition.title;
          }
        }
      }
      contentsEl.innerHTML = tooltip;
    }
    if (tooltip || tooltip === 0 || tooltip === false) {
      contentsEl.classList.add("tabulator-tooltip");
      contentsEl.addEventListener("mousemove", (e2) => e2.preventDefault());
      this.popupInstance = this.popup(contentsEl);
      if (typeof renderedCallback === "function") {
        this.popupInstance.renderCallback(renderedCallback);
      }
      coords = this.popupInstance.containerEventCoords(e);
      this.popupInstance.show(coords.x + 15, coords.y + 15).hideOnBlur(() => {
        this.dispatchExternal("TooltipClosed", component.getComponent());
        this.popupInstance = null;
      });
      this.dispatchExternal("TooltipOpened", component.getComponent());
    }
  }
};
Tooltip2.moduleName = "tooltip";
var defaultValidators = {
  integer: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    value = Number(value);
    return !isNaN(value) && isFinite(value) && Math.floor(value) === value;
  },
  float: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    value = Number(value);
    return !isNaN(value) && isFinite(value) && value % 1 !== 0;
  },
  numeric: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return !isNaN(value);
  },
  string: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return isNaN(value);
  },
  max: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return parseFloat(value) <= parameters;
  },
  min: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return parseFloat(value) >= parameters;
  },
  starts: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return String(value).toLowerCase().startsWith(String(parameters).toLowerCase());
  },
  ends: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return String(value).toLowerCase().endsWith(String(parameters).toLowerCase());
  },
  minLength: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return String(value).length >= parameters;
  },
  maxLength: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    return String(value).length <= parameters;
  },
  in: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    if (typeof parameters == "string") {
      parameters = parameters.split("|");
    }
    return parameters.indexOf(value) > -1;
  },
  regex: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    var reg = new RegExp(parameters);
    return reg.test(value);
  },
  unique: function(cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }
    var unique = true;
    var cellData = cell.getData();
    var column = cell.getColumn()._getSelf();
    this.table.rowManager.rows.forEach(function(row2) {
      var data = row2.getData();
      if (data !== cellData) {
        if (value == column.getFieldValue(data)) {
          unique = false;
        }
      }
    });
    return unique;
  },
  required: function(cell, value, parameters) {
    return value !== "" && value !== null && typeof value !== "undefined";
  }
};
var Validate = class extends Module {
  constructor(table) {
    super(table);
    this.invalidCells = [];
    this.registerTableOption("validationMode", "blocking");
    this.registerColumnOption("validator");
    this.registerTableFunction("getInvalidCells", this.getInvalidCells.bind(this));
    this.registerTableFunction("clearCellValidation", this.userClearCellValidation.bind(this));
    this.registerTableFunction("validate", this.userValidate.bind(this));
    this.registerComponentFunction("cell", "isValid", this.cellIsValid.bind(this));
    this.registerComponentFunction("cell", "clearValidation", this.clearValidation.bind(this));
    this.registerComponentFunction("cell", "validate", this.cellValidate.bind(this));
    this.registerComponentFunction("column", "validate", this.columnValidate.bind(this));
    this.registerComponentFunction("row", "validate", this.rowValidate.bind(this));
  }
  initialize() {
    this.subscribe("cell-delete", this.clearValidation.bind(this));
    this.subscribe("column-layout", this.initializeColumnCheck.bind(this));
    this.subscribe("edit-success", this.editValidate.bind(this));
    this.subscribe("edit-editor-clear", this.editorClear.bind(this));
    this.subscribe("edit-edited-clear", this.editedClear.bind(this));
  }
  editValidate(cell, value, previousValue) {
    var valid = this.table.options.validationMode !== "manual" ? this.validate(cell.column.modules.validate, cell, value) : true;
    if (valid !== true) {
      setTimeout(() => {
        cell.getElement().classList.add("tabulator-validation-fail");
        this.dispatchExternal("validationFailed", cell.getComponent(), value, valid);
      });
    }
    return valid;
  }
  editorClear(cell, cancelled) {
    if (cancelled) {
      if (cell.column.modules.validate) {
        this.cellValidate(cell);
      }
    }
    cell.getElement().classList.remove("tabulator-validation-fail");
  }
  editedClear(cell) {
    if (cell.modules.validate) {
      cell.modules.validate.invalid = false;
    }
  }
  cellIsValid(cell) {
    return cell.modules.validate ? cell.modules.validate.invalid || true : true;
  }
  cellValidate(cell) {
    return this.validate(cell.column.modules.validate, cell, cell.getValue());
  }
  columnValidate(column) {
    var invalid = [];
    column.cells.forEach((cell) => {
      if (this.cellValidate(cell) !== true) {
        invalid.push(cell.getComponent());
      }
    });
    return invalid.length ? invalid : true;
  }
  rowValidate(row2) {
    var invalid = [];
    row2.cells.forEach((cell) => {
      if (this.cellValidate(cell) !== true) {
        invalid.push(cell.getComponent());
      }
    });
    return invalid.length ? invalid : true;
  }
  userClearCellValidation(cells) {
    if (!cells) {
      cells = this.getInvalidCells();
    }
    if (!Array.isArray(cells)) {
      cells = [cells];
    }
    cells.forEach((cell) => {
      this.clearValidation(cell._getSelf());
    });
  }
  userValidate(cells) {
    var output = [];
    this.table.rowManager.rows.forEach((row2) => {
      row2 = row2.getComponent();
      var valid = row2.validate();
      if (valid !== true) {
        output = output.concat(valid);
      }
    });
    return output.length ? output : true;
  }
  initializeColumnCheck(column) {
    if (typeof column.definition.validator !== "undefined") {
      this.initializeColumn(column);
    }
  }
  initializeColumn(column) {
    var self2 = this, config = [], validator;
    if (column.definition.validator) {
      if (Array.isArray(column.definition.validator)) {
        column.definition.validator.forEach((item) => {
          validator = self2._extractValidator(item);
          if (validator) {
            config.push(validator);
          }
        });
      } else {
        validator = this._extractValidator(column.definition.validator);
        if (validator) {
          config.push(validator);
        }
      }
      column.modules.validate = config.length ? config : false;
    }
  }
  _extractValidator(value) {
    var type, params, pos;
    switch (typeof value) {
      case "string":
        pos = value.indexOf(":");
        if (pos > -1) {
          type = value.substring(0, pos);
          params = value.substring(pos + 1);
        } else {
          type = value;
        }
        return this._buildValidator(type, params);
      case "function":
        return this._buildValidator(value);
      case "object":
        return this._buildValidator(value.type, value.parameters);
    }
  }
  _buildValidator(type, params) {
    var func = typeof type == "function" ? type : Validate.validators[type];
    if (!func) {
      console.warn("Validator Setup Error - No matching validator found:", type);
      return false;
    } else {
      return {
        type: typeof type == "function" ? "function" : type,
        func,
        params
      };
    }
  }
  validate(validators, cell, value) {
    var self2 = this, failedValidators = [], invalidIndex = this.invalidCells.indexOf(cell);
    if (validators) {
      validators.forEach((item) => {
        if (!item.func.call(self2, cell.getComponent(), value, item.params)) {
          failedValidators.push({
            type: item.type,
            parameters: item.params
          });
        }
      });
    }
    if (!cell.modules.validate) {
      cell.modules.validate = {};
    }
    if (!failedValidators.length) {
      cell.modules.validate.invalid = false;
      cell.getElement().classList.remove("tabulator-validation-fail");
      if (invalidIndex > -1) {
        this.invalidCells.splice(invalidIndex, 1);
      }
    } else {
      cell.modules.validate.invalid = failedValidators;
      if (this.table.options.validationMode !== "manual") {
        cell.getElement().classList.add("tabulator-validation-fail");
      }
      if (invalidIndex == -1) {
        this.invalidCells.push(cell);
      }
    }
    return failedValidators.length ? failedValidators : true;
  }
  getInvalidCells() {
    var output = [];
    this.invalidCells.forEach((cell) => {
      output.push(cell.getComponent());
    });
    return output;
  }
  clearValidation(cell) {
    var invalidIndex;
    if (cell.modules.validate && cell.modules.validate.invalid) {
      cell.getElement().classList.remove("tabulator-validation-fail");
      cell.modules.validate.invalid = false;
      invalidIndex = this.invalidCells.indexOf(cell);
      if (invalidIndex > -1) {
        this.invalidCells.splice(invalidIndex, 1);
      }
    }
  }
};
Validate.moduleName = "validate";
Validate.validators = defaultValidators;
var modules = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AccessorModule: Accessor,
  AjaxModule: Ajax,
  ClipboardModule: Clipboard,
  ColumnCalcsModule: ColumnCalcs,
  DataTreeModule: DataTree,
  DownloadModule: Download,
  EditModule: Edit$1,
  ExportModule: Export,
  FilterModule: Filter,
  FormatModule: Format,
  FrozenColumnsModule: FrozenColumns,
  FrozenRowsModule: FrozenRows,
  GroupRowsModule: GroupRows,
  HistoryModule: History,
  HtmlTableImportModule: HtmlTableImport,
  ImportModule: Import,
  InteractionModule: Interaction2,
  KeybindingsModule: Keybindings,
  MenuModule: Menu,
  MoveColumnsModule: MoveColumns,
  MoveRowsModule: MoveRows,
  MutatorModule: Mutator,
  PageModule: Page,
  PersistenceModule: Persistence,
  PopupModule: Popup$1,
  PrintModule: Print,
  ReactiveDataModule: ReactiveData,
  ResizeColumnsModule: ResizeColumns,
  ResizeRowsModule: ResizeRows,
  ResizeTableModule: ResizeTable,
  ResponsiveLayoutModule: ResponsiveLayout,
  SelectRowModule: SelectRow,
  SortModule: Sort,
  TooltipModule: Tooltip2,
  ValidateModule: Validate
});
var defaultOptions = {
  debugEventsExternal: false,
  debugEventsInternal: false,
  debugInvalidOptions: true,
  debugInvalidComponentFuncs: true,
  debugInitialization: true,
  debugDeprecation: true,
  height: false,
  minHeight: false,
  maxHeight: false,
  columnHeaderVertAlign: "top",
  popupContainer: false,
  columns: [],
  columnDefaults: {},
  data: false,
  autoColumns: false,
  autoColumnsDefinitions: false,
  nestedFieldSeparator: ".",
  footerElement: false,
  index: "id",
  textDirection: "auto",
  addRowPos: "bottom",
  headerVisible: true,
  renderVertical: "virtual",
  renderHorizontal: "basic",
  renderVerticalBuffer: 0,
  scrollToRowPosition: "top",
  scrollToRowIfVisible: true,
  scrollToColumnPosition: "left",
  scrollToColumnIfVisible: true,
  rowFormatter: false,
  rowFormatterPrint: null,
  rowFormatterClipboard: null,
  rowFormatterHtmlOutput: null,
  rowHeight: null,
  placeholder: false,
  dataLoader: true,
  dataLoaderLoading: false,
  dataLoaderError: false,
  dataLoaderErrorTimeout: 3e3,
  dataSendParams: {},
  dataReceiveParams: {}
};
var OptionsList = class {
  constructor(table, msgType, defaults3 = {}) {
    this.table = table;
    this.msgType = msgType;
    this.registeredDefaults = Object.assign({}, defaults3);
  }
  register(option, value) {
    this.registeredDefaults[option] = value;
  }
  generate(defaultOptions2, userOptions = {}) {
    var output = Object.assign({}, this.registeredDefaults);
    Object.assign(output, defaultOptions2);
    if (userOptions.debugInvalidOptions !== false || this.table.options.debugInvalidOptions) {
      for (let key in userOptions) {
        if (!output.hasOwnProperty(key)) {
          console.warn("Invalid " + this.msgType + " option:", key);
        }
      }
    }
    for (let key in output) {
      if (key in userOptions) {
        output[key] = userOptions[key];
      } else {
        if (Array.isArray(output[key])) {
          output[key] = Object.assign([], output[key]);
        } else if (typeof output[key] === "object" && output[key] !== null) {
          output[key] = Object.assign({}, output[key]);
        } else if (typeof output[key] === "undefined") {
          delete output[key];
        }
      }
    }
    return output;
  }
};
var Renderer = class extends CoreFeature {
  constructor(table) {
    super(table);
    this.elementVertical = table.rowManager.element;
    this.elementHorizontal = table.columnManager.element;
    this.tableElement = table.rowManager.tableElement;
    this.verticalFillMode = "fit";
  }
  initialize() {
  }
  clearRows() {
  }
  clearColumns() {
  }
  reinitializeColumnWidths(columns) {
  }
  renderRows() {
  }
  renderColumns() {
  }
  rerenderRows(callback2) {
    if (callback2) {
      callback2();
    }
  }
  rerenderColumns(update, blockRedraw) {
  }
  renderRowCells(row2) {
  }
  rerenderRowCells(row2, force) {
  }
  scrollColumns(left, dir) {
  }
  scrollRows(top, dir) {
  }
  resize() {
  }
  scrollToRow(row2) {
  }
  scrollToRowNearestTop(row2) {
  }
  visibleRows(includingBuffer) {
    return [];
  }
  rows() {
    return this.table.rowManager.getDisplayRows();
  }
  styleRow(row2, index2) {
    var rowEl = row2.getElement();
    if (index2 % 2) {
      rowEl.classList.add("tabulator-row-even");
      rowEl.classList.remove("tabulator-row-odd");
    } else {
      rowEl.classList.add("tabulator-row-odd");
      rowEl.classList.remove("tabulator-row-even");
    }
  }
  clear() {
    this.clearRows();
    this.clearColumns();
  }
  render() {
    this.renderRows();
    this.renderColumns();
  }
  rerender(callback2) {
    this.rerenderRows();
    this.rerenderColumns();
  }
  scrollToRowPosition(row2, position, ifVisible) {
    var rowIndex = this.rows().indexOf(row2), rowEl = row2.getElement(), offset2 = 0;
    return new Promise((resolve2, reject) => {
      if (rowIndex > -1) {
        if (typeof ifVisible === "undefined") {
          ifVisible = this.table.options.scrollToRowIfVisible;
        }
        if (!ifVisible) {
          if (Helpers.elVisible(rowEl)) {
            offset2 = Helpers.elOffset(rowEl).top - Helpers.elOffset(this.elementVertical).top;
            if (offset2 > 0 && offset2 < this.elementVertical.clientHeight - rowEl.offsetHeight) {
              resolve2();
              return false;
            }
          }
        }
        if (typeof position === "undefined") {
          position = this.table.options.scrollToRowPosition;
        }
        if (position === "nearest") {
          position = this.scrollToRowNearestTop(row2) ? "top" : "bottom";
        }
        this.scrollToRow(row2);
        switch (position) {
          case "middle":
          case "center":
            if (this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight) {
              this.elementVertical.scrollTop = this.elementVertical.scrollTop + (rowEl.offsetTop - this.elementVertical.scrollTop) - (this.elementVertical.scrollHeight - rowEl.offsetTop) / 2;
            } else {
              this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight / 2;
            }
            break;
          case "bottom":
            if (this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight) {
              this.elementVertical.scrollTop = this.elementVertical.scrollTop - (this.elementVertical.scrollHeight - rowEl.offsetTop) + rowEl.offsetHeight;
            } else {
              this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight + rowEl.offsetHeight;
            }
            break;
          case "top":
            this.elementVertical.scrollTop = rowEl.offsetTop;
            break;
        }
        resolve2();
      } else {
        console.warn("Scroll Error - Row not visible");
        reject("Scroll Error - Row not visible");
      }
    });
  }
};
var BasicHorizontal = class extends Renderer {
  constructor(table) {
    super(table);
  }
  renderRowCells(row2) {
    row2.cells.forEach((cell) => {
      row2.element.appendChild(cell.getElement());
      cell.cellRendered();
    });
  }
  reinitializeColumnWidths(columns) {
    columns.forEach(function(column) {
      column.reinitializeWidth();
    });
  }
};
var VirtualDomHorizontal = class extends Renderer {
  constructor(table) {
    super(table);
    this.leftCol = 0;
    this.rightCol = 0;
    this.scrollLeft = 0;
    this.vDomScrollPosLeft = 0;
    this.vDomScrollPosRight = 0;
    this.vDomPadLeft = 0;
    this.vDomPadRight = 0;
    this.fitDataColAvg = 0;
    this.windowBuffer = 200;
    this.visibleRows = null;
    this.initialized = false;
    this.isFitData = false;
    this.columns = [];
  }
  initialize() {
    this.compatibilityCheck();
    this.layoutCheck();
    this.vertScrollListen();
  }
  compatibilityCheck() {
    if (this.options("layout") == "fitDataTable") {
      console.warn("Horizontal Virtual DOM is not compatible with fitDataTable layout mode");
    }
    if (this.options("responsiveLayout")) {
      console.warn("Horizontal Virtual DOM is not compatible with responsive columns");
    }
    if (this.options("rtl")) {
      console.warn("Horizontal Virtual DOM is not currently compatible with RTL text direction");
    }
  }
  layoutCheck() {
    this.isFitData = this.options("layout").startsWith("fitData");
  }
  vertScrollListen() {
    this.subscribe("scroll-vertical", this.clearVisRowCache.bind(this));
    this.subscribe("data-refreshed", this.clearVisRowCache.bind(this));
  }
  clearVisRowCache() {
    this.visibleRows = null;
  }
  renderColumns(row2, force) {
    this.dataChange();
  }
  scrollColumns(left, dir) {
    if (this.scrollLeft != left) {
      this.scrollLeft = left;
      this.scroll(left - (this.vDomScrollPosLeft + this.windowBuffer));
    }
  }
  calcWindowBuffer() {
    var buffer = this.elementVertical.clientWidth;
    this.table.columnManager.columnsByIndex.forEach((column) => {
      if (column.visible) {
        var width = column.getWidth();
        if (width > buffer) {
          buffer = width;
        }
      }
    });
    this.windowBuffer = buffer * 2;
  }
  rerenderColumns(update, blockRedraw) {
    var old = {
      cols: this.columns,
      leftCol: this.leftCol,
      rightCol: this.rightCol
    }, colPos = 0;
    if (update && !this.initialized) {
      return;
    }
    this.clear();
    this.calcWindowBuffer();
    this.scrollLeft = this.elementVertical.scrollLeft;
    this.vDomScrollPosLeft = this.scrollLeft - this.windowBuffer;
    this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer;
    this.table.columnManager.columnsByIndex.forEach((column) => {
      var config = {}, width;
      if (column.visible) {
        if (!column.modules.frozen) {
          width = column.getWidth();
          config.leftPos = colPos;
          config.rightPos = colPos + width;
          config.width = width;
          if (this.isFitData) {
            config.fitDataCheck = column.modules.vdomHoz ? column.modules.vdomHoz.fitDataCheck : true;
          }
          if (colPos + width > this.vDomScrollPosLeft && colPos < this.vDomScrollPosRight) {
            if (this.leftCol == -1) {
              this.leftCol = this.columns.length;
              this.vDomPadLeft = colPos;
            }
            this.rightCol = this.columns.length;
          } else {
            if (this.leftCol !== -1) {
              this.vDomPadRight += width;
            }
          }
          this.columns.push(column);
          column.modules.vdomHoz = config;
          colPos += width;
        }
      }
    });
    this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
    this.tableElement.style.paddingRight = this.vDomPadRight + "px";
    this.initialized = true;
    if (!blockRedraw) {
      if (!update || this.reinitChanged(old)) {
        this.reinitializeRows();
      }
    }
    this.elementVertical.scrollLeft = this.scrollLeft;
  }
  renderRowCells(row2) {
    if (this.initialized) {
      this.initializeRow(row2);
    } else {
      row2.cells.forEach((cell) => {
        row2.element.appendChild(cell.getElement());
        cell.cellRendered();
      });
    }
  }
  rerenderRowCells(row2, force) {
    this.reinitializeRow(row2, force);
  }
  reinitializeColumnWidths(columns) {
    for (let i2 = this.leftCol; i2 <= this.rightCol; i2++) {
      this.columns[i2].reinitializeWidth();
    }
  }
  deinitialize() {
    this.initialized = false;
  }
  clear() {
    this.columns = [];
    this.leftCol = -1;
    this.rightCol = 0;
    this.vDomScrollPosLeft = 0;
    this.vDomScrollPosRight = 0;
    this.vDomPadLeft = 0;
    this.vDomPadRight = 0;
  }
  dataChange() {
    var change = false, row2, rowEl;
    if (this.isFitData) {
      this.table.columnManager.columnsByIndex.forEach((column) => {
        if (!column.definition.width && column.visible) {
          change = true;
        }
      });
      if (change && this.table.rowManager.getDisplayRows().length) {
        this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer;
        row2 = this.chain("rows-sample", [1], [], () => {
          return this.table.rowManager.getDisplayRows();
        })[0];
        if (row2) {
          rowEl = row2.getElement();
          row2.generateCells();
          this.tableElement.appendChild(rowEl);
          for (let colEnd = 0; colEnd < row2.cells.length; colEnd++) {
            let cell = row2.cells[colEnd];
            rowEl.appendChild(cell.getElement());
            cell.column.reinitializeWidth();
          }
          rowEl.parentNode.removeChild(rowEl);
          this.rerenderColumns(false, true);
        }
      }
    } else {
      if (this.options("layout") === "fitColumns") {
        this.layoutRefresh();
        this.rerenderColumns(false, true);
      }
    }
  }
  reinitChanged(old) {
    var match2 = true;
    if (old.cols.length !== this.columns.length || old.leftCol !== this.leftCol || old.rightCol !== this.rightCol) {
      return true;
    }
    old.cols.forEach((col, i2) => {
      if (col !== this.columns[i2]) {
        match2 = false;
      }
    });
    return !match2;
  }
  reinitializeRows() {
    var visibleRows = this.getVisibleRows(), otherRows = this.table.rowManager.getRows().filter((row2) => !visibleRows.includes(row2));
    visibleRows.forEach((row2) => {
      this.reinitializeRow(row2, true);
    });
    otherRows.forEach((row2) => {
      row2.deinitialize();
    });
  }
  getVisibleRows() {
    if (!this.visibleRows) {
      this.visibleRows = this.table.rowManager.getVisibleRows();
    }
    return this.visibleRows;
  }
  scroll(diff) {
    this.vDomScrollPosLeft += diff;
    this.vDomScrollPosRight += diff;
    if (Math.abs(diff) > this.windowBuffer / 2) {
      this.rerenderColumns();
    } else {
      if (diff > 0) {
        this.addColRight();
        this.removeColLeft();
      } else {
        this.addColLeft();
        this.removeColRight();
      }
    }
  }
  colPositionAdjust(start, end, diff) {
    for (let i2 = start; i2 < end; i2++) {
      let column = this.columns[i2];
      column.modules.vdomHoz.leftPos += diff;
      column.modules.vdomHoz.rightPos += diff;
    }
  }
  addColRight() {
    var changes = false, working = true;
    while (working) {
      let column = this.columns[this.rightCol + 1];
      if (column) {
        if (column.modules.vdomHoz.leftPos <= this.vDomScrollPosRight) {
          changes = true;
          this.getVisibleRows().forEach((row2) => {
            if (row2.type !== "group") {
              var cell = row2.getCell(column);
              row2.getElement().insertBefore(cell.getElement(), row2.getCell(this.columns[this.rightCol]).getElement().nextSibling);
              cell.cellRendered();
            }
          });
          this.fitDataColActualWidthCheck(column);
          this.rightCol++;
          this.getVisibleRows().forEach((row2) => {
            if (row2.type !== "group") {
              row2.modules.vdomHoz.rightCol = this.rightCol;
            }
          });
          if (this.rightCol >= this.columns.length - 1) {
            this.vDomPadRight = 0;
          } else {
            this.vDomPadRight -= column.getWidth();
          }
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    if (changes) {
      this.tableElement.style.paddingRight = this.vDomPadRight + "px";
    }
  }
  addColLeft() {
    var changes = false, working = true;
    while (working) {
      let column = this.columns[this.leftCol - 1];
      if (column) {
        if (column.modules.vdomHoz.rightPos >= this.vDomScrollPosLeft) {
          changes = true;
          this.getVisibleRows().forEach((row2) => {
            if (row2.type !== "group") {
              var cell = row2.getCell(column);
              row2.getElement().insertBefore(cell.getElement(), row2.getCell(this.columns[this.leftCol]).getElement());
              cell.cellRendered();
            }
          });
          this.leftCol--;
          this.getVisibleRows().forEach((row2) => {
            if (row2.type !== "group") {
              row2.modules.vdomHoz.leftCol = this.leftCol;
            }
          });
          if (this.leftCol <= 0) {
            this.vDomPadLeft = 0;
          } else {
            this.vDomPadLeft -= column.getWidth();
          }
          let diff = this.fitDataColActualWidthCheck(column);
          if (diff) {
            this.scrollLeft = this.elementVertical.scrollLeft = this.elementVertical.scrollLeft + diff;
            this.vDomPadRight -= diff;
          }
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    if (changes) {
      this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
    }
  }
  removeColRight() {
    var changes = false, working = true;
    while (working) {
      let column = this.columns[this.rightCol];
      if (column) {
        if (column.modules.vdomHoz.leftPos > this.vDomScrollPosRight) {
          changes = true;
          this.getVisibleRows().forEach((row2) => {
            if (row2.type !== "group") {
              var cell = row2.getCell(column);
              try {
                row2.getElement().removeChild(cell.getElement());
              } catch (ex) {
                console.warn("Could not removeColRight", ex.message);
              }
            }
          });
          this.vDomPadRight += column.getWidth();
          this.rightCol--;
          this.getVisibleRows().forEach((row2) => {
            if (row2.type !== "group") {
              row2.modules.vdomHoz.rightCol = this.rightCol;
            }
          });
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    if (changes) {
      this.tableElement.style.paddingRight = this.vDomPadRight + "px";
    }
  }
  removeColLeft() {
    var changes = false, working = true;
    while (working) {
      let column = this.columns[this.leftCol];
      if (column) {
        if (column.modules.vdomHoz.rightPos < this.vDomScrollPosLeft) {
          changes = true;
          this.getVisibleRows().forEach((row2) => {
            if (row2.type !== "group") {
              var cell = row2.getCell(column);
              try {
                row2.getElement().removeChild(cell.getElement());
              } catch (ex) {
                console.warn("Could not removeColLeft", ex.message);
              }
            }
          });
          this.vDomPadLeft += column.getWidth();
          this.leftCol++;
          this.getVisibleRows().forEach((row2) => {
            if (row2.type !== "group") {
              row2.modules.vdomHoz.leftCol = this.leftCol;
            }
          });
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    if (changes) {
      this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
    }
  }
  fitDataColActualWidthCheck(column) {
    var newWidth, widthDiff;
    if (column.modules.vdomHoz.fitDataCheck) {
      column.reinitializeWidth();
      newWidth = column.getWidth();
      widthDiff = newWidth - column.modules.vdomHoz.width;
      if (widthDiff) {
        column.modules.vdomHoz.rightPos += widthDiff;
        column.modules.vdomHoz.width = newWidth;
        this.colPositionAdjust(this.columns.indexOf(column) + 1, this.columns.length, widthDiff);
      }
      column.modules.vdomHoz.fitDataCheck = false;
    }
    return widthDiff;
  }
  initializeRow(row2) {
    if (row2.type !== "group") {
      row2.modules.vdomHoz = {
        leftCol: this.leftCol,
        rightCol: this.rightCol
      };
      if (this.table.modules.frozenColumns) {
        this.table.modules.frozenColumns.leftColumns.forEach((column) => {
          this.appendCell(row2, column);
        });
      }
      for (let i2 = this.leftCol; i2 <= this.rightCol; i2++) {
        this.appendCell(row2, this.columns[i2]);
      }
      if (this.table.modules.frozenColumns) {
        this.table.modules.frozenColumns.rightColumns.forEach((column) => {
          this.appendCell(row2, column);
        });
      }
    }
  }
  appendCell(row2, column) {
    if (column && column.visible) {
      let cell = row2.getCell(column);
      row2.getElement().appendChild(cell.getElement());
      cell.cellRendered();
    }
  }
  reinitializeRow(row2, force) {
    if (row2.type !== "group") {
      if (force || !row2.modules.vdomHoz || row2.modules.vdomHoz.leftCol !== this.leftCol || row2.modules.vdomHoz.rightCol !== this.rightCol) {
        var rowEl = row2.getElement();
        while (rowEl.firstChild)
          rowEl.removeChild(rowEl.firstChild);
        this.initializeRow(row2);
      }
    }
  }
};
var ColumnManager = class extends CoreFeature {
  constructor(table) {
    super(table);
    this.blockHozScrollEvent = false;
    this.headersElement = null;
    this.contentsElement = null;
    this.element = null;
    this.columns = [];
    this.columnsByIndex = [];
    this.columnsByField = {};
    this.scrollLeft = 0;
    this.optionsList = new OptionsList(this.table, "column definition", defaultColumnOptions);
    this.redrawBlock = false;
    this.redrawBlockUpdate = null;
    this.renderer = null;
  }
  initialize() {
    this.initializeRenderer();
    this.headersElement = this.createHeadersElement();
    this.contentsElement = this.createHeaderContentsElement();
    this.element = this.createHeaderElement();
    this.contentsElement.insertBefore(this.headersElement, this.contentsElement.firstChild);
    this.element.insertBefore(this.contentsElement, this.element.firstChild);
    this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this));
    this.subscribe("scrollbar-vertical", this.padVerticalScrollbar.bind(this));
  }
  padVerticalScrollbar(width) {
    if (this.table.rtl) {
      this.headersElement.style.marginLeft = width + "px";
    } else {
      this.headersElement.style.marginRight = width + "px";
    }
  }
  initializeRenderer() {
    var renderClass;
    var renderers = {
      "virtual": VirtualDomHorizontal,
      "basic": BasicHorizontal
    };
    if (typeof this.table.options.renderHorizontal === "string") {
      renderClass = renderers[this.table.options.renderHorizontal];
    } else {
      renderClass = this.table.options.renderHorizontal;
    }
    if (renderClass) {
      this.renderer = new renderClass(this.table, this.element, this.tableElement);
      this.renderer.initialize();
    } else {
      console.error("Unable to find matching renderer:", this.table.options.renderHorizontal);
    }
  }
  createHeadersElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-headers");
    el.setAttribute("role", "row");
    return el;
  }
  createHeaderContentsElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-header-contents");
    el.setAttribute("role", "rowgroup");
    return el;
  }
  createHeaderElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-header");
    el.setAttribute("role", "rowgroup");
    if (!this.table.options.headerVisible) {
      el.classList.add("tabulator-header-hidden");
    }
    return el;
  }
  getElement() {
    return this.element;
  }
  getContentsElement() {
    return this.contentsElement;
  }
  getHeadersElement() {
    return this.headersElement;
  }
  scrollHorizontal(left) {
    this.contentsElement.scrollLeft = left;
    this.scrollLeft = left;
    this.renderer.scrollColumns(left);
  }
  generateColumnsFromRowData(data) {
    var cols = [], definitions = this.table.options.autoColumnsDefinitions, row2, sorter2;
    if (data && data.length) {
      row2 = data[0];
      for (var key in row2) {
        let col = {
          field: key,
          title: key
        };
        let value = row2[key];
        switch (typeof value) {
          case "undefined":
            sorter2 = "string";
            break;
          case "boolean":
            sorter2 = "boolean";
            break;
          case "object":
            if (Array.isArray(value)) {
              sorter2 = "array";
            } else {
              sorter2 = "string";
            }
            break;
          default:
            if (!isNaN(value) && value !== "") {
              sorter2 = "number";
            } else {
              if (value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)) {
                sorter2 = "alphanum";
              } else {
                sorter2 = "string";
              }
            }
            break;
        }
        col.sorter = sorter2;
        cols.push(col);
      }
      if (definitions) {
        switch (typeof definitions) {
          case "function":
            this.table.options.columns = definitions.call(this.table, cols);
            break;
          case "object":
            if (Array.isArray(definitions)) {
              cols.forEach((col) => {
                var match2 = definitions.find((def) => {
                  return def.field === col.field;
                });
                if (match2) {
                  Object.assign(col, match2);
                }
              });
            } else {
              cols.forEach((col) => {
                if (definitions[col.field]) {
                  Object.assign(col, definitions[col.field]);
                }
              });
            }
            this.table.options.columns = cols;
            break;
        }
      } else {
        this.table.options.columns = cols;
      }
      this.setColumns(this.table.options.columns);
    }
  }
  setColumns(cols, row2) {
    while (this.headersElement.firstChild)
      this.headersElement.removeChild(this.headersElement.firstChild);
    this.columns = [];
    this.columnsByIndex = [];
    this.columnsByField = {};
    this.dispatch("columns-loading");
    cols.forEach((def, i2) => {
      this._addColumn(def);
    });
    this._reIndexColumns();
    this.dispatch("columns-loaded");
    this.rerenderColumns(false, true);
    this.redraw(true);
  }
  _addColumn(definition, before, nextToColumn) {
    var column = new Column(definition, this), colEl = column.getElement(), index2 = nextToColumn ? this.findColumnIndex(nextToColumn) : nextToColumn;
    if (nextToColumn && index2 > -1) {
      var topColumn = nextToColumn.getTopColumn();
      var parentIndex = this.columns.indexOf(topColumn);
      var nextEl = topColumn.getElement();
      if (before) {
        this.columns.splice(parentIndex, 0, column);
        nextEl.parentNode.insertBefore(colEl, nextEl);
      } else {
        this.columns.splice(parentIndex + 1, 0, column);
        nextEl.parentNode.insertBefore(colEl, nextEl.nextSibling);
      }
    } else {
      if (before) {
        this.columns.unshift(column);
        this.headersElement.insertBefore(column.getElement(), this.headersElement.firstChild);
      } else {
        this.columns.push(column);
        this.headersElement.appendChild(column.getElement());
      }
    }
    column.columnRendered();
    return column;
  }
  registerColumnField(col) {
    if (col.definition.field) {
      this.columnsByField[col.definition.field] = col;
    }
  }
  registerColumnPosition(col) {
    this.columnsByIndex.push(col);
  }
  _reIndexColumns() {
    this.columnsByIndex = [];
    this.columns.forEach(function(column) {
      column.reRegisterPosition();
    });
  }
  verticalAlignHeaders() {
    var minHeight = 0;
    if (!this.redrawBlock) {
      this.headersElement.style.height = "";
      this.columns.forEach((column) => {
        column.clearVerticalAlign();
      });
      this.columns.forEach((column) => {
        var height = column.getHeight();
        if (height > minHeight) {
          minHeight = height;
        }
      });
      this.headersElement.style.height = minHeight + "px";
      this.columns.forEach((column) => {
        column.verticalAlign(this.table.options.columnHeaderVertAlign, minHeight);
      });
      this.table.rowManager.adjustTableSize();
    }
  }
  findColumn(subject) {
    var columns;
    if (typeof subject == "object") {
      if (subject instanceof Column) {
        return subject;
      } else if (subject instanceof ColumnComponent) {
        return subject._getSelf() || false;
      } else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
        columns = [];
        this.columns.forEach((column) => {
          columns.push(column);
          columns = columns.concat(column.getColumns(true));
        });
        let match2 = columns.find((column) => {
          return column.element === subject;
        });
        return match2 || false;
      }
    } else {
      return this.columnsByField[subject] || false;
    }
    return false;
  }
  getColumnByField(field) {
    return this.columnsByField[field];
  }
  getColumnsByFieldRoot(root) {
    var matches = [];
    Object.keys(this.columnsByField).forEach((field) => {
      var fieldRoot = field.split(".")[0];
      if (fieldRoot === root) {
        matches.push(this.columnsByField[field]);
      }
    });
    return matches;
  }
  getColumnByIndex(index2) {
    return this.columnsByIndex[index2];
  }
  getFirstVisibleColumn() {
    var index2 = this.columnsByIndex.findIndex((col) => {
      return col.visible;
    });
    return index2 > -1 ? this.columnsByIndex[index2] : false;
  }
  getColumns() {
    return this.columns;
  }
  findColumnIndex(column) {
    return this.columnsByIndex.findIndex((col) => {
      return column === col;
    });
  }
  getRealColumns() {
    return this.columnsByIndex;
  }
  traverse(callback2) {
    this.columnsByIndex.forEach((column, i2) => {
      callback2(column, i2);
    });
  }
  getDefinitions(active) {
    var output = [];
    this.columnsByIndex.forEach((column) => {
      if (!active || active && column.visible) {
        output.push(column.getDefinition());
      }
    });
    return output;
  }
  getDefinitionTree() {
    var output = [];
    this.columns.forEach((column) => {
      output.push(column.getDefinition(true));
    });
    return output;
  }
  getComponents(structured) {
    var output = [], columns = structured ? this.columns : this.columnsByIndex;
    columns.forEach((column) => {
      output.push(column.getComponent());
    });
    return output;
  }
  getWidth() {
    var width = 0;
    this.columnsByIndex.forEach((column) => {
      if (column.visible) {
        width += column.getWidth();
      }
    });
    return width;
  }
  moveColumn(from2, to2, after) {
    to2.element.parentNode.insertBefore(from2.element, to2.element);
    if (after) {
      to2.element.parentNode.insertBefore(to2.element, from2.element);
    }
    this.moveColumnActual(from2, to2, after);
    this.verticalAlignHeaders();
    this.table.rowManager.reinitialize();
  }
  moveColumnActual(from2, to2, after) {
    if (from2.parent.isGroup) {
      this._moveColumnInArray(from2.parent.columns, from2, to2, after);
    } else {
      this._moveColumnInArray(this.columns, from2, to2, after);
    }
    this._moveColumnInArray(this.columnsByIndex, from2, to2, after, true);
    this.rerenderColumns(true);
    this.dispatch("column-moved", from2, to2, after);
    if (this.subscribedExternal("columnMoved")) {
      this.dispatchExternal("columnMoved", from2.getComponent(), this.table.columnManager.getComponents());
    }
  }
  _moveColumnInArray(columns, from2, to2, after, updateRows) {
    var fromIndex = columns.indexOf(from2), toIndex, rows3 = [];
    if (fromIndex > -1) {
      columns.splice(fromIndex, 1);
      toIndex = columns.indexOf(to2);
      if (toIndex > -1) {
        if (after) {
          toIndex = toIndex + 1;
        }
      } else {
        toIndex = fromIndex;
      }
      columns.splice(toIndex, 0, from2);
      if (updateRows) {
        rows3 = this.chain("column-moving-rows", [from2, to2, after], null, []) || [];
        rows3 = rows3.concat(this.table.rowManager.rows);
        rows3.forEach(function(row2) {
          if (row2.cells.length) {
            var cell = row2.cells.splice(fromIndex, 1)[0];
            row2.cells.splice(toIndex, 0, cell);
          }
        });
      }
    }
  }
  scrollToColumn(column, position, ifVisible) {
    var left = 0, offset2 = column.getLeftOffset(), adjust = 0, colEl = column.getElement();
    return new Promise((resolve2, reject) => {
      if (typeof position === "undefined") {
        position = this.table.options.scrollToColumnPosition;
      }
      if (typeof ifVisible === "undefined") {
        ifVisible = this.table.options.scrollToColumnIfVisible;
      }
      if (column.visible) {
        switch (position) {
          case "middle":
          case "center":
            adjust = -this.element.clientWidth / 2;
            break;
          case "right":
            adjust = colEl.clientWidth - this.headersElement.clientWidth;
            break;
        }
        if (!ifVisible) {
          if (offset2 > 0 && offset2 + colEl.offsetWidth < this.element.clientWidth) {
            return false;
          }
        }
        left = offset2 + adjust;
        left = Math.max(Math.min(left, this.table.rowManager.element.scrollWidth - this.table.rowManager.element.clientWidth), 0);
        this.table.rowManager.scrollHorizontal(left);
        this.scrollHorizontal(left);
        resolve2();
      } else {
        console.warn("Scroll Error - Column not visible");
        reject("Scroll Error - Column not visible");
      }
    });
  }
  generateCells(row2) {
    var cells = [];
    this.columnsByIndex.forEach((column) => {
      cells.push(column.generateCell(row2));
    });
    return cells;
  }
  getFlexBaseWidth() {
    var totalWidth = this.table.element.clientWidth, fixedWidth = 0;
    if (this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight) {
      totalWidth -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth;
    }
    this.columnsByIndex.forEach(function(column) {
      var width, minWidth, colWidth;
      if (column.visible) {
        width = column.definition.width || 0;
        minWidth = parseInt(column.minWidth);
        if (typeof width == "string") {
          if (width.indexOf("%") > -1) {
            colWidth = totalWidth / 100 * parseInt(width);
          } else {
            colWidth = parseInt(width);
          }
        } else {
          colWidth = width;
        }
        fixedWidth += colWidth > minWidth ? colWidth : minWidth;
      }
    });
    return fixedWidth;
  }
  addColumn(definition, before, nextToColumn) {
    return new Promise((resolve2, reject) => {
      var column = this._addColumn(definition, before, nextToColumn);
      this._reIndexColumns();
      this.dispatch("column-add", definition, before, nextToColumn);
      if (this.layoutMode() != "fitColumns") {
        column.reinitializeWidth();
      }
      this.redraw(true);
      this.table.rowManager.reinitialize();
      this.rerenderColumns();
      resolve2(column);
    });
  }
  deregisterColumn(column) {
    var field = column.getField(), index2;
    if (field) {
      delete this.columnsByField[field];
    }
    index2 = this.columnsByIndex.indexOf(column);
    if (index2 > -1) {
      this.columnsByIndex.splice(index2, 1);
    }
    index2 = this.columns.indexOf(column);
    if (index2 > -1) {
      this.columns.splice(index2, 1);
    }
    this.verticalAlignHeaders();
    this.redraw();
  }
  rerenderColumns(update, silent) {
    if (!this.redrawBlock) {
      this.renderer.rerenderColumns(update, silent);
    } else {
      if (update === false || update === true && this.redrawBlockUpdate === null) {
        this.redrawBlockUpdate = update;
      }
    }
  }
  blockRedraw() {
    this.redrawBlock = true;
    this.redrawBlockUpdate = null;
  }
  restoreRedraw() {
    this.redrawBlock = false;
    this.verticalAlignHeaders();
    this.renderer.rerenderColumns(this.redrawBlockUpdate);
  }
  redraw(force) {
    if (Helpers.elVisible(this.element)) {
      this.verticalAlignHeaders();
    }
    if (force) {
      this.table.rowManager.resetScroll();
      this.table.rowManager.reinitialize();
    }
    if (!this.confirm("table-redrawing", force)) {
      this.layoutRefresh(force);
    }
    this.dispatch("table-redraw", force);
    this.table.footerManager.redraw();
  }
};
var BasicVertical = class extends Renderer {
  constructor(table) {
    super(table);
    this.verticalFillMode = "fill";
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.scrollTop = 0;
    this.scrollLeft = 0;
  }
  clearRows() {
    var element = this.tableElement;
    while (element.firstChild)
      element.removeChild(element.firstChild);
    element.scrollTop = 0;
    element.scrollLeft = 0;
    element.style.minWidth = "";
    element.style.minHeight = "";
    element.style.display = "";
    element.style.visibility = "";
  }
  renderRows() {
    var element = this.tableElement, onlyGroupHeaders = true;
    this.rows().forEach((row2, index2) => {
      this.styleRow(row2, index2);
      element.appendChild(row2.getElement());
      row2.initialize(true);
      if (row2.type !== "group") {
        onlyGroupHeaders = false;
      }
    });
    if (onlyGroupHeaders) {
      element.style.minWidth = this.table.columnManager.getWidth() + "px";
    } else {
      element.style.minWidth = "";
    }
  }
  rerenderRows(callback2) {
    this.clearRows();
    this.renderRows();
    if (callback2) {
      callback2();
    }
  }
  scrollToRowNearestTop(row2) {
    var rowTop = Helpers.elOffset(row2.getElement()).top;
    return !(Math.abs(this.elementVertical.scrollTop - rowTop) > Math.abs(this.elementVertical.scrollTop + this.elementVertical.clientHeight - rowTop));
  }
  scrollToRow(row2) {
    var rowEl = row2.getElement();
    this.elementVertical.scrollTop = Helpers.elOffset(rowEl).top - Helpers.elOffset(this.elementVertical).top + this.elementVertical.scrollTop;
  }
  visibleRows(includingBuffer) {
    return this.rows();
  }
};
var VirtualDomVertical = class extends Renderer {
  constructor(table) {
    super(table);
    this.verticalFillMode = "fill";
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.vDomRowHeight = 20;
    this.vDomTop = 0;
    this.vDomBottom = 0;
    this.vDomScrollPosTop = 0;
    this.vDomScrollPosBottom = 0;
    this.vDomTopPad = 0;
    this.vDomBottomPad = 0;
    this.vDomMaxRenderChain = 90;
    this.vDomWindowBuffer = 0;
    this.vDomWindowMinTotalRows = 20;
    this.vDomWindowMinMarginRows = 5;
    this.vDomTopNewRows = [];
    this.vDomBottomNewRows = [];
  }
  clearRows() {
    var element = this.tableElement;
    while (element.firstChild)
      element.removeChild(element.firstChild);
    element.style.paddingTop = "";
    element.style.paddingBottom = "";
    element.style.minHeight = "";
    element.style.display = "";
    element.style.visibility = "";
    this.elementVertical.scrollTop = 0;
    this.elementVertical.scrollLeft = 0;
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.vDomTop = 0;
    this.vDomBottom = 0;
    this.vDomTopPad = 0;
    this.vDomBottomPad = 0;
    this.vDomScrollPosTop = 0;
    this.vDomScrollPosBottom = 0;
  }
  renderRows() {
    this._virtualRenderFill();
  }
  rerenderRows(callback2) {
    var scrollTop = this.elementVertical.scrollTop;
    var topRow = false;
    var topOffset = false;
    var left = this.table.rowManager.scrollLeft;
    var rows3 = this.rows();
    for (var i2 = this.vDomTop; i2 <= this.vDomBottom; i2++) {
      if (rows3[i2]) {
        var diff = scrollTop - rows3[i2].getElement().offsetTop;
        if (topOffset === false || Math.abs(diff) < topOffset) {
          topOffset = diff;
          topRow = i2;
        } else {
          break;
        }
      }
    }
    rows3.forEach((row2) => {
      row2.deinitializeHeight();
    });
    if (callback2) {
      callback2();
    }
    if (this.rows().length) {
      this._virtualRenderFill(topRow === false ? this.rows.length - 1 : topRow, true, topOffset || 0);
    } else {
      this.clear();
      this.table.rowManager._showPlaceholder();
    }
    this.scrollColumns(left);
  }
  scrollColumns(left) {
    this.table.rowManager.scrollHorizontal(left);
  }
  scrollRows(top, dir) {
    var topDiff = top - this.vDomScrollPosTop;
    var bottomDiff = top - this.vDomScrollPosBottom;
    var margin = this.vDomWindowBuffer * 2;
    var rows3 = this.rows();
    this.scrollTop = top;
    if (-topDiff > margin || bottomDiff > margin) {
      var left = this.table.rowManager.scrollLeft;
      this._virtualRenderFill(Math.floor(this.elementVertical.scrollTop / this.elementVertical.scrollHeight * rows3.length));
      this.scrollColumns(left);
    } else {
      if (dir) {
        if (topDiff < 0) {
          this._addTopRow(rows3, -topDiff);
        }
        if (bottomDiff < 0) {
          if (this.vDomScrollHeight - this.scrollTop > this.vDomWindowBuffer) {
            this._removeBottomRow(rows3, -bottomDiff);
          } else {
            this.vDomScrollPosBottom = this.scrollTop;
          }
        }
      } else {
        if (bottomDiff >= 0) {
          this._addBottomRow(rows3, bottomDiff);
        }
        if (topDiff >= 0) {
          if (this.scrollTop > this.vDomWindowBuffer) {
            this._removeTopRow(rows3, topDiff);
          } else {
            this.vDomScrollPosTop = this.scrollTop;
          }
        }
      }
    }
  }
  resize() {
    this.vDomWindowBuffer = this.table.options.renderVerticalBuffer || this.elementVertical.clientHeight;
  }
  scrollToRowNearestTop(row2) {
    var rowIndex = this.rows().indexOf(row2);
    return !(Math.abs(this.vDomTop - rowIndex) > Math.abs(this.vDomBottom - rowIndex));
  }
  scrollToRow(row2) {
    var index2 = this.rows().indexOf(row2);
    if (index2 > -1) {
      this._virtualRenderFill(index2, true);
    }
  }
  visibleRows(includingBuffer) {
    var topEdge = this.elementVertical.scrollTop, bottomEdge = this.elementVertical.clientHeight + topEdge, topFound = false, topRow = 0, bottomRow = 0, rows3 = this.rows();
    if (includingBuffer) {
      topRow = this.vDomTop;
      bottomRow = this.vDomBottom;
    } else {
      for (var i2 = this.vDomTop; i2 <= this.vDomBottom; i2++) {
        if (rows3[i2]) {
          if (!topFound) {
            if (topEdge - rows3[i2].getElement().offsetTop >= 0) {
              topRow = i2;
            } else {
              topFound = true;
              if (bottomEdge - rows3[i2].getElement().offsetTop >= 0) {
                bottomRow = i2;
              } else {
                break;
              }
            }
          } else {
            if (bottomEdge - rows3[i2].getElement().offsetTop >= 0) {
              bottomRow = i2;
            } else {
              break;
            }
          }
        }
      }
    }
    return rows3.slice(topRow, bottomRow + 1);
  }
  _virtualRenderFill(position, forceMove, offset2) {
    var element = this.tableElement, holder = this.elementVertical, topPad = 0, rowsHeight = 0, heightOccupied = 0, topPadHeight = 0, i2 = 0, rows3 = this.rows(), rowsCount = rows3.length, containerHeight = this.elementVertical.clientHeight;
    position = position || 0;
    offset2 = offset2 || 0;
    if (!position) {
      this.clear();
    } else {
      while (element.firstChild)
        element.removeChild(element.firstChild);
      heightOccupied = (rowsCount - position + 1) * this.vDomRowHeight;
      if (heightOccupied < containerHeight) {
        position -= Math.ceil((containerHeight - heightOccupied) / this.vDomRowHeight);
        if (position < 0) {
          position = 0;
        }
      }
      topPad = Math.min(Math.max(Math.floor(this.vDomWindowBuffer / this.vDomRowHeight), this.vDomWindowMinMarginRows), position);
      position -= topPad;
    }
    if (rowsCount && Helpers.elVisible(this.elementVertical)) {
      this.vDomTop = position;
      this.vDomBottom = position - 1;
      while ((rowsHeight <= containerHeight + this.vDomWindowBuffer || i2 < this.vDomWindowMinTotalRows) && this.vDomBottom < rowsCount - 1) {
        var index2 = this.vDomBottom + 1, row2 = rows3[index2], rowHeight = 0;
        this.styleRow(row2, index2);
        element.appendChild(row2.getElement());
        row2.initialize();
        if (!row2.heightInitialized) {
          row2.normalizeHeight(true);
        }
        rowHeight = row2.getHeight();
        if (i2 < topPad) {
          topPadHeight += rowHeight;
        } else {
          rowsHeight += rowHeight;
        }
        if (rowHeight > this.vDomWindowBuffer) {
          this.vDomWindowBuffer = rowHeight * 2;
        }
        this.vDomBottom++;
        i2++;
      }
      if (!position) {
        this.vDomTopPad = 0;
        this.vDomRowHeight = Math.floor((rowsHeight + topPadHeight) / i2);
        this.vDomBottomPad = this.vDomRowHeight * (rowsCount - this.vDomBottom - 1);
        this.vDomScrollHeight = topPadHeight + rowsHeight + this.vDomBottomPad - containerHeight;
      } else {
        this.vDomTopPad = !forceMove ? this.scrollTop - topPadHeight : this.vDomRowHeight * this.vDomTop + offset2;
        this.vDomBottomPad = this.vDomBottom == rowsCount - 1 ? 0 : Math.max(this.vDomScrollHeight - this.vDomTopPad - rowsHeight - topPadHeight, 0);
      }
      element.style.paddingTop = this.vDomTopPad + "px";
      element.style.paddingBottom = this.vDomBottomPad + "px";
      if (forceMove) {
        this.scrollTop = this.vDomTopPad + topPadHeight + offset2 - (this.elementVertical.scrollWidth > this.elementVertical.clientWidth ? this.elementVertical.offsetHeight - containerHeight : 0);
      }
      this.scrollTop = Math.min(this.scrollTop, this.elementVertical.scrollHeight - containerHeight);
      if (this.elementVertical.scrollWidth > this.elementVertical.offsetWidth && forceMove) {
        this.scrollTop += this.elementVertical.offsetHeight - containerHeight;
      }
      this.vDomScrollPosTop = this.scrollTop;
      this.vDomScrollPosBottom = this.scrollTop;
      holder.scrollTop = this.scrollTop;
      this.dispatch("render-virtual-fill");
    }
  }
  _addTopRow(rows3, fillableSpace) {
    var table = this.tableElement, addedRows = [], paddingAdjust = 0, index2 = this.vDomTop - 1, i2 = 0, working = true;
    while (working) {
      if (this.vDomTop) {
        let row2 = rows3[index2], rowHeight, initialized;
        if (row2 && i2 < this.vDomMaxRenderChain) {
          rowHeight = row2.getHeight() || this.vDomRowHeight;
          initialized = row2.initialized;
          if (fillableSpace >= rowHeight) {
            this.styleRow(row2, index2);
            table.insertBefore(row2.getElement(), table.firstChild);
            if (!row2.initialized || !row2.heightInitialized) {
              addedRows.push(row2);
            }
            row2.initialize();
            if (!initialized) {
              rowHeight = row2.getElement().offsetHeight;
              if (rowHeight > this.vDomWindowBuffer) {
                this.vDomWindowBuffer = rowHeight * 2;
              }
            }
            fillableSpace -= rowHeight;
            paddingAdjust += rowHeight;
            this.vDomTop--;
            index2--;
            i2++;
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    for (let row2 of addedRows) {
      row2.clearCellHeight();
    }
    this._quickNormalizeRowHeight(addedRows);
    if (paddingAdjust) {
      this.vDomTopPad -= paddingAdjust;
      if (this.vDomTopPad < 0) {
        this.vDomTopPad = index2 * this.vDomRowHeight;
      }
      if (index2 < 1) {
        this.vDomTopPad = 0;
      }
      table.style.paddingTop = this.vDomTopPad + "px";
      this.vDomScrollPosTop -= paddingAdjust;
    }
  }
  _removeTopRow(rows3, fillableSpace) {
    var removableRows = [], paddingAdjust = 0, i2 = 0, working = true;
    while (working) {
      let row2 = rows3[this.vDomTop], rowHeight;
      if (row2 && i2 < this.vDomMaxRenderChain) {
        rowHeight = row2.getHeight() || this.vDomRowHeight;
        if (fillableSpace >= rowHeight) {
          this.vDomTop++;
          fillableSpace -= rowHeight;
          paddingAdjust += rowHeight;
          removableRows.push(row2);
          i2++;
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    for (let row2 of removableRows) {
      let rowEl = row2.getElement();
      if (rowEl.parentNode) {
        rowEl.parentNode.removeChild(rowEl);
      }
    }
    if (paddingAdjust) {
      this.vDomTopPad += paddingAdjust;
      this.tableElement.style.paddingTop = this.vDomTopPad + "px";
      this.vDomScrollPosTop += this.vDomTop ? paddingAdjust : paddingAdjust + this.vDomWindowBuffer;
    }
  }
  _addBottomRow(rows3, fillableSpace) {
    var table = this.tableElement, addedRows = [], paddingAdjust = 0, index2 = this.vDomBottom + 1, i2 = 0, working = true;
    while (working) {
      let row2 = rows3[index2], rowHeight, initialized;
      if (row2 && i2 < this.vDomMaxRenderChain) {
        rowHeight = row2.getHeight() || this.vDomRowHeight;
        initialized = row2.initialized;
        if (fillableSpace >= rowHeight) {
          this.styleRow(row2, index2);
          table.appendChild(row2.getElement());
          if (!row2.initialized || !row2.heightInitialized) {
            addedRows.push(row2);
          }
          row2.initialize();
          if (!initialized) {
            rowHeight = row2.getElement().offsetHeight;
            if (rowHeight > this.vDomWindowBuffer) {
              this.vDomWindowBuffer = rowHeight * 2;
            }
          }
          fillableSpace -= rowHeight;
          paddingAdjust += rowHeight;
          this.vDomBottom++;
          index2++;
          i2++;
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    for (let row2 of addedRows) {
      row2.clearCellHeight();
    }
    this._quickNormalizeRowHeight(addedRows);
    if (paddingAdjust) {
      this.vDomBottomPad -= paddingAdjust;
      if (this.vDomBottomPad < 0 || index2 == rows3.length - 1) {
        this.vDomBottomPad = 0;
      }
      table.style.paddingBottom = this.vDomBottomPad + "px";
      this.vDomScrollPosBottom += paddingAdjust;
    }
  }
  _removeBottomRow(rows3, fillableSpace) {
    var removableRows = [], paddingAdjust = 0, i2 = 0, working = true;
    while (working) {
      let row2 = rows3[this.vDomBottom], rowHeight;
      if (row2 && i2 < this.vDomMaxRenderChain) {
        rowHeight = row2.getHeight() || this.vDomRowHeight;
        if (fillableSpace >= rowHeight) {
          this.vDomBottom--;
          fillableSpace -= rowHeight;
          paddingAdjust += rowHeight;
          removableRows.push(row2);
          i2++;
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }
    for (let row2 of removableRows) {
      let rowEl = row2.getElement();
      if (rowEl.parentNode) {
        rowEl.parentNode.removeChild(rowEl);
      }
    }
    if (paddingAdjust) {
      this.vDomBottomPad += paddingAdjust;
      if (this.vDomBottomPad < 0) {
        this.vDomBottomPad = 0;
      }
      this.tableElement.style.paddingBottom = this.vDomBottomPad + "px";
      this.vDomScrollPosBottom -= paddingAdjust;
    }
  }
  _quickNormalizeRowHeight(rows3) {
    for (let row2 of rows3) {
      row2.calcHeight();
    }
    for (let row2 of rows3) {
      row2.setCellHeight();
    }
  }
};
var RowManager = class extends CoreFeature {
  constructor(table) {
    super(table);
    this.element = this.createHolderElement();
    this.tableElement = this.createTableElement();
    this.heightFixer = this.createTableElement();
    this.placeholder = null;
    this.placeholderContents = null;
    this.firstRender = false;
    this.renderMode = "virtual";
    this.fixedHeight = false;
    this.rows = [];
    this.activeRowsPipeline = [];
    this.activeRows = [];
    this.activeRowsCount = 0;
    this.displayRows = [];
    this.displayRowsCount = 0;
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.redrawBlock = false;
    this.redrawBlockRestoreConfig = false;
    this.redrawBlockRenderInPosition = false;
    this.dataPipeline = [];
    this.displayPipeline = [];
    this.scrollbarWidth = 0;
    this.renderer = null;
  }
  createHolderElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-tableholder");
    el.setAttribute("tabindex", 0);
    return el;
  }
  createTableElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-table");
    el.setAttribute("role", "rowgroup");
    return el;
  }
  initializePlaceholder() {
    var placeholder = this.table.options.placeholder;
    if (placeholder) {
      let el = document.createElement("div");
      el.classList.add("tabulator-placeholder");
      if (typeof placeholder == "string") {
        let contents = document.createElement("div");
        contents.classList.add("tabulator-placeholder-contents");
        contents.innerHTML = placeholder;
        el.appendChild(contents);
        this.placeholderContents = contents;
      } else if (typeof HTMLElement !== "undefined" && placeholder instanceof HTMLElement) {
        el.appendChild(placeholder);
        this.placeholderContents = placeholder;
      } else {
        console.warn("Invalid placeholder provided, must be string or HTML Element", placeholder);
        this.el = null;
      }
      this.placeholder = el;
    }
  }
  getElement() {
    return this.element;
  }
  getTableElement() {
    return this.tableElement;
  }
  initialize() {
    this.initializePlaceholder();
    this.initializeRenderer();
    this.element.appendChild(this.tableElement);
    this.firstRender = true;
    this.element.addEventListener("scroll", () => {
      var left = this.element.scrollLeft, leftDir = this.scrollLeft > left, top = this.element.scrollTop, topDir = this.scrollTop > top;
      if (this.scrollLeft != left) {
        this.scrollLeft = left;
        this.dispatch("scroll-horizontal", left, leftDir);
        this.dispatchExternal("scrollHorizontal", left, leftDir);
        this._positionPlaceholder();
      }
      if (this.scrollTop != top) {
        this.scrollTop = top;
        this.renderer.scrollRows(top, topDir);
        this.dispatch("scroll-vertical", top, topDir);
        this.dispatchExternal("scrollVertical", top, topDir);
      }
    });
  }
  findRow(subject) {
    if (typeof subject == "object") {
      if (subject instanceof Row) {
        return subject;
      } else if (subject instanceof RowComponent) {
        return subject._getSelf() || false;
      } else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
        let match2 = this.rows.find((row2) => {
          return row2.getElement() === subject;
        });
        return match2 || false;
      } else if (subject === null) {
        return false;
      }
    } else if (typeof subject == "undefined") {
      return false;
    } else {
      let match2 = this.rows.find((row2) => {
        return row2.data[this.table.options.index] == subject;
      });
      return match2 || false;
    }
    return false;
  }
  getRowFromDataObject(data) {
    var match2 = this.rows.find((row2) => {
      return row2.data === data;
    });
    return match2 || false;
  }
  getRowFromPosition(position) {
    return this.getDisplayRows().find((row2) => {
      return row2.getPosition() === position && row2.isDisplayed();
    });
  }
  scrollToRow(row2, position, ifVisible) {
    return this.renderer.scrollToRowPosition(row2, position, ifVisible);
  }
  setData(data, renderInPosition, columnsChanged) {
    return new Promise((resolve2, reject) => {
      if (renderInPosition && this.getDisplayRows().length) {
        if (this.table.options.pagination) {
          this._setDataActual(data, true);
        } else {
          this.reRenderInPosition(() => {
            this._setDataActual(data);
          });
        }
      } else {
        if (this.table.options.autoColumns && columnsChanged && this.table.initialized) {
          this.table.columnManager.generateColumnsFromRowData(data);
        }
        this.resetScroll();
        this._setDataActual(data);
      }
      resolve2();
    });
  }
  _setDataActual(data, renderInPosition) {
    this.dispatchExternal("dataProcessing", data);
    this._wipeElements();
    if (Array.isArray(data)) {
      this.dispatch("data-processing", data);
      data.forEach((def, i2) => {
        if (def && typeof def === "object") {
          var row2 = new Row(def, this);
          this.rows.push(row2);
        } else {
          console.warn("Data Loading Warning - Invalid row data detected and ignored, expecting object but received:", def);
        }
      });
      this.refreshActiveData(false, false, renderInPosition);
      this.dispatch("data-processed", data);
      this.dispatchExternal("dataProcessed", data);
    } else {
      console.error("Data Loading Error - Unable to process data due to invalid data type \nExpecting: array \nReceived: ", typeof data, "\nData:     ", data);
    }
  }
  _wipeElements() {
    this.dispatch("rows-wipe");
    this.destroy();
    this.adjustTableSize();
    this.dispatch("rows-wiped");
  }
  destroy() {
    this.rows.forEach((row2) => {
      row2.wipe();
    });
    this.rows = [];
    this.activeRows = [];
    this.activeRowsPipeline = [];
    this.activeRowsCount = 0;
    this.displayRows = [];
    this.displayRowsCount = 0;
  }
  deleteRow(row2, blockRedraw) {
    var allIndex = this.rows.indexOf(row2), activeIndex = this.activeRows.indexOf(row2);
    if (activeIndex > -1) {
      this.activeRows.splice(activeIndex, 1);
    }
    if (allIndex > -1) {
      this.rows.splice(allIndex, 1);
    }
    this.setActiveRows(this.activeRows);
    this.displayRowIterator((rows3) => {
      var displayIndex = rows3.indexOf(row2);
      if (displayIndex > -1) {
        rows3.splice(displayIndex, 1);
      }
    });
    if (!blockRedraw) {
      this.reRenderInPosition();
    }
    this.regenerateRowPositions();
    this.dispatchExternal("rowDeleted", row2.getComponent());
    if (!this.displayRowsCount) {
      this._showPlaceholder();
    }
    if (this.subscribedExternal("dataChanged")) {
      this.dispatchExternal("dataChanged", this.getData());
    }
  }
  addRow(data, pos, index2, blockRedraw) {
    var row2 = this.addRowActual(data, pos, index2, blockRedraw);
    return row2;
  }
  addRows(data, pos, index2, refreshDisplayOnly) {
    var rows3 = [];
    return new Promise((resolve2, reject) => {
      pos = this.findAddRowPos(pos);
      if (!Array.isArray(data)) {
        data = [data];
      }
      if (typeof index2 == "undefined" && pos || typeof index2 !== "undefined" && !pos) {
        data.reverse();
      }
      data.forEach((item, i2) => {
        var row2 = this.addRow(item, pos, index2, true);
        rows3.push(row2);
        this.dispatch("row-added", row2, data, pos, index2);
      });
      this.refreshActiveData(refreshDisplayOnly ? "displayPipeline" : false, false, true);
      this.regenerateRowPositions();
      if (rows3.length) {
        this._clearPlaceholder();
      }
      resolve2(rows3);
    });
  }
  findAddRowPos(pos) {
    if (typeof pos === "undefined") {
      pos = this.table.options.addRowPos;
    }
    if (pos === "pos") {
      pos = true;
    }
    if (pos === "bottom") {
      pos = false;
    }
    return pos;
  }
  addRowActual(data, pos, index2, blockRedraw) {
    var row2 = data instanceof Row ? data : new Row(data || {}, this), top = this.findAddRowPos(pos), allIndex = -1, activeIndex, chainResult;
    if (!index2) {
      chainResult = this.chain("row-adding-position", [row2, top], null, { index: index2, top });
      index2 = chainResult.index;
      top = chainResult.top;
    }
    if (typeof index2 !== "undefined") {
      index2 = this.findRow(index2);
    }
    index2 = this.chain("row-adding-index", [row2, index2, top], null, index2);
    if (index2) {
      allIndex = this.rows.indexOf(index2);
    }
    if (index2 && allIndex > -1) {
      activeIndex = this.activeRows.indexOf(index2);
      this.displayRowIterator(function(rows3) {
        var displayIndex = rows3.indexOf(index2);
        if (displayIndex > -1) {
          rows3.splice(top ? displayIndex : displayIndex + 1, 0, row2);
        }
      });
      if (activeIndex > -1) {
        this.activeRows.splice(top ? activeIndex : activeIndex + 1, 0, row2);
      }
      this.rows.splice(top ? allIndex : allIndex + 1, 0, row2);
    } else {
      if (top) {
        this.displayRowIterator(function(rows3) {
          rows3.unshift(row2);
        });
        this.activeRows.unshift(row2);
        this.rows.unshift(row2);
      } else {
        this.displayRowIterator(function(rows3) {
          rows3.push(row2);
        });
        this.activeRows.push(row2);
        this.rows.push(row2);
      }
    }
    this.setActiveRows(this.activeRows);
    this.dispatchExternal("rowAdded", row2.getComponent());
    if (this.subscribedExternal("dataChanged")) {
      this.dispatchExternal("dataChanged", this.table.rowManager.getData());
    }
    if (!blockRedraw) {
      this.reRenderInPosition();
    }
    return row2;
  }
  moveRow(from2, to2, after) {
    this.dispatch("row-move", from2, to2, after);
    this.moveRowActual(from2, to2, after);
    this.regenerateRowPositions();
    this.dispatch("row-moved", from2, to2, after);
    this.dispatchExternal("rowMoved", from2.getComponent());
  }
  moveRowActual(from2, to2, after) {
    this.moveRowInArray(this.rows, from2, to2, after);
    this.moveRowInArray(this.activeRows, from2, to2, after);
    this.displayRowIterator((rows3) => {
      this.moveRowInArray(rows3, from2, to2, after);
    });
    this.dispatch("row-moving", from2, to2, after);
  }
  moveRowInArray(rows3, from2, to2, after) {
    var fromIndex, toIndex, start, end;
    if (from2 !== to2) {
      fromIndex = rows3.indexOf(from2);
      if (fromIndex > -1) {
        rows3.splice(fromIndex, 1);
        toIndex = rows3.indexOf(to2);
        if (toIndex > -1) {
          if (after) {
            rows3.splice(toIndex + 1, 0, from2);
          } else {
            rows3.splice(toIndex, 0, from2);
          }
        } else {
          rows3.splice(fromIndex, 0, from2);
        }
      }
      if (rows3 === this.getDisplayRows()) {
        start = fromIndex < toIndex ? fromIndex : toIndex;
        end = toIndex > fromIndex ? toIndex : fromIndex + 1;
        for (let i2 = start; i2 <= end; i2++) {
          if (rows3[i2]) {
            this.styleRow(rows3[i2], i2);
          }
        }
      }
    }
  }
  clearData() {
    this.setData([]);
  }
  getRowIndex(row2) {
    return this.findRowIndex(row2, this.rows);
  }
  getDisplayRowIndex(row2) {
    var index2 = this.getDisplayRows().indexOf(row2);
    return index2 > -1 ? index2 : false;
  }
  nextDisplayRow(row2, rowOnly) {
    var index2 = this.getDisplayRowIndex(row2), nextRow = false;
    if (index2 !== false && index2 < this.displayRowsCount - 1) {
      nextRow = this.getDisplayRows()[index2 + 1];
    }
    if (nextRow && (!(nextRow instanceof Row) || nextRow.type != "row")) {
      return this.nextDisplayRow(nextRow, rowOnly);
    }
    return nextRow;
  }
  prevDisplayRow(row2, rowOnly) {
    var index2 = this.getDisplayRowIndex(row2), prevRow = false;
    if (index2) {
      prevRow = this.getDisplayRows()[index2 - 1];
    }
    if (rowOnly && prevRow && (!(prevRow instanceof Row) || prevRow.type != "row")) {
      return this.prevDisplayRow(prevRow, rowOnly);
    }
    return prevRow;
  }
  findRowIndex(row2, list2) {
    var rowIndex;
    row2 = this.findRow(row2);
    if (row2) {
      rowIndex = list2.indexOf(row2);
      if (rowIndex > -1) {
        return rowIndex;
      }
    }
    return false;
  }
  getData(active, transform) {
    var output = [], rows3 = this.getRows(active);
    rows3.forEach(function(row2) {
      if (row2.type == "row") {
        output.push(row2.getData(transform || "data"));
      }
    });
    return output;
  }
  getComponents(active) {
    var output = [], rows3 = this.getRows(active);
    rows3.forEach(function(row2) {
      output.push(row2.getComponent());
    });
    return output;
  }
  getDataCount(active) {
    var rows3 = this.getRows(active);
    return rows3.length;
  }
  scrollHorizontal(left) {
    this.scrollLeft = left;
    this.element.scrollLeft = left;
    this.dispatch("scroll-horizontal", left);
  }
  registerDataPipelineHandler(handler, priority) {
    if (typeof priority !== "undefined") {
      this.dataPipeline.push({ handler, priority });
      this.dataPipeline.sort((a, b) => {
        return a.priority - b.priority;
      });
    } else {
      console.error("Data pipeline handlers must have a priority in order to be registered");
    }
  }
  registerDisplayPipelineHandler(handler, priority) {
    if (typeof priority !== "undefined") {
      this.displayPipeline.push({ handler, priority });
      this.displayPipeline.sort((a, b) => {
        return a.priority - b.priority;
      });
    } else {
      console.error("Display pipeline handlers must have a priority in order to be registered");
    }
  }
  refreshActiveData(handler, skipStage, renderInPosition) {
    var table = this.table, stage = "", index2 = 0, cascadeOrder = ["all", "dataPipeline", "display", "displayPipeline", "end"];
    if (!this.table.destroyed) {
      if (typeof handler === "function") {
        index2 = this.dataPipeline.findIndex((item) => {
          return item.handler === handler;
        });
        if (index2 > -1) {
          stage = "dataPipeline";
          if (skipStage) {
            if (index2 == this.dataPipeline.length - 1) {
              stage = "display";
            } else {
              index2++;
            }
          }
        } else {
          index2 = this.displayPipeline.findIndex((item) => {
            return item.handler === handler;
          });
          if (index2 > -1) {
            stage = "displayPipeline";
            if (skipStage) {
              if (index2 == this.displayPipeline.length - 1) {
                stage = "end";
              } else {
                index2++;
              }
            }
          } else {
            console.error("Unable to refresh data, invalid handler provided", handler);
            return;
          }
        }
      } else {
        stage = handler || "all";
        index2 = 0;
      }
      if (this.redrawBlock) {
        if (!this.redrawBlockRestoreConfig || this.redrawBlockRestoreConfig && (this.redrawBlockRestoreConfig.stage === stage && index2 < this.redrawBlockRestoreConfig.index || cascadeOrder.indexOf(stage) < cascadeOrder.indexOf(this.redrawBlockRestoreConfig.stage))) {
          this.redrawBlockRestoreConfig = {
            handler,
            skipStage,
            renderInPosition,
            stage,
            index: index2
          };
        }
        return;
      } else {
        if (Helpers.elVisible(this.element)) {
          if (renderInPosition) {
            this.reRenderInPosition(this.refreshPipelines.bind(this, handler, stage, index2, renderInPosition));
          } else {
            this.refreshPipelines(handler, stage, index2, renderInPosition);
            if (!handler) {
              this.table.columnManager.renderer.renderColumns();
            }
            this.renderTable();
            if (table.options.layoutColumnsOnNewData) {
              this.table.columnManager.redraw(true);
            }
          }
        } else {
          this.refreshPipelines(handler, stage, index2, renderInPosition);
        }
        this.dispatch("data-refreshed");
      }
    }
  }
  refreshPipelines(handler, stage, index2, renderInPosition) {
    this.dispatch("data-refreshing");
    if (!handler) {
      this.activeRowsPipeline[0] = this.rows.slice(0);
    }
    switch (stage) {
      case "all":
      case "dataPipeline":
        for (let i2 = index2; i2 < this.dataPipeline.length; i2++) {
          let result = this.dataPipeline[i2].handler(this.activeRowsPipeline[i2].slice(0));
          this.activeRowsPipeline[i2 + 1] = result || this.activeRowsPipeline[i2].slice(0);
        }
        this.setActiveRows(this.activeRowsPipeline[this.dataPipeline.length]);
      case "display":
        index2 = 0;
        this.resetDisplayRows();
      case "displayPipeline":
        for (let i2 = index2; i2 < this.displayPipeline.length; i2++) {
          let result = this.displayPipeline[i2].handler((i2 ? this.getDisplayRows(i2 - 1) : this.activeRows).slice(0), renderInPosition);
          this.setDisplayRows(result || this.getDisplayRows(i2 - 1).slice(0), i2);
        }
      case "end":
        this.regenerateRowPositions();
    }
    if (this.getDisplayRows().length) {
      this._clearPlaceholder();
    }
  }
  regenerateRowPositions() {
    var rows3 = this.getDisplayRows();
    var index2 = 1;
    rows3.forEach((row2) => {
      if (row2.type === "row") {
        row2.setPosition(index2);
        index2++;
      }
    });
  }
  setActiveRows(activeRows) {
    this.activeRows = activeRows;
    this.activeRowsCount = this.activeRows.length;
  }
  resetDisplayRows() {
    this.displayRows = [];
    this.displayRows.push(this.activeRows.slice(0));
    this.displayRowsCount = this.displayRows[0].length;
  }
  setDisplayRows(displayRows, index2) {
    this.displayRows[index2] = displayRows;
    if (index2 == this.displayRows.length - 1) {
      this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
    }
  }
  getDisplayRows(index2) {
    if (typeof index2 == "undefined") {
      return this.displayRows.length ? this.displayRows[this.displayRows.length - 1] : [];
    } else {
      return this.displayRows[index2] || [];
    }
  }
  getVisibleRows(chain, viewable) {
    var rows3 = Object.assign([], this.renderer.visibleRows(!viewable));
    if (chain) {
      rows3 = this.chain("rows-visible", [viewable], rows3, rows3);
    }
    return rows3;
  }
  displayRowIterator(callback2) {
    this.activeRowsPipeline.forEach(callback2);
    this.displayRows.forEach(callback2);
    this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
  }
  getRows(type) {
    var rows3 = [];
    switch (type) {
      case "active":
        rows3 = this.activeRows;
        break;
      case "display":
        rows3 = this.table.rowManager.getDisplayRows();
        break;
      case "visible":
        rows3 = this.getVisibleRows(false, true);
        break;
      default:
        rows3 = this.chain("rows-retrieve", type, null, this.rows) || this.rows;
    }
    return rows3;
  }
  reRenderInPosition(callback2) {
    if (this.redrawBlock) {
      if (callback2) {
        callback2();
      } else {
        this.redrawBlockRenderInPosition = true;
      }
    } else {
      this.dispatchExternal("renderStarted");
      this.renderer.rerenderRows(callback2);
      if (!this.fixedHeight) {
        this.adjustTableSize();
      }
      this.scrollBarCheck();
      this.dispatchExternal("renderComplete");
    }
  }
  scrollBarCheck() {
    var scrollbarWidth = 0;
    if (this.element.scrollHeight > this.element.clientHeight) {
      scrollbarWidth = this.element.offsetWidth - this.element.clientWidth;
    }
    if (scrollbarWidth !== this.scrollbarWidth) {
      this.scrollbarWidth = scrollbarWidth;
      this.dispatch("scrollbar-vertical", scrollbarWidth);
    }
  }
  initializeRenderer() {
    var renderClass;
    var renderers = {
      "virtual": VirtualDomVertical,
      "basic": BasicVertical
    };
    if (typeof this.table.options.renderVertical === "string") {
      renderClass = renderers[this.table.options.renderVertical];
    } else {
      renderClass = this.table.options.renderVertical;
    }
    if (renderClass) {
      this.renderMode = this.table.options.renderVertical;
      this.renderer = new renderClass(this.table, this.element, this.tableElement);
      this.renderer.initialize();
      if (this.table.element.clientHeight || this.table.options.height) {
        this.fixedHeight = true;
      } else {
        this.fixedHeight = false;
      }
    } else {
      console.error("Unable to find matching renderer:", this.table.options.renderVertical);
    }
  }
  getRenderMode() {
    return this.renderMode;
  }
  renderTable() {
    this.dispatchExternal("renderStarted");
    this.element.scrollTop = 0;
    this._clearTable();
    if (this.displayRowsCount) {
      this.renderer.renderRows();
      if (this.firstRender) {
        this.firstRender = false;
        this.layoutRefresh(true);
      }
    } else {
      this.renderEmptyScroll();
    }
    if (!this.fixedHeight) {
      this.adjustTableSize();
    }
    this.dispatch("table-layout");
    if (!this.displayRowsCount) {
      this._showPlaceholder();
    }
    this.scrollBarCheck();
    this.dispatchExternal("renderComplete");
  }
  renderEmptyScroll() {
    if (this.placeholder) {
      this.tableElement.style.display = "none";
    } else {
      this.tableElement.style.minWidth = this.table.columnManager.getWidth() + "px";
    }
  }
  _clearTable() {
    this._clearPlaceholder();
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.renderer.clearRows();
  }
  _showPlaceholder() {
    if (this.placeholder) {
      this.placeholder.setAttribute("tabulator-render-mode", this.renderMode);
      this.getElement().appendChild(this.placeholder);
      this._positionPlaceholder();
    }
  }
  _clearPlaceholder() {
    if (this.placeholder && this.placeholder.parentNode) {
      this.placeholder.parentNode.removeChild(this.placeholder);
    }
    this.tableElement.style.minWidth = "";
  }
  _positionPlaceholder() {
    if (this.placeholder && this.placeholder.parentNode) {
      this.placeholder.style.width = this.table.columnManager.getWidth() + "px";
      this.placeholderContents.style.width = this.table.rowManager.element.clientWidth + "px";
      this.placeholderContents.style.marginLeft = this.scrollLeft + "px";
    }
  }
  styleRow(row2, index2) {
    var rowEl = row2.getElement();
    if (index2 % 2) {
      rowEl.classList.add("tabulator-row-even");
      rowEl.classList.remove("tabulator-row-odd");
    } else {
      rowEl.classList.add("tabulator-row-odd");
      rowEl.classList.remove("tabulator-row-even");
    }
  }
  normalizeHeight() {
    this.activeRows.forEach(function(row2) {
      row2.normalizeHeight();
    });
  }
  adjustTableSize() {
    var initialHeight = this.element.clientHeight, minHeight;
    if (this.renderer.verticalFillMode === "fill") {
      let otherHeight = Math.floor(this.table.columnManager.getElement().getBoundingClientRect().height + (this.table.footerManager && this.table.footerManager.active && !this.table.footerManager.external ? this.table.footerManager.getElement().getBoundingClientRect().height : 0));
      if (this.fixedHeight) {
        minHeight = isNaN(this.table.options.minHeight) ? this.table.options.minHeight : this.table.options.minHeight + "px";
        this.element.style.minHeight = minHeight || "calc(100% - " + otherHeight + "px)";
        this.element.style.height = "calc(100% - " + otherHeight + "px)";
        this.element.style.maxHeight = "calc(100% - " + otherHeight + "px)";
      } else {
        this.element.style.height = "";
        this.element.style.height = this.table.element.clientHeight - otherHeight + "px";
        this.element.scrollTop = this.scrollTop;
      }
      this.renderer.resize();
      if (!this.fixedHeight && initialHeight != this.element.clientHeight) {
        if (this.subscribed("table-resize")) {
          this.dispatch("table-resize");
        } else {
          this.redraw();
        }
      }
      this.scrollBarCheck();
    }
    this._positionPlaceholder();
  }
  reinitialize() {
    this.rows.forEach(function(row2) {
      row2.reinitialize(true);
    });
  }
  blockRedraw() {
    this.redrawBlock = true;
    this.redrawBlockRestoreConfig = false;
  }
  restoreRedraw() {
    this.redrawBlock = false;
    if (this.redrawBlockRestoreConfig) {
      this.refreshActiveData(this.redrawBlockRestoreConfig.handler, this.redrawBlockRestoreConfig.skipStage, this.redrawBlockRestoreConfig.renderInPosition);
      this.redrawBlockRestoreConfig = false;
    } else {
      if (this.redrawBlockRenderInPosition) {
        this.reRenderInPosition();
      }
    }
    this.redrawBlockRenderInPosition = false;
  }
  redraw(force) {
    var left = this.scrollLeft;
    this.adjustTableSize();
    this.table.tableWidth = this.table.element.clientWidth;
    if (!force) {
      this.reRenderInPosition();
      this.scrollHorizontal(left);
    } else {
      this.renderTable();
    }
  }
  resetScroll() {
    this.element.scrollLeft = 0;
    this.element.scrollTop = 0;
    if (this.table.browser === "ie") {
      var event = document.createEvent("Event");
      event.initEvent("scroll", false, true);
      this.element.dispatchEvent(event);
    } else {
      this.element.dispatchEvent(new Event("scroll"));
    }
  }
};
var FooterManager = class extends CoreFeature {
  constructor(table) {
    super(table);
    this.active = false;
    this.element = this.createElement();
    this.containerElement = this.createContainerElement();
    this.external = false;
  }
  initialize() {
    this.initializeElement();
  }
  createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-footer");
    return el;
  }
  createContainerElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-footer-contents");
    this.element.appendChild(el);
    return el;
  }
  initializeElement() {
    if (this.table.options.footerElement) {
      switch (typeof this.table.options.footerElement) {
        case "string":
          if (this.table.options.footerElement[0] === "<") {
            this.containerElement.innerHTML = this.table.options.footerElement;
          } else {
            this.external = true;
            this.containerElement = document.querySelector(this.table.options.footerElement);
          }
          break;
        default:
          this.element = this.table.options.footerElement;
          break;
      }
    }
  }
  getElement() {
    return this.element;
  }
  append(element) {
    this.activate();
    this.containerElement.appendChild(element);
    this.table.rowManager.adjustTableSize();
  }
  prepend(element) {
    this.activate();
    this.element.insertBefore(element, this.element.firstChild);
    this.table.rowManager.adjustTableSize();
  }
  remove(element) {
    element.parentNode.removeChild(element);
    this.deactivate();
  }
  deactivate(force) {
    if (!this.element.firstChild || force) {
      if (!this.external) {
        this.element.parentNode.removeChild(this.element);
      }
      this.active = false;
    }
  }
  activate() {
    if (!this.active) {
      this.active = true;
      if (!this.external) {
        this.table.element.appendChild(this.getElement());
        this.table.element.style.display = "";
      }
    }
  }
  redraw() {
    this.dispatch("footer-redraw");
  }
};
var InteractionManager = class extends CoreFeature {
  constructor(table) {
    super(table);
    this.el = null;
    this.abortClasses = ["tabulator-headers", "tabulator-table"];
    this.previousTargets = {};
    this.listeners = [
      "click",
      "dblclick",
      "contextmenu",
      "mouseenter",
      "mouseleave",
      "mouseover",
      "mouseout",
      "mousemove",
      "mouseup",
      "mousedown",
      "touchstart",
      "touchend"
    ];
    this.componentMap = {
      "tabulator-cell": "cell",
      "tabulator-row": "row",
      "tabulator-group": "group",
      "tabulator-col": "column"
    };
    this.pseudoTrackers = {
      "row": {
        subscriber: null,
        target: null
      },
      "cell": {
        subscriber: null,
        target: null
      },
      "group": {
        subscriber: null,
        target: null
      },
      "column": {
        subscriber: null,
        target: null
      }
    };
    this.pseudoTracking = false;
  }
  initialize() {
    this.el = this.table.element;
    this.buildListenerMap();
    this.bindSubscriptionWatchers();
  }
  buildListenerMap() {
    var listenerMap = {};
    this.listeners.forEach((listener) => {
      listenerMap[listener] = {
        handler: null,
        components: []
      };
    });
    this.listeners = listenerMap;
  }
  bindPseudoEvents() {
    Object.keys(this.pseudoTrackers).forEach((key) => {
      this.pseudoTrackers[key].subscriber = this.pseudoMouseEnter.bind(this, key);
      this.subscribe(key + "-mouseover", this.pseudoTrackers[key].subscriber);
    });
    this.pseudoTracking = true;
  }
  pseudoMouseEnter(key, e, target) {
    if (this.pseudoTrackers[key].target !== target) {
      if (this.pseudoTrackers[key].target) {
        this.dispatch(key + "-mouseleave", e, this.pseudoTrackers[key].target);
      }
      this.pseudoMouseLeave(key, e);
      this.pseudoTrackers[key].target = target;
      this.dispatch(key + "-mouseenter", e, target);
    }
  }
  pseudoMouseLeave(key, e) {
    var leaveList = Object.keys(this.pseudoTrackers), linkedKeys = {
      "row": ["cell"],
      "cell": ["row"]
    };
    leaveList = leaveList.filter((item) => {
      var links = linkedKeys[key];
      return item !== key && (!links || links && !links.includes(item));
    });
    leaveList.forEach((key2) => {
      var target = this.pseudoTrackers[key2].target;
      if (this.pseudoTrackers[key2].target) {
        this.dispatch(key2 + "-mouseleave", e, target);
        this.pseudoTrackers[key2].target = null;
      }
    });
  }
  bindSubscriptionWatchers() {
    var listeners = Object.keys(this.listeners), components = Object.values(this.componentMap);
    for (let comp of components) {
      for (let listener of listeners) {
        let key = comp + "-" + listener;
        this.subscriptionChange(key, this.subscriptionChanged.bind(this, comp, listener));
      }
    }
    this.subscribe("table-destroy", this.clearWatchers.bind(this));
  }
  subscriptionChanged(component, key, added) {
    var listener = this.listeners[key].components, index2 = listener.indexOf(component), changed = false;
    if (added) {
      if (index2 === -1) {
        listener.push(component);
        changed = true;
      }
    } else {
      if (!this.subscribed(component + "-" + key)) {
        if (index2 > -1) {
          listener.splice(index2, 1);
          changed = true;
        }
      }
    }
    if ((key === "mouseenter" || key === "mouseleave") && !this.pseudoTracking) {
      this.bindPseudoEvents();
    }
    if (changed) {
      this.updateEventListeners();
    }
  }
  updateEventListeners() {
    for (let key in this.listeners) {
      let listener = this.listeners[key];
      if (listener.components.length) {
        if (!listener.handler) {
          listener.handler = this.track.bind(this, key);
          this.el.addEventListener(key, listener.handler);
        }
      } else {
        if (listener.handler) {
          this.el.removeEventListener(key, listener.handler);
          listener.handler = null;
        }
      }
    }
  }
  track(type, e) {
    var path = e.composedPath && e.composedPath() || e.path;
    var targets = this.findTargets(path);
    targets = this.bindComponents(type, targets);
    this.triggerEvents(type, e, targets);
    if (this.pseudoTracking && (type == "mouseover" || type == "mouseleave") && !Object.keys(targets).length) {
      this.pseudoMouseLeave("none", e);
    }
  }
  findTargets(path) {
    var targets = {};
    let componentMap = Object.keys(this.componentMap);
    for (let el of path) {
      let classList = el.classList ? [...el.classList] : [];
      let abort = classList.filter((item) => {
        return this.abortClasses.includes(item);
      });
      if (abort.length) {
        break;
      }
      let elTargets = classList.filter((item) => {
        return componentMap.includes(item);
      });
      for (let target of elTargets) {
        if (!targets[this.componentMap[target]]) {
          targets[this.componentMap[target]] = el;
        }
      }
    }
    if (targets.group && targets.group === targets.row) {
      delete targets.row;
    }
    return targets;
  }
  bindComponents(type, targets) {
    var keys = Object.keys(targets).reverse(), listener = this.listeners[type], matches = {}, targetMatches = {};
    for (let key of keys) {
      let component, target = targets[key], previousTarget = this.previousTargets[key];
      if (previousTarget && previousTarget.target === target) {
        component = previousTarget.component;
      } else {
        switch (key) {
          case "row":
          case "group":
            if (listener.components.includes("row") || listener.components.includes("cell") || listener.components.includes("group")) {
              let rows3 = this.table.rowManager.getVisibleRows(true);
              component = rows3.find((row2) => {
                return row2.getElement() === target;
              });
              if (targets["row"] && targets["row"].parentNode && targets["row"].parentNode.closest(".tabulator-row")) {
                targets[key] = false;
              }
            }
            break;
          case "column":
            if (listener.components.includes("column")) {
              component = this.table.columnManager.findColumn(target);
            }
            break;
          case "cell":
            if (listener.components.includes("cell")) {
              if (matches["row"] instanceof Row) {
                component = matches["row"].findCell(target);
              } else {
                if (targets["row"]) {
                  console.warn("Event Target Lookup Error - The row this cell is attached to cannot be found, has the table been reinitialized without being destroyed first?");
                }
              }
            }
            break;
        }
      }
      if (component) {
        matches[key] = component;
        targetMatches[key] = {
          target,
          component
        };
      }
    }
    this.previousTargets = targetMatches;
    return matches;
  }
  triggerEvents(type, e, targets) {
    var listener = this.listeners[type];
    for (let key in targets) {
      if (targets[key] && listener.components.includes(key)) {
        this.dispatch(key + "-" + type, e, targets[key]);
      }
    }
  }
  clearWatchers() {
    for (let key in this.listeners) {
      let listener = this.listeners[key];
      if (listener.handler) {
        this.el.removeEventListener(key, listener.handler);
        listener.handler = null;
      }
    }
  }
};
var ComponentFunctionBinder = class {
  constructor(table) {
    this.table = table;
    this.bindings = {};
  }
  bind(type, funcName, handler) {
    if (!this.bindings[type]) {
      this.bindings[type] = {};
    }
    if (this.bindings[type][funcName]) {
      console.warn("Unable to bind component handler, a matching function name is already bound", type, funcName, handler);
    } else {
      this.bindings[type][funcName] = handler;
    }
  }
  handle(type, component, name) {
    if (this.bindings[type] && this.bindings[type][name] && typeof this.bindings[type][name].bind === "function") {
      return this.bindings[type][name].bind(null, component);
    } else {
      if (name !== "then" && typeof name === "string" && !name.startsWith("_")) {
        if (this.table.options.debugInvalidComponentFuncs) {
          console.error("The " + type + " component does not have a " + name + " function, have you checked that you have the correct Tabulator module installed?");
        }
      }
    }
  }
};
var DataLoader = class extends CoreFeature {
  constructor(table) {
    super(table);
    this.requestOrder = 0;
    this.loading = false;
  }
  initialize() {
  }
  load(data, params, config, replace, silent, columnsChanged) {
    var requestNo = ++this.requestOrder;
    this.dispatchExternal("dataLoading", data);
    if (data && (data.indexOf("{") == 0 || data.indexOf("[") == 0)) {
      data = JSON.parse(data);
    }
    if (this.confirm("data-loading", [data, params, config, silent])) {
      this.loading = true;
      if (!silent) {
        this.alertLoader();
      }
      params = this.chain("data-params", [data, config, silent], params || {}, params || {});
      params = this.mapParams(params, this.table.options.dataSendParams);
      var result = this.chain("data-load", [data, params, config, silent], false, Promise.resolve([]));
      return result.then((response) => {
        if (!Array.isArray(response) && typeof response == "object") {
          response = this.mapParams(response, this.objectInvert(this.table.options.dataReceiveParams));
        }
        var rowData = this.chain("data-loaded", response, null, response);
        if (requestNo == this.requestOrder) {
          this.clearAlert();
          if (rowData !== false) {
            this.dispatchExternal("dataLoaded", rowData);
            this.table.rowManager.setData(rowData, replace, typeof columnsChanged === "undefined" ? !replace : columnsChanged);
          }
        } else {
          console.warn("Data Load Response Blocked - An active data load request was blocked by an attempt to change table data while the request was being made");
        }
      }).catch((error) => {
        console.error("Data Load Error: ", error);
        this.dispatchExternal("dataLoadError", error);
        if (!silent) {
          this.alertError();
        }
        setTimeout(() => {
          this.clearAlert();
        }, this.table.options.dataLoaderErrorTimeout);
      }).finally(() => {
        this.loading = false;
      });
    } else {
      this.dispatchExternal("dataLoaded", data);
      if (!data) {
        data = [];
      }
      this.table.rowManager.setData(data, replace, typeof columnsChanged === "undefined" ? !replace : columnsChanged);
      return Promise.resolve();
    }
  }
  mapParams(params, map3) {
    var output = {};
    for (let key in params) {
      output[map3.hasOwnProperty(key) ? map3[key] : key] = params[key];
    }
    return output;
  }
  objectInvert(obj) {
    var output = {};
    for (let key in obj) {
      output[obj[key]] = key;
    }
    return output;
  }
  blockActiveLoad() {
    this.requestOrder++;
  }
  alertLoader() {
    var shouldLoad = typeof this.table.options.dataLoader === "function" ? this.table.options.dataLoader() : this.table.options.dataLoader;
    if (shouldLoad) {
      this.table.alertManager.alert(this.table.options.dataLoaderLoading || this.langText("data|loading"));
    }
  }
  alertError() {
    this.table.alertManager.alert(this.table.options.dataLoaderError || this.langText("data|error"), "error");
  }
  clearAlert() {
    this.table.alertManager.clear();
  }
};
var ExternalEventBus = class {
  constructor(table, optionsList, debug) {
    this.table = table;
    this.events = {};
    this.optionsList = optionsList || {};
    this.subscriptionNotifiers = {};
    this.dispatch = debug ? this._debugDispatch.bind(this) : this._dispatch.bind(this);
    this.debug = debug;
  }
  subscriptionChange(key, callback2) {
    if (!this.subscriptionNotifiers[key]) {
      this.subscriptionNotifiers[key] = [];
    }
    this.subscriptionNotifiers[key].push(callback2);
    if (this.subscribed(key)) {
      this._notifySubscriptionChange(key, true);
    }
  }
  subscribe(key, callback2) {
    if (!this.events[key]) {
      this.events[key] = [];
    }
    this.events[key].push(callback2);
    this._notifySubscriptionChange(key, true);
  }
  unsubscribe(key, callback2) {
    var index2;
    if (this.events[key]) {
      if (callback2) {
        index2 = this.events[key].findIndex((item) => {
          return item === callback2;
        });
        if (index2 > -1) {
          this.events[key].splice(index2, 1);
        } else {
          console.warn("Cannot remove event, no matching event found:", key, callback2);
          return;
        }
      } else {
        delete this.events[key];
      }
    } else {
      console.warn("Cannot remove event, no events set on:", key);
      return;
    }
    this._notifySubscriptionChange(key, false);
  }
  subscribed(key) {
    return this.events[key] && this.events[key].length;
  }
  _notifySubscriptionChange(key, subscribed) {
    var notifiers = this.subscriptionNotifiers[key];
    if (notifiers) {
      notifiers.forEach((callback2) => {
        callback2(subscribed);
      });
    }
  }
  _dispatch() {
    var args = Array.from(arguments), key = args.shift(), result;
    if (this.events[key]) {
      this.events[key].forEach((callback2, i2) => {
        let callResult = callback2.apply(this.table, args);
        if (!i2) {
          result = callResult;
        }
      });
    }
    return result;
  }
  _debugDispatch() {
    var args = Array.from(arguments), key = args[0];
    args[0] = "ExternalEvent:" + args[0];
    if (this.debug === true || this.debug.includes(key)) {
      console.log(...args);
    }
    return this._dispatch(...arguments);
  }
};
var InternalEventBus = class {
  constructor(debug) {
    this.events = {};
    this.subscriptionNotifiers = {};
    this.dispatch = debug ? this._debugDispatch.bind(this) : this._dispatch.bind(this);
    this.chain = debug ? this._debugChain.bind(this) : this._chain.bind(this);
    this.confirm = debug ? this._debugConfirm.bind(this) : this._confirm.bind(this);
    this.debug = debug;
  }
  subscriptionChange(key, callback2) {
    if (!this.subscriptionNotifiers[key]) {
      this.subscriptionNotifiers[key] = [];
    }
    this.subscriptionNotifiers[key].push(callback2);
    if (this.subscribed(key)) {
      this._notifySubscriptionChange(key, true);
    }
  }
  subscribe(key, callback2, priority = 1e4) {
    if (!this.events[key]) {
      this.events[key] = [];
    }
    this.events[key].push({ callback: callback2, priority });
    this.events[key].sort((a, b) => {
      return a.priority - b.priority;
    });
    this._notifySubscriptionChange(key, true);
  }
  unsubscribe(key, callback2) {
    var index2;
    if (this.events[key]) {
      if (callback2) {
        index2 = this.events[key].findIndex((item) => {
          return item.callback === callback2;
        });
        if (index2 > -1) {
          this.events[key].splice(index2, 1);
        } else {
          console.warn("Cannot remove event, no matching event found:", key, callback2);
          return;
        }
      }
    } else {
      console.warn("Cannot remove event, no events set on:", key);
      return;
    }
    this._notifySubscriptionChange(key, false);
  }
  subscribed(key) {
    return this.events[key] && this.events[key].length;
  }
  _chain(key, args, initialValue, fallback) {
    var value = initialValue;
    if (!Array.isArray(args)) {
      args = [args];
    }
    if (this.subscribed(key)) {
      this.events[key].forEach((subscriber, i2) => {
        value = subscriber.callback.apply(this, args.concat([value]));
      });
      return value;
    } else {
      return typeof fallback === "function" ? fallback() : fallback;
    }
  }
  _confirm(key, args) {
    var confirmed = false;
    if (!Array.isArray(args)) {
      args = [args];
    }
    if (this.subscribed(key)) {
      this.events[key].forEach((subscriber, i2) => {
        if (subscriber.callback.apply(this, args)) {
          confirmed = true;
        }
      });
    }
    return confirmed;
  }
  _notifySubscriptionChange(key, subscribed) {
    var notifiers = this.subscriptionNotifiers[key];
    if (notifiers) {
      notifiers.forEach((callback2) => {
        callback2(subscribed);
      });
    }
  }
  _dispatch() {
    var args = Array.from(arguments), key = args.shift();
    if (this.events[key]) {
      this.events[key].forEach((subscriber) => {
        subscriber.callback.apply(this, args);
      });
    }
  }
  _debugDispatch() {
    var args = Array.from(arguments), key = args[0];
    args[0] = "InternalEvent:" + key;
    if (this.debug === true || this.debug.includes(key)) {
      console.log(...args);
    }
    return this._dispatch(...arguments);
  }
  _debugChain() {
    var args = Array.from(arguments), key = args[0];
    args[0] = "InternalEvent:" + key;
    if (this.debug === true || this.debug.includes(key)) {
      console.log(...args);
    }
    return this._chain(...arguments);
  }
  _debugConfirm() {
    var args = Array.from(arguments), key = args[0];
    args[0] = "InternalEvent:" + key;
    if (this.debug === true || this.debug.includes(key)) {
      console.log(...args);
    }
    return this._confirm(...arguments);
  }
};
var DeprecationAdvisor = class extends CoreFeature {
  constructor(table) {
    super(table);
  }
  _warnUser() {
    if (this.options("debugDeprecation")) {
      console.warn(...arguments);
    }
  }
  check(oldOption, newOption) {
    var msg = "";
    if (typeof this.options(oldOption) !== "undefined") {
      msg = "Deprecated Setup Option - Use of the %c" + oldOption + "%c option is now deprecated";
      if (newOption) {
        msg = msg + ", Please use the %c" + newOption + "%c option instead";
        this._warnUser(msg, "font-weight: bold;", "font-weight: normal;", "font-weight: bold;", "font-weight: normal;");
      } else {
        this._warnUser(msg, "font-weight: bold;", "font-weight: normal;");
      }
      return false;
    } else {
      return true;
    }
  }
  checkMsg(oldOption, msg) {
    if (typeof this.options(oldOption) !== "undefined") {
      this._warnUser("%cDeprecated Setup Option - Use of the %c" + oldOption + " %c option is now deprecated, " + msg, "font-weight: normal;", "font-weight: bold;", "font-weight: normal;");
      return false;
    } else {
      return true;
    }
  }
  msg(msg) {
    this._warnUser(msg);
  }
};
var TableRegistry = class {
  static register(table) {
    TableRegistry.tables.push(table);
  }
  static deregister(table) {
    var index2 = TableRegistry.tables.indexOf(table);
    if (index2 > -1) {
      TableRegistry.tables.splice(index2, 1);
    }
  }
  static lookupTable(query, silent) {
    var results = [], matches, match2;
    if (typeof query === "string") {
      matches = document.querySelectorAll(query);
      if (matches.length) {
        for (var i2 = 0; i2 < matches.length; i2++) {
          match2 = TableRegistry.matchElement(matches[i2]);
          if (match2) {
            results.push(match2);
          }
        }
      }
    } else if (typeof HTMLElement !== "undefined" && query instanceof HTMLElement || query instanceof Tabulator) {
      match2 = TableRegistry.matchElement(query);
      if (match2) {
        results.push(match2);
      }
    } else if (Array.isArray(query)) {
      query.forEach(function(item) {
        results = results.concat(TableRegistry.lookupTable(item));
      });
    } else {
      if (!silent) {
        console.warn("Table Connection Error - Invalid Selector", query);
      }
    }
    return results;
  }
  static matchElement(element) {
    return TableRegistry.tables.find(function(table) {
      return element instanceof Tabulator ? table === element : table.element === element;
    });
  }
};
TableRegistry.tables = [];
function fitData(columns, forced) {
  if (forced) {
    this.table.columnManager.renderer.reinitializeColumnWidths(columns);
  }
  if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
    this.table.modules.responsiveLayout.update();
  }
}
function fitDataGeneral(columns, forced) {
  columns.forEach(function(column) {
    column.reinitializeWidth();
  });
  if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
    this.table.modules.responsiveLayout.update();
  }
}
function fitDataStretch(columns, forced) {
  var colsWidth = 0, tableWidth = this.table.rowManager.element.clientWidth, gap = 0, lastCol = false;
  columns.forEach((column, i2) => {
    if (!column.widthFixed) {
      column.reinitializeWidth();
    }
    if (this.table.options.responsiveLayout ? column.modules.responsive.visible : column.visible) {
      lastCol = column;
    }
    if (column.visible) {
      colsWidth += column.getWidth();
    }
  });
  if (lastCol) {
    gap = tableWidth - colsWidth + lastCol.getWidth();
    if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
      lastCol.setWidth(0);
      this.table.modules.responsiveLayout.update();
    }
    if (gap > 0) {
      lastCol.setWidth(gap);
    } else {
      lastCol.reinitializeWidth();
    }
  } else {
    if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
      this.table.modules.responsiveLayout.update();
    }
  }
}
function fitColumns(columns, forced) {
  var totalWidth = this.table.rowManager.element.getBoundingClientRect().width;
  var fixedWidth = 0;
  var flexWidth = 0;
  var flexGrowUnits = 0;
  var flexColWidth = 0;
  var flexColumns = [];
  var fixedShrinkColumns = [];
  var flexShrinkUnits = 0;
  var overflowWidth = 0;
  var gapFill = 0;
  function calcWidth(width) {
    var colWidth;
    if (typeof width == "string") {
      if (width.indexOf("%") > -1) {
        colWidth = totalWidth / 100 * parseInt(width);
      } else {
        colWidth = parseInt(width);
      }
    } else {
      colWidth = width;
    }
    return colWidth;
  }
  function scaleColumns(columns2, freeSpace, colWidth, shrinkCols) {
    var oversizeCols = [], oversizeSpace = 0, remainingSpace = 0, nextColWidth = 0, remainingFlexGrowUnits = flexGrowUnits, gap = 0, changeUnits = 0, undersizeCols = [];
    function calcGrow(col) {
      return colWidth * (col.column.definition.widthGrow || 1);
    }
    function calcShrink(col) {
      return calcWidth(col.width) - colWidth * (col.column.definition.widthShrink || 0);
    }
    columns2.forEach(function(col, i2) {
      var width = shrinkCols ? calcShrink(col) : calcGrow(col);
      if (col.column.minWidth >= width) {
        oversizeCols.push(col);
      } else {
        if (col.column.maxWidth && col.column.maxWidth < width) {
          col.width = col.column.maxWidth;
          freeSpace -= col.column.maxWidth;
          remainingFlexGrowUnits -= shrinkCols ? col.column.definition.widthShrink || 1 : col.column.definition.widthGrow || 1;
          if (remainingFlexGrowUnits) {
            colWidth = Math.floor(freeSpace / remainingFlexGrowUnits);
          }
        } else {
          undersizeCols.push(col);
          changeUnits += shrinkCols ? col.column.definition.widthShrink || 1 : col.column.definition.widthGrow || 1;
        }
      }
    });
    if (oversizeCols.length) {
      oversizeCols.forEach(function(col) {
        oversizeSpace += shrinkCols ? col.width - col.column.minWidth : col.column.minWidth;
        col.width = col.column.minWidth;
      });
      remainingSpace = freeSpace - oversizeSpace;
      nextColWidth = changeUnits ? Math.floor(remainingSpace / changeUnits) : remainingSpace;
      gap = scaleColumns(undersizeCols, remainingSpace, nextColWidth, shrinkCols);
    } else {
      gap = changeUnits ? freeSpace - Math.floor(freeSpace / changeUnits) * changeUnits : freeSpace;
      undersizeCols.forEach(function(column) {
        column.width = shrinkCols ? calcShrink(column) : calcGrow(column);
      });
    }
    return gap;
  }
  if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
    this.table.modules.responsiveLayout.update();
  }
  if (this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight) {
    totalWidth -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth;
  }
  columns.forEach(function(column) {
    var width, minWidth, colWidth;
    if (column.visible) {
      width = column.definition.width;
      minWidth = parseInt(column.minWidth);
      if (width) {
        colWidth = calcWidth(width);
        fixedWidth += colWidth > minWidth ? colWidth : minWidth;
        if (column.definition.widthShrink) {
          fixedShrinkColumns.push({
            column,
            width: colWidth > minWidth ? colWidth : minWidth
          });
          flexShrinkUnits += column.definition.widthShrink;
        }
      } else {
        flexColumns.push({
          column,
          width: 0
        });
        flexGrowUnits += column.definition.widthGrow || 1;
      }
    }
  });
  flexWidth = totalWidth - fixedWidth;
  flexColWidth = Math.floor(flexWidth / flexGrowUnits);
  gapFill = scaleColumns(flexColumns, flexWidth, flexColWidth, false);
  if (flexColumns.length && gapFill > 0) {
    flexColumns[flexColumns.length - 1].width += gapFill;
  }
  flexColumns.forEach(function(col) {
    flexWidth -= col.width;
  });
  overflowWidth = Math.abs(gapFill) + flexWidth;
  if (overflowWidth > 0 && flexShrinkUnits) {
    gapFill = scaleColumns(fixedShrinkColumns, overflowWidth, Math.floor(overflowWidth / flexShrinkUnits), true);
  }
  if (gapFill && fixedShrinkColumns.length) {
    fixedShrinkColumns[fixedShrinkColumns.length - 1].width -= gapFill;
  }
  flexColumns.forEach(function(col) {
    col.column.setWidth(col.width);
  });
  fixedShrinkColumns.forEach(function(col) {
    col.column.setWidth(col.width);
  });
}
var defaultModes = {
  fitData,
  fitDataFill: fitDataGeneral,
  fitDataTable: fitDataGeneral,
  fitDataStretch,
  fitColumns
};
var Layout = class extends Module {
  constructor(table) {
    super(table, "layout");
    this.mode = null;
    this.registerTableOption("layout", "fitData");
    this.registerTableOption("layoutColumnsOnNewData", false);
    this.registerColumnOption("widthGrow");
    this.registerColumnOption("widthShrink");
  }
  initialize() {
    var layout = this.table.options.layout;
    if (Layout.modes[layout]) {
      this.mode = layout;
    } else {
      console.warn("Layout Error - invalid mode set, defaulting to 'fitData' : " + layout);
      this.mode = "fitData";
    }
    this.table.element.setAttribute("tabulator-layout", this.mode);
  }
  getMode() {
    return this.mode;
  }
  layout(dataChanged) {
    this.dispatch("layout-refreshing");
    Layout.modes[this.mode].call(this, this.table.columnManager.columnsByIndex, dataChanged);
    this.dispatch("layout-refreshed");
  }
};
Layout.moduleName = "layout";
Layout.modes = defaultModes;
var defaultLangs = {
  "default": {
    "groups": {
      "item": "item",
      "items": "items"
    },
    "columns": {},
    "data": {
      "loading": "Loading",
      "error": "Error"
    },
    "pagination": {
      "page_size": "Page Size",
      "page_title": "Show Page",
      "first": "First",
      "first_title": "First Page",
      "last": "Last",
      "last_title": "Last Page",
      "prev": "Prev",
      "prev_title": "Prev Page",
      "next": "Next",
      "next_title": "Next Page",
      "all": "All",
      "counter": {
        "showing": "Showing",
        "of": "of",
        "rows": "rows",
        "pages": "pages"
      }
    },
    "headerFilters": {
      "default": "filter column...",
      "columns": {}
    }
  }
};
var Localize = class extends Module {
  constructor(table) {
    super(table);
    this.locale = "default";
    this.lang = false;
    this.bindings = {};
    this.langList = {};
    this.registerTableOption("locale", false);
    this.registerTableOption("langs", {});
  }
  initialize() {
    this.langList = Helpers.deepClone(Localize.langs);
    if (this.table.options.columnDefaults.headerFilterPlaceholder !== false) {
      this.setHeaderFilterPlaceholder(this.table.options.columnDefaults.headerFilterPlaceholder);
    }
    for (let locale in this.table.options.langs) {
      this.installLang(locale, this.table.options.langs[locale]);
    }
    this.setLocale(this.table.options.locale);
    this.registerTableFunction("setLocale", this.setLocale.bind(this));
    this.registerTableFunction("getLocale", this.getLocale.bind(this));
    this.registerTableFunction("getLang", this.getLang.bind(this));
  }
  setHeaderFilterPlaceholder(placeholder) {
    this.langList.default.headerFilters.default = placeholder;
  }
  installLang(locale, lang) {
    if (this.langList[locale]) {
      this._setLangProp(this.langList[locale], lang);
    } else {
      this.langList[locale] = lang;
    }
  }
  _setLangProp(lang, values2) {
    for (let key in values2) {
      if (lang[key] && typeof lang[key] == "object") {
        this._setLangProp(lang[key], values2[key]);
      } else {
        lang[key] = values2[key];
      }
    }
  }
  setLocale(desiredLocale) {
    desiredLocale = desiredLocale || "default";
    function traverseLang(trans, path) {
      for (var prop in trans) {
        if (typeof trans[prop] == "object") {
          if (!path[prop]) {
            path[prop] = {};
          }
          traverseLang(trans[prop], path[prop]);
        } else {
          path[prop] = trans[prop];
        }
      }
    }
    if (desiredLocale === true && navigator.language) {
      desiredLocale = navigator.language.toLowerCase();
    }
    if (desiredLocale) {
      if (!this.langList[desiredLocale]) {
        let prefix = desiredLocale.split("-")[0];
        if (this.langList[prefix]) {
          console.warn("Localization Error - Exact matching locale not found, using closest match: ", desiredLocale, prefix);
          desiredLocale = prefix;
        } else {
          console.warn("Localization Error - Matching locale not found, using default: ", desiredLocale);
          desiredLocale = "default";
        }
      }
    }
    this.locale = desiredLocale;
    this.lang = Helpers.deepClone(this.langList.default || {});
    if (desiredLocale != "default") {
      traverseLang(this.langList[desiredLocale], this.lang);
    }
    this.dispatchExternal("localized", this.locale, this.lang);
    this._executeBindings();
  }
  getLocale(locale) {
    return this.locale;
  }
  getLang(locale) {
    return locale ? this.langList[locale] : this.lang;
  }
  getText(path, value) {
    var fillPath = value ? path + "|" + value : path, pathArray = fillPath.split("|"), text = this._getLangElement(pathArray, this.locale);
    return text || "";
  }
  _getLangElement(path, locale) {
    var root = this.lang;
    path.forEach(function(level) {
      var rootPath;
      if (root) {
        rootPath = root[level];
        if (typeof rootPath != "undefined") {
          root = rootPath;
        } else {
          root = false;
        }
      }
    });
    return root;
  }
  bind(path, callback2) {
    if (!this.bindings[path]) {
      this.bindings[path] = [];
    }
    this.bindings[path].push(callback2);
    callback2(this.getText(path), this.lang);
  }
  _executeBindings() {
    for (let path in this.bindings) {
      this.bindings[path].forEach((binding) => {
        binding(this.getText(path), this.lang);
      });
    }
  }
};
Localize.moduleName = "localize";
Localize.langs = defaultLangs;
var Comms = class extends Module {
  constructor(table) {
    super(table);
  }
  initialize() {
    this.registerTableFunction("tableComms", this.receive.bind(this));
  }
  getConnections(selectors) {
    var connections = [], connection;
    connection = TableRegistry.lookupTable(selectors);
    connection.forEach((con) => {
      if (this.table !== con) {
        connections.push(con);
      }
    });
    return connections;
  }
  send(selectors, module2, action, data) {
    var connections = this.getConnections(selectors);
    connections.forEach((connection) => {
      connection.tableComms(this.table.element, module2, action, data);
    });
    if (!connections.length && selectors) {
      console.warn("Table Connection Error - No tables matching selector found", selectors);
    }
  }
  receive(table, module2, action, data) {
    if (this.table.modExists(module2)) {
      return this.table.modules[module2].commsReceived(table, action, data);
    } else {
      console.warn("Inter-table Comms Error - no such module:", module2);
    }
  }
};
Comms.moduleName = "comms";
var coreModules = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LayoutModule: Layout,
  LocalizeModule: Localize,
  CommsModule: Comms
});
var ModuleBinder = class {
  constructor(tabulator, modules2) {
    this.bindStaticFunctionality(tabulator);
    this.bindModules(tabulator, coreModules, true);
    if (modules2) {
      this.bindModules(tabulator, modules2);
    }
  }
  bindStaticFunctionality(tabulator) {
    tabulator.moduleBindings = {};
    tabulator.extendModule = function(name, property, values2) {
      if (tabulator.moduleBindings[name]) {
        var source = tabulator.moduleBindings[name][property];
        if (source) {
          if (typeof values2 == "object") {
            for (let key in values2) {
              source[key] = values2[key];
            }
          } else {
            console.warn("Module Error - Invalid value type, it must be an object");
          }
        } else {
          console.warn("Module Error - property does not exist:", property);
        }
      } else {
        console.warn("Module Error - module does not exist:", name);
      }
    };
    tabulator.registerModule = function(modules2) {
      if (!Array.isArray(modules2)) {
        modules2 = [modules2];
      }
      modules2.forEach((mod) => {
        tabulator.registerModuleBinding(mod);
      });
    };
    tabulator.registerModuleBinding = function(mod) {
      tabulator.moduleBindings[mod.moduleName] = mod;
    };
    tabulator.findTable = function(query) {
      var results = TableRegistry.lookupTable(query, true);
      return Array.isArray(results) && !results.length ? false : results;
    };
    tabulator.prototype.bindModules = function() {
      var orderedStartMods = [], orderedEndMods = [], unOrderedMods = [];
      this.modules = {};
      for (var name in tabulator.moduleBindings) {
        let mod = tabulator.moduleBindings[name];
        let module2 = new mod(this);
        this.modules[name] = module2;
        if (mod.prototype.moduleCore) {
          this.modulesCore.push(module2);
        } else {
          if (mod.moduleInitOrder) {
            if (mod.moduleInitOrder < 0) {
              orderedStartMods.push(module2);
            } else {
              orderedEndMods.push(module2);
            }
          } else {
            unOrderedMods.push(module2);
          }
        }
      }
      orderedStartMods.sort((a, b) => a.moduleInitOrder > b.moduleInitOrder ? 1 : -1);
      orderedEndMods.sort((a, b) => a.moduleInitOrder > b.moduleInitOrder ? 1 : -1);
      this.modulesRegular = orderedStartMods.concat(unOrderedMods.concat(orderedEndMods));
    };
  }
  bindModules(tabulator, modules2, core) {
    var mods = Object.values(modules2);
    if (core) {
      mods.forEach((mod) => {
        mod.prototype.moduleCore = true;
      });
    }
    tabulator.registerModule(mods);
  }
};
var Alert = class extends CoreFeature {
  constructor(table) {
    super(table);
    this.element = this._createAlertElement();
    this.msgElement = this._createMsgElement();
    this.type = null;
    this.element.appendChild(this.msgElement);
  }
  _createAlertElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-alert");
    return el;
  }
  _createMsgElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-alert-msg");
    el.setAttribute("role", "alert");
    return el;
  }
  _typeClass() {
    return "tabulator-alert-state-" + this.type;
  }
  alert(content, type = "msg") {
    if (content) {
      this.clear();
      this.type = type;
      while (this.msgElement.firstChild)
        this.msgElement.removeChild(this.msgElement.firstChild);
      this.msgElement.classList.add(this._typeClass());
      if (typeof content === "function") {
        content = content();
      }
      if (content instanceof HTMLElement) {
        this.msgElement.appendChild(content);
      } else {
        this.msgElement.innerHTML = content;
      }
      this.table.element.appendChild(this.element);
    }
  }
  clear() {
    if (this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
    this.msgElement.classList.remove(this._typeClass());
  }
};
var Tabulator = class {
  constructor(element, options) {
    this.options = {};
    this.columnManager = null;
    this.rowManager = null;
    this.footerManager = null;
    this.alertManager = null;
    this.vdomHoz = null;
    this.externalEvents = null;
    this.eventBus = null;
    this.interactionMonitor = false;
    this.browser = "";
    this.browserSlow = false;
    this.browserMobile = false;
    this.rtl = false;
    this.originalElement = null;
    this.componentFunctionBinder = new ComponentFunctionBinder(this);
    this.dataLoader = false;
    this.modules = {};
    this.modulesCore = [];
    this.modulesRegular = [];
    this.deprecationAdvisor = new DeprecationAdvisor(this);
    this.optionsList = new OptionsList(this, "table constructor");
    this.initialized = false;
    this.destroyed = false;
    if (this.initializeElement(element)) {
      this.initializeCoreSystems(options);
      setTimeout(() => {
        this._create();
      });
    }
    TableRegistry.register(this);
  }
  initializeElement(element) {
    if (typeof HTMLElement !== "undefined" && element instanceof HTMLElement) {
      this.element = element;
      return true;
    } else if (typeof element === "string") {
      this.element = document.querySelector(element);
      if (this.element) {
        return true;
      } else {
        console.error("Tabulator Creation Error - no element found matching selector: ", element);
        return false;
      }
    } else {
      console.error("Tabulator Creation Error - Invalid element provided:", element);
      return false;
    }
  }
  initializeCoreSystems(options) {
    this.columnManager = new ColumnManager(this);
    this.rowManager = new RowManager(this);
    this.footerManager = new FooterManager(this);
    this.dataLoader = new DataLoader(this);
    this.alertManager = new Alert(this);
    this.bindModules();
    this.options = this.optionsList.generate(Tabulator.defaultOptions, options);
    this._clearObjectPointers();
    this._mapDeprecatedFunctionality();
    this.externalEvents = new ExternalEventBus(this, this.options, this.options.debugEventsExternal);
    this.eventBus = new InternalEventBus(this.options.debugEventsInternal);
    this.interactionMonitor = new InteractionManager(this);
    this.dataLoader.initialize();
    this.footerManager.initialize();
  }
  _mapDeprecatedFunctionality() {
  }
  _clearSelection() {
    this.element.classList.add("tabulator-block-select");
    if (window.getSelection) {
      if (window.getSelection().empty) {
        window.getSelection().empty();
      } else if (window.getSelection().removeAllRanges) {
        window.getSelection().removeAllRanges();
      }
    } else if (document.selection) {
      document.selection.empty();
    }
    this.element.classList.remove("tabulator-block-select");
  }
  _create() {
    this.externalEvents.dispatch("tableBuilding");
    this.eventBus.dispatch("table-building");
    this._rtlCheck();
    this._buildElement();
    this._initializeTable();
    this._loadInitialData();
    this.initialized = true;
    this.externalEvents.dispatch("tableBuilt");
  }
  _rtlCheck() {
    var style = window.getComputedStyle(this.element);
    switch (this.options.textDirection) {
      case "auto":
        if (style.direction !== "rtl") {
          break;
        }
      case "rtl":
        this.element.classList.add("tabulator-rtl");
        this.rtl = true;
        break;
      case "ltr":
        this.element.classList.add("tabulator-ltr");
      default:
        this.rtl = false;
    }
  }
  _clearObjectPointers() {
    this.options.columns = this.options.columns.slice(0);
    if (Array.isArray(this.options.data) && !this.options.reactiveData) {
      this.options.data = this.options.data.slice(0);
    }
  }
  _buildElement() {
    var element = this.element, options = this.options, newElement;
    if (element.tagName === "TABLE") {
      this.originalElement = this.element;
      newElement = document.createElement("div");
      var attributes = element.attributes;
      for (var i2 in attributes) {
        if (typeof attributes[i2] == "object") {
          newElement.setAttribute(attributes[i2].name, attributes[i2].value);
        }
      }
      element.parentNode.replaceChild(newElement, element);
      this.element = element = newElement;
    }
    element.classList.add("tabulator");
    element.setAttribute("role", "grid");
    while (element.firstChild)
      element.removeChild(element.firstChild);
    if (options.height) {
      options.height = isNaN(options.height) ? options.height : options.height + "px";
      element.style.height = options.height;
    }
    if (options.minHeight !== false) {
      options.minHeight = isNaN(options.minHeight) ? options.minHeight : options.minHeight + "px";
      element.style.minHeight = options.minHeight;
    }
    if (options.maxHeight !== false) {
      options.maxHeight = isNaN(options.maxHeight) ? options.maxHeight : options.maxHeight + "px";
      element.style.maxHeight = options.maxHeight;
    }
  }
  _initializeTable() {
    var element = this.element, options = this.options;
    this.interactionMonitor.initialize();
    this.columnManager.initialize();
    this.rowManager.initialize();
    this._detectBrowser();
    this.modulesCore.forEach((mod) => {
      mod.initialize();
    });
    element.appendChild(this.columnManager.getElement());
    element.appendChild(this.rowManager.getElement());
    if (options.footerElement) {
      this.footerManager.activate();
    }
    if (options.autoColumns && options.data) {
      this.columnManager.generateColumnsFromRowData(this.options.data);
    }
    this.modulesRegular.forEach((mod) => {
      mod.initialize();
    });
    this.columnManager.setColumns(options.columns);
    this.eventBus.dispatch("table-built");
  }
  _loadInitialData() {
    this.dataLoader.load(this.options.data);
  }
  destroy() {
    var element = this.element;
    this.destroyed = true;
    TableRegistry.deregister(this);
    this.eventBus.dispatch("table-destroy");
    this.rowManager.destroy();
    while (element.firstChild)
      element.removeChild(element.firstChild);
    element.classList.remove("tabulator");
    this.externalEvents.dispatch("tableDestroyed");
  }
  _detectBrowser() {
    var ua = navigator.userAgent || navigator.vendor || window.opera;
    if (ua.indexOf("Trident") > -1) {
      this.browser = "ie";
      this.browserSlow = true;
    } else if (ua.indexOf("Edge") > -1) {
      this.browser = "edge";
      this.browserSlow = true;
    } else if (ua.indexOf("Firefox") > -1) {
      this.browser = "firefox";
      this.browserSlow = false;
    } else {
      this.browser = "other";
      this.browserSlow = false;
    }
    this.browserMobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(ua) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(ua.slice(0, 4));
  }
  initGuard(func, msg) {
    var stack, line;
    if (this.options.debugInitialization && !this.initialized) {
      if (!func) {
        stack = new Error().stack.split("\n");
        line = stack[0] == "Error" ? stack[2] : stack[1];
        if (line[0] == " ") {
          func = line.trim().split(" ")[1].split(".")[1];
        } else {
          func = line.trim().split("@")[0];
        }
      }
      console.warn("Table Not Initialized - Calling the " + func + " function before the table is initialized may result in inconsistent behavior, Please wait for the `tableBuilt` event before calling this function." + (msg ? " " + msg : ""));
    }
    return this.initialized;
  }
  blockRedraw() {
    this.initGuard();
    this.eventBus.dispatch("redraw-blocking");
    this.rowManager.blockRedraw();
    this.columnManager.blockRedraw();
    this.eventBus.dispatch("redraw-blocked");
  }
  restoreRedraw() {
    this.initGuard();
    this.eventBus.dispatch("redraw-restoring");
    this.rowManager.restoreRedraw();
    this.columnManager.restoreRedraw();
    this.eventBus.dispatch("redraw-restored");
  }
  setData(data, params, config) {
    this.initGuard(false, "To set initial data please use the 'data' property in the table constructor.");
    return this.dataLoader.load(data, params, config, false);
  }
  clearData() {
    this.initGuard();
    this.dataLoader.blockActiveLoad();
    this.rowManager.clearData();
  }
  getData(active) {
    return this.rowManager.getData(active);
  }
  getDataCount(active) {
    return this.rowManager.getDataCount(active);
  }
  replaceData(data, params, config) {
    this.initGuard();
    return this.dataLoader.load(data, params, config, true, true);
  }
  updateData(data) {
    var responses = 0;
    this.initGuard();
    return new Promise((resolve2, reject) => {
      this.dataLoader.blockActiveLoad();
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      if (data && data.length > 0) {
        data.forEach((item) => {
          var row2 = this.rowManager.findRow(item[this.options.index]);
          if (row2) {
            responses++;
            row2.updateData(item).then(() => {
              responses--;
              if (!responses) {
                resolve2();
              }
            }).catch((e) => {
              reject("Update Error - Unable to update row", item, e);
            });
          } else {
            reject("Update Error - Unable to find row", item);
          }
        });
      } else {
        console.warn("Update Error - No data provided");
        reject("Update Error - No data provided");
      }
    });
  }
  addData(data, pos, index2) {
    this.initGuard();
    return new Promise((resolve2, reject) => {
      this.dataLoader.blockActiveLoad();
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      if (data) {
        this.rowManager.addRows(data, pos, index2).then((rows3) => {
          var output = [];
          rows3.forEach(function(row2) {
            output.push(row2.getComponent());
          });
          resolve2(output);
        });
      } else {
        console.warn("Update Error - No data provided");
        reject("Update Error - No data provided");
      }
    });
  }
  updateOrAddData(data) {
    var rows3 = [], responses = 0;
    this.initGuard();
    return new Promise((resolve2, reject) => {
      this.dataLoader.blockActiveLoad();
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      if (data && data.length > 0) {
        data.forEach((item) => {
          var row2 = this.rowManager.findRow(item[this.options.index]);
          responses++;
          if (row2) {
            row2.updateData(item).then(() => {
              responses--;
              rows3.push(row2.getComponent());
              if (!responses) {
                resolve2(rows3);
              }
            });
          } else {
            this.rowManager.addRows(item).then((newRows) => {
              responses--;
              rows3.push(newRows[0].getComponent());
              if (!responses) {
                resolve2(rows3);
              }
            });
          }
        });
      } else {
        console.warn("Update Error - No data provided");
        reject("Update Error - No data provided");
      }
    });
  }
  getRow(index2) {
    var row2 = this.rowManager.findRow(index2);
    if (row2) {
      return row2.getComponent();
    } else {
      console.warn("Find Error - No matching row found:", index2);
      return false;
    }
  }
  getRowFromPosition(position) {
    var row2 = this.rowManager.getRowFromPosition(position);
    if (row2) {
      return row2.getComponent();
    } else {
      console.warn("Find Error - No matching row found:", position);
      return false;
    }
  }
  deleteRow(index2) {
    var foundRows = [];
    this.initGuard();
    if (!Array.isArray(index2)) {
      index2 = [index2];
    }
    for (let item of index2) {
      let row2 = this.rowManager.findRow(item, true);
      if (row2) {
        foundRows.push(row2);
      } else {
        console.error("Delete Error - No matching row found:", item);
        return Promise.reject("Delete Error - No matching row found");
      }
    }
    foundRows.sort((a, b) => {
      return this.rowManager.rows.indexOf(a) > this.rowManager.rows.indexOf(b) ? 1 : -1;
    });
    foundRows.forEach((row2) => {
      row2.delete();
    });
    this.rowManager.reRenderInPosition();
    return Promise.resolve();
  }
  addRow(data, pos, index2) {
    this.initGuard();
    if (typeof data === "string") {
      data = JSON.parse(data);
    }
    return this.rowManager.addRows(data, pos, index2, true).then((rows3) => {
      return rows3[0].getComponent();
    });
  }
  updateOrAddRow(index2, data) {
    var row2 = this.rowManager.findRow(index2);
    this.initGuard();
    if (typeof data === "string") {
      data = JSON.parse(data);
    }
    if (row2) {
      return row2.updateData(data).then(() => {
        return row2.getComponent();
      });
    } else {
      return this.rowManager.addRows(data).then((rows3) => {
        return rows3[0].getComponent();
      });
    }
  }
  updateRow(index2, data) {
    var row2 = this.rowManager.findRow(index2);
    this.initGuard();
    if (typeof data === "string") {
      data = JSON.parse(data);
    }
    if (row2) {
      return row2.updateData(data).then(() => {
        return Promise.resolve(row2.getComponent());
      });
    } else {
      console.warn("Update Error - No matching row found:", index2);
      return Promise.reject("Update Error - No matching row found");
    }
  }
  scrollToRow(index2, position, ifVisible) {
    var row2 = this.rowManager.findRow(index2);
    if (row2) {
      return this.rowManager.scrollToRow(row2, position, ifVisible);
    } else {
      console.warn("Scroll Error - No matching row found:", index2);
      return Promise.reject("Scroll Error - No matching row found");
    }
  }
  moveRow(from2, to2, after) {
    var fromRow = this.rowManager.findRow(from2);
    this.initGuard();
    if (fromRow) {
      fromRow.moveToRow(to2, after);
    } else {
      console.warn("Move Error - No matching row found:", from2);
    }
  }
  getRows(active) {
    return this.rowManager.getComponents(active);
  }
  getRowPosition(index2) {
    var row2 = this.rowManager.findRow(index2);
    if (row2) {
      return row2.getPosition();
    } else {
      console.warn("Position Error - No matching row found:", index2);
      return false;
    }
  }
  setColumns(definition) {
    this.initGuard(false, "To set initial columns please use the 'columns' property in the table constructor");
    this.columnManager.setColumns(definition);
  }
  getColumns(structured) {
    return this.columnManager.getComponents(structured);
  }
  getColumn(field) {
    var column = this.columnManager.findColumn(field);
    if (column) {
      return column.getComponent();
    } else {
      console.warn("Find Error - No matching column found:", field);
      return false;
    }
  }
  getColumnDefinitions() {
    return this.columnManager.getDefinitionTree();
  }
  showColumn(field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    if (column) {
      column.show();
    } else {
      console.warn("Column Show Error - No matching column found:", field);
      return false;
    }
  }
  hideColumn(field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    if (column) {
      column.hide();
    } else {
      console.warn("Column Hide Error - No matching column found:", field);
      return false;
    }
  }
  toggleColumn(field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    if (column) {
      if (column.visible) {
        column.hide();
      } else {
        column.show();
      }
    } else {
      console.warn("Column Visibility Toggle Error - No matching column found:", field);
      return false;
    }
  }
  addColumn(definition, before, field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    return this.columnManager.addColumn(definition, before, column).then((column2) => {
      return column2.getComponent();
    });
  }
  deleteColumn(field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    if (column) {
      return column.delete();
    } else {
      console.warn("Column Delete Error - No matching column found:", field);
      return Promise.reject();
    }
  }
  updateColumnDefinition(field, definition) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    if (column) {
      return column.updateDefinition(definition);
    } else {
      console.warn("Column Update Error - No matching column found:", field);
      return Promise.reject();
    }
  }
  moveColumn(from2, to2, after) {
    var fromColumn = this.columnManager.findColumn(from2), toColumn = this.columnManager.findColumn(to2);
    this.initGuard();
    if (fromColumn) {
      if (toColumn) {
        this.columnManager.moveColumn(fromColumn, toColumn, after);
      } else {
        console.warn("Move Error - No matching column found:", toColumn);
      }
    } else {
      console.warn("Move Error - No matching column found:", from2);
    }
  }
  scrollToColumn(field, position, ifVisible) {
    return new Promise((resolve2, reject) => {
      var column = this.columnManager.findColumn(field);
      if (column) {
        return this.columnManager.scrollToColumn(column, position, ifVisible);
      } else {
        console.warn("Scroll Error - No matching column found:", field);
        return Promise.reject("Scroll Error - No matching column found");
      }
    });
  }
  redraw(force) {
    this.initGuard();
    this.columnManager.redraw(force);
    this.rowManager.redraw(force);
  }
  setHeight(height) {
    this.options.height = isNaN(height) ? height : height + "px";
    this.element.style.height = this.options.height;
    this.rowManager.initializeRenderer();
    this.rowManager.redraw();
  }
  on(key, callback2) {
    this.externalEvents.subscribe(key, callback2);
  }
  off(key, callback2) {
    this.externalEvents.unsubscribe(key, callback2);
  }
  dispatchEvent() {
    var args = Array.from(arguments);
    args.shift();
    this.externalEvents.dispatch(...arguments);
  }
  alert(contents, type) {
    this.initGuard();
    this.alertManager.alert(contents, type);
  }
  clearAlert() {
    this.initGuard();
    this.alertManager.clear();
  }
  modExists(plugin2, required) {
    if (this.modules[plugin2]) {
      return true;
    } else {
      if (required) {
        console.error("Tabulator Module Not Installed: " + plugin2);
      }
      return false;
    }
  }
  module(key) {
    var mod = this.modules[key];
    if (!mod) {
      console.error("Tabulator module not installed: " + key);
    }
    return mod;
  }
};
Tabulator.defaultOptions = defaultOptions;
new ModuleBinder(Tabulator);
var TabulatorFull = class extends Tabulator {
};
new ModuleBinder(TabulatorFull, modules);

// js/components/table_hook.js
function TableHook() {
  this.mounted = function() {
    this.id = document.getElementById(this.el.id);
    this.table = null;
    this.handleEvent(this.el.id + "::refresh-data", this.handler());
    this.el.addEventListener("panel:" + this.el.id + ":download:csv", this.downloadCSV());
  };
  this.handler = function() {
    return (payload) => {
      this.createOrUpdateTable(payload.rows, payload.columns);
    };
  };
  this.createOrUpdateTable = function(rows3, columns) {
    if (this.table === null) {
      this.table = new TabulatorFull(this.id, {
        placeholder: "No data available",
        minHeight: 50,
        pagination: true,
        paginationSize: 10,
        data: rows3,
        columns,
        layout: "fitColumns"
      });
    } else {
      this.table.replaceData(rows3);
    }
    ;
  };
  this.downloadCSV = function() {
    return (event) => {
      let fields = this.table.getColumnDefinitions().map((coldef) => coldef.field);
      let titles = this.table.getColumnDefinitions().map((coldef) => coldef.title);
      let csvRows2 = ["sep=,", titles.map((title) => '"' + title + '"').join(",")];
      let data = this.table.getData();
      for (let i2 = 0; i2 < data.length; i2++) {
        csvRows2.push(fields.map((field) => data[i2][field]).join(","));
      }
      ;
      let csv3 = csvRows2.join("\r\n");
      var blob = new Blob([csv3], { type: "text/csv;charset=utf-8;" });
      var url2 = URL.createObjectURL(blob);
      sendFileToClient(url2, this.el.id + ".csv");
    };
  };
}
var table_hook_default = TableHook;

// node_modules/flatpickr/dist/esm/types/options.js
var HOOKS = [
  "onChange",
  "onClose",
  "onDayCreate",
  "onDestroy",
  "onKeyDown",
  "onMonthChange",
  "onOpen",
  "onParseConfig",
  "onReady",
  "onValueUpdate",
  "onYearChange",
  "onPreCalendarPosition"
];
var defaults2 = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function(err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function(givenDate) {
    var date2 = new Date(givenDate.getTime());
    date2.setHours(0, 0, 0, 0);
    date2.setDate(date2.getDate() + 3 - (date2.getDay() + 6) % 7);
    var week1 = new Date(date2.getFullYear(), 0, 4);
    return 1 + Math.round(((date2.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};

// node_modules/flatpickr/dist/esm/l10n/default.js
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  },
  months: {
    shorthand: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    longhand: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function(nth) {
    var s2 = nth % 100;
    if (s2 > 3 && s2 < 21)
      return "th";
    switch (s2 % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
var default_default = english;

// node_modules/flatpickr/dist/esm/utils/index.js
var pad = function(number2, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number2).slice(length * -1);
};
var int2 = function(bool) {
  return bool === true ? 1 : 0;
};
function debounce3(fn, wait) {
  var t;
  return function() {
    var _this = this;
    var args = arguments;
    clearTimeout(t);
    t = setTimeout(function() {
      return fn.apply(_this, args);
    }, wait);
  };
}
var arrayify = function(obj) {
  return obj instanceof Array ? obj : [obj];
};

// node_modules/flatpickr/dist/esm/utils/dom.js
function toggleClass(elem, className, bool) {
  if (bool === true)
    return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  var e = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e.className = className;
  if (content !== void 0)
    e.textContent = content;
  return e;
}
function clearNode(node) {
  while (node.firstChild)
    node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node))
    return node;
  else if (node.parentNode)
    return findParent(node.parentNode, condition);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0)
    for (var key in opts)
      numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error) {
    return event.target;
  }
}

// node_modules/flatpickr/dist/esm/utils/formatting.js
var doNothing = function() {
  return void 0;
};
var monthToStr = function(monthNumber, shorthand, locale) {
  return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale) {
    dateObj.setMonth(locale.months.longhand.indexOf(monthName));
  },
  G: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function(dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function(dateObj, amPM, locale) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int2(new RegExp(locale.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale) {
    dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
  },
  S: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: function(_, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1e3);
  },
  W: function(dateObj, weekNum, locale) {
    var weekNumber = parseInt(weekNum);
    var date2 = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date2.setDate(date2.getDate() - date2.getDay() + locale.firstDayOfWeek);
    return date2;
  },
  Y: function(dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function(_, ISODate) {
    return new Date(ISODate);
  },
  d: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function(dateObj, minutes) {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: function(_, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function(dateObj, year) {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function(date2) {
    return date2.toISOString();
  },
  D: function(date2, locale, options) {
    return locale.weekdays.shorthand[formats.w(date2, locale, options)];
  },
  F: function(date2, locale, options) {
    return monthToStr(formats.n(date2, locale, options) - 1, false, locale);
  },
  G: function(date2, locale, options) {
    return pad(formats.h(date2, locale, options));
  },
  H: function(date2) {
    return pad(date2.getHours());
  },
  J: function(date2, locale) {
    return locale.ordinal !== void 0 ? date2.getDate() + locale.ordinal(date2.getDate()) : date2.getDate();
  },
  K: function(date2, locale) {
    return locale.amPM[int2(date2.getHours() > 11)];
  },
  M: function(date2, locale) {
    return monthToStr(date2.getMonth(), true, locale);
  },
  S: function(date2) {
    return pad(date2.getSeconds());
  },
  U: function(date2) {
    return date2.getTime() / 1e3;
  },
  W: function(date2, _, options) {
    return options.getWeek(date2);
  },
  Y: function(date2) {
    return pad(date2.getFullYear(), 4);
  },
  d: function(date2) {
    return pad(date2.getDate());
  },
  h: function(date2) {
    return date2.getHours() % 12 ? date2.getHours() % 12 : 12;
  },
  i: function(date2) {
    return pad(date2.getMinutes());
  },
  j: function(date2) {
    return date2.getDate();
  },
  l: function(date2, locale) {
    return locale.weekdays.longhand[date2.getDay()];
  },
  m: function(date2) {
    return pad(date2.getMonth() + 1);
  },
  n: function(date2) {
    return date2.getMonth() + 1;
  },
  s: function(date2) {
    return date2.getSeconds();
  },
  u: function(date2) {
    return date2.getTime();
  },
  w: function(date2) {
    return date2.getDay();
  },
  y: function(date2) {
    return String(date2.getFullYear()).substring(2);
  }
};

// node_modules/flatpickr/dist/esm/utils/dates.js
var createDateFormatter = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults2 : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
  return function(dateObj, frmt, overrideLocale) {
    var locale = overrideLocale || l10n;
    if (config.formatDate !== void 0 && !isMobile) {
      return config.formatDate(dateObj, frmt, locale);
    }
    return frmt.split("").map(function(c, i2, arr) {
      return formats[c] && arr[i2 - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
    }).join("");
  };
};
var createDateParser = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults2 : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
  return function(date2, givenFormat, timeless, customLocale) {
    if (date2 !== 0 && !date2)
      return void 0;
    var locale = customLocale || l10n;
    var parsedDate;
    var dateOrig = date2;
    if (date2 instanceof Date)
      parsedDate = new Date(date2.getTime());
    else if (typeof date2 !== "string" && date2.toFixed !== void 0)
      parsedDate = new Date(date2);
    else if (typeof date2 === "string") {
      var format = givenFormat || (config || defaults2).dateFormat;
      var datestr = String(date2).trim();
      if (datestr === "today") {
        parsedDate = new Date();
        timeless = true;
      } else if (config && config.parseDate) {
        parsedDate = config.parseDate(date2, format);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date2);
      } else {
        var matched = void 0, ops = [];
        for (var i2 = 0, matchIndex = 0, regexStr = ""; i2 < format.length; i2++) {
          var token = format[i2];
          var isBackSlash = token === "\\";
          var escaped = format[i2 - 1] === "\\" || isBackSlash;
          if (tokenRegex[token] && !escaped) {
            regexStr += tokenRegex[token];
            var match2 = new RegExp(regexStr).exec(date2);
            if (match2 && (matched = true)) {
              ops[token !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token],
                val: match2[++matchIndex]
              });
            }
          } else if (!isBackSlash)
            regexStr += ".";
        }
        parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
        ops.forEach(function(_a2) {
          var fn = _a2.fn, val = _a2.val;
          return parsedDate = fn(parsedDate, val, locale) || parsedDate;
        });
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return void 0;
    }
    if (timeless === true)
      parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date2, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
var isBetween = function(ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
  return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function(secondsSinceMidnight) {
  var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
  DAY: 864e5
};
function getDefaultHours(config) {
  var hours = config.defaultHour;
  var minutes = config.defaultMinute;
  var seconds = config.defaultSeconds;
  if (config.minDate !== void 0) {
    var minHour = config.minDate.getHours();
    var minMinutes = config.minDate.getMinutes();
    var minSeconds = config.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
      seconds = config.minDate.getSeconds();
  }
  if (config.maxDate !== void 0) {
    var maxHr = config.maxDate.getHours();
    var maxMinutes = config.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr)
      minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes)
      seconds = config.maxDate.getSeconds();
  }
  return { hours, minutes, seconds };
}

// node_modules/flatpickr/dist/esm/utils/polyfills.js
"use strict";
if (typeof Object.assign !== "function") {
  Object.assign = function(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function(source2) {
      if (source2) {
        Object.keys(source2).forEach(function(key) {
          return target[key] = source2[key];
        });
      }
    };
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var source = args_1[_a];
      _loop_1(source);
    }
    return target;
  };
}

// node_modules/flatpickr/dist/esm/index.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s2, i2 = 1, n3 = arguments.length; i2 < n3; i2++) {
      s2 = arguments[i2];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r = Array(s2), k = 0, i2 = 0; i2 < il; i2++)
    for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  var self2 = {
    config: __assign(__assign({}, defaults2), flatpickr.defaultConfig),
    l10n: default_default
  };
  self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  self2._handlers = [];
  self2.pluginElements = [];
  self2.loadedPlugins = [];
  self2._bind = bind;
  self2._setHoursFromDate = setHoursFromDate;
  self2._positionCalendar = positionCalendar;
  self2.changeMonth = changeMonth;
  self2.changeYear = changeYear;
  self2.clear = clear;
  self2.close = close;
  self2.onMouseOver = onMouseOver;
  self2._createElement = createElement;
  self2.createDay = createDay;
  self2.destroy = destroy;
  self2.isEnabled = isEnabled;
  self2.jumpToDate = jumpToDate;
  self2.updateValue = updateValue;
  self2.open = open;
  self2.redraw = redraw;
  self2.set = set2;
  self2.setDate = setDate;
  self2.toggle = toggle;
  function setupHelperFunctions() {
    self2.utils = {
      getDaysInMonth: function(month, yr) {
        if (month === void 0) {
          month = self2.currentMonth;
        }
        if (yr === void 0) {
          yr = self2.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
          return 29;
        return self2.l10n.daysInMonth[month];
      }
    };
  }
  function init() {
    self2.element = self2.input = element;
    self2.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self2.isMobile)
      build();
    bindEvents();
    if (self2.selectedDates.length || self2.config.noCalendar) {
      if (self2.config.enableTime) {
        setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self2.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a;
    return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn) {
    return fn.bind(self2);
  }
  function setCalendarWidth() {
    var config = self2.config;
    if (config.weekNumbers === false && config.showMonths === 1) {
      return;
    } else if (config.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.style.visibility = "hidden";
          self2.calendarContainer.style.display = "block";
        }
        if (self2.daysContainer !== void 0) {
          var daysWidth = (self2.days.offsetWidth + 1) * config.showMonths;
          self2.daysContainer.style.width = daysWidth + "px";
          self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
          self2.calendarContainer.style.removeProperty("visibility");
          self2.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e) {
    if (self2.selectedDates.length === 0) {
      var defaultDate = self2.config.minDate === void 0 || compareDates(new Date(), self2.config.minDate) >= 0 ? new Date() : new Date(self2.config.minDate.getTime());
      var defaults3 = getDefaultHours(self2.config);
      defaultDate.setHours(defaults3.hours, defaults3.minutes, defaults3.seconds, defaultDate.getMilliseconds());
      self2.selectedDates = [defaultDate];
      self2.latestSelectedDateObj = defaultDate;
    }
    if (e !== void 0 && e.type !== "blur") {
      timeWrapper(e);
    }
    var prevValue = self2._input.value;
    setHoursFromInputs();
    updateValue();
    if (self2._input.value !== prevValue) {
      self2._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int2(amPM === self2.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self2.hourElement === void 0 || self2.minuteElement === void 0)
      return;
    var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
    if (self2.amPM !== void 0) {
      hours = ampm2military(hours, self2.amPM.textContent);
    }
    var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
    var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
    if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours = result[0];
        minutes = result[1];
        seconds = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours())
          minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes())
          seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes())
          minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes())
          seconds = Math.max(seconds, minTime.getSeconds());
      }
    }
    setHours(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    var date2 = dateObj || self2.latestSelectedDateObj;
    if (date2 && date2 instanceof Date) {
      setHours(date2.getHours(), date2.getMinutes(), date2.getSeconds());
    }
  }
  function setHours(hours, minutes, seconds) {
    if (self2.latestSelectedDateObj !== void 0) {
      self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
      return;
    self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int2(hours % 12 === 0) : hours);
    self2.minuteElement.value = pad(minutes);
    if (self2.amPM !== void 0)
      self2.amPM.textContent = self2.l10n.amPM[int2(hours >= 12)];
    if (self2.secondElement !== void 0)
      self2.secondElement.value = pad(seconds);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind(element2, event, handler, options) {
    if (event instanceof Array)
      return event.forEach(function(ev) {
        return bind(element2, ev, handler, options);
      });
    if (element2 instanceof Array)
      return element2.forEach(function(el) {
        return bind(el, event, handler, options);
      });
    element2.addEventListener(event, handler, options);
    self2._handlers.push({
      remove: function() {
        return element2.removeEventListener(event, handler, options);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self2.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function(evt) {
        Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
          return bind(el, "click", self2[evt]);
        });
      });
    }
    if (self2.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce3(onResize, 50);
    self2._debouncedChange = debounce3(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
      bind(self2.daysContainer, "mouseover", function(e) {
        if (self2.config.mode === "range")
          onMouseOver(getEventTarget(e));
      });
    bind(self2._input, "keydown", onKeyDown);
    if (self2.calendarContainer !== void 0) {
      bind(self2.calendarContainer, "keydown", onKeyDown);
    }
    if (!self2.config.inline && !self2.config.static)
      bind(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0)
      bind(window.document, "touchstart", documentClick);
    else
      bind(window.document, "mousedown", documentClick);
    bind(window.document, "focus", documentClick, { capture: true });
    if (self2.config.clickOpens === true) {
      bind(self2._input, "focus", self2.open);
      bind(self2._input, "click", self2.open);
    }
    if (self2.daysContainer !== void 0) {
      bind(self2.monthNav, "click", onMonthNavClick);
      bind(self2.monthNav, ["keyup", "increment"], onYearInput);
      bind(self2.daysContainer, "click", selectDate);
    }
    if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
      var selText = function(e) {
        return getEventTarget(e).select();
      };
      bind(self2.timeContainer, ["increment"], updateTime);
      bind(self2.timeContainer, "blur", updateTime, { capture: true });
      bind(self2.timeContainer, "click", timeIncrement);
      bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
      if (self2.secondElement !== void 0)
        bind(self2.secondElement, "focus", function() {
          return self2.secondElement && self2.secondElement.select();
        });
      if (self2.amPM !== void 0) {
        bind(self2.amPM, "click", function(e) {
          updateTime(e);
        });
      }
    }
    if (self2.config.allowInput) {
      bind(self2._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
    var oldYear = self2.currentYear;
    var oldMonth = self2.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self2.currentYear = jumpTo.getFullYear();
        self2.currentMonth = jumpTo.getMonth();
      }
    } catch (e) {
      e.message = "Invalid date supplied: " + jumpTo;
      self2.config.errorHandler(e);
    }
    if (triggerChange2 && self2.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self2.redraw();
  }
  function timeIncrement(e) {
    var eventTarget = getEventTarget(e);
    if (~eventTarget.className.indexOf("arrow"))
      incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e, delta, inputElem) {
    var target = e && getEventTarget(e);
    var input2 = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input2 && input2.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self2.calendarContainer = createElement("div", "flatpickr-calendar");
    self2.calendarContainer.tabIndex = -1;
    if (!self2.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self2.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self2.config.weekNumbers) {
        var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
        self2.innerContainer.appendChild(weekWrapper);
        self2.weekNumbers = weekNumbers;
        self2.weekWrapper = weekWrapper;
      }
      self2.rContainer = createElement("div", "flatpickr-rContainer");
      self2.rContainer.appendChild(buildWeekdays());
      if (!self2.daysContainer) {
        self2.daysContainer = createElement("div", "flatpickr-days");
        self2.daysContainer.tabIndex = -1;
      }
      buildDays();
      self2.rContainer.appendChild(self2.daysContainer);
      self2.innerContainer.appendChild(self2.rContainer);
      fragment.appendChild(self2.innerContainer);
    }
    if (self2.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
    toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
    toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
    self2.calendarContainer.appendChild(fragment);
    var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
    if (self2.config.inline || self2.config.static) {
      self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
      if (self2.config.inline) {
        if (!customAppend && self2.element.parentNode)
          self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
        else if (self2.config.appendTo !== void 0)
          self2.config.appendTo.appendChild(self2.calendarContainer);
      }
      if (self2.config.static) {
        var wrapper = createElement("div", "flatpickr-wrapper");
        if (self2.element.parentNode)
          self2.element.parentNode.insertBefore(wrapper, self2.element);
        wrapper.appendChild(self2.element);
        if (self2.altInput)
          wrapper.appendChild(self2.altInput);
        wrapper.appendChild(self2.calendarContainer);
      }
    }
    if (!self2.config.static && !self2.config.inline)
      (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
  }
  function createDay(className, date2, _dayNumber, i2) {
    var dateIsEnabled = isEnabled(date2, true), dayElement = createElement("span", className, date2.getDate().toString());
    dayElement.dateObj = date2;
    dayElement.$i = i2;
    dayElement.setAttribute("aria-label", self2.formatDate(date2, self2.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date2, self2.now) === 0) {
      self2.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date2)) {
        dayElement.classList.add("selected");
        self2.selectedDateElem = dayElement;
        if (self2.config.mode === "range") {
          toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date2, self2.selectedDates[0], true) === 0);
          toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date2, self2.selectedDates[1], true) === 0);
          if (className === "nextMonthDay")
            dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self2.config.mode === "range") {
      if (isDateInRange(date2) && !isDateSelected(date2))
        dayElement.classList.add("inRange");
    }
    if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i2 % 7 === 6) {
      self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date2) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self2.config.mode === "range")
      onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    for (var m = startMonth; m != endMonth; m += delta) {
      var month = self2.daysContainer.children[m];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i2 = startIndex; i2 != endIndex; i2 += delta) {
        var c = month.children[i2];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
          return c;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m = givenMonth - self2.currentMonth; m != endMonth; m += loopDelta) {
      var month = self2.daysContainer.children[m];
      var startIndex = givenMonth - self2.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i2 = startIndex; i2 >= 0 && i2 < numMonthDays && i2 != (delta > 0 ? numMonthDays : -1); i2 += loopDelta) {
        var c = month.children[i2];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i2) >= Math.abs(delta))
          return focusOnDayElem(c);
      }
    }
    self2.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset2) {
    var activeElement = getClosestActiveElement();
    var dayFocused = isInView(activeElement || document.body);
    var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
    if (startElem === void 0) {
      self2._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset2);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth2 = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth2; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth2 + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth2), dayNum, dayIndex));
    }
    var dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self2.daysContainer === void 0) {
      return;
    }
    clearNode(self2.daysContainer);
    if (self2.weekNumbers)
      clearNode(self2.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i2 = 0; i2 < self2.config.showMonths; i2++) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i2);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self2.daysContainer.appendChild(frag);
    self2.days = self2.daysContainer.firstChild;
    if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
      return;
    var shouldBuildMonth = function(month2) {
      if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
        return false;
      }
      return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
    };
    self2.monthsDropdownContainer.tabIndex = -1;
    self2.monthsDropdownContainer.innerHTML = "";
    for (var i2 = 0; i2 < 12; i2++) {
      if (!shouldBuildMonth(i2))
        continue;
      var month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self2.currentYear, i2).getMonth().toString();
      month.textContent = monthToStr(i2, self2.config.shorthandCurrentMonth, self2.l10n);
      month.tabIndex = -1;
      if (self2.currentMonth === i2) {
        month.selected = true;
      }
      self2.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
      bind(self2.monthsDropdownContainer, "change", function(e) {
        var target = getEventTarget(e);
        var selectedMonth = parseInt(target.value, 10);
        self2.changeMonth(selectedMonth - self2.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self2.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
    if (self2.config.minDate) {
      yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
    }
    if (self2.config.maxDate) {
      yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
    }
    var currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self2.monthNav);
    self2.monthNav.appendChild(self2.prevMonthNav);
    if (self2.config.showMonths) {
      self2.yearElements = [];
      self2.monthElements = [];
    }
    for (var m = self2.config.showMonths; m--; ) {
      var month = buildMonth();
      self2.yearElements.push(month.yearElement);
      self2.monthElements.push(month.monthElement);
      self2.monthNav.appendChild(month.container);
    }
    self2.monthNav.appendChild(self2.nextMonthNav);
  }
  function buildMonthNav() {
    self2.monthNav = createElement("div", "flatpickr-months");
    self2.yearElements = [];
    self2.monthElements = [];
    self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self2.prevMonthNav.innerHTML = self2.config.prevArrow;
    self2.nextMonthNav = createElement("span", "flatpickr-next-month");
    self2.nextMonthNav.innerHTML = self2.config.nextArrow;
    buildMonths();
    Object.defineProperty(self2, "_hidePrevMonthArrow", {
      get: function() {
        return self2.__hidePrevMonthArrow;
      },
      set: function(bool) {
        if (self2.__hidePrevMonthArrow !== bool) {
          toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
          self2.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self2, "_hideNextMonthArrow", {
      get: function() {
        return self2.__hideNextMonthArrow;
      },
      set: function(bool) {
        if (self2.__hideNextMonthArrow !== bool) {
          toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
          self2.__hideNextMonthArrow = bool;
        }
      }
    });
    self2.currentYearElement = self2.yearElements[0];
    updateNavigationCurrentMonth();
    return self2.monthNav;
  }
  function buildTime() {
    self2.calendarContainer.classList.add("hasTime");
    if (self2.config.noCalendar)
      self2.calendarContainer.classList.add("noCalendar");
    var defaults3 = getDefaultHours(self2.config);
    self2.timeContainer = createElement("div", "flatpickr-time");
    self2.timeContainer.tabIndex = -1;
    var separator = createElement("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self2.l10n.hourAriaLabel
    });
    self2.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self2.l10n.minuteAriaLabel
    });
    self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
    self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults3.hours : military2ampm(defaults3.hours));
    self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults3.minutes);
    self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
    self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
    self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
    self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
    self2.hourElement.setAttribute("maxlength", "2");
    self2.minuteElement.setAttribute("min", "0");
    self2.minuteElement.setAttribute("max", "59");
    self2.minuteElement.setAttribute("maxlength", "2");
    self2.timeContainer.appendChild(hourInput);
    self2.timeContainer.appendChild(separator);
    self2.timeContainer.appendChild(minuteInput);
    if (self2.config.time_24hr)
      self2.timeContainer.classList.add("time24hr");
    if (self2.config.enableSeconds) {
      self2.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self2.secondElement = secondInput.getElementsByTagName("input")[0];
      self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults3.seconds);
      self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
      self2.secondElement.setAttribute("min", "0");
      self2.secondElement.setAttribute("max", "59");
      self2.secondElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self2.timeContainer.appendChild(secondInput);
    }
    if (!self2.config.time_24hr) {
      self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int2((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
      self2.amPM.title = self2.l10n.toggleTitle;
      self2.amPM.tabIndex = -1;
      self2.timeContainer.appendChild(self2.amPM);
    }
    return self2.timeContainer;
  }
  function buildWeekdays() {
    if (!self2.weekdayContainer)
      self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
    else
      clearNode(self2.weekdayContainer);
    for (var i2 = self2.config.showMonths; i2--; ) {
      var container = createElement("div", "flatpickr-weekdaycontainer");
      self2.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self2.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self2.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self2.l10n.firstDayOfWeek;
    var weekdays2 = __spreadArrays(self2.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays2.length) {
      weekdays2 = __spreadArrays(weekdays2.splice(firstDayOfWeek, weekdays2.length), weekdays2.splice(0, firstDayOfWeek));
    }
    for (var i2 = self2.config.showMonths; i2--; ) {
      self2.weekdayContainer.children[i2].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays2.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self2.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
    var weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self2.currentMonth;
    if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
      return;
    self2.currentMonth += delta;
    if (self2.currentMonth < 0 || self2.currentMonth > 11) {
      self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
      self2.currentMonth = (self2.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self2.input.value = "";
    if (self2.altInput !== void 0)
      self2.altInput.value = "";
    if (self2.mobileInput !== void 0)
      self2.mobileInput.value = "";
    self2.selectedDates = [];
    self2.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
    }
    if (self2.config.enableTime === true) {
      var _a = getDefaultHours(self2.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
      setHours(hours, minutes, seconds);
    }
    self2.redraw();
    if (triggerChangeEvent)
      triggerEvent("onChange");
  }
  function close() {
    self2.isOpen = false;
    if (!self2.isMobile) {
      if (self2.calendarContainer !== void 0) {
        self2.calendarContainer.classList.remove("open");
      }
      if (self2._input !== void 0) {
        self2._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy() {
    if (self2.config !== void 0)
      triggerEvent("onDestroy");
    for (var i2 = self2._handlers.length; i2--; ) {
      self2._handlers[i2].remove();
    }
    self2._handlers = [];
    if (self2.mobileInput) {
      if (self2.mobileInput.parentNode)
        self2.mobileInput.parentNode.removeChild(self2.mobileInput);
      self2.mobileInput = void 0;
    } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
      if (self2.config.static && self2.calendarContainer.parentNode) {
        var wrapper = self2.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild)
            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else
        self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
    }
    if (self2.altInput) {
      self2.input.type = "text";
      if (self2.altInput.parentNode)
        self2.altInput.parentNode.removeChild(self2.altInput);
      delete self2.altInput;
    }
    if (self2.input) {
      self2.input.type = self2.input._type;
      self2.input.classList.remove("flatpickr-input");
      self2.input.removeAttribute("readonly");
    }
    [
      "_showTimeInput",
      "latestSelectedDateObj",
      "_hideNextMonthArrow",
      "_hidePrevMonthArrow",
      "__hideNextMonthArrow",
      "__hidePrevMonthArrow",
      "isMobile",
      "isOpen",
      "selectedDateElem",
      "minDateHasTime",
      "maxDateHasTime",
      "days",
      "daysContainer",
      "_input",
      "_positionElement",
      "innerContainer",
      "rContainer",
      "monthNav",
      "todayDateElem",
      "calendarContainer",
      "weekdayContainer",
      "prevMonthNav",
      "nextMonthNav",
      "monthsDropdownContainer",
      "currentMonthElement",
      "currentYearElement",
      "navigationCurrentMonth",
      "selectedDateElem",
      "config"
    ].forEach(function(k) {
      try {
        delete self2[k];
      } catch (_) {
      }
    });
  }
  function isCalendarElem(elem) {
    return self2.calendarContainer.contains(elem);
  }
  function documentClick(e) {
    if (self2.isOpen && !self2.config.inline) {
      var eventTarget_1 = getEventTarget(e);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self2.input) || ~e.path.indexOf(self2.altInput));
      var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
      var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self2.config.allowInput) {
          self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
        }
        if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
          updateTime();
        }
        self2.close();
        if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
          self2.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
      return;
    var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
    self2.currentYear = newYearNum || self2.currentYear;
    if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
      self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
    } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
      self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
    }
    if (isNewYear) {
      self2.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date2, timeless) {
    var _a;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self2.parseDate(date2, void 0, timeless);
    if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
      return false;
    if (!self2.config.enable && self2.config.disable.length === 0)
      return true;
    if (dateToCheck === void 0)
      return false;
    var bool = !!self2.config.enable, array2 = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
    for (var i2 = 0, d = void 0; i2 < array2.length; i2++) {
      d = array2[i2];
      if (typeof d === "function" && d(dateToCheck))
        return bool;
      else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime())
        return bool;
      else if (typeof d === "string") {
        var parsed = self2.parseDate(d, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime())
        return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self2.daysContainer !== void 0)
      return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e) {
    var isInput = e.target === self2._input;
    var valueChanged = self2._input.value.trimEnd() !== getDateStr();
    if (isInput && valueChanged && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
      self2.setDate(self2._input.value, true, e.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
    }
  }
  function onKeyDown(e) {
    var eventTarget = getEventTarget(e);
    var isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
    var allowInput = self2.config.allowInput;
    var allowKeydown = self2.isOpen && (!allowInput || !isInput);
    var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
    if (e.keyCode === 13 && isInput) {
      if (allowInput) {
        self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
        self2.close();
        return eventTarget.blur();
      } else {
        self2.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
      switch (e.keyCode) {
        case 13:
          if (isTimeObj) {
            e.preventDefault();
            updateTime();
            focusAndClose();
          } else
            selectDate(e);
          break;
        case 27:
          e.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self2.config.allowInput) {
            e.preventDefault();
            self2.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e.preventDefault();
            var activeElement = getClosestActiveElement();
            if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
              var delta_1 = e.keyCode === 39 ? 1 : -1;
              if (!e.ctrlKey)
                focusOnDay(void 0, delta_1);
              else {
                e.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self2.hourElement)
            self2.hourElement.focus();
          break;
        case 38:
        case 40:
          e.preventDefault();
          var delta = e.keyCode === 40 ? 1 : -1;
          if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
            if (e.ctrlKey) {
              e.stopPropagation();
              changeYear(self2.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj)
              focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self2.currentYearElement) {
            changeYear(self2.currentYear - delta);
          } else if (self2.config.enableTime) {
            if (!isTimeObj && self2.hourElement)
              self2.hourElement.focus();
            updateTime(e);
            self2._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [
              self2.hourElement,
              self2.minuteElement,
              self2.secondElement,
              self2.amPM
            ].concat(self2.pluginElements).filter(function(x) {
              return x;
            });
            var i2 = elems.indexOf(eventTarget);
            if (i2 !== -1) {
              var target = elems[i2 + (e.shiftKey ? -1 : 1)];
              e.preventDefault();
              (target || self2._input).focus();
            }
          } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e.shiftKey) {
            e.preventDefault();
            self2._input.focus();
          }
          break;
        default:
          break;
      }
    }
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      switch (e.key) {
        case self2.l10n.amPM[0].charAt(0):
        case self2.l10n.amPM[0].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self2.l10n.amPM[1].charAt(0):
        case self2.l10n.amPM[1].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
      return;
    var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0, maxRange = 0;
    for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
      if (!isEnabled(new Date(t), true)) {
        containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
        if (t < initialDate && (!minRange || t > minRange))
          minRange = t;
        else if (t > initialDate && (!maxRange || t < maxRange))
          maxRange = t;
      }
    }
    var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function(dayElem) {
      var date2 = dayElem.dateObj;
      var timestamp = date2.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function(c) {
          dayElem.classList.remove(c);
        });
        return;
      } else if (containsDisabled && !outOfRange)
        return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c) {
        dayElem.classList.remove(c);
      });
      if (elem !== void 0) {
        elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate)
          dayElem.classList.add("startRange");
        else if (initialDate > hoverDate && timestamp === initialDate)
          dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
          dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self2.isOpen && !self2.config.static && !self2.config.inline)
      positionCalendar();
  }
  function open(e, positionElement) {
    if (positionElement === void 0) {
      positionElement = self2._positionElement;
    }
    if (self2.isMobile === true) {
      if (e) {
        e.preventDefault();
        var eventTarget = getEventTarget(e);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self2.mobileInput !== void 0) {
        self2.mobileInput.focus();
        self2.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self2._input.disabled || self2.config.inline) {
      return;
    }
    var wasOpen = self2.isOpen;
    self2.isOpen = true;
    if (!wasOpen) {
      self2.calendarContainer.classList.add("open");
      self2._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self2.config.enableTime === true && self2.config.noCalendar === true) {
      if (self2.config.allowInput === false && (e === void 0 || !self2.timeContainer.contains(e.relatedTarget))) {
        setTimeout(function() {
          return self2.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function(date2) {
      var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date2, self2.config.dateFormat);
      var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== void 0) {
        self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self2.selectedDates) {
        self2.selectedDates = self2.selectedDates.filter(function(d) {
          return isEnabled(d);
        });
        if (!self2.selectedDates.length && type === "min")
          setHoursFromDate(dateObj);
        updateValue();
      }
      if (self2.daysContainer) {
        redraw();
        if (dateObj !== void 0)
          self2.currentYearElement[type] = dateObj.getFullYear().toString();
        else
          self2.currentYearElement.removeAttribute(type);
        self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = [
      "wrap",
      "weekNumbers",
      "allowInput",
      "allowInvalidPreload",
      "clickOpens",
      "time_24hr",
      "enableTime",
      "noCalendar",
      "altInput",
      "shorthandCurrentMonth",
      "inline",
      "static",
      "enableSeconds",
      "disableMobile"
    ];
    var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    var formats2 = {};
    self2.config.parseDate = userConfig.parseDate;
    self2.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self2.config, "enable", {
      get: function() {
        return self2.config._enable;
      },
      set: function(dates) {
        self2.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self2.config, "disable", {
      get: function() {
        return self2.config._disable;
      },
      set: function(dates) {
        self2.config._disable = parseDateRules(dates);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults2.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults2.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self2.config, "minDate", {
      get: function() {
        return self2.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self2.config, "maxDate", {
      get: function() {
        return self2.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function(type) {
      return function(val) {
        self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self2.config, "minTime", {
      get: function() {
        return self2.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self2.config, "maxTime", {
      get: function() {
        return self2.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self2.config.noCalendar = true;
      self2.config.enableTime = true;
    }
    Object.assign(self2.config, formats2, userConfig);
    for (var i2 = 0; i2 < boolOpts.length; i2++)
      self2.config[boolOpts[i2]] = self2.config[boolOpts[i2]] === true || self2.config[boolOpts[i2]] === "true";
    HOOKS.filter(function(hook) {
      return self2.config[hook] !== void 0;
    }).forEach(function(hook) {
      self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
    });
    self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i2 = 0; i2 < self2.config.plugins.length; i2++) {
      var pluginConf = self2.config.plugins[i2](self2) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
        } else if (typeof userConfig[key] === "undefined")
          self2.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self2.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
      self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
    self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
    tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self2.config.time_24hr = self2.l10n.time_24hr;
    }
    self2.formatDate = createDateFormatter(self2);
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self2.config.position === "function") {
      return void self2.config.position(self2, customPositionElement);
    }
    if (self2.calendarContainer === void 0)
      return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self2._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
      return acc + child.offsetHeight;
    }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
    toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
    if (self2.config.inline)
      return;
    var left = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
    toggleClass(self2.calendarContainer, "arrowRight", isRight);
    var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass(self2.calendarContainer, "rightMost", rightMost);
    if (self2.config.static)
      return;
    self2.calendarContainer.style.top = top + "px";
    if (!rightMost) {
      self2.calendarContainer.style.left = left + "px";
      self2.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self2.calendarContainer.style.left = "auto";
      self2.calendarContainer.style.right = right + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === void 0)
        return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass(self2.calendarContainer, "rightMost", false);
      toggleClass(self2.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self2.calendarContainer.style.left = centerLeft + "px";
      self2.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
      var sheet = document.styleSheets[i2];
      if (!sheet.cssRules)
        continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self2.config.noCalendar || self2.isMobile)
      return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self2._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self2.close, 0);
    } else {
      self2.close();
    }
  }
  function selectDate(e) {
    e.preventDefault();
    e.stopPropagation();
    var isSelectable = function(day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t = findParent(getEventTarget(e), isSelectable);
    if (t === void 0)
      return;
    var target = t;
    var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
    self2.selectedDateElem = target;
    if (self2.config.mode === "single")
      self2.selectedDates = [selectedDate];
    else if (self2.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex)
        self2.selectedDates.splice(parseInt(selectedIndex), 1);
      else
        self2.selectedDates.push(selectedDate);
    } else if (self2.config.mode === "range") {
      if (self2.selectedDates.length === 2) {
        self2.clear(false, false);
      }
      self2.latestSelectedDateObj = selectedDate;
      self2.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
        self2.selectedDates.sort(function(a, b) {
          return a.getTime() - b.getTime();
        });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self2.currentYear !== selectedDate.getFullYear();
      self2.currentYear = selectedDate.getFullYear();
      self2.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
      focusOnDayElem(target);
    else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
      self2.selectedDateElem && self2.selectedDateElem.focus();
    }
    if (self2.hourElement !== void 0)
      self2.hourElement !== void 0 && self2.hourElement.focus();
    if (self2.config.closeOnSelect) {
      var single = self2.config.mode === "single" && !self2.config.enableTime;
      var range2 = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
      if (single || range2) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [
      function() {
        if (self2.config.clickOpens === true) {
          bind(self2._input, "focus", self2.open);
          bind(self2._input, "click", self2.open);
        } else {
          self2._input.removeEventListener("focus", self2.open);
          self2._input.removeEventListener("click", self2.open);
        }
      }
    ]
  };
  function set2(option, value) {
    if (option !== null && typeof option === "object") {
      Object.assign(self2.config, option);
      for (var key in option) {
        if (CALLBACKS[key] !== void 0)
          CALLBACKS[key].forEach(function(x) {
            return x();
          });
      }
    } else {
      self2.config[option] = value;
      if (CALLBACKS[option] !== void 0)
        CALLBACKS[option].forEach(function(x) {
          return x();
        });
      else if (HOOKS.indexOf(option) > -1)
        self2.config[option] = arrayify(value);
    }
    self2.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format) {
    var dates = [];
    if (inputDate instanceof Array)
      dates = inputDate.map(function(d) {
        return self2.parseDate(d, format);
      });
    else if (inputDate instanceof Date || typeof inputDate === "number")
      dates = [self2.parseDate(inputDate, format)];
    else if (typeof inputDate === "string") {
      switch (self2.config.mode) {
        case "single":
        case "time":
          dates = [self2.parseDate(inputDate, format)];
          break;
        case "multiple":
          dates = inputDate.split(self2.config.conjunction).map(function(date2) {
            return self2.parseDate(date2, format);
          });
          break;
        case "range":
          dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date2) {
            return self2.parseDate(date2, format);
          });
          break;
        default:
          break;
      }
    } else
      self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d) {
      return d instanceof Date && isEnabled(d, false);
    });
    if (self2.config.mode === "range")
      self2.selectedDates.sort(function(a, b) {
        return a.getTime() - b.getTime();
      });
  }
  function setDate(date2, triggerChange2, format) {
    if (triggerChange2 === void 0) {
      triggerChange2 = false;
    }
    if (format === void 0) {
      format = self2.config.dateFormat;
    }
    if (date2 !== 0 && !date2 || date2 instanceof Array && date2.length === 0)
      return self2.clear(triggerChange2);
    setSelectedDate(date2, format);
    self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
    self2.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self2.selectedDates.length === 0) {
      self2.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2)
      triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function(rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self2.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to)
        return {
          from: self2.parseDate(rule.from, void 0),
          to: self2.parseDate(rule.to, void 0)
        };
      return rule;
    }).filter(function(x) {
      return x;
    });
  }
  function setupDates() {
    self2.selectedDates = [];
    self2.now = self2.parseDate(self2.config.now) || new Date();
    var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
    if (preloadedDate)
      setSelectedDate(preloadedDate, self2.config.dateFormat);
    self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
    self2.currentYear = self2._initialDate.getFullYear();
    self2.currentMonth = self2._initialDate.getMonth();
    if (self2.selectedDates.length > 0)
      self2.latestSelectedDateObj = self2.selectedDates[0];
    if (self2.config.minTime !== void 0)
      self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
    if (self2.config.maxTime !== void 0)
      self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
    self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
    self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self2.input = getInputElem();
    if (!self2.input) {
      self2.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self2.input._type = self2.input.type;
    self2.input.type = "text";
    self2.input.classList.add("flatpickr-input");
    self2._input = self2.input;
    if (self2.config.altInput) {
      self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
      self2._input = self2.altInput;
      self2.altInput.placeholder = self2.input.placeholder;
      self2.altInput.disabled = self2.input.disabled;
      self2.altInput.required = self2.input.required;
      self2.altInput.tabIndex = self2.input.tabIndex;
      self2.altInput.type = "text";
      self2.input.setAttribute("type", "hidden");
      if (!self2.config.static && self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
    }
    if (!self2.config.allowInput)
      self2._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self2._positionElement = self2.config.positionElement || self2._input;
  }
  function setupMobile() {
    var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
    self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
    self2.mobileInput.tabIndex = 1;
    self2.mobileInput.type = inputType;
    self2.mobileInput.disabled = self2.input.disabled;
    self2.mobileInput.required = self2.input.required;
    self2.mobileInput.placeholder = self2.input.placeholder;
    self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self2.selectedDates.length > 0) {
      self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
    }
    if (self2.config.minDate)
      self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
    if (self2.config.maxDate)
      self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
    if (self2.input.getAttribute("step"))
      self2.mobileInput.step = String(self2.input.getAttribute("step"));
    self2.input.type = "hidden";
    if (self2.altInput !== void 0)
      self2.altInput.type = "hidden";
    try {
      if (self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
    } catch (_a) {
    }
    bind(self2.mobileInput, "change", function(e) {
      self2.setDate(getEventTarget(e).value, false, self2.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e) {
    if (self2.isOpen === true)
      return self2.close();
    self2.open(e);
  }
  function triggerEvent(event, data) {
    if (self2.config === void 0)
      return;
    var hooks = self2.config[event];
    if (hooks !== void 0 && hooks.length > 0) {
      for (var i2 = 0; hooks[i2] && i2 < hooks.length; i2++)
        hooks[i2](self2.selectedDates, self2.input.value, self2, data);
    }
    if (event === "onChange") {
      self2.input.dispatchEvent(createEvent("change"));
      self2.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    var e = document.createEvent("Event");
    e.initEvent(name, true, true);
    return e;
  }
  function isDateSelected(date2) {
    for (var i2 = 0; i2 < self2.selectedDates.length; i2++) {
      var selectedDate = self2.selectedDates[i2];
      if (selectedDate instanceof Date && compareDates(selectedDate, date2) === 0)
        return "" + i2;
    }
    return false;
  }
  function isDateInRange(date2) {
    if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
      return false;
    return compareDates(date2, self2.selectedDates[0]) >= 0 && compareDates(date2, self2.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
      return;
    self2.yearElements.forEach(function(yearElement, i2) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i2);
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        self2.monthElements[i2].textContent = monthToStr(d.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
      } else {
        self2.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
    self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
    return self2.selectedDates.map(function(dObj) {
      return self2.formatDate(dObj, format);
    }).filter(function(d, i2, arr) {
      return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d) === i2;
    }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = true;
    }
    if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
      self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
    }
    self2.input.value = getDateStr(self2.config.dateFormat);
    if (self2.altInput !== void 0) {
      self2.altInput.value = getDateStr(self2.config.altFormat);
    }
    if (triggerChange2 !== false)
      triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e) {
    var eventTarget = getEventTarget(e);
    var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
    var isNextMonth = self2.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self2.changeYear(self2.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self2.changeYear(self2.currentYear - 1);
    }
  }
  function timeWrapper(e) {
    e.preventDefault();
    var isKeyDown = e.type === "keydown", eventTarget = getEventTarget(e), input2 = eventTarget;
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      self2.amPM.textContent = self2.l10n.amPM[int2(self2.amPM.textContent === self2.l10n.amPM[0])];
    }
    var min = parseFloat(input2.getAttribute("min")), max = parseFloat(input2.getAttribute("max")), step = parseFloat(input2.getAttribute("step")), curValue = parseInt(input2.value, 10), delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input2.value !== "undefined" && input2.value.length === 2) {
      var isHourElem = input2 === self2.hourElement, isMinuteElem = input2 === self2.minuteElement;
      if (newValue < min) {
        newValue = max + newValue + int2(!isHourElem) + (int2(isHourElem) && int2(!self2.amPM));
        if (isMinuteElem)
          incrementNumInput(void 0, -1, self2.hourElement);
      } else if (newValue > max) {
        newValue = input2 === self2.hourElement ? newValue - max - int2(!self2.amPM) : min;
        if (isMinuteElem)
          incrementNumInput(void 0, 1, self2.hourElement);
      }
      if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self2.amPM.textContent = self2.l10n.amPM[int2(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      input2.value = pad(newValue);
    }
  }
  init();
  return self2;
}
function _flatpickr(nodeList, config) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function(x) {
    return x instanceof HTMLElement;
  });
  var instances2 = [];
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var node = nodes[i2];
    try {
      if (node.getAttribute("data-fp-omit") !== null)
        continue;
      if (node._flatpickr !== void 0) {
        node._flatpickr.destroy();
        node._flatpickr = void 0;
      }
      node._flatpickr = FlatpickrInstance(node, config || {});
      instances2.push(node._flatpickr);
    } catch (e) {
      console.error(e);
    }
  }
  return instances2.length === 1 ? instances2[0] : instances2;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
  HTMLElement.prototype.flatpickr = function(config) {
    return _flatpickr([this], config);
  };
}
var flatpickr = function(selector, config) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config);
  } else {
    return _flatpickr(selector, config);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign({}, default_default),
  default: __assign({}, default_default)
};
flatpickr.localize = function(l10n) {
  flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function(config) {
  flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
}
Date.prototype.fp_incr = function(days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
var esm_default = flatpickr;

// js/components/time_range_hook.js
function TimeRangeHook() {
  this.mounted = function() {
    this.setupFlatpickr();
    this.handleEvent(this.el.id + "::refresh-data", (payload) => {
      let time_range = [payload.time_range.from, payload.time_range.to];
      this.flatpickr.setDate(time_range, false, null);
    });
    document.getElementById(this.el.id).addEventListener("zoomCompleted", (e) => {
      this.sendNotification({ from: e.detail.from, to: e.detail.to });
    });
  };
  this.reconnected = function() {
    this.setupFlatpickr();
  };
  this.sendNotification = function(payload) {
    this.pushEventTo("#" + this.el.id, "time_range_change", payload);
  };
  this.setupFlatpickr = function() {
    this.flatpickr = esm_default("#" + this.el.id, {
      mode: "range",
      dateFormat: "Y-m-d",
      monthSelectorType: "static",
      locale: {
        firstDayOfWeek: 1
      },
      onChange: (selectedDates, dateStr, instance) => {
        if (selectedDates.length == 2) {
          let to2 = DateTime.fromJSDate(selectedDates[1]).plus({ days: 1 }).plus({ seconds: -1 }).toJSDate();
          this.sendNotification({ from: selectedDates[0], to: to2 });
        }
      }
    });
  };
}
var time_range_hook_default = TimeRangeHook;

// js/components/map_hook.js
var import_highcharts = __toModule(require_highcharts());
var import_map = __toModule(require_map());
function MapHook() {
  this.mounted = function() {
    const element_data = this.el.dataset;
    (0, import_map.default)(import_highcharts.default);
    this.map = import_highcharts.default.mapChart(element_data.mapId, {
      chart: {
        map: JSON.parse(this.el.dataset.json),
        backgroundColor: "rgba(0,0,0,0)",
        height: "100%"
      },
      title: { text: "" },
      credits: { enabled: false },
      mapNavigation: {
        enabled: true
      },
      colorAxis: { min: 0 },
      series: [{
        name: this.el.dataset.country,
        borderColor: "#A0A0A0",
        nullColor: "rgba(200, 200, 200, 0.3)",
        states: {
          hover: {
            color: "#BADA55"
          }
        },
        tooltip: {
          headerFormat: "",
          pointFormat: "{point.description}"
        },
        dataLabels: {
          enabled: false
        }
      }, {
        type: "mappoint",
        tooltip: {
          headerFormat: "",
          pointFormat: "{point.description}"
        },
        events: {
          click: function(e) {
            const url2 = e.target.point.url;
            window.open(url2);
          }
        },
        color: "#030303"
      }]
    });
    this.handleEvent("panel-" + element_data.componentId + "::refresh-data", this.setMapData());
  };
  this.setMapData = function() {
    return (payload) => {
      this.map.series[0].setData(payload.Areas);
      this.map.series[1].setData(payload.Pins);
    };
  };
}
var map_hook_default = MapHook;
/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
/*!
 * chartjs-adapter-luxon v1.2.0
 * https://www.chartjs.org
 * (c) 2022 chartjs-adapter-luxon Contributors
 * Released under the MIT license
 */
/*!
* chartjs-plugin-zoom v1.2.1
* undefined
 * (c) 2016-2022 chartjs-plugin-zoom Contributors
 * Released under the MIT License
 */
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
